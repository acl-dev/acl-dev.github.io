<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>在 QT 界面编程中使用协程</title>
    <link href="/2024/09/24/fiber_qt/"/>
    <url>/2024/09/24/fiber_qt/</url>
    
    <content type="html"><![CDATA[<h1 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h1><p>人们在谈论协程编程时，往往与编写命令行网络程序有关，如编写网络客户端与网络服务器程序，很少涉及到客户端 UI 相关的界面编程。Acl 协程库是支持在 Windows 下的 UI 界面编程的，因为 Acl 协程的事件引擎支持了界面消息传递过程。最近学习了一下 QT UI 编程，轻松将 Acl 协程与 QT UI 集成在一起，从而实现了 QT 界面协程化，使开发人员在使用 QT 编写界面程序时，编写网络模块变得非常简单。</p><p>本文结合 Acl 中 lib_fiber&#x2F;samples-gui&#x2F;QtFiber 示例，演示了如何将 Acl 协程功能集成到 QT 界面中，实现了网络模块与界面模块的融合。</p><h1 id="二、集成"><a href="#二、集成" class="headerlink" title="二、集成"></a>二、集成</h1><h2 id="2-1、编译-Acl"><a href="#2-1、编译-Acl" class="headerlink" title="2.1、编译 Acl"></a>2.1、编译 Acl</h2><p>目前 QT IDE 还无法直接使用 Acl 里的 CMakeLists.txt 文件编译 ACL，可以借助于 VC2019 打开 Acl 里的 acl_cpp_vc2019.sln 工程编译 Acl 五个库的动态库，分别为：lib_acl.dll, lib_protocol.dll, lib_acl_cpp.dll, libfiber.dll, libfiber_cpp.dll 及静态导出库：lib_acl.lib, lib_protocol.lib lib_acl_cpp.lib, libfiber.lib, libfiber_cpp.lib。</p><h2 id="2-2、将-Acl-库集成到-QT-项目中"><a href="#2-2、将-Acl-库集成到-QT-项目中" class="headerlink" title="2.2、将 Acl 库集成到 QT 项目中"></a>2.2、将 Acl 库集成到 QT 项目中</h2><p>参考 lib_fiber&#x2F;samples-gui&#x2F;QtFiber&#x2F;CMakeLists.txt 文件，将 Acl 库的头文件包含进去，如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs txt">set(acl_path ../../..)<br><br>include_directories(<br>    $&#123;acl_path&#125;/lib_acl/include<br>    $&#123;acl_path&#125;/lib_acl_cpp/include<br>    $&#123;acl_path&#125;/lib_fiber/c/include<br>    $&#123;acl_path&#125;/lib_fiber/cpp/include<br>)<br></code></pre></td></tr></table></figure><p>然后设定编译条件：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs txt">add_definitions(&quot;-DACL_DLL&quot;<br>    &quot;-DACL_CPP_DLL&quot;<br>    &quot;-DHTTP_DLL&quot;<br>    &quot;-DICMP_DLL&quot;<br>    &quot;-DSMTP_DLL&quot;<br>    &quot;-DFIBER_CPP_DLL&quot;<br>    &quot;-D_CRT_SECURE_NO_WARNINGS&quot;<br>    &quot;-D_WINSOCK_DEPRECATED_NO_WARNINGS&quot;<br>)<br></code></pre></td></tr></table></figure><p>添加库到工程中，如下：</p><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs txt">if (CMAKE_BUILD_TYPE STREQUAL &quot;RELEASE&quot;)<br>    set(acl_libs_path $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../x64/ReleaseDll)<br>else()<br>    set(acl_libs_path $&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/../../../x64/DebugDll)<br>endif()<br><br>set(lib_all $&#123;acl_libs_path&#125;/libfiber_cpp.lib<br>    $&#123;acl_libs_path&#125;/lib_acl_cpp.lib<br>    $&#123;acl_libs_path&#125;/lib_protocol.lib<br>    $&#123;acl_libs_path&#125;/lib_acl.lib<br>    $&#123;acl_libs_path&#125;/libfiber.lib)<br><br>target_link_libraries(QtFiber PRIVATE Qt5::Widgets $&#123;lib_all&#125; Ws2_32)<br><br>add_custom_command(TARGET $&#123;PROJECT_NAME&#125; POST_BUILD<br>    COMMAND $&#123;CMAKE_COMMAND&#125; -E copy_if_different<br>        &quot;$&#123;acl_libs_path&#125;/libfiber_cpp.dll&quot;<br>        &quot;$&#123;acl_libs_path&#125;/libfiber.dll&quot;<br>        &quot;$&#123;acl_libs_path&#125;/lib_acl_cpp.dll&quot;<br>        &quot;$&#123;acl_libs_path&#125;/lib_acl.dll&quot;<br>        &quot;$&#123;acl_libs_path&#125;/lib_protocol.dll&quot;<br>        $&lt;TARGET_FILE_DIR:$&#123;PROJECT_NAME&#125;&gt;<br>)<br></code></pre></td></tr></table></figure><h2 id="2-3、开始编写代码"><a href="#2-3、开始编写代码" class="headerlink" title="2.3、开始编写代码"></a>2.3、开始编写代码</h2><p>经过摸索研究，想要集成 Acl 协程到 QT UI 程序中，需要采用以下方法（主要是协程的初始化及退出）：</p><h3 id="2-3-1、QT-程序初始化时初始化-Acl-协程"><a href="#2-3-1、QT-程序初始化时初始化-Acl-协程" class="headerlink" title="2.3.1、QT 程序初始化时初始化 Acl 协程"></a>2.3.1、QT 程序初始化时初始化 Acl 协程</h3><p>在调用 QT APP exec() 前，需要先调用 Acl 协程初始化过程，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">startupCallback</span><span class="hljs-params">()</span> </span>&#123;<br>    acl::fiber::<span class="hljs-built_in">schedule_gui</span>(); <span class="hljs-comment">// Won&#x27;t return until schedule finished.</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">QApplication <span class="hljs-title">app</span><span class="hljs-params">(argc, argv)</span></span>;<br><br>    MainWindow w;<br>    w.<span class="hljs-built_in">show</span>();<br><br>    QTimer::<span class="hljs-built_in">singleShot</span>(<span class="hljs-number">0</span>, startupCallback);<br><br>    app.<span class="hljs-built_in">exec</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，在调用 app.exec() 前注入了启动函数 startupCallback()，在里面启动了 acl 在界面模式下的协程调度过程 acl::fiber::schedule_gui()，该方法将进入界面消息循环过程，直到协程调度停止后才会返回。</p><h3 id="2-3-2、在界面中创建协程"><a href="#2-3-2、在界面中创建协程" class="headerlink" title="2.3.2、在界面中创建协程"></a>2.3.2、在界面中创建协程</h3><p>一旦协程调度器启动，就可以创建并运行协程了，可以在主界面上添加一个按钮，当点击该按钮后的处理函数中便可以创建并启动一个协程。比如在例子中，点击 “Start fiber server” 按钮，在处理函数 <code> MainWindow::onStartServer()</code> 中，可以创建一个网络监听服务器，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::onStartServer</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    server_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_server</span>(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9001</span>, <span class="hljs-keyword">this</span>);<br>    server_-&gt;<span class="hljs-built_in">start</span>();<br>    ...<br>&#125;<br></code></pre></td></tr></table></figure><p>这样在界面里就创建了一个 TCP 监听协程，当有连接连接监听地址时，在监听协程里便可以创建一个客户端连接处理协程进行处理，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    SOCKET conn = <span class="hljs-built_in">socket_accept</span>(sock);<br>    <span class="hljs-keyword">if</span> (conn == INVALID_SOCKET) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_echo</span>(conn);<br>    fb-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子的客户端协程启动后，便可以进行网络 IO 读写，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-type">int</span> ret = <span class="hljs-built_in">acl_fiber_recv</span>(conn_, buf, <span class="hljs-built_in">sizeof</span>(buf) - <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br><br>    buf[ret] = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">acl_fiber_send</span>(conn_, buf, ret, <span class="hljs-number">0</span>) != ret) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-3、界面程序退出前需要停止协程调度"><a href="#2-3-3、界面程序退出前需要停止协程调度" class="headerlink" title="2.3.3、界面程序退出前需要停止协程调度"></a>2.3.3、界面程序退出前需要停止协程调度</h3><p>必须保证在界面程序退出前停止协程调度器，否则界面程序无法正常退出，该步骤也非常重要。可以在主界面处理类里重载基类的 <code> void closeEvent(QCloseEvent *event);</code> 方法，在该方法里停止协程调度器，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::closeEvent</span><span class="hljs-params">(QCloseEvent *event)</span> </span>&#123;<br>    acl::fiber::<span class="hljs-built_in">schedule_stop</span>(); <span class="hljs-comment">// 停止协程调度器</span><br>    event-&gt;<span class="hljs-built_in">accept</span>();             <span class="hljs-comment">// 接受关闭事件</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-4、在界面线程中下载数据"><a href="#2-3-4、在界面线程中下载数据" class="headerlink" title="2.3.4、在界面线程中下载数据"></a>2.3.4、在界面线程中下载数据</h3><p>点击主界面中点击HTTP下载按钮，在事件处理函数中创建协程从后端HTTP服务器下载数据，过程如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::onUrlGet</span><span class="hljs-params">()</span> </span>&#123;<br>    ...<br>    go[<span class="hljs-keyword">this</span>] &#123;<br>        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *url = <span class="hljs-string">&quot;http://www.baidu.com/&quot;</span>;<br>        <span class="hljs-function">acl::http_request <span class="hljs-title">req</span><span class="hljs-params">(url)</span></span>;<br>        <span class="hljs-keyword">if</span> (!req.<span class="hljs-built_in">request</span>(<span class="hljs-literal">nullptr</span>, <span class="hljs-number">0</span>)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Send HTTP request failed\r\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        acl::string body;<br>        <span class="hljs-keyword">if</span> (!req.<span class="hljs-built_in">get_body</span>(body)) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Get HTTP body error\r\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Got body:&quot;</span> &lt;&lt; body.<span class="hljs-built_in">c_str</span>();<br>        ...<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-5、在协程中延迟创建容器"><a href="#2-3-5、在协程中延迟创建容器" class="headerlink" title="2.3.5、在协程中延迟创建容器"></a>2.3.5、在协程中延迟创建容器</h3><p>如果想某个容器延迟创建，不必借助定时器，直接在协程中就可以轻松实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">MainWindow::delayCreate</span><span class="hljs-params">()</span> </span>&#123;<br>    go[<span class="hljs-keyword">this</span>] &#123;<br>        acl::fiber::<span class="hljs-built_in">delay</span>(<span class="hljs-number">5000</span>); <span class="hljs-comment">// 休眠 5 秒</span><br>        <span class="hljs-function">InputDialog <span class="hljs-title">dialog</span><span class="hljs-params">(<span class="hljs-keyword">this</span>)</span></span>;<br>        dialog.<span class="hljs-built_in">exec</span>();<br>    &#125;;<br>    <span class="hljs-built_in">qDebug</span>() &lt;&lt; <span class="hljs-string">&quot;Fiber was created to create one window after a while&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-4、效果展示"><a href="#2-4、效果展示" class="headerlink" title="2.4、效果展示"></a>2.4、效果展示</h2><p>编译运行 acl&#x2F;lib_fiber&#x2F;samples-gui&#x2F;QtFiber&#x2F; 工程，可以得到以下运行界面：<br><img src="/img/fiber_qt.jpg" alt="fiber_qt"></p><ul><li>在前面窗口中，右边请求HTTP服务器时的HTTP请求头，右连接为后端服务器返回的HTTP响应头，该下载过程中在协程中进行，运行结果显示在主界面上；</li><li>窗口下方的进度条为客户端协程与服务端协程交互时的交互进度展示。</li></ul><h2 id="2-5、小结"><a href="#2-5、小结" class="headerlink" title="2.5、小结"></a>2.5、小结</h2><p>以上便是如何编译集成 Acl 协程到 QT 界面程序的方法，主要的要点是：</p><ul><li>需要使用 vc2019 编译 Acl 的动态库，并集成至 QT 界面程序的工程文件中；</li><li>编程时需要注意两点：<ul><li>在启动 QT （即调用 app.exec()）前，需要先启动 Acl 协程调度器；</li><li>在主界面类里需要重载基类关闭虚方法 <code>closeEvent()</code>，并在该方法里停止 Acl 协程调度器。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>协程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协程编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 SSL SNI 拦截 SSL 握手攻击</title>
    <link href="/2024/06/02/ssl_sni/"/>
    <url>/2024/06/02/ssl_sni/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-SSL-SNI-拦截-SSL-握手攻击"><a href="#使用-SSL-SNI-拦截-SSL-握手攻击" class="headerlink" title="使用 SSL SNI 拦截 SSL 握手攻击"></a>使用 SSL SNI 拦截 SSL 握手攻击</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>SSL&#x2F;TLS是用于在网络上进行安全通信的加密协议，各网络公司为保证数据传输的安全性均采用了SSL&#x2F;TLS通信方式，相校于明文传输方式，SSL&#x2F;TLS对于计算成本要求更高，尤其是在SSL&#x2F;TLS握手阶段更是耗费了大量计算资源，攻击者可以轻易利用这一问题对服务端发起SSL&#x2F;TLS握手攻击，攻击者只需使用少量的廉价攻击源（不必象流量攻击那样需要大量的攻击源）便可发起SSL&#x2F;TLS握手攻击，占用服务端大量的CPU资源。</p><p>如何有效地防止此类握手攻击呢？想到了在SSL SNI交互阶段进行防御的方案。</p><p>SSL SNI（Server Name Indication，服务器名称指示）是TLS协议（传输层安全协议）的一个扩展，它允许在握手阶段向服务器指明客户端正在请求哪个主机名。这样，服务器可以根据客户端提供的主机名返回适当的SSL证书，从而使得在同一个IP地址上托管多个安全网站成为可能。</p><p>在 SSL SNI 交互阶段，数据是明文传输的，不需要浪费服务端多少计算资源，我们可以在 SSL SNI 阶段对 SSL&#x2F;TLS 客户端进行身份验证并进行握手攻击拦截。</p><h2 id="二、关于SSL-SNI"><a href="#二、关于SSL-SNI" class="headerlink" title="二、关于SSL SNI"></a>二、关于SSL SNI</h2><p>在没有SNI之前，如果在同一个IP地址上托管多个SSL&#x2F;TLS网站，服务器在SSL握手时无法知道客户端想要访问哪个网站，从而无法发送正确的SSL证书。这会导致SSL握手失败或返回错误的证书。</p><p>SNI的作用流程大致如下：</p><ul><li><ol><li>客户端发起连接，并在SSL&#x2F;TLS握手的初始阶段包含它想要连接的主机名（在ClientHello消息中）。</li></ol></li><li><ol start="2"><li>服务器接收到ClientHello消息，读取其中的主机名信息。</li></ol></li><li><ol start="3"><li>服务器根据这个主机名选择并发送对应的SSL证书。</li></ol></li><li><ol start="4"><li>后续的握手过程按照通常的SSL&#x2F;TLS流程进行。</li></ol></li></ul><p>通过SNI，多个SSL&#x2F;TLS站点可以在同一个服务器或同一个IP地址上共存，而且每一个站点都可以拥有自己独立的证书。这对于节省IP地址和简化服务器配置有重要意义。</p><h2 id="三、实施案例"><a href="#三、实施案例" class="headerlink" title="三、实施案例"></a>三、实施案例</h2><p>Acl 库( <a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a> )封装的 SSL 模块中提供了通过 SSL SNI 验证客户端身份的能力，下面给出了操作过程：</p><h3 id="3-1、SSL-服务端"><a href="#3-1、SSL-服务端" class="headerlink" title="3.1、SSL 服务端"></a>3.1、SSL 服务端</h3><h4 id="3-1-2、SSL服务端实现SSL-SNI校验类"><a href="#3-1-2、SSL服务端实现SSL-SNI校验类" class="headerlink" title="3.1.2、SSL服务端实现SSL SNI校验类"></a>3.1.2、SSL服务端实现SSL SNI校验类</h4><p>下面给出 Acl SSL 模块中 SSL SNI 验证基类声明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">namespace</span> acl &#123;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ACL_CPP_API</span> ssl_sni_checker &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">ssl_sni_checker</span>() &#123;&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">ssl_sni_checker</span>() &#123;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚方法用来检查输入的sni host是否合法，子类必须实现</span><br><span class="hljs-comment"> * @param sni &#123;const char*&#125; 客户端传来的 sni 字段</span><br><span class="hljs-comment"> * @param host &#123;acl::string&amp;&#125; 从 sni 中提取的 host 字段</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 检查是否合法</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(sslbase_io* io, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sni, string&amp; host)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>用户需要实现 SSL SNI 子类并完成其中的纯虚方法，在该方法完成对客户端身份的校验。下面给出简单示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">my_sni_checker</span> : <span class="hljs-keyword">public</span> acl::ssl_sni_checker &#123;<br><span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">my_sni_checker</span>() &#123;&#125;<br>        ~<span class="hljs-built_in">my_sni_checker</span>() &#123;&#125;<br><br>        <span class="hljs-comment">// @override</span><br>        <span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">check</span><span class="hljs-params">(acl::sslbase_io* io, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sni, acl::string&amp; host)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (sni == <span class="hljs-literal">NULL</span> || *sni == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 如果客户端未提供 SNI 标识字符串则返回错误，禁止进行 SSL 握手. </span><br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No SNI=%p\r\n&quot;</span>, sni);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 从 SNI 中提取服务端主机域名，并保存，以便 Acl SSL 模块选择本地的 SSL 证书</span><br>                <span class="hljs-comment">// 并进行 SSL 握手。</span><br>                <span class="hljs-function">acl::string <span class="hljs-title">buf</span><span class="hljs-params">(sni)</span></span>;<br>                <span class="hljs-type">const</span> std::vector&lt;acl::string&gt;&amp; tokens = buf.<span class="hljs-built_in">split2</span>(<span class="hljs-string">&quot;|&quot;</span>);<br>                <span class="hljs-keyword">if</span> (tokens.<span class="hljs-built_in">size</span>() != <span class="hljs-number">2</span>) &#123;<br>                    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Invalid sni=%s\r\n&quot;</span>, sni);<br>                    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br><br>                host = tokens[<span class="hljs-number">1</span>];<br><br>                <span class="hljs-comment">// check_token(tokens[0]); // 应用自行检查加密串的合法性。</span><br><br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Check sni ok, sni=%s, host=%s\r\n&quot;</span>, sni,, host.<span class="hljs-built_in">c_str</span>());<br><br>                <span class="hljs-comment">// 返回 true 则允许 Acl SSL 模块可以进一步进行 SSL 握手。</span><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>SSL 客户端模块与服务端可以协商一个 sni 的生成规则，比如 sni 字符串类似于 <code>token|host</code>（比如：xxxxxx|myhost.test.com)，期中 token 字段可以是双方私密生成的加密字符串，host 为主机域名。服务端仅针放行符合加密规则的客户端 SSL 连接，其它连接一概拦截。</p><h4 id="3-1-2、创建全局-SSL-配置对象并绑定-SNI-验证对象"><a href="#3-1-2、创建全局-SSL-配置对象并绑定-SNI-验证对象" class="headerlink" title="3.1.2、创建全局 SSL 配置对象并绑定 SNI 验证对象"></a>3.1.2、创建全局 SSL 配置对象并绑定 SNI 验证对象</h4><p>下面代码是创建全局的 SSL 配置管理对象代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++">acl::sslbase_conf* ssl_conf =  <span class="hljs-keyword">new</span> acl::<span class="hljs-built_in">openssl_conf</span>(<span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 添加服务端 SSL 证书</span><br></code></pre></td></tr></table></figure><p>全局 SSL 配置管理对象创建后，添加 SSL SNI 验证对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">ssl_conf-&gt;<span class="hljs-built_in">set_sni_checker</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">ssl_sni_checker</span>());<br></code></pre></td></tr></table></figure><h4 id="3-1-3、与-SSL-客户端进行-SSL-握手"><a href="#3-1-3、与-SSL-客户端进行-SSL-握手" class="headerlink" title="3.1.3、与 SSL 客户端进行 SSL 握手"></a>3.1.3、与 SSL 客户端进行 SSL 握手</h4><p>与客户端连接进行 SSL 握手：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ssl_handshake</span><span class="hljs-params">(acl::sslbase_conf&amp; ssl_conf, acl::socket_stream&amp; conn)</span> </span>&#123;<br>    acl::sslbase_io* ssl = ssl_conf.<span class="hljs-built_in">create</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-keyword">if</span> (conn.<span class="hljs-built_in">setup_hook</span>(ssl) == ssl) &#123;  <span class="hljs-comment">// SSL 握手失败，包括 SSL SNI 查检失败。</span><br>        ssl-&gt;<span class="hljs-built_in">destroy</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2、SSL-客户端"><a href="#3-2、SSL-客户端" class="headerlink" title="3.2、SSL 客户端"></a>3.2、SSL 客户端</h3><p>客户端在与服务端建立 TCP 连接后，进行 SSL 握手时需要先设置 SSL SNI 字段，SNI 字段中既有域名信息，又有加密串信息，当服务端收到该 SNI 串时，从中取出加密及域名信息后，先验证加密数据的合法性，验证通过则进行 SSL 握手，否则禁止 SSL 握手，从而避免浪费 CPU 计算资源。下面是 SSL 客户端的简单示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">ssl_handshake</span><span class="hljs-params">(acl::sslbase_conf&amp; conf, acl::socket_stream&amp; conn)</span> </span>&#123;<br>    acl::sslbase_io* ssl = conf.<span class="hljs-built_in">create</span>(<span class="hljs-literal">false</span>);<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* sni = <span class="hljs-string">&quot;crypted_token|mytest.com&quot;</span>;   <span class="hljs-comment">// 期中的加密token将由服务端验证</span><br>    ssl-&gt;<span class="hljs-built_in">set_sni_host</span>(sni);  <span class="hljs-comment">// 设置 SNI 字段</span><br>    <span class="hljs-keyword">if</span> (conn.<span class="hljs-built_in">setup_hook</span>(ssl) == ssl) &#123;<br>        <span class="hljs-comment">// SSL 握手失败，销毁 SSL IO 对象。</span><br>        ssl-&gt;<span class="hljs-built_in">destroy</span>();<br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3、参考"><a href="#3-3、参考" class="headerlink" title="3.3、参考"></a>3.3、参考</h3><ul><li>Acl 库下载: <a href="https://github.com/acl-dev/acl/">https://github.com/acl-dev/acl/</a></li><li>客户端示例：acl&#x2F;lib_acl_cpp&#x2F;samples&#x2F;ssl&#x2F;client</li><li>服务端示例：acl&#x2F;lib_acl_cpp&#x2F;samples&#x2F;ssl&#x2F;server</li><li>使用SSL中对数据进行加密传输：<a href="https://acl-dev.cn/2020/01/15/ssl/">https://acl-dev.cn/2020/01/15/ssl/</a></li><li>Acl库下载：<a href="https://github.com/acl-dev/acl/">https://github.com/acl-dev/acl/</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>SSL编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSL编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Unix 系统文件锁踩坑记</title>
    <link href="/2024/04/27/file_lock/"/>
    <url>/2024/04/27/file_lock/</url>
    
    <content type="html"><![CDATA[<h1 id="Unix-系统文件锁踩坑记"><a href="#Unix-系统文件锁踩坑记" class="headerlink" title="Unix 系统文件锁踩坑记"></a>Unix 系统文件锁踩坑记</h1><h2 id="1、背景"><a href="#1、背景" class="headerlink" title="1、背景"></a>1、背景</h2><p>最近的一个项目需要通过文件锁方式实现多进程之间的资源互斥，但却遇到一个诡异的现象：当进程数比较少时，感觉加锁是正常的，但当进程数一多，加锁就失效了，似乎多个进程都可以同时加一把锁，锁的互斥性完全失效。因为锁功能的实现经过Acl库（<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a> ）进行了二次封装，同时项目本身又比较复杂，所以决定做一个简单的例子测试一下原因。</p><h2 id="2、问题分析"><a href="#2、问题分析" class="headerlink" title="2、问题分析"></a>2、问题分析</h2><p>一般来讲，编写简单示例来复现线上系统问题并不是一件容易的事，毕竟线上系统模块众多而且复杂，有时很难知道哪些模块会导致问题发生。为了复现线上问题，专门写了一个简单的demo（参见：<a href="https://github.com/acl-dev/demo/blob/master/c/lock/file_lock.c">https://github.com/acl-dev/demo/blob/master/c/lock/file_lock.c</a> ），通过对比测试不同条件加锁行为最终复现了线上系统问题，并最终得以解决。</p><p>在 Unix 平台上对文件进行加锁时一般会使用 fcntl 系统API，示例代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">fcntl_lock</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span> &#123;<br><span class="hljs-type">int</span> fd = open(filename, O_RDWR | O_CREAT, <span class="hljs-number">0600</span>);<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">flock</span> <span class="hljs-title">lock</span>;</span><br><br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br>lock.l_type   = F_WRLCK;<br>lock.l_whence = SEEK_SET;<br>lock.l_start  = <span class="hljs-number">0</span>;<br>lock.l_len    = <span class="hljs-number">0</span>;<br><br><span class="hljs-type">int</span> ret = fcntl(fd, F_SETLKW, &amp;lock);<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>单独测试这段代码是没有问题的：当第一个进程使用上述方法对指定文件加锁后，其它进程无法采用同样的方式再次加锁。</p><p>但在加锁成功后，如果再次打开该文件然后关闭，则就发生了预料之外的问题，针对上述代码稍作修改：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">...<br><span class="hljs-type">int</span> ret = fcntl(fd, F_SETLKW, &amp;lock);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> fd2 = open(filename, O_RDONLY, <span class="hljs-number">0600</span>);<br><span class="hljs-keyword">if</span> (fd2 &gt;= <span class="hljs-number">0</span>) &#123;<br>close(fd2);<br>&#125;<br>...<br></code></pre></td></tr></table></figure><p>对修改后（对同一文件进行第二次打开并<code>关闭</code>）的加锁代码进行测试时发现<code>加锁互斥</code>作用失效（即多个进程均可以对同一文件进行加锁）；另外，如果仅有二次打开并没有关闭，则文件锁的互斥行为依然有效，看来问题出在第二次打开文件并<code>关闭</code>后（有可能在关闭后内核的某些行为使 <code>fcntl</code> 加锁文件失效）。</p><p>编译上面 file_lock.c 源码生成 file_lock 可执行程序，然后以 <code>./file_lock -o -c</code> 方式启动两个进程，会发现两个进程均可以正常加锁，表明文件加锁失效。</p><h2 id="3、问题解决"><a href="#3、问题解决" class="headerlink" title="3、问题解决"></a>3、问题解决</h2><p>既然使用 <code>fcntl</code> API 加锁文件存在以上缺陷，则需要采用其它方法避免这一问题。Unix 系统提供了 <code>flock</code> API 对文件进行加锁互斥。使用 flock 加锁文件的示例如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">flock_lock</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span> &#123;<br><span class="hljs-type">int</span> fd = open(filename, O_RDWR | O_CREAT, <span class="hljs-number">0600</span>);<br><span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> ret = flock(fd, LOCK_EX);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">int</span> fd2 = open(filename, O_RDONLY, <span class="hljs-number">0600</span>);<br><span class="hljs-keyword">if</span> (fd2 &gt;= <span class="hljs-number">0</span>) &#123;&#125;<br>close(fd2);<br>&#125;<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>通过测试发现，在调用 <code>flock</code> 后再对同一文件进行『打开、关闭』操作，文件锁依然是有效的（即只有第一个进程可以加锁成功，后续进程无法再次加锁）。看来 <code>flock</code> 解决了 <code>fcntl</code> 对文件加锁时遇到的问题。</p><p>为了避免用户在使用文件锁时遇到类似的坑，在 Acl 中对文件锁进行了封装，并在内部优先使用 <code>flock</code> 方式加锁。可以参考示例：<a href="https://github.com/acl-dev/demo/blob/master/c%2B%2B/file/file_lock.cpp">https://github.com/acl-dev/demo/blob/master/c%2B%2B/file/file_lock.cpp</a> 。</p><h2 id="4、小结"><a href="#4、小结" class="headerlink" title="4、小结"></a>4、小结</h2><p>看似一个简单的小问题却耗费了1，2天时间进行分析，这进一步加深了自己对文件锁的理解。另外一方面，知识经验是需要长期积累的，与智商无关，因为有些知识点本就是一层窗户纸：会就是会，不会就是不会。</p>]]></content>
    
    
    <categories>
      
      <category>文件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>OpenSSL IO读写超时踩坑小记</title>
    <link href="/2024/03/30/openssl_io/"/>
    <url>/2024/03/30/openssl_io/</url>
    
    <content type="html"><![CDATA[<h1 id="OpenSSL-IO读写超时踩坑小记"><a href="#OpenSSL-IO读写超时踩坑小记" class="headerlink" title="OpenSSL IO读写超时踩坑小记"></a>OpenSSL IO读写超时踩坑小记</h1><h2 id="一、背景"><a href="#一、背景" class="headerlink" title="一、背景"></a>一、背景</h2><p>最近一个线上服务项目需要开启 SSL 功能，该项目使用了Acl库中的 SSL、HTTP及协程模块、，Acl SSL 模块封装了OpenSSL库，使用户编写 SSL 服务更加简便快捷。当该服务程序开启 SSL 功能后，发现有 TCP 连接句柄较长时间堵在 IO 读上，所设置的 SSL IO 读写超时失去作用，造成的后果是服务程序内存不断增长。因为在线连接比较大，同时再加上该服务程序采用了协程模式，使问题排查过程比较困难。</p><h2 id="二、问题分析"><a href="#二、问题分析" class="headerlink" title="二、问题分析"></a>二、问题分析</h2><ul><li><p>项目负责人通过记录引用计数方式给出了问题可能出在 HTTPS 的读 Body 数据体部分。于是先查看 ACL 库 HTTP 模块的超时是否有效，结论正常；同时对比 HTTPS 加密 及 HTTP 明文两种方式的运行状态，结果发现 HTTPS 有连接挂起问题，而 HTTP 方式则正常，所以初步分析可能与 SSL 模块有关。</p></li><li><p>分析 Acl 库中 openssl_io.cpp 源码（封装了OpenSSL IO）的 read() 读部分，里面会在调用 SSL_read() 前先调用 acl_read_wait() 检查 socket 是否可读，如果读超时则返回，如果有数据可读才会调用 SSL_read() 读取数据，感觉应该没有问题，于是想借助 ChatGPT 来协助分析问题，下面是 GPT4 给出的解决 SSL 读写超时的方法：</p></li></ul><p><strong>OpenSSL库的IO操作本身并没有内建的超时机制，但你可以通过其它方法实现类似的效果。具体的实现方式会因你使用的环境和代码的结构而异，但以下是一种常见的方法：<br>将底层的socket设置为非阻塞模式，并且使用系统的函数（如<code>select()</code>, <code>poll()</code> 或者 <code>epoll()</code>）监听这些socket上的事件，并在这些函数中设置超时。</strong></p><p>以下是一个使用<code>select</code>的示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 假设你已经设置了SSL *ssl和连接的socket fd</span><br><br><span class="hljs-comment">// 将socket设置为非阻塞模式</span><br>fcntl(fd, F_SETFL, O_NONBLOCK);<br><br><span class="hljs-comment">// 待超时时间设置为5秒</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">timeout</span>;</span> <br>timeout.tv_sec = <span class="hljs-number">5</span>;<br>timeout.tv_usec = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 对文件描述符进行监听</span><br>fd_set read_fds;<br>FD_ZERO(&amp;read_fds);<br>FD_SET(fd, &amp;read_fds);<br><br><span class="hljs-comment">// 使用select，等待socket有数据可读或者超时</span><br><span class="hljs-type">int</span> ready_for_reading = select(fd + <span class="hljs-number">1</span>, &amp;read_fds, <span class="hljs-literal">NULL</span>, <span class="hljs-literal">NULL</span>, &amp;timeout);<br><span class="hljs-keyword">if</span> (ready_for_reading == <span class="hljs-number">1</span>)<br>&#123;<br>    <span class="hljs-comment">// socket有数据可读，执行SSL_read</span><br>    <span class="hljs-type">int</span> ret = SSL_read(ssl, buffer, <span class="hljs-keyword">sizeof</span>(buffer));<br><br>    <span class="hljs-comment">// 处理读取结果...</span><br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ready_for_reading == <span class="hljs-number">0</span>)<br>&#123;<br>    <span class="hljs-comment">// select超时</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;SSL_read timeout.\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br>    <span class="hljs-comment">// select出错</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error: select.\n&quot;</span>);<br>  <br>    <span class="hljs-comment">// 执行错误处理...</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该方法与 Acl 库中先调用 acl_read_wait() 再调用 SSL_read() 的方式相似，另外又对比了网上查询的一些方案，思路也基本类似，</p><ul><li>显然上面的方式无法在实践中解决 OpenSSL 读导致的 socket 阻塞问题，于是想，如果每次 SSL_read 时函数内部只调用一次 read 的话，上面设置的超时读方法应该是有效的，但如果 SSL_read 内部在某种情况下有多次 read 操作则前面所设置的读等待只对第一次有效，对后面的就无效了；于是又回头仔细查询 SSL_read 的帮助文档，其中有这么一段话：<br><strong>If necessary, a read function will negotiate a TLS&#x2F;SSL session, if not already explicitly performed by SSL_connect(3) or SSL_accept(3). If the peer requests a re-negotiation, it will be performed transparently during the read function operation. The behaviour of the read functions depends on the underlying BIO.</strong></li></ul><p>通过这段话，隐约感觉 SSL_read 内部可能存在多次 read 过程，但上面的话还有点晦涩，接下来只能去看 SSL_read 源码了，从 ssl_lib.c 中找到 SSL_read，其读数据的大体流程为：<br><code>SSL_read</code> &gt;&gt; <code>ssl_read_internal</code> &gt;&gt; <code>s-&gt;method-&gt;ssl_read</code>，然后再顺藤摸瓜，找到 ssl_read 的具体位置在 s3_lib.c 的 ssl3_read_internal 函数中，如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">ssl3_read_internal</span><span class="hljs-params">(SSL *s, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> len, <span class="hljs-type">int</span> peek,</span><br><span class="hljs-params">                              <span class="hljs-type">size_t</span> *readbytes)</span><br>&#123;<br>    <span class="hljs-type">int</span> ret;<br><br>    clear_sys_error();<br>    <span class="hljs-keyword">if</span> (s-&gt;s3-&gt;renegotiate)<br>        ssl3_renegotiate_check(s, <span class="hljs-number">0</span>);<br>    s-&gt;s3-&gt;in_read_app_data = <span class="hljs-number">1</span>;<br>    ret =<br>        s-&gt;method-&gt;ssl_read_bytes(s, SSL3_RT_APPLICATION_DATA, <span class="hljs-literal">NULL</span>, buf, len,<br>                                  peek, readbytes);<br>    <span class="hljs-keyword">if</span> ((ret == <span class="hljs-number">-1</span>) &amp;&amp; (s-&gt;s3-&gt;in_read_app_data == <span class="hljs-number">2</span>)) &#123;<br>        <span class="hljs-comment">/*</span><br><span class="hljs-comment">         * ssl3_read_bytes decided to call s-&gt;handshake_func, which called</span><br><span class="hljs-comment">         * ssl3_read_bytes to read handshake data. However, ssl3_read_bytes</span><br><span class="hljs-comment">         * actually found application data and thinks that application data</span><br><span class="hljs-comment">         * makes sense here; so disable handshake processing and try to read</span><br><span class="hljs-comment">         * application data again.</span><br><span class="hljs-comment">         */</span><br>        ossl_statem_set_in_handshake(s, <span class="hljs-number">1</span>);<br>        ret =<br>            s-&gt;method-&gt;ssl_read_bytes(s, SSL3_RT_APPLICATION_DATA, <span class="hljs-literal">NULL</span>, buf,<br>                                      len, peek, readbytes);<br>        ossl_statem_set_in_handshake(s, <span class="hljs-number">0</span>);<br>    &#125; <span class="hljs-keyword">else</span><br>        s-&gt;s3-&gt;in_read_app_data = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">return</span> ret;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面代码可以看出存在两处读操作（调用ssl_read_bytes），再跟踪一下 ssl_read_bytes 应该就可以找到系统读 API了，懒得跟踪了。即然坐实了可能存在两次 read 的过程，则就可以认定在 SSL_read 设置的读等待超时对于第二次读是无效的。 </p><h2 id="三、解决方案"><a href="#三、解决方案" class="headerlink" title="三、解决方案"></a>三、解决方案</h2><p>问题原因分析出来了，但必须得要有解决方案才成，毕竟生产环境中的项目需要等米下锅。首先想到的方案是直接修改 OpenSSL 源码，在 OpenSSL 的 IO 底层解决超时问题，但觉得不太现实，一个是工作量问题，一个是安全性问题，最后一个是兼容性问题（维护一个特有的 OpenSSL 库是很糟糕的），于是快速放弃了该方案。另外还有一个方案，可以尝试使用 setsockopt() 设置 IO 读取超时，Linux平台设置方法如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tm</span>;</span><br>tm.tv_sec  = timeout;<br>tm.tv_usec = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">// 设置读超时</span><br>setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &amp;tm, <span class="hljs-keyword">sizeof</span>(tm));<br><br><span class="hljs-comment">// 设置写超时</span><br>setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &amp;tm, <span class="hljs-keyword">sizeof</span>(tm));<br></code></pre></td></tr></table></figure><p>下面给出一个示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title function_">set_timeout</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> rw_timeout)</span> &#123;<br>    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timeval</span> <span class="hljs-title">tm</span>;</span><br>    tm.tv_sec  = rw_timeout;<br>    tm.tv_usec = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_RCVTIMEO, &amp;tm, <span class="hljs-keyword">sizeof</span>(tm)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: setsockopt error: %s\r\n&quot;</span>, __FUNCTION__, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (setsockopt(fd, SOL_SOCKET, SO_SNDTIMEO, &amp;tm, <span class="hljs-keyword">sizeof</span>(tm)) &lt; <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;setsockopt error: %s\r\n&quot;</span>, strerror(errno));<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">// 明文通信方式</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">echo</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> rw_timeout)</span> &#123;<br>     <span class="hljs-comment">// 设置读写超时</span><br>    <span class="hljs-keyword">if</span> (rw_timeout &gt; <span class="hljs-number">0</span> &amp;&amp; set_timeout(fd, rw_timeout) &lt; <span class="hljs-number">0</span>) &#123;<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-type">char</span>  buf[<span class="hljs-number">8192</span>];<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">time_t</span> begin = time(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-type">int</span> ret = read(fd, buf, <span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (errno == EAGAIN) &#123;<br>                <span class="hljs-type">time_t</span> end = time(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timeout, try again, time cost=%ld\r\n&quot;</span>, end - begin);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read error: %s\r\n&quot;</span>, strerror(errno));<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        buf[ret] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (write(fd, buf, ret) != ret) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write error\r\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    close(fd);<br>&#125;<br><br><span class="hljs-comment">// SSL 通信方式</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ssl_echo</span><span class="hljs-params">(SSL_CTX *ctx, <span class="hljs-type">int</span> fd, <span class="hljs-type">int</span> rw_timeout)</span> &#123;<br>     <span class="hljs-comment">// 设置读写超时</span><br>    <span class="hljs-keyword">if</span> (rw_timeout &gt; <span class="hljs-number">0</span> &amp;&amp; set_timeout(fd, rw_timeout) &lt; <span class="hljs-number">0</span>) &#123;<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    SSL* ssl = SSL_new(ctx);<br>    <span class="hljs-keyword">if</span> (SSL_set_fd(ssl, fd) != <span class="hljs-number">0</span>) &#123;<br>        SSL_free(ssl);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (SSL_do_handshake(ssl) != <span class="hljs-number">1</span>) &#123;<br>        SSL_free(ssl);<br>        close(fd);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">char</span>   buf[<span class="hljs-number">8192</span>];<br>        <span class="hljs-type">time_t</span> begin = time(<span class="hljs-literal">NULL</span>);<br>        <span class="hljs-type">int</span> ret = SSL_read(ssl, buf, <span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>);<br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-keyword">if</span> (errno == EAGAIN) &#123;<br>                <span class="hljs-type">time_t</span> end = time(<span class="hljs-literal">NULL</span>);<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;timeout, try again, time cost=%ld\r\n&quot;</span>, end - begin);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read error: %s\r\n&quot;</span>, strerror(errno));<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br><br>        buf[ret] = <span class="hljs-number">0</span>;<br><br>        <span class="hljs-keyword">if</span> (SSL_write(fd, buf, ret) != ret) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write error\r\n&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br><br>    SSL_shutdown(ssl);<br>    SSL_free(ssl);<br>    close(fd);<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面例子中，明文模式及SSL模式均使用同样的方法设置 socket 的读写超时，针对 socket 仅需设置一次 IO 超时即可，内核会在读到数据后重新设置超时时间。将上述方法用在 OpenSSL 中就可以解决 IO 读写超时问题，因为 OpenSSL 最终也会调用系统 read API，超时的触发过程是由内核维护的，所以 OpenSSL 每次调用 read 读数据时都会由内核自动设置超时定时器。 在理清解决问题的思路后，将该解决方法用在线上使用 OpenSSL 库的服务项目中，对比观察几日，确认问题已经解决。</p><p>此外，因为该服务程序用到了 Acl 的协程框架，而 Acl 协程 Hook 了系统 read&#x2F;write API，所以也得需要 Hook setsockopt API，并且实现 IO 超时功能，不过此过程不在本次讨论范围，以后有机会再在其它文章介绍。</p><h2 id="四、更多参考"><a href="#四、更多参考" class="headerlink" title="四、更多参考"></a>四、更多参考</h2><ul><li><p>SSL 线程服务器：<a href="https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server</a></p></li><li><p>SSL 线程客户端：<a href="https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client</a></p></li><li><p>SSL 协程服务器：<a href="https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/ssl_server">https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/ssl_server</a></p></li><li><p>SSL 协程客户端：<a href="https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/ssl_client">https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/ssl_client</a></p></li><li><p>HTTPS 协程服务器：<a href="https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/https_server">https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/https_server</a></p></li><li><p>HTTPS 协程客户端：<a href="https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/https_client">https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/https_client</a></p></li></ul>]]></content>
    
    
    <categories>
      
      <category>SSL编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSL编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl_master 管理你的服务器程序</title>
    <link href="/2023/06/10/using_master/"/>
    <url>/2023/06/10/using_master/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-acl-master-管理你的服务器程序"><a href="#使用-acl-master-管理你的服务器程序" class="headerlink" title="使用 acl_master 管理你的服务器程序"></a>使用 acl_master 管理你的服务器程序</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在 Acl(<a href="https://github.com/acl-dev/acl/">https://github.com/acl-dev/acl/</a>) 项目中的 acl_master 模块(位于app&#x2F;master&#x2F;daemon&#x2F; 目录下) 是一个功能强大的服务管理模块，即可以管理使用 Acl 库编写的服务程序，也可以管理非Acl库写的服务程序（如可以管理redis, dnsmasq, ircd 等）。该模块最初来自于开源的邮件MTA–Postfix，后来被 Acl 库作者独立出来，经过长期迭代优化，最后形成一个通用的服务管理程序—acl_master，它的作用类似于 Tomcat 管理 Java Servlet 或 Apache HTTP Server 管理 CGI，管理程序与接受管理的服务子程序是紧耦合的，管理程序可以做到服务子程序的在线热升级；另外，还有一种松耦合的管理方式，比如使用 Supervisor 或 Systemd（Linux平台下）管理服务子进程，很多 Gopher 喜欢用 Supervisor 管理他们用 Go 编写的服务程序，而一些运维人员喜欢用 Systemd 管理一些服务程序。acl_master 可以支持这两类的服务管理方式。</p><p>本文主要讲解使用 acl_master 管理服务程序的一些用法。</p><h2 id="二、使用-acl-master"><a href="#二、使用-acl-master" class="headerlink" title="二、使用 acl_master"></a>二、使用 acl_master</h2><h3 id="2-1、项目下载"><a href="#2-1、项目下载" class="headerlink" title="2.1、项目下载"></a>2.1、项目下载</h3><p>acl_master 存在于 Acl 项目中，可以从以下位置下载 Acl 项目源码：</p><ul><li>Github: <a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a></li><li>Gitee:  <a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></li></ul><h3 id="2-2、模块组成"><a href="#2-2、模块组成" class="headerlink" title="2.2、模块组成"></a>2.2、模块组成</h3><ul><li>acl_master 主程序：位于 acl&#x2F;app&#x2F;master&#x2F;daemon&#x2F; 目录下；</li><li>管理工具，在 acl&#x2F;app&#x2F;master&#x2F;tools&#x2F; 下有一些辅助 acl_master 服务的管理工具：<ul><li>master_ctl: 该工具为 acl_master 的命令行管理工具，通过与 acl_master 进程交互，实现对 acl_master 所管理的服务子进程的控制与管理；</li></ul></li></ul><p><strong>有了 master_ctl 命令行管理工具，技术人员就可以在 acl_master 服务管理框架下管理自己编写的应用服务了，如果感兴趣，还可以继续了解下面的几个辅助工具：</strong></p><ul><li>master_ctld: 这是一个服务程序（同样由acl_master负责管理），其与 acl_master 进行协议层的交互，并对外提供 HTTP 接口服务，实现了类似于命令行工具–master_ctl 类似的功能；</li><li>mater_monitor：一个服务报警程序（由 acl_master 负责管理），当 acl_master 发现其所管理的服务子进程异常退出时，会通知 master_monitor 服务模块，由 master_monitor 进行异常报警（如发送报警邮件）；</li><li>master_guard：一个定期上报 acl_master 管理服务子进程状态的服务模块，该模块定期从 acl_master 获得服务子进程的状态信息（如：内存，句柄数等）并可以将信息上报至指定数据收集模块；</li><li>master_dispatch：该目录下的服务模块可以用来收集多个 acl_master 实例管理服务子进程的连接数信息，并可展示于 Web 浏览器上，方便管理员查看各个服务模块的连接数信息，在 master_dispatch 目录下，存在以下几个模块：<ul><li>server：编译该目录下的程序后的可执行程序为 master_dispatch，一般与应用服务程序部署在同一个 acl_master 节点下，负责一对一地收集服务子程序的连接数信息（即一个 master_dispatch 进程负责收集一个应用服务子进程的连接数信息，将来应该需要进一步优化，使其可以收集多个服务子进程连接数信息）；</li><li>manager：编译后生成可执行程序 dispatch_manager，负责收集所有 master_dispatch 的上报信息，并统一缓存管理；</li><li>www：这是一个 Web 服务程序，可执行程序为 webapp，其会从 dispatch_manager 获取服务集群中各个服务模块的并发连接数信息，同时该模块提供的 Web 静态页面包含了可以在浏览器绘图的 Js 等静态文件，浏览器通过这些 js 脚本定期从 webapp 获得服务模块的连接数信息后，实时动态地展示在浏览器上。</li></ul></li></ul><h3 id="2-3、编译安装"><a href="#2-3、编译安装" class="headerlink" title="2.3、编译安装"></a>2.3、编译安装</h3><ul><li>进入 acl 项目，先运行 <code>make</code> 命令编译 Acl 基础库；</li><li>进入 acl&#x2F;app&#x2F;master&#x2F;daemon 目录，运行 <code>make</code> 命令编译 acl_master；</li><li>然后运行 <code>make install</code>，acl_master 服务程序及其配置文件便会被拷贝至 acl&#x2F;dist&#x2F;master&#x2F;libexec&#x2F; 目录下；</li><li>进入 acl&#x2F;app&#x2F;master&#x2F;tools&#x2F;master_ctl 目录，运行 <code>make</code> 命令编译 acl_master 的命令行管理工具 master_ctl，然后运行 <code>make install</code>，该程序将被拷贝至 acl&#x2F;dist&#x2F;master&#x2F;bin&#x2F; 目录下</li><li>进入 acl&#x2F;dist&#x2F;master 目录，运行安装脚本：<code>./setup.sh /opt/soft/acl-master</code>，acl_master 及其相关文件便被安装至 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F; 目录下；</li></ul><p><strong>针对那些使用 CentOS 环境的开发及运维人员，Acl 库还提供了 RPM 包的生成及部署方式，极大的方便运维人员：</strong> 进入 acl&#x2F;packaging&#x2F; 目录，运行 <code>make PKG_NAME=acl_master</code> 便会在 x86_64&#x2F; 目录下生成 acl-master 的 RPM 安装包，用户可以直接安装该 RPM 包：<code>#rpm -ivh acl-master-3.5.5-0.x86_64.rpm</code>，最终 acl_master 及相关模块会被安装于 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F; 目录下。</p><h3 id="2-4、运行管理"><a href="#2-4、运行管理" class="headerlink" title="2.4、运行管理"></a>2.4、运行管理</h3><ul><li>在 acl_master 的安装目录（&#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F;sh&#x2F;）下有以下几个脚本用来启停 acl_master 服务：<ul><li>start.sh：启动 acl_master 服务；</li><li>stop.sh：停止 acl_master 服务；</li><li>master.sh（仅限Linux）：提供了 acl_master 启动、停止、重新加载配置的控制命令。</li></ul></li><li>在 CentOS Linux 下，当以 RPM 包方式安装了 acl_master 服务后，还可以通过以下命令启停 acl_master 服务：<ul><li>启动服务：<code>#service acl-master start</code>；</li><li>停止服务：<code>#service acl-master stop</code>。</li></ul></li></ul><h3 id="2-5、使用-master-ctl-命令行管理工具"><a href="#2-5、使用-master-ctl-命令行管理工具" class="headerlink" title="2.5、使用 master_ctl 命令行管理工具"></a>2.5、使用 master_ctl 命令行管理工具</h3><p><code>master_ctl</code> 一般会被安装在 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F;bin&#x2F; 目录下，使用该工具可以方便地管理由 acl_master 所管理的服务子进程，下面是该工具的常见功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell">sh-3.2# ./master_ctl -h<br>usage: ./master_ctl -h[help]<br> -s master_manage_addr[default: /opt/soft/acl-master/var/public/master.sock]<br> -f service_path<br> -t timeout[waiting the result from master, default: 0]<br> -a cmd[list|stat|start|stop|reload|restart|signal]<br> -n signum[specify the signal number if command is signal]<br> -e extname[specified the extname of service&#x27;s path, just for start and restart]<br> -v [the current version of master_ctl]<br></code></pre></td></tr></table></figure><p>针对以上参数，主要说明下面几个：</p><ul><li><strong>-s</strong> 参数指定与 <code>acl_master</code> 通信的原始套接口全路径；</li><li><strong>-f</strong> 参数指定服务子进程配置文件的全路径；</li><li><strong>-a</strong> 参数指定了常用的控制命令：<ul><li><strong>list：</strong> 列出<code>acl_master</code>所管理的所有服务子程序；</li><li><strong>start：</strong> 启动由 <strong>-f</strong> 参数所指定的服务程序；</li><li><strong>stop：</strong> 停止由 <strong>-f</strong> 参数所指定的服务程序；</li><li><strong>stat：</strong> 查看由 <strong>-f</strong> 参数所指定的服务程序的运行状态；</li><li><strong>reload：</strong> 使由 <strong>-f</strong> 参数所指定的服务程序重新加载其配置文件；</li><li><strong>restart：</strong> 重启由 <strong>-f</strong> 参数所指定的服务程序；</li><li><strong>signal：</strong> 向由 <strong>-f</strong> 参数所指定的服务程序发送由参数 <strong>-n</strong> 指定的系统信号。</li></ul></li></ul><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>本文以上内容主要描述了 Acl 中服务管理框架（acl-master）的编译、安装及管理过程，为方便大家快速掌握及理解，用户不防结合另一篇文章《使用向导快速生成服务程序》<a href="https://acl-dev.cn/2023/05/27/using_wizard/">https://acl-dev.cn/2023/05/27/using_wizard/</a> 来实际操作一下，看看 acl_master 是如何管理应用服务程序的。</p>]]></content>
    
    
    <categories>
      
      <category>服务编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用向导快速生成服务程序</title>
    <link href="/2023/05/27/using_wizard/"/>
    <url>/2023/05/27/using_wizard/</url>
    
    <content type="html"><![CDATA[<h1 id="使用向导快速生成服务程序"><a href="#使用向导快速生成服务程序" class="headerlink" title="使用向导快速生成服务程序"></a>使用向导快速生成服务程序</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在 Acl 工程提供了一个简单实用的工具（位于：acl&#x2F;app&#x2F;wizard 目录下），可协助使用者快速生成基于 Acl 库的服务器程序，所生成的服务器程序包含了 Acl 服务器编程框架中的多种服务模型（进程池模型、线程池模型、非阻塞模型、协程模型、触发器模型），同时面向 HTTP 开发者提供了基于进程池模型、线程池模型及协程模型的 HTTP 服务程序的生成模块。本文以生成一个基于协程的 HTTP 服务器为例介绍向导程序的使用过程。</p><h2 id="二、使用向导工具"><a href="#二、使用向导工具" class="headerlink" title="二、使用向导工具"></a>二、使用向导工具</h2><h3 id="2-1、下载与编译"><a href="#2-1、下载与编译" class="headerlink" title="2.1、下载与编译"></a>2.1、下载与编译</h3><ul><li>从 <a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a> 下 Acl 项目源码，在该项目的 app&#x2F;wizard 目录便是向导工具的程序源码；</li><li>在 acl 项目目录下编译 Acl 项目，直接运行 <code>make</code> 命令即可；</li><li>进入 app&#x2F;wizard 目录，运行 <code>make</code>，应该会生成 wizard 可执行程序。</li></ul><h3 id="2-2、使用-wizard-向导"><a href="#2-2、使用-wizard-向导" class="headerlink" title="2.2、使用 wizard 向导"></a>2.2、使用 wizard 向导</h3><p>运行 <code>./wizard</code>，则提示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">./wizard</span><br>select one below:<br>m: master_service; d: db; h: http; q: exit<br><span class="hljs-meta prompt_">&gt;</span><br></code></pre></td></tr></table></figure><p>上面提示如下：</p><ul><li><code>m</code> 生成标准（仅支持从原生 socket 读写数据）的 Acl 服务器程序；</li><li><code>h</code> 生成 HTTP 服务器程序；</li><li>‘d’ 生成数据库相关程序（未实现）；</li><li>‘q’ 退出 wizard 向导程序。</li><li>输入 &#96;h’ 表示将要生成 HTTP 服务器程序，提示用户输入将要生成的服务程序名称：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">h</span><br>please input your program name: httpd<br></code></pre></td></tr></table></figure>此处，输入程序名 <code>httpd</code>，然后提示如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">s: http servlet<br><span class="hljs-meta prompt_">&gt;</span><br></code></pre></td></tr></table></figure>当前，向导程序仅支持生成类似于 Java HttpServlet 类型的服务器程序，此处，我们应输入 <code>s</code>，然后提示：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs shell">create httpd/Makefile ok.<br>create httpd/valgrind.sh ok.<br>create httpd/httpd.sln ok.<br>create httpd/httpd.vcproj ok.<br>create httpd/httpd_vc2008.sln ok.<br>create httpd/httpd_vc2008.vcproj ok.<br>create httpd/httpd_vc2010.sln ok.<br>create httpd/httpd_vc2010.vcxproj ok.<br>create httpd/httpd_vc2010.vcxproj.filters ok.<br>create httpd/httpd_vc2012.sln ok.<br>create httpd/httpd_vc2012.vcxproj ok.<br>create httpd/httpd_vc2012.vcxproj.filters ok.<br>create httpd/httpd_vc2019.sln ok.<br>create httpd/httpd_vc2019.vcxproj ok.<br>create httpd/httpd_vc2019.vcxproj.filters ok.<br>create httpd/Makefile.in ok<br>create httpd/stdafx.h ok<br>create httpd/stdafx.cpp ok<br>create common_files ok!<br>Do you want add cookie? [y/n]:<br></code></pre></td></tr></table></figure>上面显示 <code>wizard</code> 程序自动生成一些源文件及工程文件，接着提示是否需要支持 <code>http cookies</code>，此处我们选择 <code>n</code> – 即不需要。然后提示：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">Do you want add cookie? [y/n]: n<br>create httpd/http_servlet.cpp ok.<br>choose master_service type:<br>        t: for master_threads<br>        f: for master_fiber<br>        p: for master_proc<br><span class="hljs-meta prompt_">&gt;</span><br></code></pre></td></tr></table></figure>此处需要我们选择服务模型类型，此处选择 <code>f</code> 表示生成协程服务程序，显示如下：<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">&gt;</span><span class="language-bash">f</span><br>create httpd/httpd.cf ok.<br>create httpd/Makefile.in ok<br>create httpd/stdafx.h ok<br>create httpd/main.cpp ok<br>create httpd/master_service.h ok<br>create httpd/master_service.cpp ok<br>create httpd/http_service.h ok<br>create httpd/http_service.cpp ok<br>create httpd/http_servlet.h ok<br>create httpd/websocket.cpp ok<br>create httpd/websocket.h ok<br>create master_fiber ok!<br>create httpd/Makefile ok.<br>create httpd/Makefile.in ok<br>select one below:<br>m: master_service; d: db; h: http; q: exit<br><span class="hljs-meta prompt_">&gt;</span><br></code></pre></td></tr></table></figure>wizard显示生成了一些与协程及http服务相关的源码文件、工程文件及配置文件。至此，我们使用 wizard 生成了一个基于 Acl 协程模型的 HTTP 服务器程序，然后退出 wizard 程序。</li></ul><h3 id="2-3、快速浏览向导生成的文件"><a href="#2-3、快速浏览向导生成的文件" class="headerlink" title="2.3、快速浏览向导生成的文件"></a>2.3、快速浏览向导生成的文件</h3><p>进入 <code>./httpd</code> 目录，可以看到帮我们生成了以下文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">-rw-------  1 zsx  staff    151 May 27 10:43 Makefile<br>-rw-------  1 zsx  staff   4388 May 27 10:43 Makefile.in<br>-rw-------  1 zsx  staff   3612 May 27 10:43 http_service.cpp<br>-rw-------  1 zsx  staff   1327 May 27 10:43 http_service.h<br>-rw-------  1 zsx  staff   3032 May 27 10:43 http_servlet.cpp<br>-rw-------  1 zsx  staff   1336 May 27 10:43 http_servlet.h<br>-rw-------  1 zsx  staff   6190 May 27 10:43 httpd.cf<br>-rw-------  1 zsx  staff   1265 May 27 10:43 httpd.sln<br>-rw-------  1 zsx  staff   8492 May 27 10:43 httpd.vcproj<br>-rw-------  1 zsx  staff   1291 May 27 10:43 httpd_vc2008.sln<br>-rw-------  1 zsx  staff  10196 May 27 10:43 httpd_vc2008.vcproj<br>-rw-------  1 zsx  staff   1292 May 27 10:43 httpd_vc2010.sln<br>-rw-------  1 zsx  staff  12782 May 27 10:43 httpd_vc2010.vcxproj<br>-rw-------  1 zsx  staff   1944 May 27 10:43 httpd_vc2010.vcxproj.filters<br>-rw-------  1 zsx  staff   2036 May 27 10:43 httpd_vc2012.sln<br>-rw-------  1 zsx  staff  21055 May 27 10:43 httpd_vc2012.vcxproj<br>-rw-------  1 zsx  staff   1944 May 27 10:43 httpd_vc2012.vcxproj.filters<br>-rw-------  1 zsx  staff   1999 May 27 10:43 httpd_vc2019.sln<br>-rw-------  1 zsx  staff  22236 May 27 10:43 httpd_vc2019.vcxproj<br>-rw-------  1 zsx  staff   1887 May 27 10:43 httpd_vc2019.vcxproj.filters<br>-rw-------  1 zsx  staff   4241 May 27 10:43 main.cpp<br>-rw-------  1 zsx  staff   5265 May 27 10:43 master_service.cpp<br>-rw-------  1 zsx  staff    672 May 27 10:43 master_service.h<br>-rw-------  1 zsx  staff    218 May 27 10:43 stdafx.cpp<br>-rw-------  1 zsx  staff   3107 May 27 10:43 stdafx.h<br>-rwxr-xr-x  1 zsx  staff   3960 May 27 10:43 setup.sh<br>-rwxr-xr-x  1 zsx  staff     79 May 27 10:43 valgrind.sh<br>-rw-------  1 zsx  staff   2978 May 27 10:43 websocket.cpp<br>-rw-------  1 zsx  staff     67 May 27 10:43 websocket.h<br></code></pre></td></tr></table></figure><p>可以看到，<code>wizard</code> 程序生成的文件主要包括：程序源文件、工程文件及配置文件。分别简单介绍一下这几类文件：</p><ul><li>程序源文件：<ul><li>main.cpp</li><li>stdafx.cpp&#x2F;stdafx.h，在头文件中包含了 Acl 相关库的头文件及其它常用系统 API 头文件；</li><li>master_service.cpp&#x2F;master_service.h，在头文件中可以看到当前的服务模型为协程服务模型，因为服务类继承于 acl::master_fiber 类；</li><li>http_service.cpp&#x2F;http_service.h，http_servlet.cpp&#x2F;http_servlet.h，与 HTTP 服务路由注册管理相关的类，一般不需要用户修改；</li><li>websocket.cpp&#x2F;websocket.h，如果用户想要支持 websocket，可以给此类增加应用功能。</li></ul></li><li>工程文件：<ul><li>Makefile&#x2F;Makefile.in，在 Linux&#x2F;Unix 平台下的工程文件，Makefile 包含并依赖于 Makefile.in，在 Makefile.in 中可以添加编译选项、程序源文件等，在 Makefile 中可以修改程序名，如果要支持 C++11 特性，还可以打开 C++11 的编译开关；</li><li>xxx.sln, xxx.vcxproj, xxx.vcxproj.filters，这些文件为在 Windows 平台下使用 VS 编译示例程序的工作文件；</li></ul></li><li>配置文件 httpd.cf，为未例服务程序运行时可以加载的配置文件。</li><li>安装脚本：setup.sh，可以将生成的服务器程序及配置文件安装至指定目录，如果当前系统部署了acl-master服务管理框架，则安装脚本会自动将该服务注册至acl-master的服务管理配置中。</li></ul><h3 id="2-4、编译测试协程-HTTP-服务器"><a href="#2-4、编译测试协程-HTTP-服务器" class="headerlink" title="2.4、编译测试协程 HTTP 服务器"></a>2.4、编译测试协程 HTTP 服务器</h3><p>在上面用向导程序生成的 <code>httpd</code> 目录下运行 <code>make</code> 编译服务程序，于是便生成了一个名为 <code>httpd</code> 的基于协程服务模型的 http 服务程序。以手工方式启动该 httpd 程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./httpd alone httpd.cf<br></code></pre></td></tr></table></figure><p>显示如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs shell">listen: 127.0.0.1|8088<br>master_log_open(36): no MASTER_LOG&#x27;s env value<br>src/fiber_server.cpp(1148), acl_fiber_server_main: configure file=httpd.cf<br>src/fiber_server.cpp(912)-&gt;server_init: can&#x27;t get SERVICE_LOG&#x27;s env value, use acl_master.log log<br>acl_inet_listen: listen 127.0.0.1:8088 ok<br>server_open: listen 127.0.0.1:8088 ok<br>master_service.cpp(126), proc_pre_jail: &gt;&gt;&gt;proc_pre_jail&lt;&lt;&lt;<br>master_service.cpp(136), proc_on_init: &gt;&gt;&gt;proc_on_init&lt;&lt;&lt;<br>master_service.cpp(142), proc_on_init: not use SSL mode<br>schedule event type - kernel<br>master_fiber.cpp(110), service_on_listen: listen 127.0.0.1|8088 ok, fd=8<br>master_service.cpp(131), proc_on_listen: &gt;&gt;&gt;listen 127.0.0.1|8088 ok&lt;&lt;&lt;<br>daemon started, log=acl_master.log, ev=0<br></code></pre></td></tr></table></figure><p>然后我们可以用浏览器或<code>curl</code> 工具进行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://127.0.0.1:8088/test</span><br>/test/: hello world!, method=1, GET<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_">$ </span><span class="language-bash">curl http://127.0.0.1:8088/</span><br>hello world!<br></code></pre></td></tr></table></figure><h3 id="2-5、发布服务程序至acl-master服务管理框架"><a href="#2-5、发布服务程序至acl-master服务管理框架" class="headerlink" title="2.5、发布服务程序至acl_master服务管理框架"></a>2.5、发布服务程序至acl_master服务管理框架</h3><p>向导程序生成安装脚本 <code>setup.sh</code> 可用来安装编译好的服务程序，执行如下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">./setup.sh /opt/soft/httpd</span><br></code></pre></td></tr></table></figure><p>该脚本自动将 httpd 服务程序安装至 <code>/opt/soft/httpd/sbin/</code> 目录下，同时将其配置文件拷贝至 <code>/opt/soft/httpd/conf</code> 目录；如果当前环境中安装了 <code>acl_master</code> 服务管理框架，安装脚本会将该服务的配置文件全路径 <code>/opt/soft/httpd/conf/httpd.cf</code> 添加进 <code>acl_master</code> 的服务管理文件 <code>/opt/soft/acl-master/conf/services.cf</code> 中，这样当 <code>acl_master</code> 程序重启后会自动拉起在 <code>services.cf</code> 配置的程序。</p>]]></content>
    
    
    <categories>
      
      <category>服务编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>iQiYi使用网络协程编写高并发应用实践</title>
    <link href="/2020/06/05/about_fiber/"/>
    <url>/2020/06/05/about_fiber/</url>
    
    <content type="html"><![CDATA[<h1 id="iQiYi使用网络协程编写高并发应用实践"><a href="#iQiYi使用网络协程编写高并发应用实践" class="headerlink" title="iQiYi使用网络协程编写高并发应用实践"></a>iQiYi使用网络协程编写高并发应用实践</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在早期程序员为了支持多个用户并发访问服务应用，往往采用多进程方式，即针对每一个 TCP 网络连接创建一个服务进程。在 2000 年左右，比较流行使用 CGI 方式编写 Web 服务，当时人们用的比较多的 Web 服务器是基于多进程模式开发的 Apache1.3.x 系列，因为进程占用系统资源较多，所以人们开始使用多线程方式编写 Web 服务应用，因为线程占用的资源更少，这使单台服务器支撑的用户并发度提高了，但依然存在资源浪费的问题。因为在多进程或多线程编程方式下，均采用了阻塞通信方式，这会使得服务端的进程或线程因『等待』客户端的请求数据而变得『空闲』，而且在该空闲期间还不能做别的事情，白白浪费了操作系统的调度时间和内存资源。这种一对一的服务方式在广域网的环境下显示变得不够廉价，于是人们开始采用非阻塞网络编程方式来提升网络服务并发度，比较著名的 Web 服务器 Nginx 就是非阻塞服务的典型代表，另外还有象 Java Netty 这样的非阻塞网络开发库。<br> 非阻塞网络编程一直以高并发和高难度而著称，这种编程方式虽然有效的提升了服务器的利用率和处理性能，但却对广大程序员提出了较大挑战，因为非阻塞 IO 的编程方式往往会把业务逻辑分隔的支离破碎，需要在通信过程中记录大量的中间状态，而且还需要处理各种异常情况，最终带来的后果就是开发周期长、复杂度高，而且难于维护。<br>阻塞式网络编程实现容易但并发度不高，非阻塞网络编程并发度高但编写难，针对这两种网络编程方式优缺点，人们提出了使用协程方式编写网络程序的思想，其实协程本身并不是一个新概念，早在2000年前 Windows NT 上就出现了『纤程』的 API，号称可以创建成千上万个纤程来处理业务任务，在 BSD Unix 上可以用来实现协程切换的 API &lt;ucontext.h&gt; 在 2002 年就已经存在了，当然另外用于上下文跳转的 API &lt;setjmp.h&gt; 出现的更早（1993年）。虽然协程的概念出现的较早，但人们终不能发现其广大的应用场景，象『longjmp』这些 API 多用在一些异常跳转上，如 Postfix（著名的邮件MTA）在处理网络异常时用其实现程序跳转。直到 Russ Cox 在 Go 语言中加入了协程（Goroutine）的功能，使用协程进行高并发网络编程才变得的简单易行。<br>Russ Cox 早在 2002 年就编写了一个简单的网络协程库 libtask（<a href="https://swtch.com/libtask/">https://swtch.com/libtask/</a> ），代码量不多，却可以使我们比较清晰地看到『通过使网络 IO 协程化，使编写高并发网络程序变得如此简单』。<br>本文以爱奇艺开源的网络协程库（<a href="https://github.com/iqiyi/libfiber">https://github.com/iqiyi/libfiber</a> ）为例，讲解网络协程的设计原理、编程实践、性能优化等方面内容。</p><h2 id="二、网络协程基本原理"><a href="#二、网络协程基本原理" class="headerlink" title="二、网络协程基本原理"></a>二、网络协程基本原理</h2><p><strong><code>网络协程</code></strong> 的 <strong><code>本质</code></strong> 是将应用层的阻塞式 IO 过程在底层转换成非阻塞 IO 过程，并通过程序运行栈的上下文切换使 <strong>IO</strong> 准备就绪的协程交替运行，从而达到以简单方式编写高并发网络程序的目的。既然网络协程的底层也是非阻塞IO过程，所以在网络在介绍网络协程基本原理前，我们先了解一下非阻塞网络通信的基本过程。</p><h3 id="2-1、网络非阻塞编程"><a href="#2-1、网络非阻塞编程" class="headerlink" title="2.1、网络非阻塞编程"></a>2.1、网络非阻塞编程</h3><p>下面给出了网络非阻塞编程的常见设计方式：<br><img src="/img/aio_architecture.png" alt="aio_architecture"></p><ul><li>使用操作系统提供的多路复用事件引擎 API（select&#x2F;poll&#x2F;epoll&#x2F;kqueue etc），将网络套接字的网络读写事件注册到事件引擎中；</li><li>当套接字满足可读或可写条件时，事件引擎设置套接字对应的事件状态并返回给调用者；</li><li>调用者根据套接字的事件状态分别『回调』对应的处理过程；</li><li>对于大部分基于 TCP 的网络应用，数据的读写往往不是一次 IO 就能完成的，这样，对于一次会话过程就会有多次 IO 读写过程，在每次 IO 过程中都需要缓存读写的数据，直至本次数据会话完成。</li></ul><p>下图以非阻塞读为例展示了整个异步非阻塞读及回调处理过程：  </p><p><img src="/img/nio_read.png" alt="nio_read"></p><p>相对于阻塞式读的处理过程（循环读数据直至读完成或关闭），非阻塞读过程的确要复杂很多：</p><ul><li>一次完整的 IO 会话过程会被分割成多次的 IO 过程；</li><li>每次 IO 过程需要缓存部分数据及当前会话的处理状态；</li><li>要求相关的解析器（如：Json&#x2F;Xml&#x2F;Mime 解析器）最好能支持流式解析方式，否则就得需要读到完整数据后才能交给解析器去处理，当遇到业数据较大时就需要分配较大的连续内存块，势必造成系统的内存分配压力；</li><li>因为当前绝大部分后台系统（如数据库、存储系统、缓存系统）所提供的客户端驱动都是阻塞式的，所以无法直接应用在非阻塞通信应用中，从而限制了非阻塞通信方式的应用场景；</li><li>因为多次 IO 过程将应用的业务处理逻辑分割的支离破碎，大大增加了业务编写过程的复杂度，降低了开发效率，同时加大了后期的不易维护性。</li></ul><h3 id="2-2、网络协程编程"><a href="#2-2、网络协程编程" class="headerlink" title="2.2、网络协程编程"></a>2.2、网络协程编程</h3><h4 id="2-2-1、几个概念"><a href="#2-2-1、几个概念" class="headerlink" title="2.2.1、几个概念"></a>2.2.1、几个概念</h4><p>在了解使用协程编写网络程序之前，需要先了解几个概念：</p><ul><li><strong>最小调度单元：</strong> 当前大部分操作系统的最小调度单元是线程，即在单核或多核 CPU 环境中，操作系统是以线程为基本调度单元的，操作系统负责将多个线程任务唤入唤出；</li><li><strong>上下文切换：</strong> 当操作系统需要将某个线程挂起时，会将该线程在 CPU 寄存器中的栈指针、状态字等保存至该线程的内存栈中；当操作系统需要唤醒某个被挂起的线程时（重新放置在CPU中运行），会将该线程之前被挂起的栈指针重新置入 CPU 寄存器中，并恢复之前保留的，从而使该线程得以运行；通过这样的挂起与唤醒操作，便完成了不同线程间的上下文切换；</li><li><strong>并行与网络并发：</strong> 并行是指同一『时刻』同时运行的任务数，并行任务数量取决于 CPU 核心数量；而网络并发是指在某一『时刻』网络连接的数量；类似于二八定律，在客户端与服务端保持 TCP 长连接时，大部分连接是空闲的，所以服务端只需响应少量活跃的网络连接即可，服务端采用多路复用技术，即使使用单核也可以支持 100K 个网络连接。</li></ul><h4 id="2-2-2、协程的切换过程"><a href="#2-2-2、协程的切换过程" class="headerlink" title="2.2.2、协程的切换过程"></a>2.2.2、协程的切换过程</h4><p>前面提到操作系统进行任务调度的最小单元是线程，操作系统无法感知这些协程的存在，自然也就无法对其进行调度，因此存在于线程中的大量协程需要相互协作，合理地占用 CPU 时间片，在合适的运行点（如：网络阻塞点）主动让出 CPU，给其它协程提供运行的机会。<br>每个协程都会经历如下过程：  </p><p><img src="/img/fiber_running.png" alt="fiber_running"></p><p>协程之间的切换一般可分为『星形切换』和『环形切换』，参照下图：<br><img src="/img/fiber_switch.png" alt="fiber_switch"></p><p>当有大量的协程需要运行时，在『环形切换』模式下，前一个协程运行完毕后直接『唤醒』并切换至下一个协程，而无需象『星形切换』那样先切换至调度原点，再从调度原点来『唤醒』下一个协程；因为『环形切换』要比『星形切换』节省了一次上下文的切换过程，所以『环形切换』方式的切换效率更高。</p><h4 id="2-2-3、网络过程协程化"><a href="#2-2-3、网络过程协程化" class="headerlink" title="2.2.3、网络过程协程化"></a>2.2.3、网络过程协程化</h4><p>下图是使网络过程协程化的示意图：</p><p><img src="/img/fiber_schedule.png" alt="fiber_schedule"></p><ul><li>在网络协程库中，内部有一个缺省的 <code>IO调度协程</code>，其负责处理与网络 IO 相关的协程调度过程，故称之为『<strong>IO 调度协程</strong>』；</li><li>每一个网络连接绑定一个套接字句柄，该套接字绑定一个协程；</li><li>当对网络套接字进行读写操作时，将该套接字添加至 IO 调度协程的事件引擎中并设置读写事件，然后将该协程挂起；这样所有处于读写等待状态的网络协程都被挂起，且与之关联的网络套接字均由 IO 调度协程的事件引擎统一监控管理；</li><li>当某些网络套接字满足可读或可写条件时，IO 调度协程的事件引擎返回这些套接字的状态，IO 调度协程找到与这些套接字绑定的协程对象，然后分别唤醒这些协程，使之依次运行；</li><li>IO 事件协程内部本身也是由系统事件引擎（如：Linux 下的 epoll 事件引擎）驱动的，其内部 IO 事件的驱动机制和上面介绍的非阻塞过程相似，当某个套接字句柄『准备就绪』时，IO 调度协程便将其所绑定的协程添加进协程调度队列中，待本次 IO 调度协程返回后，会依次运行协程调度队列里的所有协程。</li></ul><h4 id="2-2-4、网络协程示例"><a href="#2-2-4、网络协程示例" class="headerlink" title="2.2.4、网络协程示例"></a>2.2.4、网络协程示例</h4><p>下面给出一个使用协程方式编写的网络服务器程序，该程序位于：<a href="https://github.com/iqiyi/libfiber">https://github.com/iqiyi/libfiber</a> 。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fiber/lib_fiber.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;patch.h&quot;</span>  <span class="hljs-comment">// 主要包含：SOCKET, socket_close(), socket_listen(), socket_accept()</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">size_t</span> __stack_size  = <span class="hljs-number">128000</span>;  <span class="hljs-comment">// 协程栈大小设为 128 KB 左右</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">fiber_client</span><span class="hljs-params">(ACL_FIBER *fb, <span class="hljs-type">void</span> *ctx)</span> &#123;<br>    SOCKET fd = (<span class="hljs-type">int</span> *) ctx;<br>    <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];<br>    <span class="hljs-built_in">free</span>(ctx);<br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-type">int</span> ret = acl_fiber_recv(fd, buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-number">0</span>);  <span class="hljs-comment">// 读客户端请求数据</span><br>        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 说明网络连接关闭</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-keyword">if</span> (acl_fiber_last_error() == FIBER_EINTR) &#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        <span class="hljs-keyword">if</span> (acl_fiber_send(fd, buf, ret, <span class="hljs-number">0</span>) &lt; <span class="hljs-number">0</span>) &#123;  <span class="hljs-comment">// 回写数据</span><br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>    socket_close(fd);  <span class="hljs-comment">// 关闭套接字</span><br>&#125;<br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">fiber_accept</span><span class="hljs-params">(ACL_FIBER *fb, <span class="hljs-type">void</span> *ctx)</span> &#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *addr = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *) ctx;<br>    SOCKET lfd = socket_listen(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">9001</span>);  <span class="hljs-comment">// 创建监听套接字</span><br>    assert(lfd &gt;= <span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">for</span> (;;) &#123;<br>        SOCKET *pfd, cfd = socket_accept(lfd);  <span class="hljs-comment">// 等待客户端连接</span><br>        <span class="hljs-keyword">if</span> (cfd == <span class="hljs-number">-1</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept error %s\r\n&quot;</span>, acl_fiber_last_serror());<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        pfd  = (<span class="hljs-type">int</span> *) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(SOCKET));<br>        *pfd = cfd;<br>        acl_fiber_create(fiber_client, pfd, __stack_size);  <span class="hljs-comment">// 创建协程处理连接请求</span><br>    &#125;<br>    acl_fiber_schedule_stop();  <span class="hljs-comment">// 停止协程调度器</span><br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    <span class="hljs-comment">// 指定 IO 事件引擎类型，在 Linux 下将采用 epoll</span><br>    <span class="hljs-type">int</span> event_mode = FIBER_EVENT_KERNEL;<br><br>    <span class="hljs-comment">// 创建网络监听协程，用来接收客户端连接请求</span><br>    acl_fiber_create(fiber_accept, <span class="hljs-literal">NULL</span>, __stack_size);<br><br>    <span class="hljs-comment">// 开始运行协程调度器</span><br>    acl_fiber_schedule_with(event_mode);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该网络协程服务器程序处理流程为：</p><ul><li>创建一个监听协程，其『堵』在  <code>accept()</code> 调用上，等待客户端连接；</li><li>启动协程调度器，开始运行新创建的监听协程；</li><li>监听协程每当接收一个客户端连接，便创建一个客户端协程单独处理该网络连接，然后监听协程继续等待下一个客户端连接；</li><li>客户端协程以『阻塞』方式读写网络连接数据；</li><li>客户端连接处理完毕，关闭连接，并退出协程。</li></ul><p>从该例子可以看出，网络协程的处理过程都是顺序方式，比较符合人的思维模式；我们很容易将该例子改成线程方式，处理逻辑和协程方式相似，但协程方式更加轻量、占用资源更少，并发处理能力更强。<br>简单的表面必定隐藏着复杂的底层设计，因为网络协程过程在底层还是需要转为『非阻塞』处理过程，只是使用者并未感知而已。</p><h2 id="三、网络协程核心设计要点"><a href="#三、网络协程核心设计要点" class="headerlink" title="三、网络协程核心设计要点"></a>三、网络协程核心设计要点</h2><p>在介绍了网络协程的基本设计原理后，本章节主要介绍 <code>libfiber</code> 网络协程的核心设计要点，为网络协程应用实践化提供了基本的设计思路。</p><h3 id="3-1、协程调度"><a href="#3-1、协程调度" class="headerlink" title="3.1、协程调度"></a>3.1、协程调度</h3><p>libfiber 采用了单线程调度方式，主要是为了避免设计的复杂性及效率上的影响。如果设计成多线程调度模式，则必须首先需要考虑：</p><ul><li>多核环境下 CPU 缓存亲和性：因为 CPU 本身有高效的多级缓存，虽然 CPU 多级缓存容量较内存小的多，但访问效率却远高于内存，单线程调度方式下，可以方便编译器有效地进行 CPU 缓存使用优化，使运行指令和共享数据尽可能放置在 CPU 缓存中，而如果采用多线程调度方式，多个线程间共享的数据就可能使 CPU 缓存失效，会造成调度线程越多，协程的运行效率越低的问题；</li><li>多线程分配任务时的同步问题：当多个线程需要从公共协程任务资源中获取协程任务时，必然需要采用增加『锁』保护机制，一旦产生大量的『锁』冲突，则势必会造成运行性能的严重损耗；</li><li>事件引擎操作优化：下面会介绍在单线程调度模式下的事件引擎操作优化，在多线程调度则很难进行如此优化。</li></ul><p>当然，单线程调度也需解决如下问题：</p><ul><li>如何有效地使用多核：在单线程调度方式下，该线程内的多个协程在运行时仅能使用单核，这显示是不合理的，解决方案为：<ul><li>启动多个进程，每个进程运行一个线程;</li><li>同一进程内启动多个线程，每个线程运行独立的协程调度过程；</li></ul></li><li>多个线程之间的资源共享：因为协程调度是不跨线程的，在设计协程互斥锁时需要考虑：<ul><li>协程锁需要支持『同一线程内的协程之间、不同线程的协程之间、协程线程与非协程线程之间』的互斥；</li><li>网络连接池的线程隔离机制，即需要为每个线程建立各自独立的连接池，防止连接对象在不同线程的协程之间共享，否则便会造成同一网络连接在不同线程的协程之间使用，破坏单线程调度规则；</li></ul></li><li>需要防止线程内的某个协程『疯狂』占用 CPU 资源，导致本线程内的其它协程得不到运行的机会，虽然此类问题在多线程调度时也会造成问题，但显然在单线程调度时造成的后果更为严重。</li></ul><h3 id="3-2、协程事件引擎设计"><a href="#3-2、协程事件引擎设计" class="headerlink" title="3.2、协程事件引擎设计"></a>3.2、协程事件引擎设计</h3><h4 id="3-2-1、跨平台性"><a href="#3-2-1、跨平台性" class="headerlink" title="3.2.1、跨平台性"></a>3.2.1、跨平台性</h4><p>libfiber 的事件引擎支持现在主流的操作系统，从而为 libfiber 的跨平台特性提供了有力的支撑，下面为 libfiber 事件引擎所支持的平台：</p><ul><li><strong>Linux：</strong> sekect&#x2F;poll&#x2F;epoll&#x2F;io_uring，epoll 为 Linux 内核级事件引擎，采用事件触发机制，不象 select&#x2F;poll 的轮循方式，所以 epoll 在处理大并发网络连接时运行效率更高；而 io_uring 引擎是在内核5.1以后出现的新的事件引擎，由 Facebook 的 Jens Axboe(IO 压测工作 fio 作者) 设计完成，该引擎为真正的异步 IO 模型（为 IO 完成模型），统一了网络 IO 与文件 IO 过程（不象 epoll 仅支持网络，因为其是事件通知方式，无法预知 IO 何时完成）；</li><li><strong>BSD&#x2F;MacOS：</strong> select&#x2F;poll&#x2F;kqueue，kqueue 也为内核级事件引擎，在大并发环境下具有更高的性能；</li><li><strong>Windows：</strong> select&#x2F;poll&#x2F;iocp&#x2F;Windows 窗口消息，其中 iocp 为 Windows 平台下的内核级高效事件引擎；libfiber 支持采用界面消息引擎做为底层的事件引擎，这样在编写 Windows 界面程序的网络模块时便可以使用协程方式了，之前人们在 Windows 平台编写界面程序的网络模块时，一般采用以下两种方式：<ul><li>采用非阻塞方式，网络模块与界面模块在同一线程中；</li><li>将网络模块放到独立的线程中运行，运行结果通过界面消息『传递』到界面线程中；</li></ul></li></ul><p>现在 libfiber 支持 Windows 界面消息引擎，我们就可以在界面线程中直接创建网络协程，直接进行阻塞式网络编程了。(Windows 界面网络协程示例：<a href="https://github.com/iqiyi/libfiber/tree/master/samples/WinEchod">https://github.com/iqiyi/libfiber/tree/master/samples/WinEchod</a> )</p><h4 id="3-2-2、运行效率"><a href="#3-2-2、运行效率" class="headerlink" title="3.2.2、运行效率"></a>3.2.2、运行效率</h4><p>大家在谈论网络协程程序的运行效率时，往往只重视协程的切换效率，但却忽视了事件引擎对于性能影响的重要性，虽然现在很网络协程库所采用的事件引擎都是内核级的，但仍需要合理使用才能发挥其最佳性能。 </p><p>在使用 libfiber 的早期版本编译网络协程服务程序时，虽然在 Linux 平台上也是采用了 <code>epoll</code> 事件引擎，但在对网络协程服务程序进行性能压测（使用用系统命令 『<code># perf top -p pid</code>』 观察运行状态）时，却发现 <code>epoll_ctl</code> API 占用了较高的 CPU，分析原因是 <code>epoll_ctl</code> 使用次数过多导致的：因为 <code>epoll_ctl</code> 内部在对套接字句柄进行添加、修改或删除事件操作时，需要先通过红黑树的查找算法找到其对应的内部套接字对象（红黑树的查找效率并不是O(1)的），如果 epoll_ctl 的调用次数过多必然会造成 CPU 的占用较高。 </p><p>因为 TCP 数据在传输时是流式的，这就意味着数据接收者经常需要多次读操作才能获得完整的数据，反映到网络协程处理流程上如下图所示：</p><p><img src="/img/fiber_io_switch.png" alt="fiber_io_switch"></p><p>仔细观察上面处理流程，可以发现在图中的标注4（唤醒协程）和标注5（挂起协程）之间的两个事件操作：<code>标注2取消读事件</code> 与 <code>标注3注册读事件</code>，再结合 <code>标注1注册读事件</code>，完全可以把注2和标注3处的两个事件取消，因为标注1至标注3的目标是 <code>注册读事件</code>。最后，通过缓存事件操作的中间状态，合并中间态的事件操作过程，使 libfiber 的 IO 处理性能提升 20% 左右。</p><p>下图给出了采用 libfiber 编写的回显服务器与采用其它网络协程库编写的回显服务器的性能对比（对比单核条件下的 IO 处理能力）：</p><p><img src="/img/benchmark.png" alt="benchmark"></p><p>在 libfiber 中之所以可以针对中间的事件操作过程进行合并处理，主要是因为 libfiber 的调度过程是单线程模式的，如果想要在多线程调度器中实现事件过程的合并处理则难度就要大的多：当套接字所绑定的协程因IO可读被唤醒时，假设不取消该套接字的读事件，则该协程被某个线程『拿走』后，内核又因接收到新数据而通知协程调度器，此时协程调度器就不知该如何处理了。</p><h3 id="3-3、协程同步机制"><a href="#3-3、协程同步机制" class="headerlink" title="3.3、协程同步机制"></a>3.3、协程同步机制</h3><h4 id="3-3-1、单一线程内部的协程互斥"><a href="#3-3-1、单一线程内部的协程互斥" class="headerlink" title="3.3.1、单一线程内部的协程互斥"></a>3.3.1、单一线程内部的协程互斥</h4><p>对于象 libfiber 这样的采用单线程调度方案的协程库而言，如果互斥加锁过程仅限于同一个调度线程内部，则实现一个协程互斥锁是比较容易的，下图为 libfiber 中单线程内部使用的协程互斥锁的处理流程图（参考源文件：fiber_lock.c）：</p><p><img src="/img/fiber_lock.png" alt="fiber_lock"></p><p>同一线程内的协程在等待锁资源时，该协程将被挂起并被加入锁等待队列中，当加锁协程解锁后会唤醒锁等待队列中的第一个协程，单线程内部的协程互斥锁正是利用了协程的挂起和唤醒机制。  </p><h4 id="3-3-2、多线程之间的协程互斥"><a href="#3-3-2、多线程之间的协程互斥" class="headerlink" title="3.3.2、多线程之间的协程互斥"></a>3.3.2、多线程之间的协程互斥</h4><p>虽然 libfiber 的协程调度器是单线程模式的，但却可以启动多个线程使每个线程运行独立的协程调度器，如果一些资源需要在多个线程中的协程间共享，则就需要有一把可以跨线程使用的协程互斥锁。在将 libfiber 应用在多线程的简单场景时，也许直接使用系统提供的线程锁就可以解决很多问题，但线程锁当遇到如下场景时就显得无能为力：</p><p><img src="/img/dead_lock.png" alt="dead_lock"></p><p>上述显示了系统线程互斥锁在 libfiber 使用时遇到的死锁问题：</p><ul><li>线程A 中的协程A1 成功对线程锁1加锁；</li><li>线程B 中的协程B2 对线程锁2成功加锁；</li><li>当线程A 中的协程A2 想要对线程锁2 加锁而阻塞时，则会使线程A 的协程调度器阻塞，从而导致整个线程A 中的所有协程被系统挂起；同样，线程B 也会因协程B1 阻塞在线程锁1 上而被阻塞；最终造成了死锁问题。</li></ul><p>产生上述死锁的根本原因是单线程调度机制以及操作系统的最小调度单元是线程，系统对于协程是无感知的。因此，在 libfiber 中专门设计了可用于在线程的协程之间使用的事件互斥锁（源码参见 fiber_event.c, 当前最新的是 fiber_mutex.c，性能更好且占用资源更少），其设计原理如下：</p><p><img src="/img/fiber_event.png" alt="fiber_event"></p><p>该可用于在线程之间的协程进行互斥的事件互斥锁的处理流程为：</p><ul><li>协程B（假设其属于线程b）已经对事件锁加锁后；</li><li>协程A（假设其属于线程a）想对该事件锁加锁时，对原子数加锁失败后创建IO管道，将IO读管道置入该事件锁的IO读等待队列中，此时协程A被挂起；</li><li>当协程B 对事件锁解锁时，会首先获得协程A 的读管道，解锁后再向管道中写入消息，从而唤醒协程A；</li><li>协程A 被唤醒后读取管道中的消息，然后再次尝试对事件锁中的原子数加锁，如加速成功便可以继续运行，否则会再次进入睡眠状态（有可能此事件锁又被其它协程提前抢占）。</li></ul><p>在上述事件锁的加&#x2F;解锁处理流程中，使用原子数和IO管道的好处是：</p><ul><li>通过使用原子数可以使协程快速加锁空闲的事件锁，原子数在多线程或协程环境中的行为相同的，可以保证安全性；</li><li>当锁被占用时，通过等待管道IO 方式使当前协程挂起，而又不会干扰该协程所属线程的正常运行；</li><li>在 Linux 平台上可以使用 eventfd 代替管道，占用资源更少。</li></ul><h4 id="3-3-3、协程条件变量"><a href="#3-3-3、协程条件变量" class="headerlink" title="3.3.3、协程条件变量"></a>3.3.3、协程条件变量</h4><p>我们在使用线程编程时，都知道线程条件变量的价值：在线程之间传递消息时往往需要组合线程条件变量和线程锁。因此，在 libfiber 中同样设计了协程条件变量（源码见 fiber_cond.c），通过组合使用 libfiber 中的协程事件锁（fiber_event.c，目前使用 fiber_mutex.c）和协程条件变量，用户可以编写出用于在线程之间、线程与协程之间、线程内的协程之间、线程间的协程之间进行消息传递的消息队列。下图为使用 libfiber 中协程条件变量时的交互过程：</p><p><img src="/img/fiber_cond.png" alt="fiber_cond"></p><p>这是一个典型的 <code>生产者-消费者</code> 问题，通过组合使用协程条件变量和事件锁可以轻松实现。</p><h4 id="3-3-4、协程信号量"><a href="#3-3-4、协程信号量" class="headerlink" title="3.3.4、协程信号量"></a>3.3.4、协程信号量</h4><p>使用网络协程库编写的网络服务很容易实现高并发功能，可以接入大量的客户端连接，但是后台系统（如：数据库）却未必支持高并发，即使是支持高并的缓存系统（如 Redis）当连接数达高时性能也会下降，所以协程服务模块不能将前端的并发压力传递到后端，给后台系统造成很大的压力，我们需要提供一种高并发连接卸载机制，以保证后台系统可以平稳地运行，在 libfiber 中提供了协程信号量（源码见：fiber_semc.c），下面是使用 libfiber 中的协程信号量对于后台系统的并发连接卸载保护示意图：</p><p><img src="/img/fiber_sem.png" alt="fiber_sem"></p><p>当有大量协程需要访问后台系统时，通过协程信号量将大量的协程『挡在外面』，只允许部分协程与后端系统建立连接。<br><strong>注：</strong> 目前 libfiber 的协程信号量仅用在同一线程内部，还不能跨线程使用，要想在多线程环境中使用，需在每个线程内部为协程创建独立的协程信号量。</p><h3 id="3-4、协程共享栈"><a href="#3-4、协程共享栈" class="headerlink" title="3.4、协程共享栈"></a>3.4、协程共享栈</h3><p>协程网络编程相对于非阻塞网络编程简单太多，大大方便了开发者编写支持高并发的服务程序；但对于有栈协程，意味着每个协程都要占用一段内存用来存放协程栈，所以并发越高，内存占用越多也成为有栈协程的一大弊端，但仔细分析函数压栈出栈及协程挂起唤醒过程，我们会发现在协程挂起时所占用的栈空间大小要远小于协程实际运行过程中占用的最大栈空间大小（考虑到应用业务逻辑的复杂性，可能会存在大量的函数及变量压栈过程，所以占用的栈空间会比较大），而在一个 libfiber 线程空间中只有一个运行栈，所以只需保证一个较大的运行栈空间即可，当协程被挂起时只需将其栈从运行栈中拷贝并保存出来（这个栈空间相对要小一些），而被挂起的协程被唤醒时，只需将其保存的栈拷贝到线程的运行栈上即可。在实践中这的确可以大幅减少高并发时的内存使用，虽然进行栈拷贝时会耗费一些时间，但整体影响并不太大。</p><p>相对于栈拷贝时的时间损耗，在使用共享栈方式编程时有一点需要特别注意：创建在栈上的变量不能在协程之间或协程与线程之间共享，即是说，一个协程 F1 中的变量 A 传递给另一个协程 F2，并等待 F2 处理后返回，此时的 A 变量不能被创建在 F1 的栈上，因为运行栈在由 F1 切换到 F2 时，变量 A 的地址空间“暂时消失了”，此时变成了 F2 的栈空间，如果该变量在 F2 中继续被使用的话，就会存在地址非法使用的问题；解决变量在协程间共享的方法是将变量创建在堆上（即用 malloc 或 new 创建）。</p><p>注：共享栈的想法最初应该是在腾讯的 libco 中提出的，应该也是为了解决大并发时的内存占用问题。</p><h3 id="3-5、域名解析"><a href="#3-5、域名解析" class="headerlink" title="3.5、域名解析"></a>3.5、域名解析</h3><p>网络协程库既然面向网络，自然离不开域名的协程化支持，现在很多网络协程库的设计者往往忽视了这一点，有些网络协程库在使用系统 API 进行域名解析时为了防止阻塞协程调度器，将域名解析过程（即调用 gethostbyname&#x2F;getaddrinfo）扔给独立的线程去执行，当调用系统 API 进行域名解析并发量较大时必然会造成很多线程资源被占用。在 libfiber 早期通过集成第三方 dns 源码，实现了域名解析过程的协程化，基本满足了大部分服务端应用系统对于域名解析的需求；后来因为跨平台性及代码安全性的需要，在 libfiber 中实现了与域名解析相关的 DNS 协议，替换了第三方 DNS 库。</p><h3 id="3-6、Hook-系统-API"><a href="#3-6、Hook-系统-API" class="headerlink" title="3.6、Hook 系统 API"></a>3.6、Hook 系统 API</h3><p>相对于网络协程的出现时间，很多网络库很早就存在了，并且大部分已有的网络库都是阻塞式的，要改造这些网络库使之协程化的成本是非常巨大的，我们不可能采用协程方式将这些网络库重新实现一遍，目前一个广泛采用的方案是 Hook 与 IO 相关的系统中 API，在 Unix 平台上 Hook 系统 API 相对简单，在初始化时，先加载并保留系统 API 的原始地址，然后编写一个与系统 API 函数名相同且参数也相同的函数，将这段代码与应用代码一起编译，则编译器会优先使用这些 Hook API，下面的代码给出了在 Unix 平台上 Hook 系统 API 的简单示例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-keyword">typedef</span> <span class="hljs-title function_">ssize_t</span> <span class="hljs-params">(*read_fn)</span><span class="hljs-params">(<span class="hljs-type">int</span>, <span class="hljs-type">void</span> *, <span class="hljs-type">size_t</span>)</span>;<br><span class="hljs-type">static</span> read_fn __sys_read = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">hook_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>    __sys_read = (read_fn) dlsym(RTLD_NEXT, <span class="hljs-string">&quot;read&quot;</span>);<br>    assert(__sys_read);<br>&#125;<br><br><span class="hljs-type">ssize_t</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">int</span> fd, <span class="hljs-type">void</span> *buf, <span class="hljs-type">size_t</span> count)</span> &#123;<br>    <span class="hljs-keyword">if</span> (__sys_read == <span class="hljs-literal">NULL</span>) &#123;<br>        hook_init();<br>    &#125;<br>    <span class="hljs-keyword">return</span> __sys_read(fd, buf, count);<br>&#125;<br></code></pre></td></tr></table></figure><p>在 libfiber 中 hook 了大部分与 IO 及网络相关的系统 API，下面列出 libfiber 所 Hook 的系统 API：</p><ul><li><strong>IO 相关 API</strong><ul><li><strong>读 API：</strong> read&#x2F;readv&#x2F;recv&#x2F;recvfrom&#x2F;recvmsg；</li><li><strong>写 API：</strong> write&#x2F;writev&#x2F;send&#x2F;sendto&#x2F;sendmsg&#x2F;sendfile64；</li></ul></li><li><strong>网络相关 API</strong><ul><li><strong>套接字 API：</strong> socket&#x2F;listen&#x2F;accept&#x2F;connect；</li><li><strong>事件引擎 API：</strong> select&#x2F;poll，epoll: epoll_create, epoll_ctl, epoll_wait；</li><li><strong>域名解析 API：</strong> gethostbyname&#x2F;gethostbyname_r, getaddrinfo&#x2F;freeaddrinfo。</li></ul></li></ul><p>通过 Hook API 方式，libfiber 已经可以使 Mysql 客户端库、一些 HTTP 通信库及 Redis 客户端库的网络通信部分协程化，这样在使用网络协程编写服务端应用程序时，大大降低了编程复杂度及改造成本。</p><p>为了在 Windows 平台上 Hook IO API，libfiber 集成了微软的一个开源库 detours，但该库是用 C++ 编写的，所以只能集成在 libfiber 的 c++ 模块中，即用户在使用时只能通过使用 libfiber c++ 库达到 Hook 系统 IO API 的目的。</p><h2 id="四、爱奇艺核心业务的协程实践"><a href="#四、爱奇艺核心业务的协程实践" class="headerlink" title="四、爱奇艺核心业务的协程实践"></a>四、爱奇艺核心业务的协程实践</h2><h3 id="4-1、CDN-核心模块使用协程"><a href="#4-1、CDN-核心模块使用协程" class="headerlink" title="4.1、CDN 核心模块使用协程"></a>4.1、CDN 核心模块使用协程</h3><p>在爱奇艺的自建 CDN 系统中，作为数据回源及本地缓存的核心软件，奇迅承担了重要角色，该模块采用多线程多协程的软件架构设计，如下所示：</p><p><img src="/img/qixun.png" alt="qixun"></p><p>奇迅回源架构设计的特点总结如下：</p><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>高并发</td><td>采用网络协程方式，支持高并发接入，同时简化程序设计</td></tr><tr><td>高性能</td><td>采用线程池 + 协程 + 连接池 + 内存池技术，提高业务处理性能</td></tr><tr><td>高吞吐</td><td>采用磁盘内存映射及零拷贝技术，提升磁盘及网络 IO 吞吐能力</td></tr><tr><td>低回源</td><td>合并相同请求，支持部分回源及部分缓存，大大降低回源带宽</td></tr><tr><td>开播快</td><td>采用流式数据读取方式，提升视频开播速度</td></tr><tr><td>可扩展</td><td>模块化分层设计，易于扩展新功能</td></tr><tr><td>易维护</td><td>采用统一服务器编程框架，易管理，好维护</td></tr></tbody></table><p>奇迅的前后端通信模块均采用网络协程方式，分为前端连接接入层和后端下载任务层，为了有效地使用多核，前后端模块均启动多个线程（每个线程运行一个独立的协程调度器）；对于前端连接接入模块，由于采用协程方式，所以：</p><ul><li>支持更高的客户端并发连接；</li><li>允许更多慢连接的存在，而不会消耗更多秕资源；</li><li>更有助于客户端与奇迅之间保持长连接，提升响应性能。</li></ul><p>对于后端下载模块，由于采用协程方式，在数据回源时允许建立更多的并发连接去多个源站下载数据，从而获得更快的下载速度；同时，为了节省带宽，奇迅采用合并回源策略，即当前端多个客户端请求同一段数据时，下载模块将会合并相同的请求，向源站发起一份数据请求，在合并回源请求过程中，因数据共享原因，必然存在如 “3.3.2、多线程之间的协程互斥”章节所提到的多个线程之间的协程同步互斥的需求，通过使用 libfiber 中的事件锁完美地解决了一这需求（其实，当初事件锁就是为了满足奇迅的这一需求而设计编写）。</p><h3 id="4-2、高性能-DNS-模块使用协程"><a href="#4-2、高性能-DNS-模块使用协程" class="headerlink" title="4.2、高性能 DNS 模块使用协程"></a>4.2、高性能 DNS 模块使用协程</h3><p>DNS 做为互联网的基础设施，在整个互联网中发挥着举足轻重的作用，爱奇艺为了满足自身业务的发展需要，自研了高性能 DNS（简称 HPDNS），该 DNS 的软件架构如下图所示：</p><p><img src="/img/hpdns.png" alt="hpdns"></p><p>HPDNS 服务的特点如下：</p><style>table th:first-of-type {    width: 50px;}</style><table><thead><tr><th>优点</th><th>说明</th></tr></thead><tbody><tr><td>高性能</td><td>启用 Linux 3.0 内核的 REUSEPORT 功能，提升多线程并行收发包的能力</td></tr><tr><td>&amp;nbsp;</td><td>采用 Linux 3.0 内核的 recvmmsg&#x2F;sendmmsg API，提升单次 IO 数据包收发能力</td></tr><tr><td>&amp;nbsp;</td><td>采用内存预分配策略，减少内存动态分配&#x2F;释放时的“锁”冲突</td></tr><tr><td>&amp;nbsp;</td><td>针对 TCP 服务模式，采用网络协程框架，最大化 TCP 并发怎能能力</td></tr><tr><td>高可用</td><td>采用RCU（Read Copy Update）方式更新视图数据及配置项，无需停止服务，且不影响性能</td></tr><tr><td>&amp;nbsp;</td><td>网卡 IP 地址变化自动感知（即可自动添加新 IP 或摘除老IP而不必停止服务）</td></tr><tr><td>&amp;nbsp;</td><td>采用 Keepalived 保证服务高可用</td></tr><tr><td>易管理</td><td>由 master 服务管理模块管理 DNS 进程，控制 DNS 进程的启动、停止、重读配置&#x2F;数据、异常重启及异常报警等</td></tr></tbody></table><p>由于 DNS 协议要求 DNS 服务端需要同时支持 UDP 及 TCP 两种通信方式，除了要求 UDP 模块具备高性能外，对 TCP 模块也要求支持高并发及高性能，该模块的网络通信部分使用 libfiber 编写，从而支持更高的并发连接，同时具备更高的性能，又因启用多个线程调度器，从而可以更加方便地使用多核。</p><h2 id="五、总结"><a href="#五、总结" class="headerlink" title="五、总结"></a>五、总结</h2><p>本文讲述了爱奇艺开源项目 libfiber 网络协程库的设计原理及核心设计要点，描述了 libfiber 的设计特点及优缺点，方便读者了解网络协程的设计原理及运行机制，做到知其然更知其所以然；本文还从爱奇艺自身的项目实践出发，总结了在应用网络协程编程时遇到的问题及解决方案，使读者能够更加全面地了解编写网络协程类应用的注意事项。</p>]]></content>
    
    
    <categories>
      
      <category>协程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协程编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用SSL中对数据进行加密传输</title>
    <link href="/2020/01/15/ssl/"/>
    <url>/2020/01/15/ssl/</url>
    
    <content type="html"><![CDATA[<h1 id="使用SSL中对数据进行加密传输"><a href="#使用SSL中对数据进行加密传输" class="headerlink" title="使用SSL中对数据进行加密传输"></a>使用SSL中对数据进行加密传输</h1><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在 Acl 的网络通信模块中，为了支持安全网络传输，引入了第三方 SSL 库，当前支持 OpenSSL, PolarSSL 及其升级版 MbedTLS，Acl 库中通过抽象与封装，大大简化了 SSL 的使用过程（现在开源的 SSL 库使用过程确实过于太复杂），以下是在 Acl 库中使用 SSL 的特点：  </p><ul><li><strong>动态加载第三方SSL库：</strong> 为了不给非 SSL 用户造成编译上及使用 Acl 库的负担，Acl 库采用动态加载 SSL 动态库方式，这样在编译连接 Acl 库时就不必提供 SSL 库（当然，通过设置编译开关，也允许用户采用静态连接 SSL 库的方式）；  </li><li><strong>隐藏 SSL 库对外接口：</strong> 在 Acl 的工程中，仅包含了指定版本的 OpenSSL&#x2F;Polarssl&#x2F;Mbedtls 头文件（在 acl&#x2F;include&#x2F; 目录下），这些头文件在编译 Acl 的 SSL 模块时会使用到，且不对外暴露，因此使用者需要自行提供对应版本的 SSL 动态二进制库（SSL库的源代码可以去官方 <a href="https://tls.mbed.org/">https://tls.mbed.org/</a> 下载，或者去 <a href="https://github.com/acl-dev/third_party">https://github.com/acl-dev/third_party</a> 处下载）；</li><li><strong>模块分离原则：</strong> 在 Acl SSL 模块中，分为全局配置类和 IO 通信类，配置类对象只需在程序启动时进行创建与初始化，且整个进程中按单例方式使用；IO 通信类对象与每一个 TCP 连接所对应的 socket 进行绑定，TCP 连接建立时进行初始化，进行 SSL 握手并接管 IO 过程；</li><li><strong>支持服务器及客户端模式：</strong> Acl SSL 模块支持服务端及客户端方式，在服务端模块时需要加载数字证书及证书私钥；</li><li><strong>通信方式：</strong> Acl SSL 模块支持阻塞与非阻塞两种通信方式，阻塞方式还可以用在 Acl 协程通信中；</li><li><strong>多证书与SNI支持：</strong> 服务端支持加载多个 SSL 证书同时可以根据 SNI 标识加载不同域证书进行 SSL 握手及通信；客户端支持设置 SNI 标识与服务端进行 SSL 握手； </li><li><strong>线程安全性：</strong> Acl SSL 模块是线程安全的，虽然官方提供的 Mbedtls 库中增加支持线程安全的编译选项，但其默认情况下却是将此功能关闭的（这真是一个坑人的地方），当你需要打开线程支持功能时还必须得要提供线程锁功能（通过函数回调注册自己的线程锁，好在 Acl 库中有跨平台的线程模块），这应该是 Mbedtls 默认情况下不打开线程支持的原因；</li><li><strong>应用场景：</strong> Acl SSL 模块已经应用在 Acl HTTP 通信中，从而方便用户编写支持 HTTPS&#x2F;Websocket 的客户端或服务端程序；同时，Acl SSL 模块也给 Acl Redis 模块提供了安全通信功能；</li><li><strong>SSL下载：</strong><ul><li><strong>下载 MbedTLS：</strong> 当你使用 Mbedtls 时，建议从 <a href="https://github.com/acl-dev/third_party/tree/master/mbedtls-2.7.12">https://github.com/acl-dev/third_party/tree/master/mbedtls-2.7.12</a> 下载 Mbedtls 源码编译，此处的 Mbedtls 与官方的主要区别是：<ul><li>在 config.h 中打开了线程安全的编译选项，同时添加了用于线程安全的互斥锁头文件：threading_alt.h；</li><li>Mbedtls 库编译后生成了三个库文件：libmbedcrypto&#x2F;libmbedx509&#x2F;libmbedtls，而原来 Polarssl 只生成一个库文件，所以为了用户使用方便，修改了 libray&#x2F;CMakeLists.txt 文件，可以将这三个库文件合并成一个；</li><li>增加了 visualc&#x2F;VC2012（而官方仅提供了 VS2010），这样在 Windows 平台下可以使用 VS 2012 来编译生成 mbedtls 库；</li></ul></li><li><strong>下载 OpenSSL：</strong> 从 OpenSSL 官方或 <a href="https://github.com/acl-dev/third_part/">https://github.com/acl-dev/third_part/</a> 下载 OpenSSL 1.1.1q 版本。</li></ul></li></ul><h2 id="二、API-接口说明"><a href="#二、API-接口说明" class="headerlink" title="二、API 接口说明"></a>二、API 接口说明</h2><p>为了支持更加通用的 SSL 接口，在 Acl SSL 模块中定义了两个基础类：<code>sslbase_conf</code> 和 <code>sslbase_io</code>，其中 <code>ssbase_conf</code> 类对象可以用做全局单一实例，<code>ssbase_io</code> 类对象用来给每一个 TCP socket 对象提供安全 IO 通信功能。</p><h3 id="2-1、sslbase-conf-类"><a href="#2-1、sslbase-conf-类" class="headerlink" title="2.1、sslbase_conf 类"></a>2.1、sslbase_conf 类</h3><p>在 ssbase_conf 类中定义了纯虚方法：<code>open</code>，用来创建 SSL IO 通信类对象，在当前所支持的 OpenSSL，Polarssl 和 MbedTSL 中的配置类中（分别为：<code>acl::openssl_conf</code>，<code>acl::polarssl_conf</code> 和 <code>acl::mbedtls_conf</code>）均实现了该方法。下面是 <code>open</code> 方法的具体说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 纯虚方法，创建 SSL IO 对象</span><br><span class="hljs-comment"> * @param nblock &#123;bool&#125; 是否为非阻塞模式</span><br><span class="hljs-comment"> * @return &#123;sslbase_io*&#125;</span><br><span class="hljs-comment"> */</span><br>virtual sslbase_io* <span class="hljs-title function_">open</span><span class="hljs-params">(<span class="hljs-type">bool</span> nblock)</span> = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>在客户端或服务端创建 SSL IO 对象（即：sslbase_io 对象）时调用，被用来与 TCP socket 进行绑定。下面是绑定过程：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">bind_ssl_io</span><span class="hljs-params">(acl::socket_stream&amp; conn, acl::sslbase_conf&amp; ssl_conf)</span> &#123;<br><span class="hljs-comment">// 创建一个阻塞式 SSL IO 对象</span><br><span class="hljs-type">bool</span> non_block = <span class="hljs-literal">false</span>;<br>acl::sslbase_io* ssl = ssl_conf.open(non_block); <br><br><span class="hljs-comment">// 将 SSL IO 对象与 TCP 连接流对象进行绑定，在绑定过程中会进行 SSL 握手，</span><br><span class="hljs-comment">// 如果 SSL 握手失败，则返回该 SSL IO 对象，返回 NULL 表示绑定成功。</span><br><span class="hljs-keyword">if</span> (conn.setup_hook(ssl) == ssl) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中 <code>acl::sslbase_io</code> 的父类为 <code>acl::stream_hook</code>，在<code>acl::stream</code> 流基础类中提供了方法<code>setup_hook</code>用来注册外部 IO 过程，其中的参数类型为<code>stream_hook</code> ，通过绑定外部 IO 过程，将 SSL IO 过程与 acl 中的流处理 IO 过程进行绑定，从而使 acl 的 IO 流过程具备了 SSL 安全传输能力。 </p><p>下面的接口用在服务端加载证书及私钥：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加一个服务端/客户端自己的证书，可以多次调用本方法加载多个证书</span><br><span class="hljs-comment"> * @param crt_file &#123;const char*&#125; 证书文件全路径，非空</span><br><span class="hljs-comment"> * @param key_file &#123;const char*&#125; 密钥文件全路径，非空</span><br><span class="hljs-comment"> * @param key_pass &#123;const char*&#125; 密钥文件的密码，没有密钥密码可写 NULL</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 添加证书是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">add_cert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* crt_file, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_file,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_pass = <span class="hljs-literal">NULL</span>)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-2、sslbase-io-类"><a href="#2-2、sslbase-io-类" class="headerlink" title="2.2、sslbase_io 类"></a>2.2、sslbase_io 类</h3><p><code>acl::sslbase_io</code> 类对象与每一个 TCP 连接对象 <code>acl::socket_stream</code> 进行绑定，使 <code>acl::socket_stream</code> 具备了进行 SSL 安全通信的能力，在 <code>acl::sslbase_io</code>类中声明了纯虚方法<code>handshake</code>，这使之成为纯虚类；另外，<code>acl::sslbase_io</code> 虽然继承于<code>acl::stream_hook</code>类，但并没有实现 <code>acl::stream_hook</code> 中规定的四个纯虚方法：<code>open</code>，<code>on_close</code>，<code>read</code>，<code>send</code>，这几个虚方法也需要 <code>acl::sslbase_io</code>的子类来实现，目前<code>acl::sslbase_io</code>的子类有 <code>acl::openssl_io</code>，<code>acl::polarssl_io</code>及<code>acl::mbedtls_io</code> 分别用来支持 <code>OpenSSL</code>，<code>PolarSSL</code> 及 <code>MbedTLS</code>。<br>下面是这几个纯虚方法的声明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ssl 握手纯虚方法（属于 sslbase_io 类）</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示 SSL 握手成功，否则表示失败</span><br><span class="hljs-comment"> */</span><br>virtual <span class="hljs-type">bool</span> <span class="hljs-title function_">handshake</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>下面几个虚方法声明于 <code>acl::stream_hook</code> 类中：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读数据接口</span><br><span class="hljs-comment"> * @param buf &#123;void*&#125; 读缓冲区地址，读到的数据将存放在该缓冲区中</span><br><span class="hljs-comment"> * @param len &#123;size_t&#125; buf 缓冲区大小</span><br><span class="hljs-comment"> * @return &#123;int&#125; 读到字节数，当返回值 &lt; 0 时表示出错</span><br><span class="hljs-comment"> */</span><br>virtual <span class="hljs-type">int</span> <span class="hljs-title function_">read</span><span class="hljs-params">(<span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len)</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送数据接口</span><br><span class="hljs-comment"> * @param buf &#123;const void*&#125; 发送缓冲区地址</span><br><span class="hljs-comment"> * @param len &#123;size_t&#125; buf 缓冲区中数据的长度(必须 &gt; 0) </span><br><span class="hljs-comment"> * @return &#123;int&#125; 写入的数据长度，返回值 &lt;０　时表示出错</span><br><span class="hljs-comment"> */</span><br>virtual <span class="hljs-type">int</span> <span class="hljs-title function_">send</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* buf, <span class="hljs-type">size_t</span> len)</span> = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在 stream/aio_stream 的 setup_hook 内部将会调用 stream_hook::open</span><br><span class="hljs-comment"> * 过程，以便于子类对象用来初始化一些数据及会话</span><br><span class="hljs-comment"> * @param s &#123;ACL_VSTREAM*&#125; 在 setup_hook 内部调用该方法将创建的流对象</span><br><span class="hljs-comment"> *  作为参数传入</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 如果子类实例返回 false，则 setup_hook 调用失败且会恢复原样</span><br><span class="hljs-comment"> */</span><br>virtual <span class="hljs-type">bool</span> <span class="hljs-title function_">open</span><span class="hljs-params">(ACL_VSTREAM* s)</span> = <span class="hljs-number">0</span>; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当 stream/aio_stream 流对象关闭前将会回调该函数以便于子类实例做一些善后工作</span><br><span class="hljs-comment"> * @param alive &#123;bool&#125; 该连接是否依然正常</span><br><span class="hljs-comment"> * @return &#123;bool&#125;</span><br><span class="hljs-comment"> */</span><br>virtual <span class="hljs-type">bool</span> <span class="hljs-title function_">on_close</span><span class="hljs-params">(<span class="hljs-type">bool</span> alive)</span> &#123; (<span class="hljs-type">void</span>) alive; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125; <br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当 stream/aio_stream 对象需要释放 stream_hook 子类对象时调用此方法</span><br><span class="hljs-comment"> */</span><br>virtual <span class="hljs-type">void</span> <span class="hljs-title function_">destroy</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;&#125;<br></code></pre></td></tr></table></figure><p>以上几个虚方法均可以在 <code>acl::openssl_io</code>，<code>acl::polarssl_io</code> 及 <code>acl::mbedtls_io</code> 中看到被实现。</p><h2 id="三、编程示例"><a href="#三、编程示例" class="headerlink" title="三、编程示例"></a>三、编程示例</h2><h3 id="2-1、服务器模式（使用-OpenSSL）"><a href="#2-1、服务器模式（使用-OpenSSL）" class="headerlink" title="2.1、服务器模式（使用 OpenSSL）"></a>2.1、服务器模式（使用 OpenSSL）</h3><p>首先给出一个完整的支持 SSL 的服务端例子，该例子使用了 OpenSSL 做为 SSL 库，如果想切换成 MbedTLS 或 Polarssl 也简单，方法类似（该示例位置：<a href="https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server%EF%BC%89%EF%BC%9A">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server）：</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">echo_thread</span> :</span> public acl::thread &#123;<br>public:<br>        echo_thread(acl::sslbase_conf&amp; ssl_conf, acl::socket_stream* conn)<br>        : ssl_conf_(ssl_conf), conn_(conn) &#123;&#125;<br><br>private:<br>        acl::sslbase_conf&amp;  ssl_conf_;<br>        acl::socket_stream* conn_;<br><br>        ~echo_thread(<span class="hljs-type">void</span>) &#123; delete conn_; &#125;<br><br>        <span class="hljs-comment">// @override</span><br>        <span class="hljs-type">void</span>* <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>                conn_-&gt;set_rw_timeout(<span class="hljs-number">60</span>);<br><br>                <span class="hljs-comment">// 给 socket 安装 SSL IO 过程</span><br>                <span class="hljs-keyword">if</span> (!setup_ssl()) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>                do_echo();<br><br>                delete this;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br><br>        <span class="hljs-type">bool</span> <span class="hljs-title function_">setup_ssl</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>                <span class="hljs-type">bool</span> non_block = <span class="hljs-literal">false</span>;<br>                acl::sslbase_io* ssl = ssl_conf_.open(non_block);<br><br>                <span class="hljs-comment">// 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络</span><br>                <span class="hljs-comment">// 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程</span><br>                <span class="hljs-keyword">if</span> (conn_-&gt;setup_hook(ssl) == ssl) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;setup ssl IO hook error!\r\n&quot;</span>);<br>                        ssl-&gt;destroy();<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">void</span> <span class="hljs-title function_">do_echo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>                <span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>];<br><br>                <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                        <span class="hljs-type">int</span> ret = conn_-&gt;read(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-literal">false</span>);<br>                        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>                                <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        <span class="hljs-keyword">if</span> (conn_-&gt;write(buf, ret) == <span class="hljs-number">-1</span>) &#123;<br>                                <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                &#125;<br>        &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">start_server</span><span class="hljs-params">(<span class="hljs-type">const</span> acl::<span class="hljs-built_in">string</span> addr, acl::sslbase_conf&amp; ssl_conf)</span> &#123;<br>        acl::server_socket ss;<br>        <span class="hljs-keyword">if</span> (!ss.open(addr)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listen %s error %s\r\n&quot;</span>, addr.c_str(), acl::last_serror());<br>                <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>                acl::socket_stream* conn = ss.accept();<br>                <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">NULL</span>) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept error %s\r\n&quot;</span>, acl::last_serror());<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>                acl::thread* thr = new echo_thread(ssl_conf, conn);<br>                thr-&gt;set_detachable(<span class="hljs-literal">true</span>);<br>                thr-&gt;start();<br>        &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title function_">ssl_init</span><span class="hljs-params">(<span class="hljs-type">const</span> acl::<span class="hljs-built_in">string</span>&amp; ssl_crt, <span class="hljs-type">const</span> acl::<span class="hljs-built_in">string</span>&amp; ssl_key,</span><br><span class="hljs-params">        acl::mbedtls_conf&amp; ssl_conf)</span> &#123;<br><br>        ssl_conf.enable_cache(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 加载 SSL 证书</span><br>        <span class="hljs-keyword">if</span> (!ssl_conf.add_cert(ssl_crt)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;add ssl crt=%s error\r\n&quot;</span>, ssl_crt.c_str());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 设置 SSL 证书私钥</span><br>        <span class="hljs-keyword">if</span> (!ssl_conf.set_key(ssl_key)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set ssl key=%s error\r\n&quot;</span>, ssl_key.c_str());<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* procname)</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s -h [help]\r\n&quot;</span><br>                <span class="hljs-string">&quot; -s listen_addr\r\n&quot;</span><br>                <span class="hljs-string">&quot; -L ssl_lib_path\r\n&quot;</span><br>                <span class="hljs-string">&quot; -C crypto_lib_path\r\n&quot;</span><br>                <span class="hljs-string">&quot; -c ssl_crt\r\n&quot;</span><br>                <span class="hljs-string">&quot; -k ssl_key\r\n&quot;</span>, procname);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>        acl::<span class="hljs-built_in">string</span> addr = <span class="hljs-string">&quot;0.0.0.0|1443&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__APPLE__)</span><br>        acl::<span class="hljs-built_in">string</span> crypto_lib = <span class="hljs-string">&quot;/usr/local/lib/libcrypto.dylib&quot;</span>;<br>        acl::<span class="hljs-built_in">string</span> ssl_lib = <span class="hljs-string">&quot;/usr/local/lib/libssl.dylib&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(__linux__)</span><br>        acl::<span class="hljs-built_in">string</span> crypto_lib = <span class="hljs-string">&quot;/usr/local/lib64/libcrypto.so&quot;</span>;<br>        acl::<span class="hljs-built_in">string</span> ssl_lib = <span class="hljs-string">&quot;/usr/local/lib64/libssl.so&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">error</span> <span class="hljs-string">&quot;unknown OS type&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>        acl::<span class="hljs-built_in">string</span> ssl_crt = <span class="hljs-string">&quot;../ssl_crt.pem&quot;</span>, ssl_key = <span class="hljs-string">&quot;../ssl_key.pem&quot;</span>;<br><br>        <span class="hljs-type">int</span> ch;<br>        <span class="hljs-keyword">while</span> ((ch = getopt(argc, argv, <span class="hljs-string">&quot;hs:L:C:c:k:&quot;</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">switch</span> (ch) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>                        usage(argv[<span class="hljs-number">0</span>]);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>                        addr = optarg;<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>                        ssl_lib = optarg;<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;C&#x27;</span>:<br>                        crypto_lib = optarg;<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>                        ssl_crt = optarg;<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;k&#x27;</span>:<br>                        ssl_key = optarg;<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>        &#125;<br><br>        acl::<span class="hljs-built_in">log</span>::stdout_open(<span class="hljs-literal">true</span>);<br>        <br>        <span class="hljs-comment">// 设置 OpenSSL 动态库路径</span><br>        <span class="hljs-comment">// libcrypto, libssl);</span><br>        acl::openssl_conf::set_libpath(crypto_lib, ssl_lib);<br><br>        <span class="hljs-comment">// 动态加载 OpenSSL 动态库</span><br>        <span class="hljs-keyword">if</span> (!acl::openssl_conf::load()) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;load %s, %s error\r\n&quot;</span>, crypto_lib.c_str(), ssl_lib.c_str());<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化服务端模式下的全局 SSL 配置对象</span><br>        <span class="hljs-type">bool</span> server_side = <span class="hljs-literal">true</span>;<br><br>        acl::sslbase_conf* ssl_conf = new acl::openssl_conf(server_side);<br><br>        <span class="hljs-keyword">if</span> (!ssl_init(ssl_crt, ssl_key, *ssl_conf)) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ssl_init failed\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <br>        start_server(addr, *ssl_conf);<br><br>        delete ssl_conf;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>关于该示例有以下几点说明：</p><ul><li>该服务端例子使用了 OpenSSL 动态库；</li><li>采用动态加载 OpenSSL 动态库的方式；</li><li>动态加载时需要设置 OpenSSL 动态库的路径，然后再加载；</li><li>该例子大体处理流程：<ul><li>通过 <code>acl::openssl_conf::set_libpath</code> 方法设置 OpenSSL 的两个动态库路径，然后调用 <code>acl::openssl_conf::load</code> 加载动态库；</li><li>在 <code>ssl_init</code> 函数中，调用基类 <code>acl::sslbase_conf</code> 中的虚方法 <code>add_cert</code> 用来加载 SSL 数字证书及证书私钥；</li><li>在 <code>start_server</code> 函数中，监听本地服务地址，每接收一个 TCP 连接（对应一个 <code>acl::socket_stream</code> 对象）便启动一个线程进行 echo 过程；</li><li>在客户端处理线程中，调用 <code>echo_thread::setup_ssl</code> 方法给该 <code>acl::socket_stream</code> TCP 流对象绑定一个 SSL IO 对象，即：先通过调用 <code>acl::mbedtls_conf::open</code> 方法创建一个 <code>acl::mbedtls_io</code> SSL IO 对象，然后通过 <code>acl::socket_stream</code> 的基类中的方法 <code>set_hook</code> 将该 SSL IO 对象与 TCP 流对象进行绑定并完成 SSL 握手过程；</li><li>SSL 握手成功后进入到 <code>echo_thread::do_echo</code> 函数中进行简单的 SSL 安全 echo 过程。</li></ul></li></ul><h3 id="2-2、客户端模式（使用-MbedTLS）"><a href="#2-2、客户端模式（使用-MbedTLS）" class="headerlink" title="2.2、客户端模式（使用 MbedTLS）"></a>2.2、客户端模式（使用 MbedTLS）</h3><p>在熟悉了上面的 SSL 服务端编程后，下面给出使用 SSL 进行客户端编程的示例（该示例位置：<a href="https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client%EF%BC%89%EF%BC%9A">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client）：</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">echo_thread</span> :</span> public acl::thread &#123;<br>public:<br>        echo_thread(acl::sslbase_conf&amp; ssl_conf, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr, <span class="hljs-type">int</span> count)<br>        : ssl_conf_(ssl_conf), addr_(addr), count_(count) &#123;&#125;<br><br>        ~echo_thread(<span class="hljs-type">void</span>) &#123;&#125;<br><br>private:<br>        acl::sslbase_conf&amp;  ssl_conf_;<br>        acl::<span class="hljs-built_in">string</span> addr_;<br>        <span class="hljs-type">int</span> count_;<br><br>private:<br>        <span class="hljs-comment">// @override</span><br>        <span class="hljs-type">void</span>* <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br>                acl::socket_stream conn;<br>                conn.set_rw_timeout(<span class="hljs-number">60</span>);<br>                <span class="hljs-keyword">if</span> (!conn.open(addr_, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>)) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect %s error %s\r\n&quot;</span>,<br>                                addr_.c_str(), acl::last_serror());<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>                <span class="hljs-comment">// 给 socket 安装 SSL IO 过程</span><br>                <span class="hljs-keyword">if</span> (!setup_ssl(conn)) &#123;<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>                &#125;<br><br>                do_echo(conn);<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>        &#125;<br>        <span class="hljs-type">bool</span> <span class="hljs-title function_">setup_ssl</span><span class="hljs-params">(acl::socket_stream&amp; conn)</span> &#123;<br>                <span class="hljs-type">bool</span> non_block = <span class="hljs-literal">false</span>;<br>                acl::sslbase_io* ssl = ssl_conf_.open(non_block);<br><br>                <span class="hljs-comment">// 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络</span><br>                <span class="hljs-comment">// 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程</span><br>                <span class="hljs-keyword">if</span> (conn.setup_hook(ssl) == ssl) &#123;<br>                        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;setup ssl IO hook error!\r\n&quot;</span>);<br>                        ssl-&gt;destroy();<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ssl setup ok!\r\n&quot;</span>);<br><br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br><br>        <span class="hljs-type">void</span> <span class="hljs-title function_">do_echo</span><span class="hljs-params">(acl::socket_stream&amp; conn)</span> &#123;<br>                <span class="hljs-type">const</span> <span class="hljs-type">char</span>* data = <span class="hljs-string">&quot;hello world!\r\n&quot;</span>;<br>                <span class="hljs-type">int</span> i;<br>                <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; count_; i++) &#123;<br>                        <span class="hljs-keyword">if</span> (conn.write(data, <span class="hljs-built_in">strlen</span>(data)) == <span class="hljs-number">-1</span>) &#123;<br>                                <span class="hljs-keyword">break</span>;<br>                        &#125;<br><br>                        <span class="hljs-type">char</span> buf[<span class="hljs-number">4096</span>];<br>                        <span class="hljs-type">int</span> ret = conn.read(buf, <span class="hljs-keyword">sizeof</span>(buf) - <span class="hljs-number">1</span>, <span class="hljs-literal">false</span>);<br>                        <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read over, count=%d\r\n&quot;</span>, i + <span class="hljs-number">1</span>);<br>                                <span class="hljs-keyword">break</span>;<br>                        &#125;<br>                        buf[ret] = <span class="hljs-number">0</span>;<br>                        <span class="hljs-keyword">if</span> (i == <span class="hljs-number">0</span>) &#123;<br>                                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;read: %s&quot;</span>, buf);<br>                        &#125;<br>                &#125;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread-%lu: count=%d\n&quot;</span>, acl::thread::self(), i);<br>        &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">start_clients</span><span class="hljs-params">(acl::sslbase_conf&amp; ssl_conf, <span class="hljs-type">const</span> acl::<span class="hljs-built_in">string</span> addr,</span><br><span class="hljs-params">        <span class="hljs-type">int</span> cocurrent, <span class="hljs-type">int</span> count)</span> &#123;<br><br>        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;acl::thread*&gt; threads;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; cocurrent; i++) &#123;<br>                acl::thread* thr = new echo_thread(ssl_conf, addr, count);<br>                threads.push_back(thr);<br>                thr-&gt;start();<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>                it != threads.end(); ++it) &#123;<br>                (*it)-&gt;wait(<span class="hljs-literal">NULL</span>);<br>                delete *it;<br>        &#125;<br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* procname)</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s -h [help]\r\n&quot;</span><br>                <span class="hljs-string">&quot; -s listen_addr\r\n&quot;</span><br>                <span class="hljs-string">&quot; -L ssl_libs_path\r\n&quot;</span><br>                <span class="hljs-string">&quot; -c cocurrent\r\n&quot;</span><br>                <span class="hljs-string">&quot; -n count\r\n&quot;</span>, procname);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span> &#123;<br>        acl::<span class="hljs-built_in">string</span> addr = <span class="hljs-string">&quot;0.0.0.0|2443&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">if</span> defined(__APPLE__)</span><br>        acl::<span class="hljs-built_in">string</span> ssl_lib = <span class="hljs-string">&quot;../libmbedtls_all.dylib&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(__linux__)</span><br>        acl::<span class="hljs-built_in">string</span> ssl_lib = <span class="hljs-string">&quot;../libmbedtls_all.so&quot;</span>;<br><span class="hljs-meta">#<span class="hljs-keyword">elif</span> defined(_WIN32) || defined(_WIN64)</span><br>        acl::<span class="hljs-built_in">string</span> ssl_path = <span class="hljs-string">&quot;../mbedtls.dll&quot;</span>;<br><br>        acl::acl_cpp_init();<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-meta"># <span class="hljs-keyword">error</span> <span class="hljs-string">&quot;unknown OS type&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>        <span class="hljs-type">int</span> ch, cocurrent = <span class="hljs-number">10</span>, count = <span class="hljs-number">10</span>;<br>        <span class="hljs-keyword">while</span> ((ch = getopt(argc, argv, <span class="hljs-string">&quot;hs:L:c:n:&quot;</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br>                <span class="hljs-keyword">switch</span> (ch) &#123;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>                        usage(argv[<span class="hljs-number">0</span>]);<br>                        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>                        addr = optarg;<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;L&#x27;</span>:<br>                        ssl_lib = optarg;<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>                        cocurrent = atoi(optarg);<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;n&#x27;</span>:<br>                        count = atoi(optarg);<br>                        <span class="hljs-keyword">break</span>;<br>                <span class="hljs-keyword">default</span>:<br>                        <span class="hljs-keyword">break</span>;<br>                &#125;<br>        &#125;<br><br>        acl::<span class="hljs-built_in">log</span>::stdout_open(<span class="hljs-literal">true</span>);<br><br>        <span class="hljs-comment">// 设置 MbedTLS 动态库路径</span><br>        <span class="hljs-type">const</span> <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;acl::<span class="hljs-built_in">string</span>&gt;&amp; libs = ssl_lib.split2(<span class="hljs-string">&quot;,; \t&quot;</span>);<br>        <span class="hljs-keyword">if</span> (libs.size() == <span class="hljs-number">1</span>) &#123;<br>                acl::mbedtls_conf::set_libpath(libs[<span class="hljs-number">0</span>]);<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (libs.size() == <span class="hljs-number">3</span>) &#123;<br>                <span class="hljs-comment">// libcrypto, libx509, libssl);</span><br>                acl::mbedtls_conf::set_libpath(libs[<span class="hljs-number">0</span>], libs[<span class="hljs-number">1</span>], libs[<span class="hljs-number">2</span>]);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;invalid ssl_lib=%s\r\n&quot;</span>, ssl_lib.c_str());<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 加载 MbedTLS 动态库</span><br>        <span class="hljs-keyword">if</span> (!acl::mbedtls_conf::load()) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;load %s error\r\n&quot;</span>, ssl_lib.c_str());<br>                <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 初始化客户端模式下的全局 SSL 配置对象</span><br>        <span class="hljs-type">bool</span> server_side = <span class="hljs-literal">false</span>;<br><br>        <span class="hljs-comment">// SSL 证书校验级别</span><br>        acl::<span class="hljs-type">mbedtls_verify_t</span> verify_mode = acl::MBEDTLS_VERIFY_NONE;<br>        acl::mbedtls_conf <span class="hljs-title function_">ssl_conf</span><span class="hljs-params">(server_side, verify_mode)</span>;<br>        start_clients(ssl_conf, addr, cocurrent, count);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在客户方式下使用 SSL 时的方法与服务端时相似，不同之处是在客户端下使用 SSL 时不必加载证书和设置私钥。</p><h3 id="2-3、非阻塞模式"><a href="#2-3、非阻塞模式" class="headerlink" title="2.3、非阻塞模式"></a>2.3、非阻塞模式</h3><p>在使用 SSL 进行非阻塞编程时，动态库的加载、证书的加载及设置私钥过程与阻塞式 SSL 编程方法相同，不同之处在于创建 SSL IO 对象时需要设置为非阻塞方式，另外在 SSL 握手阶段需要不断检测 SSL 握手是否成功，下面只给出相关不同之处，完整示例可以参考：<a href="https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_server%EF%BC%8Chttps://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_client%EF%BC%89%EF%BC%9A">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_server，https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_client）：</a></p><ul><li>调用 <code>acl::sslbase_conf</code> 中的虚方法 <code>open</code> 时传入的参数为 <code>true</code> 表明所创建的 SSL IO 对象为非阻塞方式；</li><li>在创建非阻塞 IO 对象后，需要调用 <code>acl::aio_socket_stream</code> 中的 <code>read_wait</code> 方法，以便可以触发 <code>acl::aio_istream::read_wakeup</code> 回调，从而在该回调里完成 SSL 握手过程；</li><li>在非阻塞IO的读回调里需要调用 <code>acl::sslbase_io</code> 中的虚方法 <code>handshake</code> 尝试进行 SSL 握手并通过 <code>handshake_ok</code> 检测握手是否成功。<br>下面给出在 <code>read_wakeup</code> 回调里进行 SSL 握手的过程：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">bool</span> <span class="hljs-title function_">read_wakeup</span><span class="hljs-params">()</span><br>&#123;<br>        acl::sslbase_io* hook = (acl::sslbase_io*) client_-&gt;get_hook();<br>        <span class="hljs-keyword">if</span> (hook == <span class="hljs-literal">NULL</span>) &#123; <br>                <span class="hljs-comment">// 非 SSL 模式，异步读取数据</span><br>                <span class="hljs-comment">//client_-&gt;read(__timeout);</span><br>                client_-&gt;gets(__timeout, <span class="hljs-literal">false</span>); <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;       <br><br>        <span class="hljs-comment">// 尝试进行 SSL 握手</span><br>        <span class="hljs-keyword">if</span> (!hook-&gt;handshake()) &#123;<br>                <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;ssl handshake failed\r\n&quot;</span>);<br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>        &#125;       <br><br>        <span class="hljs-comment">// 如果 SSL 握手已经成功，则开始按行读数据</span><br>        <span class="hljs-keyword">if</span> (hook-&gt;handshake_ok()) &#123;<br>                <span class="hljs-comment">// 由 reactor 模式转为 proactor 模式，从而取消</span><br>                <span class="hljs-comment">// read_wakeup 回调过程</span><br>                client_-&gt;disable_read();<br><br>                <span class="hljs-comment">// 异步读取数据，将会回调 read_callback</span><br>                <span class="hljs-comment">//client_-&gt;read(__timeout);</span><br>                client_-&gt;gets(__timeout, <span class="hljs-literal">false</span>); <br>                <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;       <br><br>        <span class="hljs-comment">// SSL 握手还未完成，等待本函数再次被触发</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>在该代码片断中，如果 SSL 握手一直处于进行中，则 <code>read_wakeup</code> 可能会被调用多次，这就意味着 <code>handshake</code> 握手过程也会被调用多次，然后再通过 <code>handshake_ok</code> 判断握手是否已经成功，如果成果，则通过调用 <code>gets</code> 方法切换到 IO 过程（该 IO 过程对应的回调为 <code>read_callback</code>），否则进行 SSL 握手过程（继续等待 <code>read_wakeup</code> 被回调）。</li></ul><h3 id="2-4、SNI方式支持使用多个证书"><a href="#2-4、SNI方式支持使用多个证书" class="headerlink" title="2.4、SNI方式支持使用多个证书"></a>2.4、SNI方式支持使用多个证书</h3><p>SSL 的早期设计认为一个服务器仅提供一个域名服务，因此只需要加载一个证书即可。但后来因为 HTTP 虚拟主机的产生与发展，只能加载一个 SSL 证书显然是不能满足要求的（服务端与客户端进行 SSL 握手时必须选择合适的域名证书），为此 SSL 协议进行了扩展：在客户端向服务端发起SSL握手阶段便将相应域名信息以明文方式发送至服务端，于时服务器便根据此信息选择相应的 SSL 证书，从而完成了 SSL 过程。在 Acl 的 SSL 模块中也增加了针对 SNI 的支持，从而可以使客户端与服务端进行多域名 SSL 通信。<br>更多 SSL SNI 内容可以参考：<a href="https://abcdxyzk.github.io/blog/2021/06/08/tools-sni/">https://abcdxyzk.github.io/blog/2021/06/08/tools-sni/</a> .</p><h4 id="2-4-1、客户端"><a href="#2-4-1、客户端" class="headerlink" title="2.4.1、客户端"></a>2.4.1、客户端</h4><p>在 <code>acl::sslbase_io</code> 基类中提供了设置 SNI 标识的方法，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 SNI HOST 字段</span><br><span class="hljs-comment"> * @param host &#123;const char*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_sni_host</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* host)</span></span>;<br></code></pre></td></tr></table></figure><p>该方法设置了所请求的域名主机标识（对应 <code>sslbase_io::sni_host_</code> 成员变量），在 <code>acl::sslbase_io</code> 的子类（目前主要是 <code>acl::openssl_io</code> 及 <code>acl::mbedtls_io</code>）中，当开始 SSL 会话时会首先检测该成员变量（<code>sni_host_</code>）是否已经设置，如果已设置，则会自动在 SSL 握手阶段添加 SNI 扩展标识。</p><h4 id="2-4-1、服务端"><a href="#2-4-1、服务端" class="headerlink" title="2.4.1、服务端"></a>2.4.1、服务端</h4><p>Acl SSL 模块在服务端处理 SSL SNI 的方式是自动的，无需应用特殊处理，只需要使用者添加多个不同域名的证书即可，即多次调用下面方法加载多个域名证书（即调用基类 <code>acl::sslbase_conf</code> 中的方法）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加一个服务端/客户端自己的证书，可以多次调用本方法加载多个证书</span><br><span class="hljs-comment"> * @param crt_file &#123;const char*&#125; 证书文件全路径，非空</span><br><span class="hljs-comment"> * @param key_file &#123;const char*&#125; 密钥文件全路径，非空</span><br><span class="hljs-comment"> * @param key_pass &#123;const char*&#125; 密钥文件的密码，没有密钥密码可写 NULL</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 添加证书是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">add_cert</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* crt_file, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_file,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* key_pass = <span class="hljs-literal">NULL</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>使用者每通过 <code>sslbase_conf::add_cert</code> 方法添加一个 SSL 证书，内部人自动解析该证书，并提取证书中记录主机 DNS 信息的扩展数据，并添加主机域名与证书的映射关系；启动运行后，当收到客户端带有 SNI 标识的 SSL 握手请求时，会根据主机域名自动去查找匹配相应的 SSL 证书，从而为该次 SSL 会话选择正确的 SSL 证书。</p><h2 id="四、Acl-库编译集成第三方-SSL-方式"><a href="#四、Acl-库编译集成第三方-SSL-方式" class="headerlink" title="四、Acl 库编译集成第三方 SSL 方式"></a>四、Acl 库编译集成第三方 SSL 方式</h2><p>Acl 库在缺省情况下自动支持 SSL 通信功能并采用动态加载第三方 SSL（OpenSSL&#x2F;MbedTLS&#x2F;PolarSSL） 动态库的方式来集成 SSL 功能，查看 Makefile 文件或 VC 工程可以看到在编译 Acl 库时指定了 HAS_OPENSSL_DLL&#x2F;HAS_MBEDTLS_DLL&#x2F;HAS_POLARSSL_DLL 编译选项，这样在 openssl_conf.cpp 等与 SSL 相关的功能模块代码中会根据此编译选项动态加载 SSL 动态库；但有时，有的项目希望可以静态链接 SSL 动态库，则在编译 Acl 项目中就需要指定静态连接编译选项，即（下面以集成 OpenSSL 为例）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$ </span><span class="language-bash"><span class="hljs-built_in">cd</span> acl; make OPENSSL_STATIC=<span class="hljs-built_in">yes</span></span><br></code></pre></td></tr></table></figure><p>然后在应用程序自身的 Makefile 中指定 SSL 库，如下 ：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">app:</span><br>        g++ -o app app.o -lacl_cpp -lprotocol -lacl -lcrypto -lssl -lz -lpthread<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SSL编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SSL编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>acl库使用FAQ</title>
    <link href="/2019/06/30/faq/"/>
    <url>/2019/06/30/faq/</url>
    
    <content type="html"><![CDATA[<h2 id="acl库使用FAQ"><a href="#acl库使用FAQ" class="headerlink" title="acl库使用FAQ"></a>acl库使用FAQ</h2><ul><li><a href="#%E4%B8%80%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98">一、基础问题</a><ul><li><a href="#1acl-%E5%BA%93%E6%98%AF%E5%95%A5%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD">1、acl 库是啥、主要包含哪些功能？</a></li><li><a href="#2acl-%E5%BA%93%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%B9%B3%E5%8F%B0">2、acl 库支持哪些平台？</a></li><li><a href="#3acl-%E5%BA%93%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E5%87%A0%E4%B8%AA%E5%BA%93">3、acl 库主要包含几个库？</a></li><li><a href="#4acl-%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E5%BA%93">4、acl 库有哪些外部依赖库？</a></li><li><a href="#5%E6%B2%A1%E6%9C%89%E8%BF%99%E4%BA%9B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-acl-%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8">5、没有这些第三方库 acl 能否使用？</a></li><li><a href="#6acl-%E5%BA%93%E7%9A%84%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%BD%8D%E7%BD%AE%E5%9C%A8%E5%93%AA%E5%84%BF">6、acl 库的源码下载位置在哪儿？</a></li></ul></li><li><a href="#%E4%BA%8C%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98">二、编译&amp;使用问题</a><ul><li><a href="#1acl-%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B">1、acl 库的编译过程？</a></li><li><a href="#2linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98">2、Linux 平台下库的编译顺序问题？</a></li><li><a href="#3unixlinux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%BC%96%E8%AF%91-acl-%E5%BA%93%E6%97%B6%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E6%98%AF%E4%BB%80%E4%B9%88">3、Unix&#x2F;Linux 平台下编译 acl 库时的编译选项是什么</a></li><li><a href="#4%E8%AF%B7%E7%BB%99%E5%87%BA-linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%80%E4%B8%AA-makefile">4、请给出 Linux 平台下最简单的一个 Makefile？</a></li><li><a href="#5linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%89%BE%E4%B8%8D%E5%88%B0-libza-%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E">5、Linux 平台下找不到 libz.a 库怎么办？</a></li><li><a href="#6linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B-acl-%E5%BA%93%E8%83%BD%E6%89%93%E5%8C%85%E6%88%90%E4%B8%80%E4%B8%AA%E5%BA%93%E5%90%97">6、Linux 平台下 acl 库能打包成一个库吗？</a></li><li><a href="#7linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ssl-%E5%8A%9F%E8%83%BD">7、Linux 平台下如何使用 ssl 功能？</a></li><li><a href="#8linux-%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-mysql-%E5%8A%9F%E8%83%BD">8、Linux 下如何使用 mysql 功能？</a></li></ul></li><li><a href="#%E4%B8%89%E5%90%84%E4%B8%AA%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98">三、各个功能模块的使用问题</a><ul><li><a href="#%E4%B8%80%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1">（一）、网络通信</a></li><li><a href="#%E4%BA%8Chttp-%E6%A8%A1%E5%9D%97">（二）、HTTP 模块</a><ul><li><a href="#1-acl-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%96%AD%E7%82%B9%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD">1. acl HTTP 服务器是否支持断点下载功能？</a></li><li><a href="#2-acl-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD">2. acl HTTP 服务器是否支持文件上传功能？</a></li><li><a href="#3-acl-http-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F">3. acl HTTP 模块是否支持服务器&#x2F;客户端两种模式？</a></li><li><a href="#4-acl-http-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-websocket-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE">4. acl HTTP 模块是否支持 websocket 通信协议？</a></li><li><a href="#5-acl-http-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-session">5. acl HTTP 模块是否支持 session？</a></li><li><a href="#6-HttpServletRequest-%E4%B8%BA%E4%BD%95%E8%AF%BB%E4%B8%8D%E5%88%B0-json-%E6%88%96-xml-%E6%95%B0%E6%8D%AE%E4%BD%93">6. HttpServletRequest 为何读不到 json 或 xml 数据体？</a></li><li><a href="#7-http_request-%E5%9B%A0%E6%9C%AA%E8%AE%BE-Host-%E5%AD%97%E6%AE%B5%E8%80%8C%E5%87%BA%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98">7. http_request 因未设 Host 字段而出错的问题</a></li></ul></li><li><a href="#%E4%B8%89redis-%E6%A8%A1%E5%9D%97">（三）、Redis 模块</a><ul><li><a href="#1-acl-redis-%E5%BA%93%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E9%9B%86%E7%BE%A4%E5%8A%9F%E8%83%BD">1. acl redis 库是否支持集群功能？</a></li><li><a href="#2-acl-redis-%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84">2. acl redis 库是如何划分的？</a></li><li><a href="#3-acl-redis-%E5%BA%93%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84">3. acl redis 库中的哪些类对象操作是线程安全的？</a></li><li><a href="#4-acl-redis-%E5%AE%A2%E6%88%B7%E5%BA%93%E5%BD%93%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%E6%97%B6%E6%98%AF%E5%90%A6%E4%BC%9A%E9%87%8D%E8%BF%9E">4. acl redis 客户库当连接断开时是否会重连？</a></li></ul></li><li><a href="#%E5%9B%9B%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97">（四）、协程模块</a><ul><li><a href="#1-%E5%8D%8F%E7%A8%8B%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%E7%9A%84">1. 协程里面的非阻塞是什么原理的？</a></li><li><a href="#2-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B">2. acl 协程库是否支持多线程？</a></li><li><a href="#3-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%A4%9A%E6%A0%B8-cpu">3. acl 协程库如何支持多核 CPU？</a></li><li><a href="#4-acl-%E5%8D%8F%E7%A8%8B%E9%87%8C%E9%92%88%E5%AF%B9-mysql-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%93%E7%9A%84%E5%8D%8F%E7%A8%8B%E5%8C%96%E6%98%AF%E5%90%A6%E4%BF%AE%E6%94%B9%E4%BA%86-mysql-%E5%BA%93%E7%9A%84%E6%BA%90%E7%A0%81">4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？</a></li><li><a href="#5-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E6%94%AF%E6%8C%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E5%90%97">5. acl 协程库支持域名解析功能吗？</a></li><li><a href="#6-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%9A%84%E7%B3%BB%E7%BB%9F-errno-%E5%8F%B7%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86">6. acl 协程库的系统 errno 号如何处理？</a></li><li><a href="#7-%E5%A6%82%E6%9E%9C%E5%90%AF%E5%8A%A8%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%BF%87%E5%A4%9A%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%AF%B9%E4%BA%8E%E5%90%8E%E7%AB%AF%E4%BE%8B%E5%A6%82-mysql-%E4%B9%8B%E7%B1%BB%E6%9C%8D%E5%8A%A1%E9%80%A0%E6%88%90%E5%B9%B6%E5%8F%91%E5%8E%8B%E5%8A%9B%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D">7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？</a></li></ul></li><li><a href="#%E4%BA%94%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9D%97">（五）、服务器模块</a><ul><li><a href="#1-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9D%87%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9">1. 有几种服务器编程模型？均有何特点？</a></li><li><a href="#2-acl_master-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%B9%B3%E5%8F%B0">2. acl_master 的作用是什么？支持哪些平台？</a></li><li><a href="#3-%E6%B2%A1%E6%9C%89-acl_master-%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E8%BF%90%E8%A1%8C">3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？</a></li><li><a href="#4-%E6%89%8B%E5%B7%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E9%81%87%E5%88%B0idle-timeout----exiting-idle%E6%80%8E%E4%B9%88%E5%8A%9E">4. 手工模式下运行时遇到“idle timeout – exiting, idle”怎么办？</a></li><li><a href="#5-acl_master-%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E9%A2%84%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B">5. acl_master 控制模式下，服务子进程如何预启动多个进程？</a></li><li><a href="#6-acl_master-%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8F%AA%E7%9B%91%E5%90%AC%E5%86%85%E7%BD%91%E5%9C%B0%E5%9D%80">6. acl_master 控制模式下，如何只监听内网地址？</a></li></ul></li><li><a href="#%E5%85%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97">（六）、数据库模块</a><ul><li><a href="#1-acl-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93">1. acl 数据库客户端支持哪些数据库？</a></li><li><a href="#2-acl-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8">2. acl 数据库模块如何使用？</a></li></ul></li><li><a href="#%E4%B8%83%E9%82%AE%E4%BB%B6mime%E6%A8%A1%E5%9D%97">（七）、邮件&amp;mime模块</a></li></ul></li></ul><h3 id="一、基础问题"><a href="#一、基础问题" class="headerlink" title="一、基础问题"></a>一、基础问题</h3><h3 id="1、acl-库是啥、主要包含哪些功能？"><a href="#1、acl-库是啥、主要包含哪些功能？" class="headerlink" title="1、acl 库是啥、主要包含哪些功能？"></a>1、acl 库是啥、主要包含哪些功能？</h3><p>acl 工程是一个跨平台（支持LINUX，WIN32，Solaris，MacOS，FreeBSD）的网络通信库及服务器编程框架，同时提供更多的实用功能库。通过该库，用户可以非常容易地编写支持多种模式(多线程、多进程、非阻塞、触发器、UDP方式、协程方式)的服务器程序，WEB 应用程序，数据库应用程序。此外，该库还提供了常见应用的客户端通信库（如：HTTP、SMTP、ICMP、redis、disque、memcache、beanstalk、handler socket），常见流式编解码库：XML&#x2F;JSON&#x2F;MIME&#x2F;BASE64&#x2F;UUCODE&#x2F;QPCODE&#x2F;RFC2047 等。</p><h3 id="2、acl-库支持哪些平台？"><a href="#2、acl-库支持哪些平台？" class="headerlink" title="2、acl 库支持哪些平台？"></a>2、acl 库支持哪些平台？</h3><p>目前主要支持 Linux&#x2F;Windows&#x2F;Macos&#x2F;Freebsd&#x2F;Solaris(x86)。</p><h3 id="3、acl-库主要包含几个库？"><a href="#3、acl-库主要包含几个库？" class="headerlink" title="3、acl 库主要包含几个库？"></a>3、acl 库主要包含几个库？</h3><p>主要包括：lib_acl（用 C 语言写的基础库）、lib_protocol（用 C 语言写的一些网络应用协议库）、lib_acl_cpp（用 C++ 语言编写，封装了 lib_acl&#x2F;lib_protocol 两个库，同时增加更多实用的功能库）、 lib_fiber（用 C 语言编写的支持高性能、高并发的网络协程库）、lib_rpc（用C++语言编写的封装了 google protobuf 网络库）。</p><h3 id="4、acl-库有哪些外部依赖库？"><a href="#4、acl-库有哪些外部依赖库？" class="headerlink" title="4、acl 库有哪些外部依赖库？"></a>4、acl 库有哪些外部依赖库？</h3><p>lib_acl&#x2F;lib_protocol&#x2F;lib_fiber 仅依赖系统基础库；lib_acl_cpp 库的 db 模块依赖于 mysql 客户端库、sqlite 库，stream 流模块依赖于 polarssl 库（该库源码附在 acl&#x2F;resource 目录下），另外，在 UNIX&#x2F;LINUX 平台下还需要压缩库 — libz 库（一般 LINUX 会自带该压缩库）；lib_rpc 依赖于 protobuf 库。</p><h3 id="5、没有这些第三方库-acl-能否使用？"><a href="#5、没有这些第三方库-acl-能否使用？" class="headerlink" title="5、没有这些第三方库 acl 能否使用？"></a>5、没有这些第三方库 acl 能否使用？</h3><p>可以。默认情况下，没有这些第三方库编译和使用 acl 库是没有问题的，只是不能使用 mysql&#x2F;sqlite&#x2F;ssl&#x2F;protobuf 功能。</p><h3 id="6、acl-库的源码下载位置在哪儿？"><a href="#6、acl-库的源码下载位置在哪儿？" class="headerlink" title="6、acl 库的源码下载位置在哪儿？"></a>6、acl 库的源码下载位置在哪儿？</h3><ul><li>github：<a href="https://github.com/acl-dev/acl/">https://github.com/acl-dev/acl/</a></li><li>oschina: <a href="https://git.oschina.net/acl-dev/acl/">https://git.oschina.net/acl-dev/acl/</a></li><li>sourceforge：<a href="https://sourceforge.net/projects/acl/">https://sourceforge.net/projects/acl/</a></li></ul><h3 id="二、编译-amp-使用问题"><a href="#二、编译-amp-使用问题" class="headerlink" title="二、编译&amp;使用问题"></a>二、编译&amp;使用问题</h3><h3 id="1、acl-库的编译过程？"><a href="#1、acl-库的编译过程？" class="headerlink" title="1、acl 库的编译过程？"></a>1、acl 库的编译过程？</h3><p>acl 库的编译过程请参考：<a href="http://zsxxsz.iteye.com/blog/1506554">acl 的编译与使用</a> 博客。</p><h3 id="2、Linux-平台下库的编译顺序问题？"><a href="#2、Linux-平台下库的编译顺序问题？" class="headerlink" title="2、Linux 平台下库的编译顺序问题？"></a>2、Linux 平台下库的编译顺序问题？</h3><p>lib_acl 库是 acl 库中的基础库，其它库均依赖于该库，库的依赖顺序为：lib_protocol 依赖于 lib_acl，lib_acl_cpp 依赖于 lib_acl 和 lib_protocol，lib_fiber 依赖于 lib_acl，lib_rpc 依赖于 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp。因此当应用在连接 acl 库时，需要注意连接的顺序为：-l_acl_cpp -l_protocol -l_acl。</p><h3 id="3、Unix-x2F-Linux-平台下编译-acl-库时的编译选项是什么？"><a href="#3、Unix-x2F-Linux-平台下编译-acl-库时的编译选项是什么？" class="headerlink" title="3、Unix&#x2F;Linux 平台下编译 acl 库时的编译选项是什么？"></a>3、Unix&#x2F;Linux 平台下编译 acl 库时的编译选项是什么？</h3><p>在 Unix&#x2F;Linux 平台下编译 acl 库时需要指明 gcc 的编译选项，acl 库自带的 Makefile 会自动识别操作系统而选择不同的编译选项，下面列出不同 Unix 平台的不同编译选项（当前版本已自动识别系统类型，无需添加如下编译选项）：</p><ul><li>Linux 平台：-DLINUX2</li><li>MacOS 平台：-DMACOSX</li><li>FreeBSD 平台：-DFREEBSD</li><li>Solaris(x86) 平台：-DSUNOS5</li></ul><h3 id="4、请给出-Linux-平台下最简单的一个-Makefile？"><a href="#4、请给出-Linux-平台下最简单的一个-Makefile？" class="headerlink" title="4、请给出 Linux 平台下最简单的一个 Makefile？"></a>4、请给出 Linux 平台下最简单的一个 Makefile？</h3><p>下面是使用 acl 库的最简单的编译选项（因为排版问题，当拷贝下面内容至 Makefile 时，需要注意将每行前空格手工转成 TAB 键）：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs gradle">fiber: main.o<br>g++ -o fiber main.o \<br>-L.<span class="hljs-regexp">/lib_fiber/</span>lib -lfiber_cpp \<br>-L.<span class="hljs-regexp">/lib_acl_cpp/</span>lib -l_acl_cpp \<br>-L.<span class="hljs-regexp">/lib_protocol/</span>lib -l_protocol \<br>-L.<span class="hljs-regexp">/lib_acl/</span>lib -l_acl \<br>-L.<span class="hljs-regexp">/lib_fiber/</span>lib -lfiber \<br>-lz -lpthread -ldl<br>main.o: main.cpp<br>g++ -O3 -Wall -c main.cpp -DLINUX2 \<br>-I.<span class="hljs-regexp">/lib_acl/i</span>nclude \<br>-I.<span class="hljs-regexp">/lib_acl_cpp/i</span>nclude \<br>-I.<span class="hljs-regexp">/lib_fiber/</span>cpp/<span class="hljs-keyword">include</span> \<br>-I.<span class="hljs-regexp">/lib_fiber/</span>c/<span class="hljs-keyword">include</span><br></code></pre></td></tr></table></figure><h3 id="5、Linux-平台下找不到-libz-a-库怎么办？"><a href="#5、Linux-平台下找不到-libz-a-库怎么办？" class="headerlink" title="5、Linux 平台下找不到 libz.a 库怎么办？"></a>5、Linux 平台下找不到 libz.a 库怎么办？</h3><p>一般 Unix&#x2F;Linux 平台下系统会自带 libz.a 或 libz.so 压缩库，如果找不到该库，则可以在线安装或采用编译安装 zlib 库，针对 Centos 和 Ubuntu 可分别通过以下方式在线安装（均需切换至 root 身份）：</p><ul><li>Centos：yum install zlib-devel</li><li>Ubuntu：apt-get install zlib1g.dev</li></ul><h3 id="6、Linux-平台下-acl-库能打包成一个库吗？"><a href="#6、Linux-平台下-acl-库能打包成一个库吗？" class="headerlink" title="6、Linux 平台下 acl 库能打包成一个库吗？"></a>6、Linux 平台下 acl 库能打包成一个库吗？</h3><p>可以。在 acl 目录下运行：make build_one 则可以将 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp 打包成一个完整的库：lib_acl.a&#x2F;lib_acl.so，则应用最终使用时可以仅连接这一个库即可。</p><h3 id="7、Linux-平台下如何使用-ssl-功能？"><a href="#7、Linux-平台下如何使用-ssl-功能？" class="headerlink" title="7、Linux 平台下如何使用 ssl 功能？"></a>7、Linux 平台下如何使用 ssl 功能？</h3><p>目前 acl 中的 lib_acl_cpp C++ 库通过集成 polarssl 支持 ssl 功能，所支持的 polarssl 源码的下载位置：<a href="https://github.com/acl-dev/third_party">https://github.com/acl-dev/third_party</a>, 老版本 acl 通过静态连接 libpolarssl.a 实现对 ssl 的支持，当前版本则是通过动态加载 libpolarssl.so 方式实现了对 ssl 的支持，此动态支持方式更加灵活方便，无须特殊编译条件，也更为通用。</p><h4 id="7-1、老版本-acl-对-ssl-的支持方式"><a href="#7-1、老版本-acl-对-ssl-的支持方式" class="headerlink" title="7.1、老版本 acl 对 ssl 的支持方式"></a>7.1、老版本 acl 对 ssl 的支持方式</h4><p>如果使用上面统一的 acl 库，则可以在 acl 根目录下编译时运行：make build_one polarssl&#x3D;on；如果使用三个库：lib_acl.a，lib_protocol.a，lib_acl_cpp.a，则在编译前需要先指定环境变量：export ENV_FLAGS&#x3D;HAS_POLARSSL，然后分别编译这三个库；解压 polarssl-1.2.19-gpl.tgz，然后进入 polarssl-1.2.19 目录运行：make 编译后在 polarssl-1.2.19&#x2F;library 目录得到 libpolarssl.a 库；最后在编译应用时将 libpolarssl.a 连接进你的工程中即可。</p><h4 id="7-2、当前版本-acl-对-ssl-的支持方式"><a href="#7-2、当前版本-acl-对-ssl-的支持方式" class="headerlink" title="7.2、当前版本 acl 对 ssl 的支持方式"></a>7.2、当前版本 acl 对 ssl 的支持方式</h4><ul><li>首先下载解压 polarssl 库后进入polarssl-1.2.19 目录，运行 make lib SHARED&#x3D;yes，在library 目录下会生成 libpolarssl.so 动态库;</li><li>在 acl 根目录下运行 make build_one，则会将 acl 的三个基础库：libacl.a, libprotocol.a, libacl_cpp.a 合成 libacl_all.a 一个静态库，将 libacl.so, libprotocol.so, lib_acl_cpp.so 合成 libacl_all.so 一个动态库;</li><li>当程序启动时添加代码：acl::polarssl_conf::set_libpath(“libpolarssl.so”); 其中的路径根据实际位置而定，这样 acl 模块在需要 ssl 通信时会自动切换至 ssl 方式。</li></ul><h3 id="8、Linux-下如何使用-mysql-功能？"><a href="#8、Linux-下如何使用-mysql-功能？" class="headerlink" title="8、Linux 下如何使用 mysql 功能？"></a>8、Linux 下如何使用 mysql 功能？</h3><p>lib_acl_cpp 库是以动态加载方式加载 mysql 动态库的，所以在编译 lib_acl_cpp 时，mysql 功能就已经被编译进去 acl库中了。用户仅需要将 mysql 动态库通过函数 acl::db_handle::set_loadpath 注册进 acl 库中即可；至于 mysql 客户端库，用户可以去 mysql 官方下载或在 acl&#x2F;resource 目录下编译 mysql-connector-c-6.1.6-src.tar.gz。</p><h3 id="三、各个功能模块的使用问题"><a href="#三、各个功能模块的使用问题" class="headerlink" title="三、各个功能模块的使用问题"></a>三、各个功能模块的使用问题</h3><h3 id="（一）、网络通信"><a href="#（一）、网络通信" class="headerlink" title="（一）、网络通信"></a>（一）、网络通信</h3><h3 id="（二）、HTTP-模块"><a href="#（二）、HTTP-模块" class="headerlink" title="（二）、HTTP 模块"></a>（二）、HTTP 模块</h3><h4 id="1-acl-HTTP-服务器是否支持断点下载功能？"><a href="#1-acl-HTTP-服务器是否支持断点下载功能？" class="headerlink" title="1. acl HTTP 服务器是否支持断点下载功能？"></a>1. acl HTTP 服务器是否支持断点下载功能？</h4><p>支持。acl HTTP 模块支持断点续传功能，一个支持断点下载的服务器示例参照：acl\app\wizard_demo\httpd_download。</p><h4 id="2-acl-HTTP-服务器是否支持文件上传功能？"><a href="#2-acl-HTTP-服务器是否支持文件上传功能？" class="headerlink" title="2. acl HTTP 服务器是否支持文件上传功能？"></a>2. acl HTTP 服务器是否支持文件上传功能？</h4><p>支持。参考示例：acl\app\wizard_demo\httpd_upload。</p><h4 id="3-acl-HTTP-模块是否支持服务器-x2F-客户端两种模式？"><a href="#3-acl-HTTP-模块是否支持服务器-x2F-客户端两种模式？" class="headerlink" title="3. acl HTTP 模块是否支持服务器&#x2F;客户端两种模式？"></a>3. acl HTTP 模块是否支持服务器&#x2F;客户端两种模式？</h4><p>支持。目前 acl 的 HTTP 协议模块同时支持客户端及服务端模式，即你既可以使用 acl HTTP 编写客户端程序，又可以编写服务器程序，其中 acl 中的 http_request&#x2F;http_request_pool&#x2F;http_request_manager 类用来编写客户端程序，http_response&#x2F;HttpServlet&#x2F;HttpServletRequest&#x2F;HttpServeletResponse 用来编写服务器程序。</p><h4 id="4-acl-HTTP-模块是否支持-websocket-通信协议？"><a href="#4-acl-HTTP-模块是否支持-websocket-通信协议？" class="headerlink" title="4. acl HTTP 模块是否支持 websocket 通信协议？"></a>4. acl HTTP 模块是否支持 websocket 通信协议？</h4><p>支持。可以参考示例：lib_acl_cpp\samples\websocket。</p><h4 id="5-acl-HTTP-模块是否支持-session？"><a href="#5-acl-HTTP-模块是否支持-session？" class="headerlink" title="5. acl HTTP 模块是否支持 session？"></a>5. acl HTTP 模块是否支持 session？</h4><p>支持。acl HTTP 模块当用在服务器编程时支持 session 存储，目前支持使用 memcached 或 redis 存储 session 数据。</p><h4 id="6-HttpServletRequest-为何读不到-json-或-xml-数据体"><a href="#6-HttpServletRequest-为何读不到-json-或-xml-数据体" class="headerlink" title="6. HttpServletRequest 为何读不到 json 或 xml 数据体"></a>6. HttpServletRequest 为何读不到 json 或 xml 数据体</h4><p>当 HTTP 客户端请求的数据体为 json 或 xml 时，默认情况下从 acl::HttpServletRequest 对象中是读不到 json&#x2F;xml 数据的，主要原因在于 HttpServletRequest 内置了自动读取并解析 json&#x2F;xml&#x2F;x-www-form-urlencoded 类型数据的功能，使用者只需直接获取解析后的对象即可，如针对 json 类数据体：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">get_json</span><span class="hljs-params">(acl::HttpServletRequest&amp; req)</span></span><br><span class="hljs-function"></span>&#123;<br>acl::json* json = req.<span class="hljs-built_in">getJson</span>();<br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>如果应用想自己读取并解析 json 数据，则需要在调用 acl::HttpServlet::setParseBody(false)，禁止 acl::HttpServletRequest 类对象内部自动读取数据。</p><h4 id="7-http-request-因未设-Host-字段而出错的问题"><a href="#7-http-request-因未设-Host-字段而出错的问题" class="headerlink" title="7. http_request 因未设 Host 字段而出错的问题"></a>7. http_request 因未设 Host 字段而出错的问题</h4><p>在使用 acl::http_request 类对象访问标准 WEB 服务器（如：nginx）时，如果没有设置 HTTP 请求头中的 Host 字段，nginx 会返回 400 错误，主要是 HTTP&#x2F;1.1 协议要求 HTTP 客户端必须设置 Host 字段，方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">http_client</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">acl::http_request <span class="hljs-title">req</span><span class="hljs-params">(<span class="hljs-string">&quot;www.sina.com.cn:80&quot;</span>)</span></span>;<br>acl::http_header&amp; hdr = req.<span class="hljs-built_in">request_header</span>();<br>hdr.<span class="hljs-built_in">set_url</span>(<span class="hljs-string">&quot;/&quot;</span>).<span class="hljs-built_in">set_host</span>(<span class="hljs-string">&quot;www.sina.com.cn&quot;</span>);<br><span class="hljs-keyword">if</span> (!req.<span class="hljs-built_in">request</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>acl::string body;<br><span class="hljs-keyword">if</span> (req.<span class="hljs-built_in">get_body</span>(body)) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\r\n&quot;</span>, body.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br>... <br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="（三）、Redis-模块"><a href="#（三）、Redis-模块" class="headerlink" title="（三）、Redis 模块"></a>（三）、Redis 模块</h3><h4 id="1-acl-redis-库是否支持集群功能？"><a href="#1-acl-redis-库是否支持集群功能？" class="headerlink" title="1. acl redis 库是否支持集群功能？"></a>1. acl redis 库是否支持集群功能？</h4><p>答案：是，acl redis 客户端库同时支持集群和单机方式的 redis-server。</p><h4 id="2-acl-redis-库是如何划分的？"><a href="#2-acl-redis-库是如何划分的？" class="headerlink" title="2. acl redis 库是如何划分的？"></a>2. acl redis 库是如何划分的？</h4><p>acl redis 客户端库主要分为两类：命令类和连接类：</p><ul><li><strong>命令类主要有</strong>：redis_key, redis_string, redis_hash, redis_list, redis_set, redis_zset, redis_cluster, redis_geo, redis_hyperloglog, redis_pubsub, redis_transaction, redis_server, redis_script, 这些类都继承于基类 redis_command，同时子类 redis 又继承了所有这些命令类，以便于用户可以直接使用 acl::redis 操作所有的 redis 客户端命令；</li><li><strong>连接类主要有</strong>：redis_client, redis_client_pool, redis_client_cluster，命令类对象通过这些连接类对象与 redis-server 进行交互，redis_client 为单连接类，redis_client_pool 为连接池类，这两个类仅能在非集群模式的 redis-server 环境中使用，不支持 redis-server 的集群模式，必须使用 redis_client_cluster 连接集群模式的 redis-server，同时 redis_client_cluster 也兼容非集群模式的连接。</li></ul><h4 id="3-acl-redis-库中的哪些类对象操作是线程安全的？"><a href="#3-acl-redis-库中的哪些类对象操作是线程安全的？" class="headerlink" title="3. acl redis 库中的哪些类对象操作是线程安全的？"></a>3. acl redis 库中的哪些类对象操作是线程安全的？</h4><p>acl redis 库中的所有命令类对象及 redis_client 单连接类对象不能同时被多个线程使用（就象 std::string 一样不能跨线程使用）；redis_client_pool，redis_client_cluster 两个连接类对象是线程操作安全的，同一个对象可以被多个线程同时使用。</p><h4 id="4-acl-redis-客户库当连接断开时是否会重连？"><a href="#4-acl-redis-客户库当连接断开时是否会重连？" class="headerlink" title="4. acl redis 客户库当连接断开时是否会重连？"></a>4. acl redis 客户库当连接断开时是否会重连？</h4><p>acl redis 库中的连接类中：redis_client，redis_client_pool，redis_client_cluster 三个连接类对象当检测到网络连接异常断开时会尝试自动重连，上层使用者无需考虑连接断开重试的情况。</p><h3 id="（四）、协程模块"><a href="#（四）、协程模块" class="headerlink" title="（四）、协程模块"></a>（四）、协程模块</h3><h4 id="1-协程里面的非阻塞是什么原理的？"><a href="#1-协程里面的非阻塞是什么原理的？" class="headerlink" title="1. 协程里面的非阻塞是什么原理的？"></a>1. 协程里面的非阻塞是什么原理的？</h4><p>比如我现在需要访问数据库，这个动作肯定是个阻塞的操作，如果有10个协程进行数据库访问，这个非阻塞是怎么理解的？<br>协程方式在底层将系统的 IO API（read&#x2F;write 等）都 hook 了，数据库操作也要调用这些API，所以表面上的阻塞式DB操作在协程底层的IO也会被转为非阻塞模式。</p><h4 id="2-acl-协程库是否支持多线程？"><a href="#2-acl-协程库是否支持多线程？" class="headerlink" title="2. acl 协程库是否支持多线程？"></a>2. acl 协程库是否支持多线程？</h4><p>acl 协程库支持多线程方式，只是支持的方式与 go 语言有所不同。用户可以创建多个线程，每个线程一个协程调度器，线程之间的协程调度是相互隔离的，正如多进程与多线程之间的关系一样（每个进程内可以启动多个线程，但进程之间的线程的调度过程是隔离的），在每个线程内部可以创建大量 acl 协程，每个协程均由其所属的线程内的协程调度器调度运行。</p><h4 id="3-acl-协程库如何支持多核-CPU？"><a href="#3-acl-协程库如何支持多核-CPU？" class="headerlink" title="3. acl 协程库如何支持多核 CPU？"></a>3. acl 协程库如何支持多核 CPU？</h4><p>正如 2）所说，用户可以启动多个线程，每个线程一个 acl 协程调度器，每个协程调度器负责调度与其同属相同线程的协程运行状态。</p><h4 id="4-acl-协程里针对-mysql-客户端库的协程化是否修改了-mysql-库的源码？"><a href="#4-acl-协程里针对-mysql-客户端库的协程化是否修改了-mysql-库的源码？" class="headerlink" title="4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？"></a>4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？</h4><p>没有。mysql 客户端库使用的系统 IO API 为 read&#x2F;write&#x2F;poll，而 acl 协程库 HOOK 了系统底层的 IO 过程，因此当将用户程序与 mysql 库及 acl 协程库一起编译后，mysql 库的 IO 过程直接被 acl 协程库 HOOK 的 API 接管，从而将 mysql 客户端库协程化而无须修改一行 mysql 库代码。</p><h4 id="5-acl-协程库支持域名解析功能吗？"><a href="#5-acl-协程库支持域名解析功能吗？" class="headerlink" title="5. acl 协程库支持域名解析功能吗？"></a>5. acl 协程库支持域名解析功能吗？</h4><p>支持。很多 C&#x2F;C++ 实现的协程库并未实现 gethostbyname(_r) 函数，导致用户在使用协程编程遇到域名解析时还需要借助单独的线程来完成，acl 库本身从 DNS 协议层次实现了域名解析过程，acl 协程库基于此功能模块 HOOK 了系统的 gethostbyname(_r) API 而无须借助第三方函数库或起单独的线程完成域名解析。</p><h4 id="6-acl-协程库的系统-errno-号如何处理？"><a href="#6-acl-协程库的系统-errno-号如何处理？" class="headerlink" title="6. acl 协程库的系统 errno 号如何处理？"></a>6. acl 协程库的系统 errno 号如何处理？</h4><p>acl 协程库实现了协程安全的 errno 号，正如之前使用多线程编程时 errno 可以与每个线程绑定一样，在 acl 协程库里 errno 也是与每个 acl 协程进行绑定的。因此，当你调用 strerror(errno) 时也是协程安全的。</p><h4 id="7-如果启动的协程过多，会不会对于后端例如-mysql-之类服务造成并发压力？如何避免？"><a href="#7-如果启动的协程过多，会不会对于后端例如-mysql-之类服务造成并发压力？如何避免？" class="headerlink" title="7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？"></a>7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？</h4><p>当启动用协程较多且都需要 mysql 操作时的确会造成 mysql 服务器的并发压力。为避免此并发压力，acl 协程库提供了协程信号量，用来针对后端不支持高并发的服务提供连接保护。</p><h3 id="（五）、服务器模块"><a href="#（五）、服务器模块" class="headerlink" title="（五）、服务器模块"></a>（五）、服务器模块</h3><h4 id="1-有几种服务器编程模型？均有何特点？"><a href="#1-有几种服务器编程模型？均有何特点？" class="headerlink" title="1. 有几种服务器编程模型？均有何特点？"></a>1. 有几种服务器编程模型？均有何特点？</h4><p>目前 acl 库中提供：进程池模型、线程池模型、非阻塞模型、协程模型、UDP 通信模型、触发器模型。其中各个编程模型的特点如下：  </p><p><strong>进程池模型：</strong> 每个进程处理一个客户端连接，当需要处理多个连接时则需要启动多个进程，此模型的最大缺点是并发度低，优点是编程简单；<br><strong>线程池模型：</strong> 由多个线程组成线程池处理大量的客户端连接，只有当某个连接有数据可读时该连接才会与一个线程绑定，处理完毕则线程归还给线程池，此模型的优点是启动少数线程便处理较大并发，缺点是需要注意线程编程时的线程安全问题；<br><strong>非阻塞模型：</strong> 一个进程内仅有一个工作线程，通过采用非阻塞通信方式可以支持非常大的客户端并发连接，优点是资源消耗小、支持大并发、性能高，缺点是编程复杂度高；<br><strong>协程模型：</strong> 每个客户端连接与一个协程绑定，每个进程内一个工作线程，每个线程内可以创建大 量的协程，优点是支持大并发、性能高、编程简单、应用场景比较广，缺点是占用内存要比非阻塞模型高；<br><strong>UDP通信模型：</strong> 支持简单的 UDP 通信方式；触发器模型：常用在定时任务的应用场景中。<br>以上的服务模型均可启动多个进程，通过配置文件的配置项来决定启动进程的数量。</p><h4 id="2-acl-master-的作用是什么？支持哪些平台？"><a href="#2-acl-master-的作用是什么？支持哪些平台？" class="headerlink" title="2. acl_master 的作用是什么？支持哪些平台？"></a>2. acl_master 的作用是什么？支持哪些平台？</h4><p>acl_master 为由以上各个服务器编写的服务进程的控制管理程序， acl_master<br>启动、停止各个服务子进程，控制子进程的启动数量及预启动策略，监控子进程的异常情况；acl_master 有点类似于 LINUX 下的 xinetd 服务进程，不同之处是 acl_master 功能更完善强大，支持服务子进程的常驻留、半驻留，而 xinetd 则只针对一个连接创建一个进程，不能用于高并发的服务应用场景。<br>目前 acl_master 进程仅支持 LINUX&#x2F;MACOS&#x2F;FREEBSD&#x2F;SOLARIS(X86）等 UNIX 平台，不支持 WINDOWS 平台。  </p><h4 id="3-没有-acl-master-控制管理，服务子进程是否可以单独运行？"><a href="#3-没有-acl-master-控制管理，服务子进程是否可以单独运行？" class="headerlink" title="3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？"></a>3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？</h4><p>可以。在没有 acl_master 的情况下，由以上各个服务模型编写的服务程序可以通过手工方式启动。启动方式一般为：.&#x2F;xxxx alone xxxx.cf，这样服务程序便以 alone 模式启动运行，具体情况可以参考 main.cpp 里的启动方式；在 WINDOWS 平台下只能是以 alone 模式手工启动运行。</p><h4 id="4-手工模式下运行时遇到”idle-timeout-–-exiting-idle”怎么办？"><a href="#4-手工模式下运行时遇到”idle-timeout-–-exiting-idle”怎么办？" class="headerlink" title="4. 手工模式下运行时遇到”idle timeout – exiting, idle”怎么办？"></a>4. 手工模式下运行时遇到”idle timeout – exiting, idle”怎么办？</h4><p>因为 acl 的服务器编程模型均支持半驻留方式（即运行空闲一段时间或处理连接次数达到设定值后会自动退出，这样的好处是：可以定期通过进程退出释放可能存在的资源泄露，另一方面便于用户在开发时通过 valgrind 进行内存检查），如果让进程不退出，可以在 alone 模式下给服务程序传递启动配置文件，如启动方式为：.&#x2F;xxxx alone xxxx.cf（传递方式可以看 main.cpp 和相关头文件），不同的服务器模型分别采取下面不同的配置项：  </p><p><strong>程池模型：</strong> 将配置项 single_use_limit 和 single_idle_limit 设为 0；<br><strong>线程池模型：</strong> 将配置项 ioctl_use_limit 和 ioctl_idle_limit 设为 0；<br><strong>非阻塞模型：</strong> 将配置项 aio_use_limit 和 aio_idle_limit 设为 0；<br><strong>协程模型：</strong> 将配置项 fiber_use_limit 和 fiber_idle_limit 设为 0；<br><strong>UDP通信模型：</strong> 将配置项 udp_use_limit 和 udp_idle_limit 设为 0；<br><strong>触发器模型：</strong> 将配置项 trigger_use_limit 设为 0。</p><h4 id="5-acl-master-控制模式下，服务子进程如何预启动多个进程？"><a href="#5-acl-master-控制模式下，服务子进程如何预启动多个进程？" class="headerlink" title="5. acl_master 控制模式下，服务子进程如何预启动多个进程？"></a>5. acl_master 控制模式下，服务子进程如何预启动多个进程？</h4><p>需要修改每个服务子进程的配置文件，将配置项：master_maxproc 及 master_prefork 设置成要启动的进程数（设置值需相同），同时需要将 xxx_use_limit 及 xxx_idle_limit 配置项设成 0 以防止子进程空闲退出，xxx_use_limit 及 xxx_idle_limit  的依每种服务器模型而不同，具体可参考上面（4）中的说明。</p><h4 id="6-acl-master-控制模式下，如何只监听内网地址？"><a href="#6-acl-master-控制模式下，如何只监听内网地址？" class="headerlink" title="6. acl_master 控制模式下，如何只监听内网地址？"></a>6. acl_master 控制模式下，如何只监听内网地址？</h4><p>在 acl_master 模式下，可以将 master_service 配置项支持模糊匹配方式，即可以将监听地址写成 <code>192.168.*.*:8192</code> 或 <code>10.0.*.*:8192</code> 方式，这样 acl_master 会自动扫描服务器所有的网卡地址，但只监听服务匹配条件的内网地址，这样为统一部署提供方便。</p><h3 id="（六）、数据库模块"><a href="#（六）、数据库模块" class="headerlink" title="（六）、数据库模块"></a>（六）、数据库模块</h3><h4 id="1-acl-数据库客户端支持哪些数据库？"><a href="#1-acl-数据库客户端支持哪些数据库？" class="headerlink" title="1. acl 数据库客户端支持哪些数据库？"></a>1. acl 数据库客户端支持哪些数据库？</h4><p>当前 acl 数据库客户端库支持的数据库有：mysql，postgresql，sqlite。</p><h4 id="2-acl-数据库模块如何使用？"><a href="#2-acl-数据库模块如何使用？" class="headerlink" title="2. acl 数据库模块如何使用？"></a>2. acl 数据库模块如何使用？</h4><p>acl 数据库模块封装了官方数据库的驱动（包括 mysql，postgresql，sqlite），所以使用者应先下载所对应的官方数据库驱动，考虑到版本的一致性，建议从 <a href="https://github.com/acl-dev/third_party">https://github.com/acl-dev/third_party</a> 处下载；<br>另外，acl 数据库模块是采用动态加载方式加载数据库驱动的，所以使用者应将编译好的数据库动态库放置在合适的位置，并调用 <code>acl::db_handle::set_loadpath()</code> 设置数据库驱动动态库的全路径，以便于 acl 数据库模块内部可以使用该路径进行动态加载。</p><h3 id="（七）、邮件-amp-mime模块"><a href="#（七）、邮件-amp-mime模块" class="headerlink" title="（七）、邮件&amp;mime模块"></a>（七）、邮件&amp;mime模块</h3><p>。。。</p><ul><li>微博：<a href="http://weibo.com/zsxxsz">http://weibo.com/zsxxsz</a></li><li>qq 群：242722074</li></ul>]]></content>
    
    
    <categories>
      
      <category>faq</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Acl 网络协程框架编程指南</title>
    <link href="/2019/04/07/fiber/"/>
    <url>/2019/04/07/fiber/</url>
    
    <content type="html"><![CDATA[<h1 id="Acl-网络协程框架编程指南"><a href="#Acl-网络协程框架编程指南" class="headerlink" title="Acl 网络协程框架编程指南"></a>Acl 网络协程框架编程指南</h1><!-- vim-markdown-toc GFM --><ul><li><a href="#%E6%91%98%E8%A6%81">摘要</a></li><li><a href="#%E4%B8%80%E6%A6%82%E8%BF%B0">一、概述</a></li><li><a href="#%E4%BA%8C%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B">二、简单示例</a></li><li><a href="#%E4%B8%89%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85">三、编译安装</a></li><li><a href="#%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%A0%B8">四、使用多核</a></li><li><a href="#%E4%BA%94%E5%A4%9A%E6%A0%B8%E5%90%8C%E6%AD%A5">五、多核同步</a></li><li><a href="#%E5%85%AD%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92">六、消息传递</a></li><li><a href="#%E4%B8%83HOOKAPI">七、HOOK API</a></li><li><a href="#%E5%85%AB%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90">八、域名解析</a></li><li><a href="#%E4%B9%9D%E5%8D%8F%E7%A8%8B%E5%85%B1%E4%BA%AB%E6%A0%88">九、协程共享栈</a></li><li><a href="#%E5%8D%81%E4%BD%BF%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%BB%9C%E5%BA%93%E5%8D%8F%E7%A8%8B%E5%8C%96">十、使第三方网络库协程化</a></li><li><a href="#%E5%8D%81%E4%B8%80Windows%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8C%96">十一、Windows 界面编程协程化</a></li><li><a href="#%E5%8D%81%E4%BA%8C%E6%89%93%E5%8D%B0%E5%8D%8F%E7%A8%8B%E8%B0%83%E7%94%A8%E6%A0%88">十二、打印协程调用栈</a></li><li><a href="#%E5%8D%81%E4%B8%89%E6%A3%80%E6%B5%8B%E5%8D%8F%E7%A8%8B%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98">十三、检测协程死锁问题</a></li></ul><!-- vim-markdown-toc --><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>本文主要讲述Acl网络协程框架的使用，从协程的应用场景出发，以一个简单的协程示例开始，然后逐步深入到Acl网络协程的各个使用场景及使用细节，以及需要避免的“坑”，希望能给大家带来实践上的帮助。</p><h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>讲到协程，大家必然会提到 Go 语言，毕竟是 Go 语言把协程的概念及使用实践普及的；但协程并不是一个新概念，我印象中在九十年代就出现了，当时一位同事还说微软推出了纤程（基本一个意思），可以创建成午上万个纤程，不必象线程那样只能创建较少的线程数量，但当时也没明白创建这么多纤程有啥用，只不过是一个上下文的快速切换协同而已。所以自己在写网络高并发服务时，主要还是以非阻塞方式来实现。<br>后来，Go 语言的作者之一 Russ Cox 在 2002 年左右用 C 实现了一个简单的基于协程的网络通信模型 – libtask，但其只是一个简单的网络协程原型，还远达不到实践的要求。自从 Go 语言兴起后，很多基于 C&#x2F;C++ 开发的协程库也多了起来，其中 Acl 协程库便是其中之一。</p><ul><li>Acl 工程地址：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a></li><li>Acl 协程地址：<a href="https://github.com/acl-dev/acl/tree/master/lib_fiber">https://github.com/acl-dev/acl/tree/master/lib_fiber</a></li></ul><h2 id="二、简单示例"><a href="#二、简单示例" class="headerlink" title="二、简单示例"></a>二、简单示例</h2><p>下面为一个使用 Acl 库编写的简单线程的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mythread</span> : <span class="hljs-keyword">public</span> acl::thread &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">mythread</span>(<span class="hljs-type">void</span>) &#123;&#125;<br>~<span class="hljs-built_in">mythread</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 实现基类中纯虚方法，当线程启动时该方法将被回调</span><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread-%lu: running ...\r\n&quot;</span>, acl::thread::<span class="hljs-built_in">self</span>());<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>std::vector&lt;acl::thread*&gt; threads;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>acl::thread* thr = <span class="hljs-keyword">new</span> mythread;<br>threads.<span class="hljs-built_in">push_back</span>(thr);<br>thr-&gt;<span class="hljs-built_in">start</span>();  <span class="hljs-comment">// 启动线程</span><br>&#125;<br><br><span class="hljs-keyword">for</span> (std::vector&lt;acl::thread*&gt;::iterator it = threads.<span class="hljs-built_in">begin</span>();<br>it != threads.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>(*it)-&gt;<span class="hljs-built_in">wait</span>();  <span class="hljs-comment">// 等待线程退出</span><br><span class="hljs-keyword">delete</span> *it;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面线程例子非常简单，接着再给一个简单的协程的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfiber</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myfiber</span>(<span class="hljs-type">void</span>) &#123;&#125;<br>~<span class="hljs-built_in">myfiber</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 实现基类纯虚方法，当调用 fiber::start() 时，该方法将被调用</span><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world! the fiber is %d\r\n&quot;</span>, acl::fiber::<span class="hljs-built_in">self</span>());<br>acl::fiber::<span class="hljs-built_in">yield</span>();  <span class="hljs-comment">// 让出CPU运行权给其它协程</span><br>&#125;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>std::vector&lt;acl::fiber*&gt; fibers;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>acl::fiber* fb = <span class="hljs-keyword">new</span> myfiber;<br>fibers.<span class="hljs-built_in">push_back</span>(fb);<br>fb-&gt;<span class="hljs-built_in">start</span>();  <span class="hljs-comment">// 启动一个协程</span><br>&#125;<br><br>acl::fiber::<span class="hljs-built_in">schedule</span>();  <span class="hljs-comment">// 启用协程调度器</span><br><br><span class="hljs-keyword">for</span> (std::vector&lt;acl::fiber*&gt;::iterator it = fibers.<span class="hljs-built_in">begin</span>();<br>it != fibers.<span class="hljs-built_in">end</span>(); ++it) &#123;<br><span class="hljs-keyword">delete</span> *it;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面示例演示了协程的创建、启动及运行的过程，与前一个线程的例子非常相似，也很简单（<strong>简单实用</strong>是 Acl 库的设计目标之一）。</p><p><strong>协程调度其实是应用层面多个协程之间通过上下文切换形成的协作过程，如果一个协程库仅是实现了上下文切换，其实并不具备太多实用价值，当与网络事件绑定后，其价值才会显现出来</strong>。下面一个简单的使用协程的网络服务程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-comment">// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_echo</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_echo</span>(acl::socket_stream* conn) : <span class="hljs-built_in">conn_</span>(conn) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::socket_stream* conn_;<br>~<span class="hljs-built_in">fiber_echo</span>(<span class="hljs-type">void</span>) &#123; <span class="hljs-keyword">delete</span> conn_; &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">// 从客户端读取数据（第三个参数为false表示不必填满整个缓冲区才返回）</span><br><span class="hljs-type">int</span> ret = conn_-&gt;<span class="hljs-built_in">read</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 向客户端写入读到的数据</span><br><span class="hljs-keyword">if</span> (conn_-&gt;<span class="hljs-built_in">write</span>(buf, ret) != ret) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 自销毁动态创建的协程对象</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_listen</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_listen</span>(acl::server_socket&amp; listener) : <span class="hljs-built_in">listener_</span>(listener) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::server_socket&amp; listener_;<br>~<span class="hljs-built_in">fiber_listen</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>acl::socket_stream* conn = listener_.<span class="hljs-built_in">accept</span>();  <span class="hljs-comment">// 等待客户端连接</span><br><span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept failed: %s\r\n&quot;</span>, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 创建并启动单独的协程处理客户端连接</span><br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_echo</span>(conn);<br><span class="hljs-comment">// 启动独立的客户端处理协程</span><br>fb-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr = <span class="hljs-string">&quot;127.0.0.1:8800&quot;</span>;<br>acl::server_socket listener;<br><span class="hljs-comment">// 监听本地地址</span><br><span class="hljs-keyword">if</span> (listener.<span class="hljs-built_in">open</span>(addr) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listen %s error %s\r\n&quot;</span>, addr, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">// 创建并启动独立的监听协程，接受客户端连接</span><br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_listen</span>(listener);<br>fb-&gt;<span class="hljs-built_in">start</span>();<br><br><span class="hljs-comment">// 启动协程调度器</span><br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个支持回显功能的网络协程服务器（也可以修改成线程模式）。使用协程或线程处理网络通信都可以采用<strong>顺序思维</strong>模式，不必象非阻塞网络编程那样复杂，同时使用协程的最大好处是可以创建大量的协程来处理网络高并发连接，而要创建大量的线程是不现实的（线程数非常多时，会导致操作系统的调度能力下降）。</p><p>在上面的示例中，启动协程调度（即调用 <code>acl::fiber::schedule()</code>）时，内部事件引擎为默认的内核级事件引擎，该方法有一个缺省的事件类型参数可以由用户修改，可选的事件引擎如下：</p><ul><li><strong>acl::FIBER_EVENT_T_KERNEL：</strong> 内核级高效事件引擎，在 Linux 上使用 epoll，FreeBSD&#x2F;MacOS 上使用 kqueue，Windows 平台上则会使用 IOCP；</li><li><strong>acl::FIBER_EVENT_T_SELECT, acl::FIBER_EVENT_T_POLL：</strong> 这两个引擎是跨平台的，基本上所有平台都支持；</li><li><strong>acl::FIBER_EVENT_T_WMSG：</strong> 当在 Windows 平台开发界面程序时可以使用该引擎，以使网络过程协程化且与界面操作过程同属一个线程空间中，从而可以轻松在网络 IO 过程中操作界面元素；</li><li><strong>acl::FIBER_EVENT_T_IO_URING：</strong> 这是在 Linux 5.1x 内核以上新增加的高效事件引擎 io_uring，与 epoll 仅能支持网络（及管道）IO相比，io_uring 引擎同时支持网络 IO 及文件 IO，实现了真正意义上的 IO 大统一，而且 io_uring 引擎为 IO 完成模型，非常容易与协程模式相结合。</li></ul><h2 id="三、编译安装"><a href="#三、编译安装" class="headerlink" title="三、编译安装"></a>三、编译安装</h2><p>在编译前，需要先从 <strong>github</strong>  <a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a>  下载源码，国内用户可以选择从 <strong>gitee</strong>  <a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a>  下载源码。</p><h3 id="3-1、Linux-x2F-Unix-平台上编译安装"><a href="#3-1、Linux-x2F-Unix-平台上编译安装" class="headerlink" title="3.1、Linux&#x2F;Unix 平台上编译安装"></a>3.1、Linux&#x2F;Unix 平台上编译安装</h3><p>在 Linux&#x2F;Unix 平台上的编译非常简单，可以选择使用 make 方式或 cmake 方式进行编译。  </p><ul><li><strong>make 方式编译：</strong><br>在 acl 项目根目录下运行：<strong>make &amp;&amp; make packinstall</strong>，则会自动执行编译与安装过程，安装目录默认为系统目录：libacl_all.a, libfiber_cpp.a, libfiber.a 将被拷贝至 &#x2F;usr&#x2F;lib&#x2F; 目录，头文件将被拷贝至 &#x2F;usr&#x2F;include&#x2F;acl-lib&#x2F; 目录。</li><li><strong>cmake 方式编译：</strong><br>在 acl 项目根目录下创建 build 目录，然后：<strong>cd build &amp;&amp; cmake .. &amp;&amp; make</strong></li><li><strong>将 acl 库加入至你的工程</strong>（以 make 方式为例）<br>先在代码中加入头文件包含项：<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br></code></pre></td></tr></table></figure>然后修改你的 Makefile 文件，示例如下：<figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs Makefile"><span class="hljs-section">mytest: mytest.cpp</span><br>g++ -o mytest mytest.cpp -lfiber_cpp -lacl_all -lfiber -ldl -lpthread -lz<br></code></pre></td></tr></table></figure><strong>注意在 Makefile 中各个库的依赖顺序：</strong> libfiber_cpp.a 依赖于 libacl_all.a 和 libfiber.a，其中 libacl_all.a 为 acl 的基础库，libfiber.a 为独立的 C 语言协程库（其不依赖于 libacl_all.a），libfiber_cpp.a 用 C++ 语言封装了 libfiber.a，且使用了 libacl_all.a 中的一些功能；同时，因为 libfiber.a 协程库 Hook 了系统的网络及IO API，所以 libfiber.a 需放在 libacl_all.a 后面，以便 libacl_all.a 中的 IO 调用过程被 libfiber.a 中的 API Hook 住；因此，在执行程序连接时需要明确告诉 gcc&#x2F;g++ 连接顺序为：<br>libfiber_cpp.a, libacl_all.a, libfiber.a。</li></ul><h3 id="3-2、Windows-平台上编译"><a href="#3-2、Windows-平台上编译" class="headerlink" title="3.2、Windows 平台上编译"></a>3.2、Windows 平台上编译</h3><p>在 Windows 平台的编译也非常简单，可以用 vc2012&#x2F;2013&#x2F;2019 打开相应的工程文件进行编译，如：可以用 vc2019 打开 acl_cpp_vc2019.sln 工程进行编译。</p><p><strong>注意：</strong> 在 Windows 平台上建议使用 vc2019 及以上版本打开 Acl 库，因为 Acl fiber 在 Windows 平台用来 Hook 系统 API 的第三方库（detours）目前不支持 vc2012&#x2F;2013。</p><h3 id="3-3-Mac-平台上编译"><a href="#3-3-Mac-平台上编译" class="headerlink" title="3.3 Mac 平台上编译"></a>3.3 Mac 平台上编译</h3><p>除可以使用 Unix 统一方式（命令行方式）编译外，还可以用 Xcode 打开工程文件进行编译。</p><h3 id="3-4-Android-平台上编译"><a href="#3-4-Android-平台上编译" class="headerlink" title="3.4 Android 平台上编译"></a>3.4 Android 平台上编译</h3><p>目前可以使用 Android Studio3.x 打开 acl\android\acl 目录下的工程文件进行编译。</p><h3 id="3-5-使用-MinGW-编译"><a href="#3-5-使用-MinGW-编译" class="headerlink" title="3.5 使用 MinGW 编译"></a>3.5 使用 MinGW 编译</h3><p>如果想要在 Windows 平台上编译 Unix 平台上的软件，可以借用 MinGW 套件进行编译，为此 Acl 库还提供了此种编译方式，但一般不建议用户使用这种编译方式，一方面是执行效率低，另一方面可能会存在不兼容性问题。</p><h3 id="3-6-小结"><a href="#3-6-小结" class="headerlink" title="3.6 小结"></a>3.6 小结</h3><p>为了保证 Acl 工程无障碍使用，本人在编译 Acl 库方面下了很大功夫，支持几乎在所有平台上使用原生编译环境进行编译使用，真正达到了一键编译。甚至为了避免因依赖第三方库而导致的编译问题（如：有的模块需要 zlib 库，有的需要 polassl 库，有的需要 mysql&#x2F;postgresql&#x2F;sqlite 库），将这些依赖第三方库的模块都写成动态加载第三方库的方式，毕竟不是所有人都需要这些第三方库所提供的功能。</p><h2 id="四、使用多核"><a href="#四、使用多核" class="headerlink" title="四、使用多核"></a>四、使用多核</h2><p>Acl 协程的调度过程是基于单CPU的（虽然也可以修改成多核调度，但考虑到很多原因，最终还是采用了单核调度模式），即创建一个线程，所创建的所有协程都在这个线程空间中运行。为了使用多核，充分使用CPU资源，可以创建多个线程（也可以创建多个进程），每个线程为一个独立的协程运行容器，各个线程之间的协程相互隔离，互不影响。<br>下面先修改一下上面的例子，改成多线程的协程方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-comment">// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_echo</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_echo</span>(acl::socket_stream* conn) : <span class="hljs-built_in">conn_</span>(conn) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::socket_stream* conn_;<br>~<span class="hljs-built_in">fiber_echo</span>(<span class="hljs-type">void</span>) &#123; <span class="hljs-keyword">delete</span> conn_; &#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-type">int</span> ret = conn_-&gt;<span class="hljs-built_in">read</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (conn_-&gt;<span class="hljs-built_in">write</span>(buf, ret) != ret) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 自销毁动态创建的协程对象</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_listen</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_listen</span>(acl::server_socket&amp; listener) : <span class="hljs-built_in">listener_</span>(listener) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::server_socket&amp; listener_;<br>~<span class="hljs-built_in">fiber_listen</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>acl::socket_stream* conn = listener_.<span class="hljs-built_in">accept</span>();  <span class="hljs-comment">// 等待客户端连接</span><br><span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept failed: %s\r\n&quot;</span>, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 创建并启动单独的协程处理客户端连接</span><br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_echo</span>(conn);<br>fb-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 独立的线程调度类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_server</span> : <span class="hljs-keyword">public</span> acl::thread &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">thread_server</span>(acl::server_socket&amp; listener) : <span class="hljs-built_in">listener_</span>(listener) &#123;&#125;<br>~<span class="hljs-built_in">thread_server</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::server_socket&amp; listener_;<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-comment">// 创建并启动独立的监听协程，接受客户端连接</span><br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_listen</span>(listener);<br>fb-&gt;<span class="hljs-built_in">start</span>();<br><span class="hljs-comment">// 启动协程调度器</span><br>acl::fiber::<span class="hljs-built_in">schedule</span>(); <span class="hljs-comment">// 内部处于死循环过程</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr = <span class="hljs-string">&quot;127.0.0.1:8800&quot;</span>;<br>acl::server_socket listener;<br><span class="hljs-comment">// 监听本地地址</span><br><span class="hljs-keyword">if</span> (listener.<span class="hljs-built_in">open</span>(addr) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listen %s error %s\r\n&quot;</span>, addr, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br>std::vector&lt;acl::thread*&gt; threads;<br><span class="hljs-comment">// 创建多个独立的线程对象，每个线程启用独立的协程调度过程</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>acl::thread* thr = <span class="hljs-built_in">thread_server</span>(listener);<br>threads.<span class="hljs-built_in">push_back</span>(thr);<br>thr-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><span class="hljs-keyword">for</span> (std::vector&lt;acl::thread*&gt;::iterator it = threads.<span class="hljs-built_in">begin</span>();<br>it != threads.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>(*it)-&gt;<span class="hljs-built_in">wait</span>();<br><span class="hljs-keyword">delete</span> *it;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经过修改，上面的例子不仅可以支持大并发，而且还可以使用多核。</p><h2 id="五、多核同步"><a href="#五、多核同步" class="headerlink" title="五、多核同步"></a>五、多核同步</h2><p>上面的例子中涉及到了通过创建多线程使用多核的过程，但肯定会有人问，在多个线程中的协程之间如果想要共享某个资源怎么办？Acl 协程库提供了可以跨线程使用同步原语：线程协程互斥锁及条件变量。<br>首先介绍一下协程互斥锁类：acl::fiber_mutex，该类提供了三个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待互斥锁</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示加锁成功，否则表示内部出错</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">lock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 尝试等待互斥锁</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示加锁成功，否则表示锁正在被占用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">trylock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 互斥锁拥有者释放锁并通知等待者</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示通知成功，否则表示内部出错</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">unlock</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>下面给出一个例子，看看在多个线程中的协程之间如何进行互斥的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfiber</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myfiber</span>(acl::fiber_mutex&amp; lock, <span class="hljs-type">int</span>&amp; count)<br>: <span class="hljs-built_in">lock_</span>(lock)<br>, <span class="hljs-built_in">count_</span>(count)<br>&#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">myfiber</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>lock_.<span class="hljs-built_in">lock</span>();<br>count_++;<br>acl::fiber::<span class="hljs-built_in">delay</span>(<span class="hljs-number">1</span>);  <span class="hljs-comment">// 本协程休息1毫秒</span><br>lock_.<span class="hljs-built_in">unlock</span>();<br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>acl::fiber_mutex&amp; lock_;<br><span class="hljs-type">int</span>&amp; count_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mythread</span> : <span class="hljs-keyword">public</span> acl::thread &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">mythread</span>(acl::fiber_mutex&amp; lock, <span class="hljs-type">int</span>&amp; count)<br>: <span class="hljs-built_in">lock_</span>(lock)<br>, <span class="hljs-built_in">count_</span>(count)<br>&#123;&#125;<br><br>~<span class="hljs-built_in">mythread</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">myfiber</span>(lock_, count_);<br>fb-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>acl::fiber_mutex&amp; lock_;<br><span class="hljs-type">int</span>&amp; count_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>acl::fiber_mutex lock;  <span class="hljs-comment">// 可以用在多个线程之间、各个线程中的协程之间的同步过程</span><br><span class="hljs-type">int</span> count = <span class="hljs-number">0</span>;<br><br>std::vector&lt;acl::thread*&gt; threads;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>acl::thread* thr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">mythread</span>(lock, count);<br>threads.<span class="hljs-built_in">push_back</span>(thr);<br>thr-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-keyword">for</span> (std::vector&lt;acl::thread*&gt;::iterator it = threads.<span class="hljs-built_in">begin</span>();<br>it != threads.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>(*it)-&gt;<span class="hljs-built_in">wait</span>();<br><span class="hljs-keyword">delete</span> *it;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;all over, count=%d\r\n&quot;</span>, count);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>acl::fiber_mutex</strong> 常被用在不同线程中的协程之间的同步，也可以用在多个线程之间甚至协程与独立线程之间的同步，这在很大程度弥补了 Acl 协程框架在使用多核上的不足。</p><h2 id="六、消息传递"><a href="#六、消息传递" class="headerlink" title="六、消息传递"></a>六、消息传递</h2><p>通过组合 <strong>acl::fiber_mutex</strong>（协程互斥锁）和 <strong>acl::fiber_cond</strong>（协程条件变量），实现了协程间进行消息传递的功能模块：<strong>acl::fiber_tbox</strong>，<strong>fiber_tbox</strong> 不仅可以用在同一线程内的协程之间传递消息，还可以用在不同线程中的协程之间，不同线程之间，线程与协程之间传递消息。<strong>fiber_tbox</strong> 为模板类，因而可以传递各种类型对象。以下给出一个示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myobj</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myobj</span>(<span class="hljs-type">void</span>) : <span class="hljs-built_in">i_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>~<span class="hljs-built_in">myobj</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>i_ = i;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world, i=%d\r\n&quot;</span>, i_);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> i_;<br>&#125;;<br><br><span class="hljs-comment">// 消费者协程，从消息管道中读取消息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_consumer</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_consumer</span>(acl::fiber_tbox&lt;myobj&gt;&amp; box) : <span class="hljs-built_in">box_</span>(box) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">fiber_consumer</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::fiber_tbox&lt;myobj&gt;&amp; box_;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>myobj* o = box_.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 如果读到空消息，则结束</span><br><span class="hljs-keyword">if</span> (o == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>o-&gt;<span class="hljs-built_in">test</span>();<br><span class="hljs-keyword">delete</span> o;<br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 生产者协程，向消息管道中放置消息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_producer</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_producer</span>(acl::fiber_tbox&lt;myobj&gt;&amp; box) : <span class="hljs-built_in">box_</span>(box) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">fiber_producer</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::fiber_tbox&lt;myobj&gt;&amp; box_;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>myobj* o = <span class="hljs-keyword">new</span> myobj;<br>o-&gt;<span class="hljs-built_in">set</span>(i);<br><span class="hljs-comment">// 向消息管道中放置消息</span><br>box_.<span class="hljs-built_in">push</span>(o);<br>&#125;<br><span class="hljs-comment">// 放置空消息至消息管道中，从而通知消费者协程结束</span><br>box_.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>acl::fiber_tbox&lt;myobj&gt; box;<br><span class="hljs-comment">// 创建并启动消费者协程</span><br>acl::fiber* consumer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_consumer</span>(box);<br>consumer-&gt;<span class="hljs-built_in">start</span>();<br><span class="hljs-comment">// 创建并启动生产者协程</span><br>acl::fiber* producer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_producer</span>(box);<br>producer-&gt;<span class="hljs-built_in">start</span>();<br><span class="hljs-comment">// 启动协程调度器</span><br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子展示了同一线程中的两个协程之间的消息传递过程，因为 acl::fiber_tbox 是可以跨线程的，所以它的更大价值是用在多个线程中的不同协程之间进行消息传递。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myobj</span> &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myobj</span>(<span class="hljs-type">void</span>) : <span class="hljs-built_in">i_</span>(<span class="hljs-number">0</span>) &#123;&#125;<br>~<span class="hljs-built_in">myobj</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> </span>&#123;<br>i_ = i;<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world, i=%d\r\n&quot;</span>, i_);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> i_;<br>&#125;;<br><br><span class="hljs-comment">// 消费者协程，从消息管道中读取消息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_consumer</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_consumer</span>(acl::fiber_tbox&lt;myobj&gt;&amp; box) : <span class="hljs-built_in">box_</span>(box) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">fiber_consumer</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::fiber_tbox&lt;myobj&gt;&amp; box_;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>myobj* o = box_.<span class="hljs-built_in">pop</span>();<br><span class="hljs-comment">// 如果读到空消息，则结束</span><br><span class="hljs-keyword">if</span> (o == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>o-&gt;<span class="hljs-built_in">test</span>();<br><span class="hljs-keyword">delete</span> o;<br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 生产者线程，向消息管道中放置消息</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_producer</span> : <span class="hljs-keyword">public</span> acl::thread &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">thread_producer</span>(acl::fiber_tbox&lt;myobj&gt;&amp; box) : <span class="hljs-built_in">box_</span>(box) &#123;&#125;<br>~<span class="hljs-built_in">thread_producer</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::fiber_tbox&lt;myobj&gt;&amp; box_;<br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) &#123;<br>myobj* o = <span class="hljs-keyword">new</span> myobj;<br>o-&gt;<span class="hljs-built_in">set</span>(i);<br>box_.<span class="hljs-built_in">push</span>(o);<br>&#125;<br>box_.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>acl::fiber_tbox&lt;myobj&gt; box;<br><span class="hljs-comment">// 创建并启动消费者协程</span><br>acl::fiber* consumer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_consumer</span>(box);<br>consumer-&gt;<span class="hljs-built_in">start</span>();<br><span class="hljs-comment">// 创建并启动生产者线程</span><br>acl::thread* producer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">thread_producer</span>(box);<br>producer-&gt;<span class="hljs-built_in">start</span>();<br><span class="hljs-comment">// 启动协程调度器</span><br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><span class="hljs-comment">// schedule() 过程返回后，表示该协程调度器结束。</span><br><span class="hljs-comment">// 等待生产者线程退出</span><br>producer-&gt;<span class="hljs-built_in">wait</span>();<br><span class="hljs-keyword">delete</span> producer;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure><p>在该示例中，生产者为一个独立的线程，消费者为另一个线程中的协程，二者通过 acl::fiber_tbox 进行消息通信。</p><p>下面再给一个应用场景的例子，也是我们平时经常会遇到的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mythread</span> : <span class="hljs-keyword">public</span> acl::thread &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">mythread</span>(acl::fiber_tbox&lt;<span class="hljs-type">int</span>&gt;&amp; box) :<span class="hljs-built_in">box_</span>(box) &#123;&#125;<br>~<span class="hljs-built_in">mythread</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::fiber_tbox&lt;<span class="hljs-type">int</span>&gt;&amp; box_;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">int</span> i;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br><span class="hljs-comment">/* 假设这是一个比较耗时的操作*/</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;sleep one second\r\n&quot;</span>);<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-type">int</span>* n = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(i);<br><span class="hljs-comment">// 将计算结果通过消息管道传递给等待者协程</span><br>box_.<span class="hljs-built_in">push</span>(n);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfiber</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myfiber</span>(<span class="hljs-type">void</span>) &#123;&#125;<br>~<span class="hljs-built_in">myfiber</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>acl::fiber_tbox&lt;<span class="hljs-type">int</span>&gt; box;<br><span class="hljs-function">mythread <span class="hljs-title">thread</span><span class="hljs-params">(box)</span></span>;<br>thread.<span class="hljs-built_in">set_detachable</span>(<span class="hljs-literal">true</span>);<br>thread.<span class="hljs-built_in">start</span>();  <span class="hljs-comment">// 启动独立的线程计算耗时运算</span><br><span class="hljs-type">int</span>* n = box.<span class="hljs-built_in">pop</span>();  <span class="hljs-comment">// 等待计算线程返回运算结果，仅会阻塞当前协程</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;n is %d\r\n&quot;</span>, *n);<br><span class="hljs-keyword">delete</span> n;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>myfiber fb;<br>fb.<span class="hljs-built_in">start</span>();<br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>协程一般用在网络高并发环境中，但协程并不是万金油，协程并不适合计算密集型应用，因为线程才是操作系统的最小调度单元，而协程不是，所以当遇到一些比较耗时的运算时，为了不阻塞当前协程所在的协程调度器，应将该耗时运算过程中抛给独立的线程去处理，然后通过 <strong>acl::fiber_tbox</strong> 等待线程的运算结果。</p><h2 id="七、HOOK-API"><a href="#七、HOOK-API" class="headerlink" title="七、HOOK API"></a>七、HOOK API</h2><p>为了使现有的很多网络应用和网络库在尽量不修改的情况下协程化，Acl 协程库 Hook 了很多与 IO 和网络通信相关的系统 API，目前已经 Hook 的系统 API 有：</p><table><thead><tr><th>内容项</th><th>API</th></tr></thead><tbody><tr><td>网络相关</td><td>socket&#x2F;listen&#x2F;accept&#x2F;connect</td></tr><tr><td>IO相关</td><td>read&#x2F;readv&#x2F;recv&#x2F;recvfrom&#x2F;recvmsg&#x2F;write&#x2F;writev&#x2F;send&#x2F;sendto&#x2F;sendmsg&#x2F;sendfile64</td></tr><tr><td>域名相关</td><td>gethostbyname(_r)&#x2F;getaddrinfo&#x2F;freeaddrinfo</td></tr><tr><td>事件相关</td><td>select&#x2F;poll&#x2F;epoll_create&#x2F; epoll_ctl&#x2F;epoll_wait</td></tr><tr><td>其它</td><td>close&#x2F;sleep</td></tr></tbody></table><h2 id="八、域名解析"><a href="#八、域名解析" class="headerlink" title="八、域名解析"></a>八、域名解析</h2><p>使用协程方式编写网络通信程序，域名解析是不能绕过的，记得有一个协程库说为了支持域名解析，甚至看了相关实现代码，然后说通过 Hook _poll API 就可以了，实际上这并不是通用的做法，至少在我的环境里通过 Hook _poll API 是没用的，所以最稳妥的做法还是应该将 DNS 查询协议实现了，在 acl 的协程库中，域名解析模块在初期集成了第三方 DNS 库，参见：<a href="https://github.com/wahern/dns">https://github.com/wahern/dns</a>  ，但因为该第 DNS 库存在很多问题（如：不能跨平台，代码混乱，没处理IO异常等问题），所以最终 acl 协程丢弃该库，自己实现了一套更加方便灵活跨平台的 DNS 协议库。 </p><p>下面给出协程下进行域名解析的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;netdb.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;arpa/inet.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ns_lookup</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">ns_lookup</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name) : <span class="hljs-built_in">name_</span>(name) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    ~<span class="hljs-built_in">ns_lookup</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>    std::string name_;<br><br>    <span class="hljs-comment">// @override</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>        <span class="hljs-keyword">struct</span> <span class="hljs-title class_">hostent</span> *ent = <span class="hljs-built_in">gethostbyname</span>(name_.<span class="hljs-built_in">c_str</span>());<br>        <span class="hljs-keyword">if</span> (ent == <span class="hljs-literal">NULL</span>) &#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;gethostbyname error=%s, name=%s\r\n&quot;</span>,<br>                <span class="hljs-built_in">hstrerror</span>(h_errno), name_.<span class="hljs-built_in">c_str</span>());<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;h_name=%s, h_length=%d, h_addrtype=%d\r\n&quot;</span>,<br>            ent-&gt;h_name, ent-&gt;h_length, ent-&gt;h_addrtype);<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; ent-&gt;h_addr_list[i]; i++) &#123;<br>            <span class="hljs-type">char</span> *addr = ent-&gt;h_addr_list[i];<br>            <span class="hljs-type">char</span>  ip[<span class="hljs-number">64</span>];<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr;<br><br>            ptr = <span class="hljs-built_in">inet_ntop</span>(ent-&gt;h_addrtype, addr, ip, <span class="hljs-built_in">sizeof</span>(ip));<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;&gt;addr: %s\r\n&quot;</span>, ptr);<br>        &#125;<br><br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *name1 = <span class="hljs-string">&quot;www.google.com&quot;</span>, *name2 = <span class="hljs-string">&quot;www.baidu.com&quot;</span>,<br>               *name3 = <span class="hljs-string">&quot;zsx.xsz.zzz&quot;</span>;<br><br>    acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ns_lookup</span>(name1);<br>    fb-&gt;<span class="hljs-built_in">start</span>();<br><br>    fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ns_lookup</span>(name2);<br>    fb-&gt;<span class="hljs-built_in">start</span>();<br><br>    fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">ns_lookup</span>(name3);<br>    fb-&gt;<span class="hljs-built_in">start</span>();<br><br>    acl::fiber::<span class="hljs-built_in">schedule</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子中，在协程 <code>ns_lookup</code> 中调用 <code>gethostbyname</code> API 进行域名查询与我们平时进行域名解析没有什么不同，在 Acl 协程中 Hook 了 <code>gethostbyname(_r)</code> 等域名解析相关 API 并进行了协程化处理，对于用户而言是无感知的。编译运行上面例子，便可得到如下结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs text">gethostbyname error=No address associated with name, name=zsx.xsz.zzz<br>h_name=www.a.shifen.com, h_length=4, h_addrtype=2<br>&gt;&gt;&gt;addr: 110.242.68.4<br>&gt;&gt;&gt;addr: 110.242.68.3<br>h_name=www.google.com, h_length=4, h_addrtype=2<br>&gt;&gt;&gt;addr: 199.59.149.210<br></code></pre></td></tr></table></figure><h2 id="九、协程共享栈"><a href="#九、协程共享栈" class="headerlink" title="九、协程共享栈"></a>九、协程共享栈</h2><p>Acl 协程是有协程栈的，在网络高并发时具有很高的网络处理能力，但有栈协程在非常大量的并发时势必占用较多的内存，为此在 Acl 协程中增加了对于<strong>共享运行栈</strong>的支持（据说该方式在微信后端服务使用后可以大幅节省内存占用）。</p><p>以下给出了使用协程共享栈的使用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfiber</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myfiber</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">myfiber</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-comment">// ...</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100000</span>; i++) &#123;<br>acl::fiber* fb = <span class="hljs-keyword">new</span> myfiber;<br>fb-&gt;<span class="hljs-built_in">start</span>(<span class="hljs-number">8000</span>, <span class="hljs-literal">true</span>);  <span class="hljs-comment">// 第二个参数为 true 时表示该协程使用共享栈模式</span><br>&#125;<br><br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面示例可以看出，我们只需在调用协程启动方法 <code>start()</code> 时将第二个参数设为 <code>true</code> 便可以使该协程以 <code>协程共享运行栈</code> 模式运行；在 Acl 协程调度器中<code>协程独立运行栈</code>模式和<code>共享运行栈</code>模式是可以共存的（即：可以同时存在）。</p><p>在实践中这的确可以大幅减少高并发时的内存使用，虽然进行栈拷贝时会耗费一些时间，但整体影响并不太大。</p><p>相对于栈拷贝时的时间损耗，在使用共享栈方式编程时有一点需要<strong>特别注意：</strong> 创建在栈上的变量不能在协程之间或协程与线程之间共享，即是说，一个协程 F1 中的变量 A 传递给另一个协程 F2，并等待 F2 处理后返回，此时的 A 变量不能被创建在 F1 的栈上，因为运行栈在由 F1 切换到 F2 时，变量 A 的地址空间“暂时消失了”，此时变成了 F2 的栈空间，如果该变量在 F2 中继续被使用的话，就会存在地址非法使用的问题；解决变量在协程间共享的方法是将变量创建在堆上（即用 malloc 或 new 创建）。</p><p><strong>注意：</strong> 当前 Acl 协程<code>共享运行栈</code>模式仅支持 Unix 平台，即还不支持 Windows 平台。</p><p>下面给出一个例子，如果在<strong>非共享运行栈</strong>模式运行是没有问题的，但如果以<strong>共享栈</strong>方式运行则就会出现问题：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_runner</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_runner</span>(acl::fiber_tbox&lt;<span class="hljs-type">int</span>&gt;* box) : <span class="hljs-built_in">box_</span>(box) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">fiber_runner</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-function">acl::fiber_tbox&lt;<span class="hljs-type">int</span>&gt;* <span class="hljs-title">box_</span><span class="hljs-params">(box)</span></span>;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">int</span>* n = <span class="hljs-keyword">new</span> <span class="hljs-type">int</span>;<br>*n = <span class="hljs-number">1000</span>;<br>box_.<span class="hljs-built_in">push</span>(n);<br><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_waiter</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_waiter</span>(<span class="hljs-type">bool</span> share_stack) : <span class="hljs-built_in">share_stack_</span>(share_stack) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">fiber_waiter</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">bool</span> share_stack_;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>acl::fiber_tbox&lt;<span class="hljs-type">int</span>&gt; box;  <span class="hljs-comment">// box 创建在栈上，且在两个协程之间共享</span><br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_runner</span>(&amp;box);<br>fb-&gt;<span class="hljs-built_in">start</span>(<span class="hljs-number">64000</span>, share_stack_);<br><span class="hljs-type">int</span> * n = box.<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">delete</span> n;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">bool</span> share_stack = <span class="hljs-literal">false</span>;<br><br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_waiter</span>(share_stack);<br>fb-&gt;<span class="hljs-built_in">start</span>(<span class="hljs-number">64000</span>, share_stack);<br><br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，<code>box</code> 对象在两个协程之间共享使用，因为两个协程以<code>协程独立栈</code>方式运行（上面的 share_stack &#x3D; false），所以不会有问题，但如果将控制参数 <code>share_stack = true</code> 则两个协程都运行在 <code>共享栈</code> 上，此时就会产生问题：在协程 <code>fiber_waiter</code> 中创建协程 <code>fiber_runner</code> 并将创建在运行栈上的变量 <code>box</code> 传递给 <code>fiber_runner</code> 对象后，调用 <code>box.pop()</code>，此时协程 <code>fiber_waiter</code> 就会被挂起（其运行栈从共享栈中拷贝并保存起来）并让出 <code>协程共享运行栈</code> 给协程 <code>fiber_runner</code>，在协程 <code>fiber_runner</code> 内部操作由协程 <code>fiber_waiter</code> 传递来的变量 <code>box</code> 时，创建在<code>共享运行栈</code>上的对象 <code>box</code> 的地址空间可能已经被协程 <code>fiber_runner</code> 的栈数据覆盖了，所以传递到 <code>fiber_runner</code> 中的对象 box 的地址上的数据发生了改变（不再是 box 对象了），这时如果再操作 box 对象便是非法了。</p><p>要想解决在 <code>协程共享运行栈</code> 模式下地址空间覆盖时带来的问题，就需要在协程之间共享的对象创建在堆上，针对上面的例子，可修改成如下方式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_waiter</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-comment">//...</span><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-comment">// 在两个协程之间共享的对象需要创建在堆上</span><br>acl::fiber_tbox&lt;<span class="hljs-type">int</span>&gt;* box = <span class="hljs-keyword">new</span> acl::fiber_tbox&lt;<span class="hljs-type">int</span>&gt;;<br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_runner</span>(box);<br>fb-&gt;<span class="hljs-built_in">start</span>(<span class="hljs-number">64000</span>, share_stack_);<br><span class="hljs-type">int</span> *n = box-&gt;<span class="hljs-built_in">pop</span>();<br><span class="hljs-keyword">delete</span> n;<br><span class="hljs-keyword">delete</span> box;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>针对上面的例子，如果协程<code>fiber_waiter</code>以独立栈方式运行，而协程<code>fiber_runner</code>以共享栈方式运行时，box 对象能否创建栈上呢？答案是肯定的，因为当协程<code>fiber_waiter</code>被挂起时，其栈空间依然保留不会被其它协程占用，所以在其栈创建的对象的地址上的数据不会被覆盖。</p><h2 id="十、使第三方网络库协程化"><a href="#十、使第三方网络库协程化" class="headerlink" title="十、使第三方网络库协程化"></a>十、使第三方网络库协程化</h2><p>通常网络通信库都是阻塞式的，因为非阻塞式的通信库的通用性不高（使用各自封装的事件引擎，很难达到应用层的使用一致性），如果把这些第三方通信库（如：mysql 客户端库，Acl 中的 Redis 库等）使用协程所提供的 IO 及网络  API 重写一遍则工作量太大，不太现实，所以在 Acl 协程库中通过 Hook 系统 API，使阻塞式网络通信库协程化变得简单。所谓网络库协程化就是使这些网络库可以应用在协程环境中，从而可以很容易编写出支持高并发的网络程序。</p><p>先写一个将 Acl Redis 客户端库协程化的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_redis</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_redis</span>(acl::redis_client_cluster&amp; cluster) : <span class="hljs-built_in">cluster_</span>(cluster) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">fiber_redis</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::redis_client_cluster&amp; cluster_;<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* key = <span class="hljs-string">&quot;hash-key&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br><span class="hljs-function">acl::redis <span class="hljs-title">cmd</span><span class="hljs-params">(&amp;cluster_)</span></span>;<br>acl::string name, val;<br>name.format(<span class="hljs-string">&quot;hash-name-%d&quot;</span>, i);<br>val.format(<span class="hljs-string">&quot;hash-val-%d&quot;</span>, i);<br><span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">hset</span>(key, name, val) == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hset error: %s, key=%s, name=%s\r\n&quot;</span>,<br>cmd.<span class="hljs-built_in">result_error</span>(), key, name.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* redis_addr = <span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>;<br>acl::redis_client_cluster cluster;<br>cluster.<span class="hljs-built_in">set</span>(redis_addr, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_redis</span>(cluster);<br>fb-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>读者可以尝试将上面的代码拷贝到自己机器上，编译后运行一下。另外，这个例子是只有一个线程，所以会发现 acl::redis_client_cluster 的使用方式和在线程下是一样的。如果将 acl::redis_client_cluster 在多个线程调度器上共享会怎样？还是有一点区别，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-comment">// 每个协程共享相同的 cluster 对象，向 redis-server 中添加数据</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_redis</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber_redis</span>(acl::redis_client_cluster&amp; cluster) : <span class="hljs-built_in">cluster_</span>(cluster) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">fiber_redis</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>acl::redis_client_cluster&amp; cluster_;<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* key = <span class="hljs-string">&quot;hash-key&quot;</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br><span class="hljs-function">acl::redis <span class="hljs-title">cmd</span><span class="hljs-params">(&amp;cluster_)</span></span>;<br>acl::string name, val;<br>name.format(<span class="hljs-string">&quot;hash-name-%d&quot;</span>, i);<br>val.format(<span class="hljs-string">&quot;hash-val-%d&quot;</span>, i);<br><span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">hset</span>(key, name, val) == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hset error: %s, key=%s, name=%s\r\n&quot;</span>,<br>cmd.<span class="hljs-built_in">result_error</span>(), key, name.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 每个线程运行一个独立的协程调度器</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mythread</span> : <span class="hljs-keyword">public</span> acl::thread &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">mythread</span>(acl::redis_client_cluster&amp; cluster) : <span class="hljs-built_in">cluster_</span>(cluster) &#123;&#125;<br>~<span class="hljs-built_in">mythread</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>acl::redis_client_cluster&amp; cluster_;<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_redis</span>(cluster_);<br>fb-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* redis_addr = <span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>;<br>acl::redis_client_cluster cluster;<br>cluster.<span class="hljs-built_in">set</span>(redis_addr, <span class="hljs-number">0</span>);<br>cluster.<span class="hljs-built_in">bind_thread</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 创建多个线程，共享 redis 集群连接池管理对象：cluster，即所有线程中的</span><br><span class="hljs-comment">// 所有协程共享同一个 cluster 集群管理对象</span><br>std::vector&lt;acl::thread*&gt; threads;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>acl::thread* thr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">mythread</span>(cluster);<br>threads.<span class="hljs-built_in">push_back</span>(thr);<br>thr-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><span class="hljs-keyword">for</span> (std::vector&lt;acl::thread*&gt;::iterator it = threads.<span class="hljs-built_in">begin</span>();<br>it != threads.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>(*it)-&gt;<span class="hljs-built_in">wait</span>();<br><span class="hljs-keyword">delete</span> *it;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个多线程多协程环境里使用 acl::redis_client_cluster 对象时与前面的一个例子有所不同，在这里调用了：<strong>cluster.bind_thread(true);</strong> </p><p>为何要这样做？原因是 Acl Redis 的协程调度器是单线程工作模式，网络套接字句柄在协程环境里不能跨线程使用，当调用 bind_thread(true) 后，Acl 连接池管理对象会自动给每个线程分配一个连接池对象，每个线程内的所有协程共享这个绑定于本线程的连接池对象。</p><h2 id="十一、Windows-界面编程协程化"><a href="#十一、Windows-界面编程协程化" class="headerlink" title="十一、Windows 界面编程协程化"></a>十一、Windows 界面编程协程化</h2><p>在Windows下写过界面程序的程序员都经历过使通信模块与界面结合的痛苦过程，因为 Windows 界面过程是基于 win32 消息引擎驱动的，所以在编写通信模块时一般有两个选择：要么使用 Windows 提供的异步非阻塞 API，要么把通信模块放在独立于界面的单独线程中然后通过窗口消息将结果通知窗口界面过程。<br>Acl 协程库的事件引擎支持 win32 消息引擎，所以很容易将界面过程的通信过程协程化，采用这种方式，一方面程序员依然可以采用顺序编程方式，另一方面通信协程与界面过程运行于相同的线程空间，则二者在相互访问对方的成员对象时不必加锁，从而使编写通信过程变得更加简单。<br>下面以一个简单的对话框为例说明界面网络通信协程化过程：    </p><ol><li><p>首先使用向导程序生成一个对话框界面程序，需要指定支持 socket 通信；</p></li><li><p>然后在 OnInitDialog() 方法尾部添加如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 设置协程调度的事件引擎，同时将协程调度设为自动启动模式</span><br>acl::fiber::<span class="hljs-built_in">init</span>(acl::FIBER_EVENT_T_WMSG, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// HOOK ACL 库中的网络 IO 过程</span><br>acl::fiber::<span class="hljs-built_in">acl_io_hook</span>();<br></code></pre></td></tr></table></figure></li><li><p>创建一个按钮，并使其绑定一个事件方法，如：OnBnClickedListen，然后在这个方法里添加一些代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 创建一个协程用来监听指定地址，接收客户端连接请求</span><br>m_fiberListen = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CFiberListener</span>(<span class="hljs-string">&quot;127.0.0.1:8800&quot;</span>);<br><span class="hljs-comment">// 启动监听协程</span><br>m_fiberListen-&gt;<span class="hljs-built_in">start</span>();<br></code></pre></td></tr></table></figure></li><li><p>实现步骤 3 中指定的监听协程类</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">CFiberListener</span> : <span class="hljs-keyword">public</span> acl::fiber<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">CFiberListener</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr) : <span class="hljs-built_in">m_addr</span>(addr) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">CFiberListener</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><span class="hljs-keyword">private</span>:<br>acl::string m_addr;<br>acl::server_socket m_listener;<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-comment">// 绑定并监听指定的本地地址</span><br><span class="hljs-keyword">if</span> (m_listener.<span class="hljs-built_in">open</span>(m_addr) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">// 等待客户端连接</span><br>acl::socket_stream* conn = m_listener.<span class="hljs-built_in">accept</span>();<br><span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 创建独立的协程处理该客户端的请求</span><br>acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">CFiberClient</span>(conn);<br>fb-&gt;<span class="hljs-built_in">start</span>(); <span class="hljs-comment">// 启动客户端处理协程</span><br>&#125;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li><li><p>实现步骤 4 中指定的客户端响应协程类</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CFiberClient</span> :</span> public acl::fiber<br>&#123;<br>public:<br>CFiberClient(acl::socket_stream* conn) : m_conn(conn) &#123;&#125;<br>private:<br>~CFiberClient(<span class="hljs-type">void</span>) &#123; delete m_conn; &#125;<br>private:<br>acl::socket_stream* m_conn;<br><span class="hljs-comment">// @override</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> &#123;<br><span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br><span class="hljs-comment">// 从客户端读取数据</span><br><span class="hljs-type">int</span> ret = m_conn-&gt;read(buf, <span class="hljs-keyword">sizeof</span>(buf), <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-comment">// 将读到的数据回写给客户端</span><br><span class="hljs-keyword">if</span> (m_conn-&gt;write(buf, ret) != ret) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>delete this;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li></ol><p>通过以上步骤就可为 win32 界面程序添加基于协程模式的通信模块，上面的两个协程类的处理过程都是“死循环”的，而且又与界面过程同处同一线程运行空间，却为何却不会阻塞界面消息过程呢？其原因就是当通信协程类对象在遇到网络 IO 阻塞时，会自动将自己挂起，将线程的运行权交给其它协程或界面过程。原理就是这么简单，但内部实现还有点复杂度的，感兴趣的可以看看 Acl 协程库的实现源码(<a href="https://github.com/acl-dev/acl/tree/master/lib_fiber/">https://github.com/acl-dev/acl/tree/master/lib_fiber/</a> )。<br>此外，上面示例的完整代码请参考：<a href="https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/WinEchod">https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/WinEchod</a>  。</p><h2 id="十二、打印协程调用栈"><a href="#十二、打印协程调用栈" class="headerlink" title="十二、打印协程调用栈"></a>十二、打印协程调用栈</h2><p>当一个协程因为网络阻塞、加锁等待等原因被挂起时，有时需要打印该协程的函数调用栈以方便调试；因为协程的运行栈是我们通过分配一段动态内存模拟的运行栈，同时又因为协程又不是操作系统的调度单元，所以我们无法通过 GDB 来检查协程栈。Acl 协程目前通过结合 libunwind 库支持打印正在运行或被挂起的协程的调用栈，虽然仅支持 Linux 平台下的特定上下文切换方式（仅支持 swapcontext 上下文切换方式），但对于协程调试帮助很大。下面给出打印协程栈的过程：</p><ul><li>重新设置编译条件：打开 lib_fiber&#x2F;c&#x2F;Makefile 文件，将上下文切换方式由 <code>JMP_CTX = USE_JMP_DEF</code> 修改为 <code>JMP_CTX = USE_CONTEXT</code>，即将协程的上下文切换方式改成 <code>swapcontext</code>; 给编译选项 <code>CFLAGS</code> 增加条件编译，即 <code>CFLAGS += -DDEBUG_STACK</code>；然后重新编译 libfiber.a 库；</li><li>在协程代码中通过静态方法 <code>acl::fiber::stacktrace</code> 获取指定协程的函数调用栈；</li><li>在可执行程序的 Makefile 里进行程序连接时，需要添加 libunwind 相关库，即：<code>-lunwind -lunwind-x86_64</code>;</li><li>编译可执行程序，便可以自行打印被挂起协程的调用栈了。</li></ul><p>下面给出一个程序例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfiber</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myfiber</span>(acl::fiber_tbox&lt;<span class="hljs-type">bool</span>&gt;&amp; box) : <span class="hljs-built_in">box_</span>(box) &#123;&#125;<br>~<span class="hljs-built_in">myfiber</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::fiber_tbox&lt;<span class="hljs-type">bool</span>&gt;&amp; box_;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-built_in">func1</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func1</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-built_in">func2</span>();<br>&#125;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">func3</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-comment">// 等待消息，在获得消息后退出</span><br>box_.<span class="hljs-built_in">pop</span>();<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">checker</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">checker</span>(acl::fiber_tbox&lt;<span class="hljs-type">bool</span>&gt;&amp; box, acl::fiber&amp; fb)<br>: <span class="hljs-built_in">box_</span>(box), <span class="hljs-built_in">fiber_</span>(fb) &#123;&#125;<br>~<span class="hljs-built_in">checker</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::fiber_tbox&lt;<span class="hljs-type">bool</span>&gt;&amp; box_;<br>acl::fiber&amp; fiber_;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>std::vector&lt;acl::fiber_frame&gt; stack;<br><span class="hljs-comment">// 获得指定协程的调用栈</span><br>acl::fiber::<span class="hljs-built_in">stacktrace</span>(fiber_, stack, <span class="hljs-number">50</span>);<br><span class="hljs-comment">// 打印指定协程的函数调用栈</span><br><span class="hljs-keyword">for</span> (std::vector&lt;acl::fiber_frame&gt;::const_iterator<br> cit = stack.<span class="hljs-built_in">begin</span>(); cit != stack.<span class="hljs-built_in">end</span>(); ++cit) &#123;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0x%lx(%s)+0x%lx\r\n&quot;</span>,<br>(*cit).pc, (*cit).func.<span class="hljs-built_in">c_str</span>(), (*cit).off);<br>&#125;<br><br><span class="hljs-comment">// 通过等待消息的协程退出</span><br>box_.<span class="hljs-built_in">push</span>(<span class="hljs-literal">NULL</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>acl::fiber_tbox&lt;<span class="hljs-type">bool</span>&gt; box;<br>acl::fiber* fb1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">myfiber</span>(box);<br>fb1-&gt;<span class="hljs-built_in">start</span>();<br><br>acl::fiber* fb2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">checker</span>(box, *fb1);<br>fb2-&gt;<span class="hljs-built_in">start</span>();<br><br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><br><span class="hljs-keyword">delete</span> fb2;<br><span class="hljs-keyword">delete</span> fb1;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的示例中，执行过程如下：</p><ul><li>先创建 <code>myfiber</code> 协程实例，然后阻塞在 <code>fiber_tbox</code> 上等待消息通知；</li><li>再创建一个 <code>checker</code> 协程实例，运行后获得并打印前面所创建 <code>myfiber</code> 协程的调用栈；</li><li><code>checker</code> 协程最后给 <code>fiber_tbox</code> 发消息通知 <code>myfiber</code> 协程返回后退出。</li></ul><p>编译运行上面示例，便可以得到如下结果：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs text">0x434b0d(acl_fiber_cond_timedwait)+0x22d<br>0x405c85(_ZN3acl10fiber_cond4waitERNS_11fiber_mutexEi)+0x25<br>0x403a50(_ZN3acl10fiber_tboxIbE3popEiPb)+0x9e<br>0x40378d(_ZN7myfiber5func3Ev)+0x35<br>0x403756(_ZN7myfiber5func2Ev)+0x18<br>0x40373c(_ZN7myfiber5func1Ev)+0x18<br>0x4036ff(_ZN7myfiber3runEv)+0x3f<br>0x427bb1(fiber_start)+0x11<br>0x2b7cadaad0d0(__correctly_grouped_prefixwc)+0x160<br></code></pre></td></tr></table></figure><p>可以看出 myfiber 的调用栈为：<br><code>run-&gt;func1-&gt;func2-&gt;func3-&gt;pop-&gt;wait-&gt;acl_fiber_cond_timedwait</code></p><p>结合上面输出的 pc 字段，通过工具 <code>addr2line</code> 可以获得具体源码的文件位置，当执行：  </p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">$addr2line -e fiber_stack 0x434b0d 0x405c85 0x403a50 0x40378d 0x403756 0x40373c 0x4036ff 0x427bb1<br></code></pre></td></tr></table></figure><p>便得到如下信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs text">/home/zsx/workspace/github/acl/lib_fiber/c/src/sync/fiber_cond.c:150<br>/home/zsx/workspace/github/acl/lib_fiber/cpp/src/fiber_cond.cpp:22<br>/usr/include/acl-lib/fiber/fiber_tbox.hpp:148<br>/home/zsx/workspace/github/demo/c++/fiber/fiber_stack.cpp:32<br>/home/zsx/workspace/github/demo/c++/fiber/fiber_stack.cpp:28<br>/home/zsx/workspace/github/demo/c++/fiber/fiber_stack.cpp:24<br>/home/zsx/workspace/github/demo/c++/fiber/fiber_stack.cpp:19<br>/home/zsx/workspace/github/acl/lib_fiber/c/src/fiber.c:590<br></code></pre></td></tr></table></figure><h2 id="十三、检测协程死锁问题"><a href="#十三、检测协程死锁问题" class="headerlink" title="十三、检测协程死锁问题"></a>十三、检测协程死锁问题</h2><p>在稍微复杂的协程编程中，经常会使用协程锁对共享的资源进行同步保护，如果使用的互斥锁较多，有可能会形成死锁问题，比如下面的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber1</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber1</span>(acl::fiber_mutex&amp; lock1, acl::fiber_mutex&amp; lock2)<br>: <span class="hljs-built_in">lock1_</span>(lock1), <span class="hljs-built_in">lock2_</span>(lock2) &#123;&#125;<br>~<span class="hljs-built_in">fiber1</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::fiber_mutex&amp; lock1_;<br>acl::fiber_mutex&amp; lock2_;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>lock1_.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>lock2_.<span class="hljs-built_in">lock</span>();<br>&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber2</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">fiber2</span>(acl::fiber_mutex&amp; lock1, acl::fiber_mutex&amp; lock2)<br>: <span class="hljs-built_in">lock1_</span>(lock1), <span class="hljs-built_in">lock2_</span>(lock2) &#123;&#125;<br>~<span class="hljs-built_in">fiber2</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::fiber_mutex&amp; lock1_;<br>acl::fiber_mutex&amp; lock2_;<br><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>lock2_.<span class="hljs-built_in">lock</span>();<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>lock1_.<span class="hljs-built_in">lock</span>();<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>acl::fiber_mutex lock1, lock2;<br><br><span class="hljs-function">fiber1 <span class="hljs-title">fb1</span><span class="hljs-params">(lock1, lock2)</span></span>;<br>fb1.<span class="hljs-built_in">start</span>();<br><br><span class="hljs-function">fiber2 <span class="hljs-title">fb2</span><span class="hljs-params">(lock1, lock2)</span></span>;<br>fb2.<span class="hljs-built_in">start</span>();<br><br>acl::fiber::<span class="hljs-built_in">schedule</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以看出，上面的例子中出现了死锁问题，我们似乎可以很容易看出并解决掉它，但实际应用中程序逻辑要复杂的多，有时很难找到死锁的位置及原因，给开发应用带来了很大的困扰，为此，在 Acl 协程中给出了死锁检测方法，将发生死锁的协程及锁资源都列出，方便开发者查找死锁原因：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">checker</span> : <span class="hljs-keyword">public</span> acl::fiber &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">checker</span>(<span class="hljs-type">void</span>) &#123;&#125;<br>~<span class="hljs-built_in">checker</span>(<span class="hljs-type">void</span>) &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">2</span>);<br><span class="hljs-comment">// 打印死锁信息至标准输出</span><br>acl::fiber_mutex::<span class="hljs-built_in">deadlock_show</span>();<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>我们可以创建一个独立的协程定期检测协程锁死锁状态，将这个检测协程放到上面的示例中运行，便会得到如下的死锁信息：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs text">Deadlock happened!<br>fiber-1:<br>0x42df4f(acl_fiber_mutex_lock)+0x1af<br>0x40415c(_ZN3acl11fiber_mutex4lockEv)+0xc<br>0x403314(_ZN6fiber13runEv)+0x36<br>0x420781(fiber_start)+0x11<br>0x2b6143ac30d0(__correctly_grouped_prefixwc)+0x160<br>Holding mutex=0x15e3040<br>Waiting for mutex=0x15e32c0<br><br>fiber-2:<br>0x42df4f(acl_fiber_mutex_lock)+0x1af<br>0x40415c(_ZN3acl11fiber_mutex4lockEv)+0xc<br>0x4033f2(_ZN6fiber23runEv)+0x36<br>0x420781(fiber_start)+0x11<br>0x2b6143ac30d0(__correctly_grouped_prefixwc)+0x160<br>Holding mutex=0x15e32c0<br>Waiting for mutex=0x15e3040<br></code></pre></td></tr></table></figure><p>可以看出，协程1拥有锁的地址为 <code>mutex=0x15e3040</code>，但在等待锁 <code>mutex=0x15e32c0</code>，而协程2恰恰相反，所以这两个协程处于死锁状态。</p><p>将上面显示栈的 pc 字段使用 addr2line 便可以得到具体的位置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">$</span><span class="language-bash">addr2line -e fiber_deadlock 0x42df4f 0x40415c 0x403314 0x420781 0x42df4f 0x40415c 0x4033f2 0x420781</span><br><br>/home/zsx/workspace/github/acl/lib_fiber/c/src/sync/fiber_mutex.c:494<br>/home/zsx/workspace/github/acl/lib_fiber/cpp/src/fiber_mutex.cpp:28<br>/home/zsx/workspace/github/demo/c++/fiber/fiber_deadlock.cpp:21<br>/home/zsx/workspace/github/acl/lib_fiber/c/src/fiber.c:590<br>/home/zsx/workspace/github/acl/lib_fiber/c/src/sync/fiber_mutex.c:494<br>/home/zsx/workspace/github/acl/lib_fiber/cpp/src/fiber_mutex.cpp:28<br>/home/zsx/workspace/github/demo/c++/fiber/fiber_deadlock.cpp:39<br>/home/zsx/workspace/github/acl/lib_fiber/c/src/fiber.c:590<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>协程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协程编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>编译使用Acl协程库</title>
    <link href="/2019/03/23/build_use_fiber/"/>
    <url>/2019/03/23/build_use_fiber/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在《使用 acl 协程编写高并发网络服务》和《使用协程方式编写高并发的 WEB 服务》两篇文章中介绍了如何使用 acl 的协程功能编写高并发服务器程序，本文主要介绍如何编译使用 acl 的网络协程库。</p><h2 id="二、-acl-协程库的依赖关系"><a href="#二、-acl-协程库的依赖关系" class="headerlink" title="二、 acl 协程库的依赖关系"></a>二、 acl 协程库的依赖关系</h2><p>目前 acl 协程主要分为 C 库（lib_fiber.a，在 acl&#x2F;lib_fiber&#x2F;c 目录下）和 C++库（libfiber_cpp.a，在 acl&#x2F;lib_fiber&#x2F;cpp 目录下），其中 lib_fiber_cpp.a 依赖 libfiber.a，具体的依赖关系如下：<br><img src="/img/fiber_depedence.png" alt="协程库依赖"></p><p>libfiber.a 目前是独立的库，libfiber_cpp.a 依赖 libfiber.a 和 lib_acl_cpp.a，lib_acl_cpp.a 依赖 lib_protocol.a 和 lib_acl.a，lib_protocol.a 依赖 lib_acl.a。</p><p>其中，lib_acl.a 为 acl 中的核心基础 C 库，lib_protocol.a 为 acl 中的网络协议（http&#x2F;icmp&#x2F;smtp）基础 C 库，lib_acl_cpp 为 C++库，依赖上述两个 C 库；libfiber.a 为独立的网络协程库，仅依赖于系统库，libfiber_cpp.a 为封装了 libfiber.a 的 C++ 库，如果用户所用的 GCC 支持 C++11，则该库还支持更为简洁的创建协程的方式（借助于 C++11中的 lambda 表达式方式）。</p><h2 id="三、一个简单的例子"><a href="#三、一个简单的例子" class="headerlink" title="三、一个简单的例子"></a>三、一个简单的例子</h2><p>下面是一个简单的使用 acl 协程的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fiber/lib_fiber.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __max_loop = <span class="hljs-number">100</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __max_fiber = <span class="hljs-number">10</span>;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __stack_size = <span class="hljs-number">64000</span>;<br><br><span class="hljs-comment">/* 协程处理入口函数 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">fiber_main</span><span class="hljs-params">(ACL_FIBER *fiber, <span class="hljs-type">void</span> *ctx acl_unused)</span><br>&#123;<br>    <span class="hljs-type">int</span>  i;<br><br>    <span class="hljs-comment">/* 两种方式均可以获得当前的协程号 */</span><br>    assert(acl_fiber_self() == acl_fiber_id(fiber));<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; __max_loop; i++) &#123;<br>        acl_fiber_yield();  <span class="hljs-comment">/* 主动让出 CPU 给其它协程 */</span><br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;fiber-%d\r\n&quot;</span>, acl_fiber_self());<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>    <span class="hljs-type">int</span>   ch, i;<br><br>    <span class="hljs-comment">/* 创建协程 */</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; __max_fiber; i++) &#123;<br>        acl_fiber_create(fiber_main, <span class="hljs-literal">NULL</span>, __stack_size);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---- begin schedule fibers now ----\r\n&quot;</span>);<br>    acl_fiber_schedule(); <span class="hljs-comment">/* 循环调度所有协程，直至所有协程退出 */</span><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;---- all fibers exit ----\r\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述例子非常简单，说明了 acl 协程创建、启动和运行过程，如果仅此而已，当然使用协程并没有什么卵用，协程的关键价值在于与网络通信的结合，可以达到高并发、高性能的目的。因此，现实中协程的应用范围主要还是网络服务方面，更为准确的叫法应该是“网络协程”，脱离了“网络”协程基本没啥价值。本文的开头给出了两个链接，指明了网络协程的应用场景及实例。</p><h2 id="四、编译例子"><a href="#四、编译例子" class="headerlink" title="四、编译例子"></a>四、编译例子</h2><p>下面的 Makefile 文件说明了最简单的编译方式：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">fiber: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span><br>        gcc -o fiber <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span> -L./lib_fiber/lib -L./lib_acl/lib -l_acl  -lfiber -lpthread -ldl<br><span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.o</span>: <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span><br>        gcc -c <span class="hljs-selector-tag">main</span><span class="hljs-selector-class">.c</span> -O3 -DLINUX2 -I./lib_fiber/c/include -I./lib_acl/include<br></code></pre></td></tr></table></figure><p>该 Makefile 也非常简单，也仅是说明了使用 acl 网络协程库时的编译条件。其中，l_fiber 指定了 acl 的网络协程库，l_acl 指定了 acl 基础库，-lpthread 及 -ldl 指定所依赖的系统库；-DLINUX2 指定 LINUX 平台的编译条件，-I 指定头文件所在位置。</p><h2 id="五、C-示例"><a href="#五、C-示例" class="headerlink" title="五、C++ 示例"></a>五、C++ 示例</h2><p>上面的例子展示了使用 acl C 协程库的使用方法，同时 acl 也提供了 C++ 类封装，方便 C++ 程序员编写协程应用，下面的例子为使用标准 C++ 编写的协程示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fiber/lib_fiber.hpp&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myfiber</span> : <span class="hljs-keyword">public</span> acl::fiber<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">myfiber</span>(<span class="hljs-type">int</span> max_loop) : <span class="hljs-built_in">max_loop_</span>(max_loop) &#123;&#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// @override 实现基类纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 两种方式均可以获得当前的协程号</span><br>        <span class="hljs-built_in">assert</span>(<span class="hljs-built_in">get_id</span>() == acl::fiber::<span class="hljs-built_in">self</span>());<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max_loop_; i++) &#123;<br>            acl::fiber::<span class="hljs-built_in">yield</span>(); <span class="hljs-comment">// 主动让出 CPU 给其它协程</span><br>            std::cout &lt;&lt; <span class="hljs-string">&quot;fiber-&quot;</span> &lt;&lt; acl::fiber::<span class="hljs-built_in">self</span>() &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 因为是动态创建的，所以需自动销毁</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> max_loop_;<br><br>    ~<span class="hljs-built_in">myfiber</span>(<span class="hljs-type">void</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, max_fiber = <span class="hljs-number">10</span>, max_loop = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; max_fiber; i++) &#123;<br>        acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">myfiber</span>(max_loop); <span class="hljs-comment">// 创建协程</span><br>        fb-&gt;<span class="hljs-built_in">start</span>(); <span class="hljs-comment">// 启动协程</span><br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;---- begin schedule fibers now ----&quot;</span> &lt;&lt; std::endl;<br>    acl::fiber::<span class="hljs-built_in">schedule</span>(); <span class="hljs-comment">// 循环调度所有协程，直至所有协程退出</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;---- all fibers exit ----&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该例子也非常简单，实现了与上面 C 示例相同的功能，只是采用 C++ 而已。用户首先需要定义自己的类，其继承于 acl::fiber 协程类，然后实现协程类中的纯虚方法：run()，当调用协程的启动方法 start() 时，acl::fiber 基类会自动回调纯虚方法  run()。</p><p>该 C++ 示例的 Makefile 与 C 的有所不同，内容如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">fiber: main.o<br>        g++ -o fiber main.o -L.<span class="hljs-regexp">/lib_fiber/</span>lib -lfiber_cpp \<br>                -L.<span class="hljs-regexp">/lib_acl_cpp/</span>lib -l_acl_cpp \<br>                -L.<span class="hljs-regexp">/lib_acl/</span>lib -l_acl -lfiber \<br>                -lpthread -ldl<br>main.o: main.cpp<br>        g++ -O3 -Wall -c main.cpp -DLINUX2 -I.<span class="hljs-regexp">/lib_fiber/</span>cpp/<span class="hljs-keyword">include</span> \<br>                -I.<span class="hljs-regexp">/lib_acl_cpp/i</span>nclude<br></code></pre></td></tr></table></figure><h2 id="六、C-11-示例"><a href="#六、C-11-示例" class="headerlink" title="六、C++11 示例"></a>六、C++11 示例</h2><p>acl 的协程库同时提供了支持 C++11 方式的调用方法，使创建协程更加方便，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fiber/lib_fiber.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">fiber_main</span><span class="hljs-params">(<span class="hljs-type">int</span> max_loop)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max_loop; i++) &#123;<br>        acl::fiber::<span class="hljs-built_in">yield</span>(); <span class="hljs-comment">// 主动让出 CPU 给其它协程</span><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;fiber-&quot;</span> &lt;&lt; acl::fiber::<span class="hljs-built_in">self</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">int</span> i, max_fiber = <span class="hljs-number">10</span>, max_loop = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; max_fiber; i++) &#123;<br>        go[=] &#123; <span class="hljs-comment">// 采用 c++11 的 lambad 表达式方式创建协程</span><br>            <span class="hljs-built_in">fiber_main</span>(max_loop); <span class="hljs-comment">// 进入协程处理函数</span><br>        &#125;;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;---- begin schedule fibers now ----&quot;</span> &lt;&lt; std::endl;<br>    <span class="hljs-comment">// 循环调度所有协程，直至所有协程退出</span><br>    acl::fiber::<span class="hljs-built_in">schedule</span>();<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;---- all fibers exit ----&quot;</span> &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 C++11 方式创建协程是不是感觉更加简洁？</p><p>同样下面给出 makefile 内容：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs gradle">fiber: main.o<br>        g++ -o fiber main.o -L..<span class="hljs-regexp">/../</span>../lib -lfiber_cpp \<br>                -L..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>lib_acl_cpp/lib -l_acl_cpp \<br>                -L..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>lib_acl/lib -l_acl  -lfiber \<br>                -lpthread -ldl<br>main.o: main.cpp<br>        g++ -std=c++<span class="hljs-number">11</span> -O3 -Wall -c main.cpp -DLINUX2 -I.. -I..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/cpp/i</span>nclude \<br>                -I..<span class="hljs-regexp">/../</span>..<span class="hljs-regexp">/../</span>lib_acl_cpp/<span class="hljs-keyword">include</span><br></code></pre></td></tr></table></figure><h2 id="七、基于协程的网络服务"><a href="#七、基于协程的网络服务" class="headerlink" title="七、基于协程的网络服务"></a>七、基于协程的网络服务</h2><p>前面提到了“如果协程不与网络应用结合，则不会发挥其价值“，因此，下面就给出一个具体的基于协程的网络服务器程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fiber/lib_fiber.hpp&quot;</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_client</span> : <span class="hljs-keyword">public</span> acl::fiber<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">fiber_client</span>(acl::socket_stream* conn) : <span class="hljs-built_in">conn_</span>(conn) &#123;&#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// @override 实现基类纯虚函数</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;fiber-&quot;</span> &lt;&lt; acl::fiber::<span class="hljs-built_in">self</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;: fd=&quot;</span> &lt;&lt; conn_-&gt;<span class="hljs-built_in">sock_handle</span>()<br>            &lt;&lt; <span class="hljs-string">&quot;, addr=&quot;</span> &lt;&lt; conn_-&gt;<span class="hljs-built_in">get_peer</span>() &lt;&lt; std::endl;<br>        <span class="hljs-built_in">echo</span>();<br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>; <span class="hljs-comment">// 因为是动态创建的，所以需自动销毁</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    acl::socket_stream* conn_;<br><br>    ~<span class="hljs-built_in">fiber_client</span>(<span class="hljs-type">void</span>)<br>    &#123;<br>        <span class="hljs-keyword">delete</span> conn_;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">echo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];<br><br>        <span class="hljs-comment">// 从客户端读取数据并回显</span><br>        <span class="hljs-keyword">while</span> (!conn_-&gt;<span class="hljs-built_in">eof</span>()) &#123;<br>            <span class="hljs-type">int</span> ret = conn_-&gt;<span class="hljs-built_in">read</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-literal">false</span>);<br>            <span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;read &quot;</span> &lt;&lt; acl::<span class="hljs-built_in">last_serror</span>() &lt;&lt; std::endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (conn_-&gt;<span class="hljs-built_in">write</span>(buf, ret) == <span class="hljs-number">-1</span>) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;write &quot;</span> &lt;&lt; acl::<span class="hljs-built_in">last_serror</span>() &lt;&lt; std::endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">fiber_server</span> : <span class="hljs-keyword">public</span> acl::fiber<br>&#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">fiber_server</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr) : <span class="hljs-built_in">addr_</span>(addr) &#123;&#125;<br><br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-comment">// @override</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function">    </span>&#123;<br>        <span class="hljs-comment">// 监听服务地址</span><br>        acl::server_socket ss;<br>        <span class="hljs-keyword">if</span> (ss.<span class="hljs-built_in">open</span>(addr_) == <span class="hljs-literal">false</span>) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;listen &quot;</span> &lt;&lt; addr_.<span class="hljs-built_in">c_str</span>() &lt;&lt; <span class="hljs-string">&quot; error&quot;</span> &lt;&lt; std::endl;<br>            <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class="hljs-string">&quot;listen &quot;</span> &lt;&lt; addr_.<span class="hljs-built_in">c_str</span>() &lt;&lt; <span class="hljs-string">&quot; ok&quot;</span> &lt;&lt; std::endl;<br><br>        <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>            <span class="hljs-comment">// 等待接收客户端连接</span><br>            acl::socket_stream* conn = ss.<span class="hljs-built_in">accept</span>();<br>            <span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">NULL</span>) &#123;<br>                std::cout &lt;&lt; <span class="hljs-string">&quot;accept error&quot;</span> &lt;&lt; std::endl;<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<br><br>            <span class="hljs-comment">// 创建客户端处理协程</span><br>            acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_client</span>(conn);<br>            fb-&gt;<span class="hljs-built_in">start</span>();<br>        &#125;<br><br>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    acl::string addr_;<br><br>    ~<span class="hljs-built_in">fiber_server</span>(<span class="hljs-type">void</span>) &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr = <span class="hljs-string">&quot;127.0.0.1:8089&quot;</span>;<br><br>    acl::fiber* fb = <span class="hljs-keyword">new</span> <span class="hljs-built_in">fiber_server</span>(addr); <span class="hljs-comment">// 创建监听服务协程</span><br>    fb-&gt;<span class="hljs-built_in">start</span>(); <span class="hljs-comment">// 启动监听协程</span><br><br>    <span class="hljs-comment">// 循环调度所有协程，直至所有协程退出</span><br>    acl::fiber::<span class="hljs-built_in">schedule</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>麻雀虽小，五脏俱全，该示例简明扼要地说明了如何使用 acl 的网络协程库编写支持高并发的网络服务应用。</p><h2 id="八、参考"><a href="#八、参考" class="headerlink" title="八、参考"></a>八、参考</h2><p>在 acl&#x2F;lib_fiber&#x2F;samples&#x2F; 目录下，还有大量的使用 acl 协程的例子，包括：定时器、简单聊天服务、mysql 访问协程化、redis 访问协程化、域名解析协程化等。</p><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee: <a href="http://git.oschina.net/acl-dev/acl">http://git.oschina.net/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>协程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协程编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>c++对象序列化编程实例 编辑</title>
    <link href="/2016/11/14/serialize2/"/>
    <url>/2016/11/14/serialize2/</url>
    
    <content type="html"><![CDATA[<p>在《使用 acl 库针对 C++ 对象进行序列化及反序列编程》中介绍了 acl 库中针对 C&#x2F;C++ 的 struct 对象进行序列化和反序列化的功能，并且给出了一个简单的例子。本文将介绍一些较为复杂的例子。</p><h2 id="一、示例一：支持多继承的例子"><a href="#一、示例一：支持多继承的例子" class="headerlink" title="一、示例一：支持多继承的例子"></a>一、示例一：支持多继承的例子</h2><p>先定义 struct.stub 文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">student</span><br>&#123;<br>std::string shcool;<br>std::string class_name;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">province</span><br>&#123;<br>std::string province_name;<br>std::string position;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">user</span> : student, province<br>&#123;<br>std::string name;<br><span class="hljs-type">int</span>  age;<br><span class="hljs-type">bool</span> male;<br>&#125;;<br></code></pre></td></tr></table></figure><p>上面的定义中，user 继承于 student 和 province。</p><p>然后使用 gson 工具（运行：.&#x2F;gson -d ）根据此 struct.stub 生成目标源文件和头文件：gson.cpp, gson.h, struct.h。</p><p>下面就可以编写业务逻辑代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;struct.h&quot;</span>  <span class="hljs-comment">// 由 gson 工具根据 struct.stub 转换而成</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gson.h&quot;</span>    <span class="hljs-comment">// 由 gson 工具根据 struct.stub 生成</span></span><br><br><span class="hljs-comment">// 序列化过程</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>user u;<br><br>u.name = <span class="hljs-string">&quot;zsx&quot;</span>;<br>u.age = <span class="hljs-number">11</span>;<br>u.male = <span class="hljs-literal">true</span>;<br><br>u.province_name = <span class="hljs-string">&quot;省&quot;</span>;<br>u.position = <span class="hljs-string">&quot;位置&quot;</span>;<br><br>u.shcool = <span class="hljs-string">&quot;大学&quot;</span>;<br>u.class_name = <span class="hljs-string">&quot;班级&quot;</span>;<br><br>acl::json json;<br><br><span class="hljs-comment">// 将 user 对象转换为 json 对象</span><br>acl::json_node&amp; node = acl::<span class="hljs-built_in">gson</span>(json, u);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;serialize:\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;json: %s\r\n&quot;</span>, node.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>());<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 反序列化过程</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;&#123;\&quot;shcool\&quot;: \&quot;大学\&quot;, \&quot;class_name\&quot;: \&quot;班级\&quot;, \&quot;province_name\&quot;: \&quot;省\&quot;, \&quot;position\&quot;: \&quot;位置\&quot;, \&quot;name\&quot;: \&quot;zsx\&quot;, \&quot;age\&quot;: 11, \&quot;male\&quot;: true&#125;&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;deserialize:\r\n&quot;</span>);<br><br>acl::json json;<br>json.<span class="hljs-built_in">update</span>(s);<br>user u;<br><br><span class="hljs-comment">// 将 json 对象转换为 user 对象</span><br>std::pair&lt;<span class="hljs-type">bool</span>, std::string&gt; ret = acl::<span class="hljs-built_in">gson</span>(json.<span class="hljs-built_in">get_root</span>(), u);<br><br><span class="hljs-comment">// 如果转换失败，则打印转换失败原因</span><br><span class="hljs-keyword">if</span> (ret.first == <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\r\n&quot;</span>, ret.second.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s, age: %d, male: %s\r\n&quot;</span>,<br>u.name.<span class="hljs-built_in">c_str</span>(), u.age, u.male ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;province_name: %s, position: %s\r\n&quot;</span>,<br>u.province_name.<span class="hljs-built_in">c_str</span>(), u.position.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;shcool: %s, class_name: %s\r\n&quot;</span>,<br>u.shcool.<span class="hljs-built_in">c_str</span>(), u.class_name.<span class="hljs-built_in">c_str</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">serialize</span>();<br><span class="hljs-built_in">deserialize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译并运行该例子，结果如下：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">serialize:</span><br><span class="hljs-attr">json:</span> &#123;<span class="hljs-attr">&quot;shcool&quot;:</span> <span class="hljs-string">&quot;大学&quot;</span>, <span class="hljs-attr">&quot;class_name&quot;:</span> <span class="hljs-string">&quot;班级&quot;</span>, <span class="hljs-attr">&quot;province_name&quot;:</span> <span class="hljs-string">&quot;省&quot;</span>, <span class="hljs-attr">&quot;position&quot;:</span> <span class="hljs-string">&quot;位置&quot;</span>, <span class="hljs-attr">&quot;name&quot;:</span> <span class="hljs-string">&quot;zsx&quot;</span>, <span class="hljs-attr">&quot;age&quot;:</span> <span class="hljs-number">11</span>, <span class="hljs-attr">&quot;male&quot;:</span> <span class="hljs-literal">true</span>&#125;<br><br><span class="hljs-attr">deserialize:</span><br><span class="hljs-attr">name:</span> <span class="hljs-string">zsx,</span> <span class="hljs-attr">age:</span> <span class="hljs-number">11</span><span class="hljs-string">,</span> <span class="hljs-attr">male:</span> <span class="hljs-literal">yes</span><br><span class="hljs-attr">province_name:</span> <span class="hljs-string">省,</span> <span class="hljs-attr">position:</span> <span class="hljs-string">位置</span><br><span class="hljs-attr">shcool:</span> <span class="hljs-string">大学,</span> <span class="hljs-attr">class_name:</span> <span class="hljs-string">班级</span><br></code></pre></td></tr></table></figure><h2 id="二、示例二：支持-C-11-的例子"><a href="#二、示例二：支持-C-11-的例子" class="headerlink" title="二、示例二：支持 C++11 的例子"></a>二、示例二：支持 C++11 的例子</h2><p> 定义 struct.stub 文件如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">user</span><br>&#123;<br><span class="hljs-comment">// 带参数的构造函数</span><br><span class="hljs-built_in">user</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* user_name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* user_domain,<br><span class="hljs-type">int</span> user_age, <span class="hljs-type">bool</span> user_male)<br>: <span class="hljs-built_in">username</span>(user_name)<br>, <span class="hljs-built_in">domain</span>(user_domain)<br>, <span class="hljs-built_in">age</span>(user_age)<br>, <span class="hljs-built_in">male</span>(user_male)<br>&#123;&#125;<br><br><span class="hljs-built_in">user</span>() &#123;&#125;<br>~<span class="hljs-built_in">user</span>() &#123;&#125;<br><br>acl::string username;<br>acl::string domain;<br><span class="hljs-type">int</span> age = <span class="hljs-number">100</span>;<br><span class="hljs-type">bool</span> male = <span class="hljs-literal">true</span>;<br>&#125;;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">message</span><br>&#123;<br><span class="hljs-type">int</span> type;<br>acl::string cmd;<br>std::list&lt;user&gt; user_list;<br>std::list&lt;user&gt; user_vector;<br>std::map&lt;acl::string, user&gt; user_map;<br><br>std::list&lt;user*&gt; *user_list_ptr = <span class="hljs-literal">nullptr</span>;<br>std::vector&lt;user*&gt; *user_vector_ptr = <span class="hljs-literal">nullptr</span>;<br>std::map&lt;acl::string, user*&gt; *user_map_ptr = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-type">int</span> n = <span class="hljs-number">100</span>;<span class="hljs-comment">// c++11 允许初始化成员变量</span><br><span class="hljs-type">long</span> n1 = <span class="hljs-number">1000</span>;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> n2 = <span class="hljs-number">1000</span>;<br><span class="hljs-type">short</span> n3 = <span class="hljs-number">100</span>;<br><span class="hljs-comment">//Gson@optional</span><br>user* u = <span class="hljs-literal">nullptr</span>;<br><br><span class="hljs-built_in">message</span>() &#123;&#125;<br><br>~<span class="hljs-built_in">message</span>()<br>&#123;<br><span class="hljs-keyword">if</span> (user_list_ptr)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : *user_list_ptr)<br><span class="hljs-keyword">delete</span> it;<br><span class="hljs-keyword">delete</span> user_list_ptr;<br>&#125;<br><span class="hljs-keyword">if</span> (user_vector_ptr)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : *user_vector_ptr)<br><span class="hljs-keyword">delete</span> it;<br><span class="hljs-keyword">delete</span> user_vector_ptr;<br>&#125;<br><span class="hljs-keyword">if</span> (user_map_ptr)<br>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> it : *user_map_ptr)<br><span class="hljs-keyword">delete</span> it.second;<br><span class="hljs-keyword">delete</span> user_map_ptr;<br>&#125;<br>&#125;<br>&#125;;<br></code></pre></td></tr></table></figure><p>用 gson 工具将上述 stub 文件生成同样的三个文件：gson.cpp, gson.h, struct.h，然后编写业务处理代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;struct.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gson.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">print_msg</span><span class="hljs-params">(message&amp; msg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;=======================================================\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;type: %d\r\n&quot;</span>, msg.type);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;cmd: %s\r\n&quot;</span>, msg.cmd.<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------- user list ------------------------\r\n&quot;</span>);<br><span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cit : msg.user_list)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\r\n&quot;</span>,<br>cit.username.<span class="hljs-built_in">c_str</span>(), cit.domain.<span class="hljs-built_in">c_str</span>(),<br>cit.age, cit.male ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><span class="hljs-keyword">if</span> (++i &gt;= <span class="hljs-number">10</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------- user vector ----------------------\r\n&quot;</span>);<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cit : msg.user_vector)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\r\n&quot;</span>,<br>cit.username.<span class="hljs-built_in">c_str</span>(), cit.domain.<span class="hljs-built_in">c_str</span>(),<br>cit.age, cit.male ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><span class="hljs-keyword">if</span> (++i &gt;= <span class="hljs-number">10</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------------------- user map --------------------------\r\n&quot;</span>);<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cit : msg.user_map)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;key: %s, username: %s, domain: %s, age: %d, male: %s\r\n&quot;</span>,<br>cit.first.<span class="hljs-built_in">c_str</span>(),<br>cit.second.username.<span class="hljs-built_in">c_str</span>(),<br>cit.second.domain.<span class="hljs-built_in">c_str</span>(),<br>cit.second.age,<br>cit.second.male ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><span class="hljs-keyword">if</span> (++i &gt;= <span class="hljs-number">10</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------- user list ptr --------------------\r\n&quot;</span>);<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cit : *msg.user_list_ptr)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\r\n&quot;</span>,<br>cit-&gt;username.<span class="hljs-built_in">c_str</span>(), cit-&gt;domain.<span class="hljs-built_in">c_str</span>(),<br>cit-&gt;age, cit-&gt;male ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><span class="hljs-keyword">if</span> (++i &gt;= <span class="hljs-number">10</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------- user vector ptr ------------------\r\n&quot;</span>);<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cit : *msg.user_vector_ptr)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\r\n&quot;</span>,<br>cit-&gt;username.<span class="hljs-built_in">c_str</span>(), cit-&gt;domain.<span class="hljs-built_in">c_str</span>(),<br>cit-&gt;age, cit-&gt;male ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><span class="hljs-keyword">if</span> (++i &gt;= <span class="hljs-number">10</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;------------------- user map ptr ----------------------\r\n&quot;</span>);<br>i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> cit : *msg.user_map_ptr)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;key: %s, username: %s, domain: %s, age: %d, male: %s\r\n&quot;</span>,<br>cit.first.<span class="hljs-built_in">c_str</span>(),<br>cit.second-&gt;username.<span class="hljs-built_in">c_str</span>(),<br>cit.second-&gt;domain.<span class="hljs-built_in">c_str</span>(),<br>cit.second-&gt;age,<br>cit.second-&gt;male ? <span class="hljs-string">&quot;true&quot;</span> : <span class="hljs-string">&quot;false&quot;</span>);<br><span class="hljs-keyword">if</span> (++i &gt;= <span class="hljs-number">10</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;-------------------------------------------------------\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">//////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// 序列化过程</span><br><br>message msg;<br>msg.user_list_ptr   = <span class="hljs-keyword">new</span> std::list&lt;user*&gt;;<br>msg.user_vector_ptr = <span class="hljs-keyword">new</span> std::vector&lt;user*&gt;;<br>msg.user_map_ptr    = <span class="hljs-keyword">new</span> std::map&lt;acl::string, user*&gt;;<br><br>msg.type = <span class="hljs-number">1</span>;<br>msg.cmd  = <span class="hljs-string">&quot;add&quot;</span>;<br><br>user u = &#123;<span class="hljs-string">&quot;zsx1&quot;</span>, <span class="hljs-string">&quot;263.net&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">true</span>&#125;;<br>msg.user_list.<span class="hljs-built_in">push_back</span>(u);<br>msg.user_list.<span class="hljs-built_in">emplace_back</span>(u);<br>msg.user_list.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;zsx1&quot;</span>, <span class="hljs-string">&quot;263.net&quot;</span>, <span class="hljs-number">13</span>, <span class="hljs-literal">false</span>);<br><br>u = &#123;<span class="hljs-string">&quot;zsx2&quot;</span>, <span class="hljs-string">&quot;263.net&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">true</span>&#125;;<br>msg.user_vector.<span class="hljs-built_in">push_back</span>(u);<br>msg.user_vector.<span class="hljs-built_in">emplace_back</span>(u);<br>msg.user_vector.<span class="hljs-built_in">emplace_back</span>(<span class="hljs-string">&quot;zsx2&quot;</span>, <span class="hljs-string">&quot;263.net4&quot;</span>, <span class="hljs-number">14</span>, <span class="hljs-literal">true</span>);<br><br>u = &#123;<span class="hljs-string">&quot;zsx31&quot;</span>, <span class="hljs-string">&quot;263.net&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">true</span>&#125;;<br>msg.user_map[u.username] = u;<br>msg.user_map[<span class="hljs-string">&quot;zsx32&quot;</span>] = &#123;<span class="hljs-string">&quot;zsx32&quot;</span>, <span class="hljs-string">&quot;263.net&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">true</span> &#125;;<br><br>msg.user_list_ptr-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">user</span>(<span class="hljs-string">&quot;zsx4&quot;</span>, <span class="hljs-string">&quot;263.net1&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">true</span>));<br>msg.user_list_ptr-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">user</span>(<span class="hljs-string">&quot;zsx4&quot;</span>, <span class="hljs-string">&quot;263.net2&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">true</span>));<br><br>msg.user_vector_ptr-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">user</span>(<span class="hljs-string">&quot;zsx5&quot;</span>, <span class="hljs-string">&quot;263.net1&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">true</span>));<br>msg.user_vector_ptr-&gt;<span class="hljs-built_in">push_back</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">user</span>(<span class="hljs-string">&quot;zsx5&quot;</span>, <span class="hljs-string">&quot;263.net2&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">true</span>));<br><br>(*msg.user_map_ptr)[<span class="hljs-string">&quot;zsx61&quot;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">user</span>(<span class="hljs-string">&quot;zsx61:&quot;</span>, <span class="hljs-string">&quot;263.net1&quot;</span>, <span class="hljs-number">11</span>, <span class="hljs-literal">true</span>);<br>(*msg.user_map_ptr)[<span class="hljs-string">&quot;zsx62&quot;</span>] = <span class="hljs-keyword">new</span> <span class="hljs-built_in">user</span>(<span class="hljs-string">&quot;zsx62&quot;</span>, <span class="hljs-string">&quot;263.net2&quot;</span>, <span class="hljs-number">12</span>, <span class="hljs-literal">true</span>);<br><br>acl::json json;<br><br><span class="hljs-comment">// 序列化</span><br>acl::json_node&amp; node = acl::<span class="hljs-built_in">gson</span>(json, msg);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;serialize: %s\r\n&quot;</span>, node.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-comment">/////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// 反序列化过程</span><br><br>message msg1;<br>acl::json json1;<br>json1.<span class="hljs-built_in">update</span>(node.<span class="hljs-built_in">to_string</span>());<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;json1 to_string: %s\r\n&quot;</span>, json1.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-comment">// 反序列化</span><br>std::pair&lt;<span class="hljs-type">bool</span>, std::string&gt; ret = acl::<span class="hljs-built_in">gson</span>(json1.<span class="hljs-built_in">get_root</span>(), msg1);<br><span class="hljs-keyword">if</span> (ret.first == <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\r\n&quot;</span>, ret.second.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">print_msg</span>(msg);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">test</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>       上述例子主要体现了 gson 的两个特点：<span class="hljs-number">1</span>、允许有构造函数，<span class="hljs-number">2</span>、支持 C++<span class="hljs-number">11</span> 中的结构成员初始化。<br></code></pre></td></tr></table></figure><h2 id="三、参考"><a href="#三、参考" class="headerlink" title="三、参考"></a>三、参考</h2><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>对象序列化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl 库针对 C++ 对象进行序列化及反序列编程</title>
    <link href="/2016/10/16/serialize/"/>
    <url>/2016/10/16/serialize/</url>
    
    <content type="html"><![CDATA[<p>在开发网络应用程序时，各个模块之间的数据通信可谓是家常便饭，为了应对这些数据通信时数据交换的要求，程序员发明了各种数据格式：采用二进制数据结构（早期 C 程序员）、采用 XML、采用SOAP（坑人的设计）、采用 URL 编码、采用JSON格式等。客户端与服务端交互时采用这些数据格式进行数据交换时，必然要经历数据编码及数据解码的繁琐过程。早期的二进制数据结构格式对于 C 程序员而是比较简单的，在解码时直接进行结构硬对齐就OK了，但对于其它语言（如 JAVA，PHP）则就麻烦很多，JAVA 语言不仅需要采用字节流一个一个对齐，而且还得要考虑到 C 结构体的数据打包填充方式；SOAP 方式看似满足了各类编程语言数据交换的目的，但数据臃肿是一个很大的问题，我们为了传输几个字节的数据则需要不得不封装大量的 XML 标记。为了使跨语言开发的程序员从麻烦的数据编解码中解脱出来，后来出来很多序列化&#x2F;反序列化的工具库，比较著名的象 Facebook 的 thrift，Google 的 protobuf。这些工具库功能非常强大，但有一个问题是，这些工具库所要求的预先定义的 schema 的亲民性不够好，增加了额外的大量学习成本。</p><p>最近由 <a href="mailto:&#x6e;&#105;&#117;&#107;&#101;&#x79;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;">&#x6e;&#105;&#117;&#107;&#101;&#x79;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a> 为 acl 库新增了 C++ 对象序列化与反序列化库，大大提高了程序员的编程效率及代码准确率。acl 序列化库实现了 C++ struct 对象与 JSON 对象之间互转功能，使用方式非常简单。</p><h2 id="一、acl-序列化库的功能特点："><a href="#一、acl-序列化库的功能特点：" class="headerlink" title="一、acl 序列化库的功能特点："></a>一、acl 序列化库的功能特点：</h2><ul><li>可以直接将 C++ struct 对象转换为 Json 对象，同时还可以将 Json 对象反序列化为 C++ struct 对象；</li><li>支持 C++ struct 对象中包含构造函数及析构函数；</li><li>C++ struct 对象中的成员支持常见基本类型（short, int, long, long long, char*）、标准 C++ 类对象；</li><li>C++ struct 对象中的成员支持指针类型；</li><li>C++ struct 对象中的成员支持常见 C++ 容器类型：std::vector、std::list、std::map，且支持容器对象的内部嵌套；</li><li>C++ struct 对象中的成员为基本数据类型（如：short, int, long, long long）和指针类型时，支持直接在 struct 中针对这些成员进行初始化（C++11）；</li><li>支持在 C++ struct 中添加注释（&#x2F;&#x2F; 或 &#x2F;**&#x2F;）；</li><li>支持 C++ struct 对象的多继承；</li><li>支持在 C++ struct 对象中的多级包含，建议使用包含方式代替继承方式；</li><li>支持 C++ struct 成员增加注释项：&#x2F;&#x2F;Gson@optional 表示该成员变量为可选项，&#x2F;&#x2F;Gson@required 表示该成员为必须项，默认为必须的。</li></ul><h2 id="二、使用-acl-序列化库的限制："><a href="#二、使用-acl-序列化库的限制：" class="headerlink" title="二、使用 acl 序列化库的限制："></a>二、使用 acl 序列化库的限制：</h2><ul><li>struct 中的成员类型不能为 char 类型，主要是因为 Json 对象中不存在 char 类型；</li><li>struct 中的成员前不得有 const 常量限定词，主要是在反序列化时需要对这些成员进行赋值；</li><li>struct 中不支持 C++ 关键词：public、private、protected；</li><li>struct 中的成员变量名不得为：$json、$node、$obj，因为这些关键词被 acl 序列化库生成的代码占用；<br>-存在包含关系的 struct 类型定义必须在同一个文件中；</li><li>不支持纯 C 语言的数组功能，比如，针对 int a[10]，因无法确切知道数组 a 中真实存储的数量而无法进行序列化和反序列化，因此推荐使用 std::vector<int> 代替它。</li></ul><h2 id="三、使用-acl-序列化库的过程："><a href="#三、使用-acl-序列化库的过程：" class="headerlink" title="三、使用 acl 序列化库的过程："></a>三、使用 acl 序列化库的过程：</h2><ul><li>首先编译 acl 库：在 acl 目录前运行：make build_one，会生成 acl 的三个基础库（lib_acl&#x2F;lib&#x2F;lib_acl.a, lib_protocol&#x2F;lib&#x2F;lib_protocol.a, lib_acl_cpp&#x2F;liblib_acl_cpp.a），同时还会在 acl 根目录下生成这三个库的合集（lib_acl.a 和 lib_acl.so）；</li><li>编译 acl 序列化工具：进入 app&#x2F;gson 目录，运行 make，生成 gson 工具，该工具将被用于根据用户自定义 struct 生成序列化 C++ 代码；</li><li>定义自己的 struct 结构体（可以定义多个）并保存在文件中（文件后缀名为 .stub）；</li><li>使用 gson 工具根据用户的 .stub 文件生成序列化所需的 C++ 代码：.&#x2F;gson -d path，其中 path 为保含 .stub 文件的目录，将会生成三个文件 gson.cpp、 gson.h 和 由 .stub 转换的 .h 头文件；</li><li>将 gson.h 和由 .stub 文件转换的 .h 头文件包含在自己的代码中；</li><li>针对用户自定义的每一个 struct，在 gson.h 头文件中均会提供 struct 对象的序列化和反序列化的方法，假设用户自定义了一个结构体类型：struct user，则在由工具 gson 生成的 gson.h 文件中包含如下五个方法：<figure class="highlight nsis"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs nsis"><span class="hljs-title function_">acl::string</span> gson(const <span class="hljs-literal">user</span> &amp;<span class="hljs-variable">$obj</span>)<span class="hljs-comment">;  </span><br><br>  将用户填充好的 <span class="hljs-literal">user</span> 对象 <span class="hljs-variable">$obj</span> 转换为 Json 字符串；<br><span class="hljs-title function_">acl::json_node</span>&amp; gson(<span class="hljs-title function_">acl::json</span> &amp;<span class="hljs-variable">$json</span>, const <span class="hljs-literal">user</span> &amp;<span class="hljs-variable">$obj</span>)<span class="hljs-comment">;</span><br><br>  将用户填充好的 <span class="hljs-literal">user</span> 对象 <span class="hljs-variable">$obj</span> 转化为 <span class="hljs-title function_">acl::json</span> 对象 <span class="hljs-variable">$json</span> 中的一个 <span class="hljs-title function_">acl::json_node</span> 节点对象并将之返回，这样用户可以将这个返回的 <span class="hljs-title function_">acl::json_node</span>&amp; 对象引用添加于 <span class="hljs-variable">$json</span> 对象中；<br><br><span class="hljs-title function_">acl::json_node</span>&amp; gson(<span class="hljs-title function_">acl::json</span> &amp;<span class="hljs-variable">$json</span>, const <span class="hljs-literal">user</span> *<span class="hljs-variable">$obj</span>)<span class="hljs-comment">;</span><br><br>   功能与 <span class="hljs-number">2</span>）中的方法相同，只是 <span class="hljs-variable">$obj</span> 参数为对象指针；<br><br><span class="hljs-title function_">std::pair</span>&lt;bool,<span class="hljs-title function_">std::string</span>&gt; gson(<span class="hljs-title function_">acl::json_node</span> &amp;<span class="hljs-variable">$node</span>, <span class="hljs-literal">user</span> &amp;<span class="hljs-variable">$obj</span>)<span class="hljs-comment">;</span><br><br>   将一个 <span class="hljs-title function_">acl::json_node</span> Json 节点对象转化为用户自定义的 struct <span class="hljs-literal">user</span> 对象，如果 <span class="hljs-variable">$node</span> 为该 Json 对象中的根节点，则该根节点可由 <span class="hljs-variable">$json.get_root</span>() 获得，<span class="hljs-variable">$obj</span> 存储转换后的结果；<br><br><span class="hljs-title function_">std::pair</span>&lt;bool,<span class="hljs-title function_">std::string</span>&gt; gson(<span class="hljs-title function_">acl::json_node</span> &amp;<span class="hljs-variable">$node</span>, <span class="hljs-literal">user</span> *<span class="hljs-variable">$obj</span>)<span class="hljs-comment">;</span><br><br>   功能与 <span class="hljs-number">5</span>）中的方法相同，只是 <span class="hljs-variable">$obj</span> 参数为对象指针。<br></code></pre></td></tr></table></figure></li></ul><h2 id="四、举例："><a href="#四、举例：" class="headerlink" title="四、举例："></a>四、举例：</h2><p>假设自定义结构对象如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// struct.stub</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">user</span><br>&#123;<br>        std::string name;<br>        std::string domain;<br>        <span class="hljs-type">int</span> age;<br>        <span class="hljs-type">bool</span> male;<br>&#125;;<br><br>      应用操作 user 对象的过程如下：<br><br><span class="hljs-comment">// main.cpp</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;list&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;map&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;time.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;struct.h&quot;</span>  <span class="hljs-comment">// 由 gson 工具根据 struct.stub 转换而成</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gson.h&quot;</span>   <span class="hljs-comment">// 由 gson 工具根据 struct.stub 生成</span></span><br><br><span class="hljs-comment">// 序列化过程</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">serialize</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>user u;<br><br>u.name = <span class="hljs-string">&quot;zsxxsz&quot;</span>;<br>u.domain = <span class="hljs-string">&quot;263.net&quot;</span>;<br>u.age = <span class="hljs-number">11</span>;<br>u.male = <span class="hljs-literal">true</span>;<br><br>acl::json json;<br><br><span class="hljs-comment">// 将 user 对象转换为 json 对象</span><br>acl::json_node&amp; node = acl::<span class="hljs-built_in">gson</span>(json, u);<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;serialize:\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;json: %s\r\n&quot;</span>, node.<span class="hljs-built_in">to_string</span>().<span class="hljs-built_in">c_str</span>());<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 反序列化过程</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">deserialize</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *s = <span class="hljs-string">&quot;&#123;\&quot;name\&quot;: \&quot;zsxxsz\&quot;, \&quot;domain\&quot;: \&quot;263.net\&quot;, \&quot;age\&quot;: 11, \&quot;male\&quot;: true&#125;&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;deserialize:\r\n&quot;</span>);<br><br>acl::json json;<br>json.<span class="hljs-built_in">update</span>(s);<br>user u;<br><br><span class="hljs-comment">// 将 json 对象转换为 user 对象</span><br>std::pair&lt;<span class="hljs-type">bool</span>, std::string&gt; ret = acl::<span class="hljs-built_in">gson</span>(json.<span class="hljs-built_in">get_root</span>(), u);<br><br><span class="hljs-comment">// 如果转换失败，则打印转换失败原因</span><br><span class="hljs-keyword">if</span> (ret.first == <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error: %s\r\n&quot;</span>, ret.second.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;name: %s, domain: %s, age: %d, male: %s\r\n&quot;</span>,<br>u.name.<span class="hljs-built_in">c_str</span>(), u.domain.<span class="hljs-built_in">c_str</span>(), u.age,<br>u.male ? <span class="hljs-string">&quot;yes&quot;</span> : <span class="hljs-string">&quot;no&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">serialize</span>();<br><span class="hljs-built_in">deserialize</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="五、参考："><a href="#五、参考：" class="headerlink" title="五、参考："></a>五、参考：</h2><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>对象序列化</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用协程方式编写高并发的WEB服务</title>
    <link href="/2016/07/06/fiber_web/"/>
    <url>/2016/07/06/fiber_web/</url>
    
    <content type="html"><![CDATA[<p>在《使用 acl 协程编写高并发网络服务》中介绍了一个使用 acl 协程库编写高并发网络服务的应用示例，本节将展示一个稍微复杂些且更具实际意义的例子：基于协程的 WEB 服务器程序。下面首先展示这个 WEB 服务器程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.h&quot;</span><span class="hljs-comment">// acl 基础库头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fiber/lib_fiber.h&quot;</span><span class="hljs-comment">// acl 协程库头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span><span class="hljs-comment">// acl C++ 封装库头文件</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">http_servlet</span> : <span class="hljs-keyword">public</span> acl::HttpServlet<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">http_servlet</span>(acl::socket_stream* stream, acl::session* session)<br>: <span class="hljs-built_in">HttpServlet</span>(stream, session)<br>&#123;<br>&#125;<br><br>~<span class="hljs-built_in">http_servlet</span>(<span class="hljs-type">void</span>)<br>&#123;<br>&#125;<br><br><span class="hljs-comment">// override</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">doGet</span><span class="hljs-params">(acl::HttpServletRequest&amp; req, acl::HttpServletResponse&amp; res)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">doPost</span>(req, res);<br>&#125;<br><br><span class="hljs-comment">// override</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">doPost</span><span class="hljs-params">(acl::HttpServletRequest&amp;, acl::HttpServletResponse&amp; res)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* buf = <span class="hljs-string">&quot;hello world!&quot;</span>;<br><span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(buf);<br><br>res.<span class="hljs-built_in">setContentLength</span>(len);<br>res.<span class="hljs-built_in">setKeepAlive</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 发送 http 响应体</span><br><span class="hljs-keyword">return</span> res.<span class="hljs-built_in">write</span>(buf, len) &amp;&amp; res.<span class="hljs-built_in">write</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> STACK_SIZE320000          <span class="hljs-comment">// 指定协程堆栈大小(字节)</span></span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __rw_timeout = <span class="hljs-number">0</span>;<span class="hljs-comment">// 网络 IO 超时时间(秒)</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">http_server</span><span class="hljs-params">(ACL_FIBER *, <span class="hljs-type">void</span> *ctx)</span></span><br><span class="hljs-function"></span>&#123;<br>acl::socket_stream *conn = (acl::socket_stream *) ctx;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start one http_server\r\n&quot;</span>);<br><br><span class="hljs-function">acl::memcache_session <span class="hljs-title">session</span><span class="hljs-params">(<span class="hljs-string">&quot;127.0.0.1:11211&quot;</span>)</span></span>;<br><br><span class="hljs-comment">// 基于 ACL HTTP 模块的 Http 服务类</span><br><span class="hljs-function">http_servlet <span class="hljs-title">servlet</span><span class="hljs-params">(conn, &amp;session)</span></span>;<br>servlet.<span class="hljs-built_in">setLocalCharset</span>(<span class="hljs-string">&quot;gb2312&quot;</span>);<br><br><span class="hljs-comment">// 循环处理客户端的 HTTP 请求</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// 调用 acl::HttpServlet 类中的方法，从而触发子类重载的 doPost/doGet 方法</span><br><span class="hljs-keyword">if</span> (servlet.<span class="hljs-built_in">doRun</span>() == <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;close one connection: %d, %s\r\n&quot;</span>, conn-&gt;<span class="hljs-built_in">sock_handle</span>(), acl::<span class="hljs-built_in">last_serror</span>());<br><br><span class="hljs-comment">// 销毁客户端连接对象</span><br><span class="hljs-keyword">delete</span> conn;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">fiber_accept</span><span class="hljs-params">(ACL_FIBER *, <span class="hljs-type">void</span> *ctx)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr = (<span class="hljs-type">const</span> <span class="hljs-type">char</span>* ) ctx;<br>acl::server_socket server;<br><br><span class="hljs-comment">// 监听本机服务端口</span><br><span class="hljs-keyword">if</span> (server.<span class="hljs-built_in">open</span>(addr) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open %s error\r\n&quot;</span>, addr);<br><span class="hljs-built_in">exit</span> (<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open %s ok\r\n&quot;</span>, addr);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// 等待接收外来 HTTP 客户端连接</span><br>acl::socket_stream* client = server.<span class="hljs-built_in">accept</span>();<br><span class="hljs-keyword">if</span> (client == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept failed: %s\r\n&quot;</span>, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br>client-&gt;<span class="hljs-built_in">set_rw_timeout</span>(__rw_timeout);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept one: %d\r\n&quot;</span>, client-&gt;<span class="hljs-built_in">sock_handle</span>());<br><br><span class="hljs-comment">// 创建协程处理 HTTP 客户端连接请求</span><br><span class="hljs-built_in">acl_fiber_create</span>(http_server, client, STACK_SIZE);<br>&#125;<br><br><span class="hljs-built_in">exit</span> (<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* procname)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s -h [help] -s listen_addr -r rw_timeout\r\n&quot;</span>, procname);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">acl::string <span class="hljs-title">addr</span><span class="hljs-params">(<span class="hljs-string">&quot;127.0.0.1:9001&quot;</span>)</span></span>;<br><span class="hljs-type">int</span>  ch;<br><br><span class="hljs-keyword">while</span> ((ch = <span class="hljs-built_in">getopt</span>(argc, argv, <span class="hljs-string">&quot;hs:r:&quot;</span>)) &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">switch</span> (ch)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br><span class="hljs-built_in">usage</span>(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;s&#x27;</span>:<br>addr = optarg;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br>__rw_timeout = <span class="hljs-built_in">atoi</span>(optarg);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br>acl::<span class="hljs-built_in">acl_cpp_init</span>();<br>acl::log::<span class="hljs-built_in">stdout_open</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 创建服务监听协程</span><br><span class="hljs-built_in">acl_fiber_create</span>(fiber_accept, addr.<span class="hljs-built_in">c_str</span>(), STACK_SIZE);<br><br><span class="hljs-comment">// 启动协程调度过程</span><br><span class="hljs-built_in">acl_fiber_schedule</span>();<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>此例子的流程为：创建服务监听协程 —&gt; 启动协程调度过程 —&gt; 监听协程收到 HTTP 客户端连接后，创建 HTTP 协程处理该连接 —&gt; HTTP 协程与 HTTP 客户端进行交互。</p><p>因为协程相对于线程来说是非常轻量级的，所以虽然针对每一个 HTTP 客户端连接都会创建一个新的协程，但这并不会费太多系统资源，因而可以支持非常高的并发连接。</p><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="http://git.oschina.net/acl-dev/acl">http://git.oschina.net/acl-dev/acl</a> </p>]]></content>
    
    
    <categories>
      
      <category>协程编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>协程编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 redis_builder 管理 redis 集群</title>
    <link href="/2016/04/23/redis_builder2/"/>
    <url>/2016/04/23/redis_builder2/</url>
    
    <content type="html"><![CDATA[<p>在 &lt;一个 C++ redis 集群管理工具&gt; 中主要讲述了如何使用 redis_builder 工具创建 redis 集群的过程，除此之外，该工具还具有更为强大的 redis 客户端管理功能（相对于官方提供的 redis-cli功能要强大的多）。本文主要讲解使用 redis_builder 以交互方式管理 redis 集群的过程。</p><h2 id="一、启动-redis-builder-的交互过程"><a href="#一、启动-redis-builder-的交互过程" class="headerlink" title="一、启动 redis_builder 的交互过程"></a>一、启动 redis_builder 的交互过程</h2><p>只要运行：.&#x2F;redis_builder -s redis_ip:redis_port，便进入 redis_builder 工具的命令行交互过程，其中 redis_ip 和 redis_port 为 redis 集群中的任一个节点的 IP 及端口号。启动成功后，显示界面如下：</p><p><img src="/img/redis_builder.png" alt="redis_builder界面"></p><p>在上图中，首先显示了针对一些 redis 客户端命令的：是否采用广播方式，命令执行权限。</p><p>“广播方式”的含义是：该命令需要向 redis 集群中的所有节点发送某个 redis 客户端命令，有的命令向所有主从节点广播，有的命令仅向所有主节点广播。对于象 config xxx xxx （如：config get save）类的命令，是需要向所有主从节点广播以获得所有节点的配置信息；对于象 dbsize 命令，则需要向所有主节点广播，以便获得整个集群总的键值数。</p><p>“执行权限”的用处是：1、防止误操作，2、禁止使用 redis_builder 执行某些非常危险的命令。其中“执行权限”的三个级别分别为：yes — 允许执行，warn — 警告执行，no — 禁止执行。对于大部分命令，如：get, incr, dbsize 等命令的执行对于整个系统一般是无害的，所以不会有限制，而对于象 del 类的命令则带有一定危险性，管理员可以配置该命令（下面单独介绍如何配置命令的执行权限）的执行为“警告”方式，这样当运行此类命令时，redis_builder 会首先提示警告信息让管理员再次确认是否真的要执行，这样做的好处是可以在一定程度上防止管理员误操作。</p><h2 id="二、配置-redis-客户端命令的执行权限"><a href="#二、配置-redis-客户端命令的执行权限" class="headerlink" title="二、配置 redis 客户端命令的执行权限"></a>二、配置 redis 客户端命令的执行权限</h2><p>当以命令行交互方式启动 redis_builder 时，该工具首先会强制检查该工具所在目录下是否有 redis_commands.txt 文件（该文件里配置着一些 redis 客户端命令的执行权限及广播方式），如果存在，则加载命令配置信息，如果该文件不存在则尝试加载由 -F 指定的命令配置信息。之所以要强制加载 redis_commands.txt 命令配置文件，主要适应这样一种应用场景：由 root 超级管理员创建了 redis_commands.txt 文件（属主当然为 root），普通用户只有读的权限，这样 root 管理员在 redis_commands.txt 中设置的 redis 命令执行权限普通用户是不能修改的。</p><p>如果在 redis_builder 命令的相同目录下存在 redis_commands.txt 文件且内容如下：<br><img src="/img/redis_commands.png" alt="redis命令权限"> </p><p>则启动 redis_builder 交互方式后，则显示一些 redis 命令的执行权限如下（红圈内的命令为 redis_commands.txt 文件指定的）：</p><p>i<img src="/img/redis_commands2.png" alt="redis命令权限"></p><p>如果在 redis_commands.txt 指定的 redis 命令与 redis_builder 内部缺省的命令相同，则执行 redis_commands.txt 中指定的 redis 命令权限。</p><h2 id="三、redis-builder-在交互方式下的命令操作"><a href="#三、redis-builder-在交互方式下的命令操作" class="headerlink" title="三、redis_builder 在交互方式下的命令操作"></a>三、redis_builder 在交互方式下的命令操作</h2><p>在交互模式下，redis_builder 可以执行所有的 redis 客户端命令，其中，redis_builder 内置了一些针对某些重要命令的特殊执行过程，除了这些内置的 redis 客户端命令，其它的命令执行方式均为标准的 redis 协议命令格式（具体格式可参考：redis.io 或 redisdoc.com）。下面首先介绍 redis_builder 内置的一些 redis 命令，随便输入一些字符串回车后，显示内置的命令如下：</p><p><img src="/img/redis_help.png" alt="redis命令帮助"></p><ul><li>keys 命令：该命令根据字符串匹配模式 pattern 扫描 redis 集群中所有子节点（之所以扫描子节点，是为了减轻对主节点的访问压力，如果需要强制扫描主节点，则在启动 redis_builder 时增加参数 -M），获得符合匹配条件的所有键值，为了防止键太多造成刷屏问题，可以通过 limit 参数指定每个节点显示的条目数</li><li>get 命令：该命令可以获得五种数据类型（STRING, HASH, LIST, SET, ZSET）的值，内部会根据数据类型自动匹配查询，并根据类型的不同按不同的方式显示。示例如下：</li></ul><p><img src="/img/redis_get.png" alt="redis获取命令"></p><p>由上图可以看到，对于 STRING 和 HASH 类型，get 命令会自行进行分别处理。此外，为了防止结果集太大造成刷屏，还可以通过指定参数 :limit 来限定显示的条目，如对于 HASH 类型的 hash_test_key_53479，可以这样查找：get :2 hash_test_key_53479，虽然有三个值，则最多只会显示两个，如下：<br><img src="/img/redis_hash_get.png" alt="redisHash获取命令"></p><ul><li>dbsize 命令：这是一个广播式式命令，会向所有主节点（当启动时指定参数 -M）或从所有主节点各挑选一个子节点发送 dbsize，获得整个 redis 集群中总的记录条数：</li></ul><p><img src="/img/redis_dbsize.png" alt="redis数据量命令"></p><ul><li>nodes 命令：该命令会发送给随意一个 redis 节点，获得当前 redis 集群的分布状态，显示如下：<br><img src="/img/redis_nodes.png" alt="redis节点状态命令"></li></ul><p>该图以树型方式展示了整个 redis 集群中的主从分布情况，层次结构清晰，一目了然。</p><ul><li>server 命令：该命令用于切换 redis 集群，管理员可以使用该命令随时切换至其它的 redis 的集群，从而方便管理员使用 redis_builder 命令同时管理多个 redis 集群。命令格式：server ip port</li><li>非 redis_builder 内置的其它 redis 命令：随了上面列出的一些内置命令外，管理员可以通过在命令行中输入任意合法的 redis 客户端命令，redis_builder 会将该命令发送至单个 redis 节点或广播（通过在 redis_commands.txt 指定广播方式）至所有的节点。比如：</li></ul><p><img src="/img/redis_set.png" alt="redis设置命令"></p><p>图中的 set 及 hmset 命令均不是 redis_builder 内置的命令，但 redis_builder 依然可以按标准 redis 协议命令将请求发送至 redis 节点。</p><h2 id="四、使用-redis-builder-实时显示当前-redis-集群的运行状态："><a href="#四、使用-redis-builder-实时显示当前-redis-集群的运行状态：" class="headerlink" title="四、使用 redis_builder 实时显示当前 redis 集群的运行状态："></a>四、使用 redis_builder 实时显示当前 redis 集群的运行状态：</h2><p>此外，redis_builder 还提供了以命令行方式实时显示当前 redis 集群的运行状态，显示如下：<br><img src="/img/redis_status.png" alt="redis状态"></p><h2 id="五、编译-redis-builder"><a href="#五、编译-redis-builder" class="headerlink" title="五、编译 redis_builder"></a>五、编译 redis_builder</h2><p>因为该工具依赖于 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$cd</span> lib_acl; make</span><br><span class="hljs-meta"><span class="hljs-keyword">$cd</span> lib_protocol; make</span><br><span class="hljs-meta"><span class="hljs-keyword">$cd</span> lib_acl_cpp; make</span><br></code></pre></td></tr></table></figure><p>然后再进入 app&#x2F;redis_tools&#x2F;redis_builder 编译：$cd app&#x2F;redis_tools&#x2F;redis_builder; make</p><p>六、参考</p><p>redis_builder 工具下载：<a href="https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder">https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder</a><br>acl 中的 redis 模块例子：<a href="https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis</a></p><p>acl on github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>acl on gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>redis使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl 内存池模块管理动态对象</title>
    <link href="/2015/11/15/memory_pool/"/>
    <url>/2015/11/15/memory_pool/</url>
    
    <content type="html"><![CDATA[<p>C&#x2F;C++ 最容易出问题的地方是内存管理，容易造成内存泄露和内存越界，这一直是 C&#x2F;C++ 程序员比较头疼的事情，但 C&#x2F;C++ 最大的优势也是内存管理，可以让程序员直接管理内存，从而使程序运行更为高效。acl 库中的内存池管理器 dbuf_guard 在管理内存的效率上比系统级内存管理方式（malloc&#x2F;free, new&#x2F;delete）更为高效，同时也使内存管理更为健壮性，这可以使 C&#x2F;C++ 程序员避免出现一些常见的内存问题。本节主要介绍了 acl 库中 dbuf_guard 类的设计特点及使用方法。</p><p>dbuf_guard 类内部封装了内存池对象类 dbuf_pool，提供了与 dbuf_pool 一样的内存分配方法，dbuf_guard 类与 dbuf_pool 类的最大区别是 dbuf_guard 类对象既可以在堆上动态分配，也可以在栈上分配，而 dbuf_pool 类对象必须在堆上动态分配，另外，dbuf_guard 类还统一管理在 dbuf_pool 内存池上所创建的所有 dbuf_obj 子类对象，在 dbuf_guard 类对象析构时，所有由其管理的 dbuf_obj 子类对象被统一析构。下面先从一个简单的例子来说明 dbuf_guard 的使用方法，例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 定义一个内存池管理对象</span><br>acl::dbuf_guard dbuf;<br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span>STR<span class="hljs-string">&quot;hello world&quot;</span></span><br><br><span class="hljs-comment">// 在 dbuf 对象上动态创建一个字符串内存</span><br><span class="hljs-type">char</span>* str = dbuf.<span class="hljs-built_in">dbuf_strdup</span>(STR);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str: %s\r\n&quot;</span>, str);<br><br><span class="hljs-comment">// 在 dbuf 对象上动态创建内存</span><br><br><span class="hljs-comment">// sizeof(STR) 取得 STR 所包含的字符串长度 + 1</span><br>str = (<span class="hljs-type">char</span>*) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-built_in">sizeof</span>(STR));<br><span class="hljs-built_in">memcpy</span>(str, STR, <span class="hljs-built_in">sizeof</span>(STR));<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str: %s\r\n&quot;</span>, str);<br><br><span class="hljs-comment">// 在本函数返回前，dbuf 对象自动被销毁，同时释放其所管理的</span><br><span class="hljs-comment">// 内存池以及在内存池上分配的内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子展示了使用 dbuf_guard 类对象直接分配内存块的过程，可以看出，所有在 dbuf_guard 对象的内存池上动态分配的内存都会在 dbuf_guard 对象销毁时被自动释放。这只是一个简单的使用 dbuf_guard 进行内存管理的例子，那么对于 C++ 对象的内存如何进行管理呢？请看下面的的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">myobj</span> : <span class="hljs-keyword">public</span> acl::dbuf_obj<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myobj</span>()<br>&#123;<br><span class="hljs-comment">// 调用系统 API 分配动态内存</span><br>str_ = <span class="hljs-built_in">strdup</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str: %s\r\n&quot;</span>, str_);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* str_;<br><br>~<span class="hljs-built_in">myobj</span>()<br>&#123;<br><span class="hljs-comment">// 释放构造函数中分配的内存，否则会造成内存泄露</span><br><span class="hljs-built_in">free</span>(str_);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>acl::dbuf_guard dbuf;<br><br><span class="hljs-comment">// 调用 dbuf_guard::create&lt;T&gt;() 模板函数创建 myobj 对象</span><br>myobj* obj = dbuf.<span class="hljs-built_in">create</span>&lt;myobj&gt;();<br><br><span class="hljs-comment">// 调用 myobj::run 方法</span><br>obj-&gt;<span class="hljs-built_in">run</span>();<br><br><span class="hljs-comment">// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>该例子展示了 C++ 对象在 dbuf_guard 动态创建的过程，其中有两个要点：</p><ul><li>由 dbuf_guard 对象统一管理的 C++ 对象必须是 dbuf_obj 的子类，这样在 dbuf_guard 类对象的析构时才可以通过调用 dbuf_obj 的析构函数来达到将 dbuf_obj 子类析构的目的（其中 dbuf_obj 的析构函数为虚函数）；</li><li>创建 dbuf_obj 的子类对象时，调用 dbuf_guard 对象的模板函数 create，同时指定子类名称 myobj 来创建 myobj 对象，create 内部会自动将该对象指针加入内部数组对象集合中，从而达到统一管理的目的。</li></ul><p>上面例子的构造函数不带参数，在 dbuf_guard::create 模板函数中允许添加 0  至 10 个参数（其实内部有 11 个 create 模板函数），如果一个构造函数需要多于 10 个参数，则说明该构造函数设计的太复杂了。下面的例子展示了构造函数带参数的类对象创建过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 继承于 acl::dbuf_obj 类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myobj</span> : <span class="hljs-keyword">public</span> acl::dbuf_obj<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myobj</span>(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;myobj, i=%d, j=%d\r\n&quot;</span>, i, j);<br><span class="hljs-comment">// 在内存池上分配动态内存</span><br>str_ = dbuf.<span class="hljs-built_in">dbuf_strdup</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;str: %s\r\n&quot;</span>, str_);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* str_;<br><br>~<span class="hljs-built_in">myobj</span>()<br>&#123;<br><span class="hljs-comment">// 因为 str_ 的内存也是创建在内存池上，所以此处禁止再调用 free 来释放该内存</span><br><span class="hljs-comment">// free(str_);</span><br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>acl::dbuf_guard dbuf;<br><br><span class="hljs-comment">// 调用 dbuf_guard::create&lt;T&gt;(P1, P2) 模板函数创建构造函数带两个参数的 myobj 对象</span><br>myobj* obj = dbuf.<span class="hljs-built_in">create</span>&lt;myobj&gt;(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>);<br><br><span class="hljs-comment">// 调用 myobj::run 方法</span><br>obj-&gt;<span class="hljs-built_in">run</span>();<br><br><span class="hljs-comment">// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁</span><br>&#125;<br></code></pre></td></tr></table></figure><p>在 dbuf_guard 类中除了上面提供的方法外，还提供了以下多个方法方便使用：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 dbuf_pool::dbuf_reset</span><br><span class="hljs-comment"> * @param reserve &#123;size_t&#125;</span><br><span class="hljs-comment"> * @return &#123;bool&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dbuf_reset</span><span class="hljs-params">(<span class="hljs-type">size_t</span> reserve = <span class="hljs-number">0</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> dbuf_-&gt;<span class="hljs-built_in">dbuf_reset</span>(reserve);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 dbuf_pool::dbuf_alloc</span><br><span class="hljs-comment"> * @param len &#123;size_t&#125;</span><br><span class="hljs-comment"> * @return &#123;void*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">dbuf_alloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> dbuf_-&gt;<span class="hljs-built_in">dbuf_alloc</span>(len);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 dbuf_pool::dbuf_calloc</span><br><span class="hljs-comment"> * @param len &#123;size_t&#125;</span><br><span class="hljs-comment"> * @return &#123;void*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">dbuf_calloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> dbuf_-&gt;<span class="hljs-built_in">dbuf_calloc</span>(len);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 dbuf_pool::dbuf_strdup</span><br><span class="hljs-comment"> * @param s &#123;const char*&#125;</span><br><span class="hljs-comment"> * @return &#123;char*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">dbuf_strdup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> dbuf_-&gt;<span class="hljs-built_in">dbuf_strdup</span>(s);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 dbuf_pool::dbuf_strndup</span><br><span class="hljs-comment"> * @param s &#123;const char*&#125;</span><br><span class="hljs-comment"> * @param len &#123;size_t&#125;</span><br><span class="hljs-comment"> * @return &#123;char*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">char</span>* <span class="hljs-title">dbuf_strndup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* s, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> dbuf_-&gt;<span class="hljs-built_in">dbuf_strndup</span>(s, len);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 dbuf_pool::dbuf_memdup</span><br><span class="hljs-comment"> * @param addr &#123;const void*&#125;</span><br><span class="hljs-comment"> * @param len &#123;size_t&#125;</span><br><span class="hljs-comment"> * @return &#123;void*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">dbuf_memdup</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr, <span class="hljs-type">size_t</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> dbuf_-&gt;<span class="hljs-built_in">dbuf_memdup</span>(addr, len);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 dbuf_pool::dbuf_free</span><br><span class="hljs-comment"> * @param addr &#123;const void*&#125;</span><br><span class="hljs-comment"> * @return &#123;bool&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dbuf_free</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> dbuf_-&gt;<span class="hljs-built_in">dbuf_free</span>(addr);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 dbuf_pool::dbuf_keep</span><br><span class="hljs-comment"> * @param addr &#123;const void*&#125;</span><br><span class="hljs-comment"> * @return &#123;bool&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dbuf_keep</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> dbuf_-&gt;<span class="hljs-built_in">dbuf_keep</span>(addr);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用 dbuf_pool::dbuf_unkeep</span><br><span class="hljs-comment"> * @param addr &#123;const void*&#125;</span><br><span class="hljs-comment"> * @return &#123;bool&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">dbuf_unkeep</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* addr)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> dbuf_-&gt;<span class="hljs-built_in">dbuf_unkeep</span>(addr);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得 dbuf_pool 对象</span><br><span class="hljs-comment"> * @return &#123;acl::dbuf_pool&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">acl::dbuf_pool&amp; <span class="hljs-title">get_dbuf</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> *dbuf_;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 可以手动调用本函数，将在 dbuf_pool 上分配的 dbuf_obj 子类对象交给</span><br><span class="hljs-comment"> * dbuf_guard 对象统一进行销毁管理；严禁将同一个 dbuf_obj 子类对象同</span><br><span class="hljs-comment"> * 时将给多个 dbuf_guard 对象进行管理，否则将会产生对象的重复释放</span><br><span class="hljs-comment"> * @param obj &#123;dbuf_obj*&#125;</span><br><span class="hljs-comment"> * @return &#123;int&#125; 返回 obj 被添加后其在 dbuf_obj 对象数组中的下标位置，</span><br><span class="hljs-comment"> *  dbuf_guard 内部对 dbuf_obj 对象的管理具有防重添加机制，所以当多次</span><br><span class="hljs-comment"> *  将同一个 dbuf_obj 对象置入同一个 dbuf_guard 对象时，内部只会放一次</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">push_back</span><span class="hljs-params">(dbuf_obj* obj)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得当前内存池中管理的对象数量</span><br><span class="hljs-comment"> * @return &#123;size_t&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">size_t</span> <span class="hljs-title">size</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> size_;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得当前内存池中管理的对象集合，该函数必须与 size() 函数配合使用，</span><br><span class="hljs-comment"> * 以免指针地址越界</span><br><span class="hljs-comment"> * @return &#123;dbuf_obj**&#125; 返回 dbuf_obj 对象集合，永远返回非 NULL 值，</span><br><span class="hljs-comment"> *  该数组的大小由 size() 函数决定</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">dbuf_obj** <span class="hljs-title">get_objs</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> objs_;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回指定下标的对象</span><br><span class="hljs-comment"> * @param pos &#123;size_t&#125; 指定对象的下标位置，不应越界</span><br><span class="hljs-comment"> * @return &#123;dbuf_obj*&#125; 当下标位置越界时返回 NULL</span><br><span class="hljs-comment"> */</span><br>dbuf_obj* <span class="hljs-keyword">operator</span>[](<span class="hljs-type">size_t</span> pos) <span class="hljs-type">const</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回指定下标的对象</span><br><span class="hljs-comment"> * @param pos &#123;size_t&#125; 指定对象的下标位置，不应越界</span><br><span class="hljs-comment"> * @return &#123;dbuf_obj*&#125; 当下标位置越界时返回 NULL</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">dbuf_obj* <span class="hljs-title">get</span><span class="hljs-params">(<span class="hljs-type">size_t</span> pos)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置内建 objs_ 数组对象每次在扩充空间时的增量，内部缺省值为 100</span><br><span class="hljs-comment"> * @param incr &#123;size_t&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_increment</span><span class="hljs-params">(<span class="hljs-type">size_t</span> incr)</span></span>;<br><br>      同时，dbuf_obj 类中也提供了额外的操作方法：<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得该对象在 dbuf_guard 中的数组中的下标位置</span><br><span class="hljs-comment"> * @return &#123;int&#125; 返回该对象在 dbuf_guard 中的数组中的下标位置，当该</span><br><span class="hljs-comment"> *  对象没有被 dbuf_guard 保存时，则返回 -1，此时有可能会造成内存泄露</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">pos</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> pos_;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 返回构造函数中 dbuf_guard 对象</span><br><span class="hljs-comment"> * @return &#123;dbuf_guard*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">dbuf_guard* <span class="hljs-title">get_guard</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> guard_;<br>&#125;<br></code></pre></td></tr></table></figure><p>最后，以一个稍微复杂的例子做为结尾(该例子源码在 acl 库中的位置：lib_acl_cpp\samples\dbuf\dbuf2)，该例子展示了使用 dbuf_guard 类的几种方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sys/time.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * dbuf_obj 子类，在 dbuf_pool 上动态分配，由 dbuf_guard 统一进行管理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myobj</span> : <span class="hljs-keyword">public</span> acl::dbuf_obj<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myobj</span>(acl::dbuf_guard* guard = <span class="hljs-literal">NULL</span>) : <span class="hljs-built_in">dbuf_obj</span>(guard)<br>&#123;<br>ptr_ = <span class="hljs-built_in">strdup</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;----&gt; run-&gt;hello world &lt;-----\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">char</span>* ptr_;<br><br><span class="hljs-comment">// 将析构声明为私人，以强制要求该对象被动态分配，该析构函数将由</span><br><span class="hljs-comment">// dbuf_guard 统一调用，以释放本类对象中产生的动态内存(ptr_)</span><br>~<span class="hljs-built_in">myobj</span>()<br>&#123;<br><span class="hljs-built_in">free</span>(ptr_);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test_dbuf</span><span class="hljs-params">(acl::dbuf_guard&amp; dbuf)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">102400</span>; i++)<br>&#123;<br><span class="hljs-comment">// 动态分配内存</span><br><span class="hljs-type">char</span>* ptr = (<span class="hljs-type">char</span>*) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">10</span>);<br>(<span class="hljs-type">void</span>) ptr;<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">102400</span>; i++)<br>&#123;<br><span class="hljs-comment">// 动态分配字符串</span><br><span class="hljs-type">char</span>* str = dbuf.<span class="hljs-built_in">dbuf_strdup</span>(<span class="hljs-string">&quot;hello world&quot;</span>);<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">5</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;str-&gt;%s\r\n&quot;</span>, str);<br>&#125;<br><br><span class="hljs-comment">// 动态分配内存</span><br><br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">2048</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">1024</span>);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-number">10240</span>);<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br><span class="hljs-comment">// 动态分配 dbuf_obj 子类对象，并通过将 dbuf_guard 对象传入</span><br><span class="hljs-comment">// dbuf_obj 的构造函数，从而将之由 dbuf_guard 统一管理，</span><br><br>myobj* obj = dbuf.<span class="hljs-built_in">create</span>&lt;myobj&gt;(&amp;dbuf);<br><br><span class="hljs-comment">// 验证 dbuf_obj 对象在 dbuf_guard 中的在在一致性</span><br><span class="hljs-built_in">assert</span>(obj == dbuf[obj-&gt;<span class="hljs-built_in">pos</span>()]);<br><br><span class="hljs-comment">// 调用 dbuf_obj 子类对象 myobj 的函数 run</span><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>)<br>obj-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br>myobj* obj = dbuf.<span class="hljs-built_in">create</span>&lt;myobj&gt;();<br><br><span class="hljs-built_in">assert</span>(dbuf[obj-&gt;<span class="hljs-built_in">pos</span>()] == obj);<br><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>)<br>obj-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++)<br>&#123;<br>myobj* obj = dbuf.<span class="hljs-built_in">create</span>&lt;myobj&gt;(&amp;dbuf);<br><br><span class="hljs-comment">// 虽然多次将 dbuf_obj 对象置入 dbuf_guard 中，因为 dbuf_obj</span><br><span class="hljs-comment">// 内部的引用计数，所以可以防止被重复添加</span><br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">push_back</span>(obj);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">push_back</span>(obj);<br>(<span class="hljs-type">void</span>) dbuf.<span class="hljs-built_in">push_back</span>(obj);<br><br><span class="hljs-built_in">assert</span>(obj == dbuf[obj-&gt;<span class="hljs-built_in">pos</span>()]);<br><br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>)<br>obj-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">wait_pause</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter any key to continue ...&quot;</span>);<br><span class="hljs-built_in">fflush</span>(stdout);<br><span class="hljs-built_in">getchar</span>();<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// dbuf_gaurd 对象创建在栈上，函数返回前该对象自动销毁</span><br>acl::dbuf_guard dbuf;<br><br><span class="hljs-built_in">test_dbuf</span>(dbuf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test2</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 动态创建 dbuf_guard 对象，需要手动销毁该对象</span><br>acl::dbuf_guard* dbuf = <span class="hljs-keyword">new</span> acl::dbuf_guard;<br><br><span class="hljs-built_in">test_dbuf</span>(*dbuf);<br><br><span class="hljs-comment">// 手工销毁该对象</span><br><span class="hljs-keyword">delete</span> dbuf;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test3</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 将内存池对象 dbuf_pool 做为 dbuf_guard 构造函数参数传入，当</span><br><span class="hljs-comment">// dbuf_guard 对象销毁时，dbuf_pool 对象一同被销毁</span><br><span class="hljs-function">acl::dbuf_guard <span class="hljs-title">dbuf</span><span class="hljs-params">(<span class="hljs-keyword">new</span> acl::dbuf_pool)</span></span>;<br><br><span class="hljs-built_in">test_dbuf</span>(dbuf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test4</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 动态创建 dbuf_guard 对象，同时指定内存池中内存块的分配倍数为 10，</span><br><span class="hljs-comment">// 即指定内部每个内存块大小为 4096 * 10 = 40 KB，同时</span><br><span class="hljs-comment">// 指定内部动态数组的初始容量大小</span><br><span class="hljs-function">acl::dbuf_guard <span class="hljs-title">dbuf</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">100</span>)</span></span>;<br><br><span class="hljs-built_in">test_dbuf</span>(dbuf);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test5</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>acl::dbuf_pool* dp = <span class="hljs-keyword">new</span> acl::dbuf_pool;<br><br><span class="hljs-comment">// 在内存池对象上动态创建 dbuf_guard 对象，这样可以将内存分配的次数</span><br><span class="hljs-comment">// 进一步减少一次</span><br>acl::dbuf_guard* dbuf = <span class="hljs-built_in">new</span> (dp-&gt;<span class="hljs-built_in">dbuf_alloc</span>(<span class="hljs-built_in">sizeof</span>(acl::dbuf_guard)))<br>acl::<span class="hljs-built_in">dbuf_guard</span>(dp);<br><br><span class="hljs-built_in">test_dbuf</span>(*dbuf);<br><br><span class="hljs-comment">// 因为 dbuf_gaurd 对象也是在 dbuf_pool 内存池对象上动态创建的，所以</span><br><span class="hljs-comment">// 只能通过直接调用 dbuf_guard 的析构函数来释放所有的内存对象；</span><br><span class="hljs-comment">// 既不能直接 dbuf_pool-&gt;desotry()，也不能直接 delete dbuf_guard 来</span><br><span class="hljs-comment">// 销毁 dbuf_guard 对象</span><br>dbuf-&gt;~<span class="hljs-built_in">dbuf_guard</span>();<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myobj2</span> : <span class="hljs-keyword">public</span> acl::dbuf_obj<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myobj2</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">myobj2</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myobj3</span> : <span class="hljs-keyword">public</span> acl::dbuf_obj<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myobj3</span>(<span class="hljs-type">int</span> i) : <span class="hljs-built_in">i_</span>(i) &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hello world: %d\r\n&quot;</span>, i_);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">myobj3</span>() &#123;&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span> i_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myobj_dummy</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myobj_dummy</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;can&#x27;t be compiled\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>~<span class="hljs-built_in">myobj_dummy</span>() &#123;&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test6</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>acl::dbuf_guard dbuf;<br><br>myobj* o = dbuf.<span class="hljs-built_in">create</span>&lt;myobj&gt;();<br>o-&gt;<span class="hljs-built_in">run</span>();<br><br>myobj* o1 = dbuf.<span class="hljs-built_in">create</span>&lt;myobj&gt;(&amp;dbuf);<br>o1-&gt;<span class="hljs-built_in">run</span>();<br><br>myobj2* o2 = dbuf.<span class="hljs-built_in">create</span>&lt;myobj2&gt;();<br>o2-&gt;<span class="hljs-built_in">run</span>();<br><br>myobj3* o3 = dbuf.<span class="hljs-built_in">create</span>&lt;myobj3&gt;(<span class="hljs-number">10</span>);<br>o3-&gt;<span class="hljs-built_in">run</span>();<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br>myobj3* o4 = dbuf.<span class="hljs-built_in">create</span>&lt;myobj3&gt;(i);<br>o4-&gt;<span class="hljs-built_in">run</span>();<br>&#125;<br><br><span class="hljs-comment">// below codes can&#x27;t be compiled, because myobj_dummy isn&#x27;t</span><br><span class="hljs-comment">// acl::dbuf_obj&#x27;s subclass</span><br><span class="hljs-comment">// myobj_dummy* dummy = dbuf.create&lt;myobj_dummy&gt;();</span><br><span class="hljs-comment">// dummy-&gt;run();</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>acl::log::<span class="hljs-built_in">stdout_open</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-built_in">test1</span>();<br><span class="hljs-built_in">wait_pause</span>();<br><br><span class="hljs-built_in">test2</span>();<br><span class="hljs-built_in">wait_pause</span>();<br><br><span class="hljs-built_in">test3</span>();<br><span class="hljs-built_in">wait_pause</span>();<br><br><span class="hljs-built_in">test4</span>();<br><span class="hljs-built_in">wait_pause</span>();<br><br><span class="hljs-built_in">test5</span>();<br><span class="hljs-built_in">wait_pause</span>();<br><br><span class="hljs-built_in">test6</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>内存管理</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>一个 C++ redis 集群管理工具</title>
    <link href="/2015/04/20/redis_builder/"/>
    <url>/2015/04/20/redis_builder/</url>
    
    <content type="html"><![CDATA[<p>集群版 redis3.0 发布以来，官方仅提供了一个使用 Ruby 写的集群管理工具，在创建 redis 集群时需要使用该工具。因为 Ruby 中的一些包依赖问题，导致一些生手在建立 redis 集群时吃尽了苦头。于是 acl 库作者基于 acl 中的 redis 模块库，用 C++ 语言写了一个 redis 集群管理工具: redis_builder，没有过多的包依赖，可以方便 redis 使用者快速地建立 redis 集群，此外，该工具还可以进行一些集群的其它管理工作。</p><p>下面是 redis_builder 的一些功能：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs stylus">./redis_build -h<br>usage: redis_builder<span class="hljs-selector-class">.exe</span> -h<span class="hljs-selector-attr">[help]</span><br>-s redis_addr<span class="hljs-selector-attr">[ip:port]</span><br>-<span class="hljs-selector-tag">a</span> cmd<span class="hljs-selector-attr">[nodes|slots|create|add_node|del_node|node_id|reshard]</span><br><br>-<span class="hljs-selector-tag">p</span> passwd<br>-N new_node<span class="hljs-selector-attr">[ip:port]</span><br>-S <span class="hljs-selector-attr">[add node as slave]</span><br>-f configure_file<br><br><span class="hljs-keyword">for</span> samples:<br>./redis_builder -s <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span> -<span class="hljs-selector-tag">a</span> create -f cluster<span class="hljs-selector-class">.xml</span><br>./redis_builder -s <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span> -<span class="hljs-selector-tag">a</span> nodes<br>./redis_builder -s <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span> -<span class="hljs-selector-tag">a</span> slots<br>./redis_builder -s <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span> -<span class="hljs-selector-tag">a</span> del_node -I node_id<br>./redis_builder -s <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span> -<span class="hljs-selector-tag">a</span> node_id<br><br>./redis_builder -s <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span> -<span class="hljs-selector-tag">a</span> reshard<br>./redis_builder -s <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6379</span> -<span class="hljs-selector-tag">a</span> add_node -N <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">6380</span> -S<br></code></pre></td></tr></table></figure><p>注：如果集群中的每个 redis 节点设置了密码验证，则使用该工具需要增加参数： -p [passwod]</p><h2 id="一、建立-redis-集群"><a href="#一、建立-redis-集群" class="headerlink" title="一、建立 redis 集群"></a>一、建立 redis 集群</h2><h3 id="1-1、方法一："><a href="#1-1、方法一：" class="headerlink" title="1.1、方法一："></a>1.1、方法一：</h3><p>在启动所有的 redis 进程后，可以使用 redis_builder 将这些 redis 结点组成一个 redis 集群，redis_builder 使用 xml 格式的配置文件管理 redis 各个结点的关系，如该 cluster.xml 文件的内容例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xml</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16380&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16381&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16382&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16383&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16384&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16385&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16386&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16387&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16388&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">node</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xml</span>&gt;</span><br></code></pre></td></tr></table></figure><p>这样就可以运行：.&#x2F;redis_builder -a create -f cluster.xml，则redis 集群便会自动建立起来，集群中主从结点的分布情况如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">master</span>: <span class="hljs-number">192.168.136.172:16380</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.172:16381</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.172:16382</span><br><span class="hljs-attribute">master</span>: <span class="hljs-number">192.168.136.172:16383</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.172:16384</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.172:16385</span><br><span class="hljs-attribute">master</span>: <span class="hljs-number">192.168.136.172:16386</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.172:16387</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.172:16388</span><br></code></pre></td></tr></table></figure><p>这种方式的好处是由配置文件直接指定集群中各个结点的主从关系，缺点是：当 redis 结点非常多时配置管理起来也非常麻烦，因此该工具提供了另外一种 redis 集群创建模式，如方法二：</p><h3 id="1-2、方法二"><a href="#1-2、方法二" class="headerlink" title="1.2、方法二"></a>1.2、方法二</h3><p>运行方式：.&#x2F;redis_builder -a create -f cluster.xml -r 2，其中的 -r 参数指定每个从结点的从结点个数，当指定了 -r 参数后，配置文件中指定的主从关系便不再生效，由工具根据以下三个原则进行主从结点的自动分配：</p><ul><li>主从节点在不同的服务器上</li><li>主节点尽量均分在各个服务器上</li><li>从节点尽量均匀的分在不同的机器上</li></ul><p>如配置文件中的内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span>?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">xml</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.171:16380&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.171:16381&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.171:16382&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16380&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16381&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.172:16382&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.173:16380&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.173:16381&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">node</span> <span class="hljs-attr">addr</span> = <span class="hljs-string">&quot;192.168.136.173:16382&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">xml</span>&gt;</span><br></code></pre></td></tr></table></figure><p>则主从结点的分布情况可能如下：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">master</span>: <span class="hljs-number">192.168.136.171:16380</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.172:16380</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.173:16380</span><br><span class="hljs-attribute">master</span>: <span class="hljs-number">192.168.136.172:16381</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.173:16382</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.171:16382</span><br><span class="hljs-attribute">master</span>: <span class="hljs-number">192.168.136.173:16381</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.172:16382</span><br>        <span class="hljs-attribute">slave</span>: <span class="hljs-number">192.168.136.171:16381</span><br></code></pre></td></tr></table></figure><p>可以看出，主从结点的分配基本满足以上三个原则，这样的好处就是当一台服务出现问题，整个集群中的其它机器的从结点可以顺利接管主结点服务。</p><h2 id="二、显示当前-redis-集群中的结点信息："><a href="#二、显示当前-redis-集群中的结点信息：" class="headerlink" title="二、显示当前 redis 集群中的结点信息："></a>二、显示当前 redis 集群中的结点信息：</h2><p>运行：<code>./redis_builder -s 192.168.136.171:16380 -a nodes</code> 显示如下信息：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">master,</span> <span class="hljs-attr">id:</span> <span class="hljs-string">4dcf8df124888e614cf08bd4df7987986124dd23,</span> <span class="hljs-attr">addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.171</span><span class="hljs-string">：16380</span><br><span class="hljs-attr">slots range:</span> <span class="hljs-number">5462</span><span class="hljs-number">-10922</span><br><span class="hljs-string">slave,</span> <span class="hljs-attr">id:</span> <span class="hljs-string">2b02cda1384336956d22c6c84fbe339210959bcb,</span> <span class="hljs-attr">addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.172</span><span class="hljs-string">:16380,</span> <span class="hljs-attr">master_id:</span> <span class="hljs-string">4dcf8df124888e614cf08bd4df7987986124dd23</span><br><span class="hljs-string">slave,</span> <span class="hljs-attr">id:</span> <span class="hljs-string">a041490f734ca7478330acf5b609c542936214c2,</span> <span class="hljs-attr">addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.173</span><span class="hljs-string">:16380,</span> <span class="hljs-attr">master_id:</span> <span class="hljs-string">4dcf8df124888e614cf08bd4df7987986124dd23</span><br><span class="hljs-string">---------------------------------------</span><br><span class="hljs-string">master,</span> <span class="hljs-attr">id:</span> <span class="hljs-string">bfa250d0f6cae39623515dbce084b904f070fd96,</span> <span class="hljs-attr">addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.172</span><span class="hljs-string">:16381</span><br><span class="hljs-attr">slots range:</span> <span class="hljs-number">10923</span><span class="hljs-number">-16383</span><br><span class="hljs-string">slave,</span> <span class="hljs-attr">id:</span> <span class="hljs-string">4dfd12785d85b8c195c899511ac470aa9a2a4181,</span> <span class="hljs-attr">addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.173</span><span class="hljs-string">:16382,</span> <span class="hljs-attr">master_id:</span> <span class="hljs-string">bfa250d0f6cae39623515dbce084b904f070fd96</span><br><span class="hljs-string">slave,</span> <span class="hljs-attr">id:</span> <span class="hljs-string">fff7ecf70418300e1d41c6bb572c5ba995cc44c3,</span> <span class="hljs-attr">addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.171</span><span class="hljs-string">:16382,</span> <span class="hljs-attr">master_id:</span> <span class="hljs-string">bfa250d0f6cae39623515dbce084b904f070fd96</span><br><span class="hljs-string">---------------------------------------</span><br><span class="hljs-string">master,</span> <span class="hljs-attr">id:</span> <span class="hljs-string">ebecfb9cc3548b17b37f2de94346473baa59721c,</span> <span class="hljs-attr">addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.173</span><span class="hljs-string">:16381</span><br><span class="hljs-attr">slots range:</span> <span class="hljs-number">0</span><span class="hljs-number">-5461</span><br><span class="hljs-string">slave,</span> <span class="hljs-attr">id:</span> <span class="hljs-string">842db09336dee58bbcd13e4a93ee680d96fa9915,</span> <span class="hljs-attr">addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.172</span><span class="hljs-string">:16382,</span> <span class="hljs-attr">master_id:</span> <span class="hljs-string">ebecfb9cc3548b17b37f2de94346473baa59721c</span><br><span class="hljs-string">slave,</span> <span class="hljs-attr">id:</span> <span class="hljs-string">025f58e174f8cd156d1c9621d32956bac2a90032,</span> <span class="hljs-attr">addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.136</span><span class="hljs-number">.171</span><span class="hljs-string">:16381,</span> <span class="hljs-attr">master_id:</span> <span class="hljs-string">ebecfb9cc3548b17b37f2de94346473baa59721c</span><br></code></pre></td></tr></table></figure><h2 id="三、添加新的-redis-结点"><a href="#三、添加新的-redis-结点" class="headerlink" title="三、添加新的 redis 结点"></a>三、添加新的 redis 结点</h2><p>随着数据规模的扩大，如果当前 redis 集群需要添加新的 redis 结点，则可以动态扩充 redis 结点，下面提供了使用 redis_builder 增加新结点的步骤：</p><h3 id="3-1、确定新结点的主结点并给新结点的主结点添加从结点"><a href="#3-1、确定新结点的主结点并给新结点的主结点添加从结点" class="headerlink" title="3.1、确定新结点的主结点并给新结点的主结点添加从结点"></a>3.1、确定新结点的主结点并给新结点的主结点添加从结点</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs dns">./redis_builder -s <span class="hljs-number">192.168.136.171</span>:<span class="hljs-number">16383</span> -N <span class="hljs-number">192.168.136.172</span>:<span class="hljs-number">16383</span> -S -a add_node<br>./redis_builder -s <span class="hljs-number">192.168.136.171</span>:<span class="hljs-number">16383</span> -N <span class="hljs-number">192.168.136.173</span>:<span class="hljs-number">16383</span> -S -a add_node<br></code></pre></td></tr></table></figure><p>该命令确定新增结点的主结点为 192.168.136.171:16383，两个从结点为：192.168.136.172:16383 和 192.168.136.173:16383</p><h3 id="3-2、将新增结点并入已有集群中"><a href="#3-2、将新增结点并入已有集群中" class="headerlink" title="3.2、将新增结点并入已有集群中"></a>3.2、将新增结点并入已有集群中</h3><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">./redis_builder -s <span class="hljs-number">192.168.136.171</span>:<span class="hljs-number">16380</span> -N <span class="hljs-number">192.168.136.171</span>:<span class="hljs-number">15383</span> -a add_node<br></code></pre></td></tr></table></figure><p>这样，便给已有的 redis 集群添加了新的结点，注意步骤 3.2 与 3.1 中参数的不同，在步骤 3.2 中将新结点添加进集群时，只需指定集群中的一个主结点即可，且不能添加 -S 参数。</p><p>在添加完新结点后， 还需要将集群中的其它结点的哈希槽及数据移至新结点上，以便达到数据均衡性。下面给出了数据迁移的过程：</p><h2 id="四、将数据重新分区"><a href="#四、将数据重新分区" class="headerlink" title="四、将数据重新分区"></a>四、将数据重新分区</h2><p>运行：<code>./redis_builder -s 192.168.136.171:16383 -a reshard</code></p><figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs vbnet"><span class="hljs-symbol">addr:</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">136.171</span>:<span class="hljs-number">16380</span><br><br><span class="hljs-symbol">id:</span> <span class="hljs-number">10280</span>b2f2d4938c7f3dffd6a56369f470b34f11adfd<br><span class="hljs-symbol">slots:</span> <span class="hljs-number">2500</span> - <span class="hljs-number">8191</span><br>-----------------------------------------------<br><span class="hljs-symbol">addr:</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">136.172</span>:<span class="hljs-number">16381</span><br><br><span class="hljs-symbol">id:</span> <span class="hljs-number">24664</span>d58862274c8a600dae3be5c6b38998d6824<br><span class="hljs-symbol">slots:</span> <span class="hljs-number">10692</span> - <span class="hljs-number">16383</span><br>-----------------------------------------------<br><span class="hljs-symbol">addr:</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">136.173</span>:<span class="hljs-number">16381</span><br><br><span class="hljs-symbol">id:</span> <span class="hljs-number">5</span>a422ace11d20ed7b3735661bd82d7ff0343164df<br><span class="hljs-symbol">slots:</span> <span class="hljs-number">0</span> - <span class="hljs-number">2499</span><br><span class="hljs-symbol">slots:</span> <span class="hljs-number">8192</span> - <span class="hljs-number">10691</span><br><br>-----------------------------------------------<br><span class="hljs-symbol">addr:</span> <span class="hljs-number">192.168</span>.<span class="hljs-number">136.171</span>:<span class="hljs-number">16383</span><br><br><span class="hljs-symbol">id:</span> <span class="hljs-number">5</span>a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf<br><br>How many slots <span class="hljs-keyword">do</span> you want <span class="hljs-keyword">to</span> move (<span class="hljs-keyword">from</span> <span class="hljs-number">1</span> <span class="hljs-keyword">to</span> <span class="hljs-number">16384</span>) ? <span class="hljs-number">2000</span>       ------  此处指定需要迁移的哈希槽数量<br><br>What <span class="hljs-built_in">is</span> the receiving node ID?  <span class="hljs-number">5</span>a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf   ----- 此处指定目标 redis 结点<br><br>Please input all the source node IDs.<br>  Type <span class="hljs-comment">&#x27;all&#x27; to use all the nodes as source nodes for the hash slots</span><br>  Type <span class="hljs-comment">&#x27;done&#x27; once you entered all the source node IDs.</span><br>Source node #<span class="hljs-number">1</span>:<br></code></pre></td></tr></table></figure><p>输入 all 后 redis_builder 工具会自动将数据从所有已存在结点中将哈希槽及存储于哈希槽中的数据迁移至目标结点中。</p><h2 id="五、编译-redis-builder"><a href="#五、编译-redis-builder" class="headerlink" title="五、编译 redis_builder"></a>五、编译 redis_builder</h2><p>因为该工具依赖于 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-meta"><span class="hljs-keyword">$cd</span> lib_acl; make</span><br><span class="hljs-meta"><span class="hljs-keyword">$cd</span> lib_protocol; make</span><br><span class="hljs-meta"><span class="hljs-keyword">$cd</span> lib_acl_cpp; make</span><br></code></pre></td></tr></table></figure><p>然后再进入 app&#x2F;redis_tools&#x2F;redis_builder 编译：</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs awk"><span class="hljs-variable">$cd</span> app<span class="hljs-regexp">/redis_tools/</span>redis_builder; make<br></code></pre></td></tr></table></figure><h2 id="六、参考"><a href="#六、参考" class="headerlink" title="六、参考"></a>六、参考</h2><p>redis_builder 的工具下载：<a href="https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder">https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder</a></p><p>acl 中的 redis 模块例子：<a href="https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis</a></p><p>acl on github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>acl on gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>redis使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl 库编写高效的 C++ redis 客户端应用</title>
    <link href="/2015/02/10/redis_client/"/>
    <url>/2015/02/10/redis_client/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>（可以直接略过此段）redis 最近做为 nosql 数据服务应用越来越广泛，其相对于 memcached 的最大优点是提供了更加丰富的数据结构，所以应用场景就更为广泛。redis 的出现可谓是广大网络应用开发者的福音，同时有大量的开源人员贡献了客户端代码，象针对 java 语言的 jedis，php 语言的 phpredis&#x2F;predis 等，这些语言的 redis 库既丰富又好用，而对 C&#x2F;C++ 程序员似乎就没那么幸运了，官方提供了 C 版的 hiredis 作为客户端库，很多爱好者都是基于 hiredis 进行二次封装和开发形成了 C++ 客户端库，但这些库（包括官方的 hiredis）大都使用麻烦，给使用者造成了许多出错的机会。一直想开发一个更易用的接口型的 C++ 版 redis 客户端库（注：官方提供的库基本属于协议型的，这意味着使用者需要花费很多精力去填充各个协议字段同时还得要分析服务器可能返回的不同的结果类型），但每当看到 redis 那 150 多个客户端命令时便心生退缩，因为要给每个命令提供一个方便易用的 C++ 函数接口，则意味着非常巨大的开发工作量。</p><p>在后来的多次项目开发中被官方的 hiredis 库屡次摧残后，终于忍受不了，决定重新开发一套全新的 redis 客户端 API，该库不仅要实现这 150 多个客户端命令，同时需要提供方便灵活的连接池及连接池集群管理功能（幸运的是在 acl 库中已经具备了通用的网络连接池及连接池集群管理模块），另外，根据之前的实践，有可能提供的函数接口要远大于这 150 多个，原因是针对同一个命令可能会因为不同的参数类型场景提供多个函数接口（最终的结果是提供了3，4百个函数 API，7000+行源码，2000+行头文件）；在仔细研究了 redis 的通信协议后便着手开始进行设计开发了（redis 的协议设计还是非常简单实用的，即能支持二进制，同时又便于手工调试）。在开发过程中大量参考了 <a href="http://redisdoc.com/">http://redisdoc.com</a> 网站上的中文在线翻译版（非常感谢 黄键宏 同学的辛勤工作）。</p><h2 id="二、acl-redis-库分类"><a href="#二、acl-redis-库分类" class="headerlink" title="二、acl redis 库分类"></a>二、acl redis 库分类</h2><p>根据 redis 的数据结构类型，分成 12 个大类，每个大类提供不同的函数接口，这 12 个 C++ 类展示如下：</p><ol><li>redis_key：redis 所有数据类型的统一键操作类；因为 redis 的数据结构类型都是基本的 KEY-VALUE 类型，其中 VALUE 分为不同的数据结构类型；</li><li>redis_connectioin：与 redis-server 连接相关的类；</li><li>redis_server：与 redis-server 服务管理相关的类；</li><li>redis_string：redis 中用来表示字符串的数据类型；</li><li>redis_hash：redis 中用来表示哈希表的数据类型；每一个数据对象由 “KEY-域值对集合” 组成，即一个 KEY 对应多个“域值对”，每个“域值对”由一个字段名与字段值组成；</li><li>redis_list：redis 中用来表示列表的数据类型；</li><li>redis_set：redis 中用来表示集合的数据类型；</li><li>redis_zset：redis 中用来表示有序集合的数据类型；</li><li>redis_pubsub：redis 中用来表示“发布-订阅”的数据类型；</li><li>redis_hyperloglog：redis 中用来表示 hyperloglog 基数估值算法的数据类型；</li><li>redis_stream：redis 中用来处理消息队列的数据类型；</li><li>redis_script：redis 中用来与 lua 脚本进行转换交互的数据类型；</li><li>redis_transaction：redis 中用以事务方式执行多条 redis 命令的数据类型（注：该事务处理方式与数据库的事务有很大不同，redis 中的事务处理过程没有数据库中的事务回滚机制，仅能保证其中的多条命令都被执行或都不被执行）；</li></ol><p>除了以上对应于官方 redis 命令的 12 个类别外，在 acl 库中还提供了另外几个类：</p><ol start="14"><li>redis_command：以上 12 个类的基类；</li><li>redis_client：redis 客户端网络连接类；</li><li>redis_result：redis 命令结果类；</li><li>redis_pool：针对以上所有命令支持连接池方式；</li><li>redis_manager：针对以上所有命令允许与多个 redis-server 服务建立连接池集群（即与每个 redis-server 建立一个连接池）；</li><li>redis_cluster：支持 redis3.0 集群模式的类。</li></ol><h2 id="三、acl-redis-使用举例"><a href="#三、acl-redis-使用举例" class="headerlink" title="三、acl redis 使用举例"></a>三、acl redis 使用举例</h2><h3 id="3-1、下面是一个使用-acl-框架中-redis-客户端库的简单例子："><a href="#3-1、下面是一个使用-acl-框架中-redis-客户端库的简单例子：" class="headerlink" title="3.1、下面是一个使用 acl 框架中 redis 客户端库的简单例子："></a>3.1、下面是一个使用 acl 框架中 redis 客户端库的简单例子：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param conn &#123;acl::redis_client&amp;&#125; redis 连接对象</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 操作过程是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test_redis_string</span><span class="hljs-params">(acl::redis_client&amp; conn, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key)</span> </span>&#123;<br><span class="hljs-comment">// 创建 redis string 类型的命令操作类对象，同时将连接类对象与操作类</span><br><span class="hljs-comment">// 对象进行绑定</span><br><span class="hljs-function">acl::redis_string <span class="hljs-title">string_operation</span><span class="hljs-params">(&amp;conn)</span></span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* value = <span class="hljs-string">&quot;test_value&quot;</span>;<br><br><span class="hljs-comment">// 添加 K-V 值至 redis-server 中</span><br><span class="hljs-keyword">if</span> (string_operation.<span class="hljs-built_in">set</span>(key, value) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-type">const</span> acl::redis_result* res = string_operation.<span class="hljs-built_in">get_result</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set key: %s error: %s\r\n&quot;</span>,<br>key, res ? res-&gt;<span class="hljs-built_in">get_error</span>() : <span class="hljs-string">&quot;unknown error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set key: %s ok!\r\n&quot;</span>, key);<br><br><span class="hljs-comment">// 需要重置连接对象的状态</span><br>string_operation.<span class="hljs-built_in">clear</span>();<br><br><span class="hljs-comment">// 从 redis-server 中取得对应 key 的值</span><br>acl::string buf;<br><span class="hljs-keyword">if</span> (string_operation.<span class="hljs-built_in">get</span>(key, buf) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-type">const</span> acl::redis_result* res = string_operation.<span class="hljs-built_in">get_result</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get key: %s error: %s\r\n&quot;</span>,<br>key, res ? res-&gt;<span class="hljs-built_in">get_error</span>() : <span class="hljs-string">&quot;unknown error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get key: %s ok, value: %s\r\n&quot;</span>, key, buf.<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-comment">// 探测给定 key 是否存在于 redis-server 中，需要创建 redis 的 key</span><br><span class="hljs-comment">// 类对象，同时将 redis 连接对象与之绑定</span><br>acl::redis_key key_operation;<br>key_operation.<span class="hljs-built_in">set_client</span>(conn);  <span class="hljs-comment">// 将连接对象与操作对象进行绑定</span><br><span class="hljs-keyword">if</span> (key_operation.<span class="hljs-built_in">exists</span>(key) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">if</span> (conn.<span class="hljs-built_in">eof</span>()) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;disconnected from redis-server\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key: %s not exists\r\n&quot;</span>, key);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;key: %s exists\r\n&quot;</span>, key);<br>&#125;<br><br><span class="hljs-comment">// 删除指定 key 的字符串类对象</span><br><span class="hljs-keyword">if</span> (key_operation.<span class="hljs-built_in">del</span>(key, <span class="hljs-literal">NULL</span>) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;del key: %s error\r\n&quot;</span>, key);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;del key: %s ok\r\n&quot;</span>, key);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param redis_addr &#123;const char*&#125; redis-server 服务器地址，</span><br><span class="hljs-comment"> *  格式为：ip:port，如：127.0.0.1:6379</span><br><span class="hljs-comment"> * @param conn_timeout &#123;int&#125; 连接 redis-server 的超时时间(秒)</span><br><span class="hljs-comment"> * @param rw_timeout &#123;int&#125; 与 redis-server 进行通信的 IO 超时时间(秒)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test_redis</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* redis_addr, <span class="hljs-type">int</span> conn_timeout, <span class="hljs-type">int</span> rw_timeout)</span> </span>&#123;<br><span class="hljs-comment">// 创建 redis 客户端网络连接类对象</span><br><span class="hljs-function">acl::redis_client <span class="hljs-title">conn</span><span class="hljs-params">(redis_addr, conn_timeout, rw_timeout)</span></span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* key = <span class="hljs-string">&quot;test_key&quot;</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">test_redis_string</span>(conn, key);<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的简单例子的操作过程是：在 redis-server 中添加字符串类型数据 –&gt; 从 redis-server 中获取指定的字符串数据 –&gt; 判断指定指定 key 的对象在 redis-server 上是否存在 —&gt; 从 redis-server 中删除指定 key 的数据对象（即该例中的字符串对象）。通过以上简单示例，使用者需要注意以下几点：</p><ul><li>acl 中的 redis 库的设计中 redis 连接类对象与命令操作类对象是分离的，12 个 redis 命令操作类对应 acl  redis 库中相应的 12 个命令操作类；</li><li>在使用 redis 命令操作类时需要先将 redis 连接类对象与命令操作类对象进行绑定（以便于操作类内部可以利连接类中的网络连接、协议组包以及协议解析等方法）；</li><li>在重复使用一个 redis 命令类对象时，需要首先重置该命令类对象的状态（即调用：clear()），这样主要是为了释放上一次命令操作过程的中间内存资源；</li><li>一个 redis 连接类对象可以被多个命令类操作类对象使用（使用前需先绑定一次）；</li><li>将 redis 连接对象与命令操作对象绑定有两种方式：可以在构造函数中传入非空 redis 连接对象，或调用操作对象的 set_client 方法进行绑定。</li></ul><h3 id="3-2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下："><a href="#3-2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：" class="headerlink" title="3.2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下："></a>3.2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param conn &#123;acl::redis_client&amp;&#125; redis 连接对象</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 操作过程是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test_redis_string</span><span class="hljs-params">(acl::redis_client&amp; conn, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key)</span> </span>&#123;<br>...... <span class="hljs-comment">// 代码与上述代码相同，省略</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 子线程处理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test_thread</span> : <span class="hljs-keyword">public</span> acl::thread &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">test_thread</span>(acl::redis_pool&amp; pool) : <span class="hljs-built_in">pool_</span>(pool) &#123;&#125;<br><br>~<span class="hljs-built_in">test_thread</span>() &#123;&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类（acl::thread）纯虚函数</span><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>acl::string key;<br><span class="hljs-comment">// 给每个线程一个自己的 key，以便以测试，其中 thread_id()</span><br><span class="hljs-comment">// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号</span><br>key.format(<span class="hljs-string">&quot;test_key: %lu&quot;</span>, <span class="hljs-built_in">thread_id</span>());<br><br>acl::redis_client* conn;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br><span class="hljs-comment">// 从 redis 客户端连接池中获取一个 redis 连接对象</span><br>conn = (acl::redis_client*) pool_.<span class="hljs-built_in">peek</span>();<br><span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;peek redis connection error\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 进行 redis 客户端命令操作过程</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">test_redis_string</span>(*conn) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;redis operation error\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 回收连接对象</span><br>pool_.<span class="hljs-built_in">put</span>(conn, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::redis_pool&amp; pool_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_redis_pool</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* redis_addr, <span class="hljs-type">int</span> max_threads,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> conn_timeout, <span class="hljs-type">int</span> rw_timeout)</span> </span>&#123;<br><span class="hljs-comment">// 创建 redis 连接池对象</span><br><span class="hljs-function">acl::redis_client_pool <span class="hljs-title">pool</span><span class="hljs-params">(redis_addr, max_threads)</span></span>;<br><span class="hljs-comment">// 设置连接 redis 的超时时间及 IO 超时时间，单位都是秒</span><br>pool.<span class="hljs-built_in">set_timeout</span>(conn_timeout, rw_timeout);<br><br><span class="hljs-comment">// 创建一组子线程</span><br>std::vector&lt;test_thread*&gt; threads;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max_threads; i++) &#123;<br>test_thread* thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">test_thread</span>(pool);<br>threads.<span class="hljs-built_in">push_back</span>(thread);<br>thread-&gt;<span class="hljs-built_in">set_detachable</span>(<span class="hljs-literal">false</span>);<br>thread-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-comment">// 等待所有子线程正常退出</span><br>std::vector&lt;test_thread*&gt;::iterator it = threads.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != threads.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>(*it)-&gt;<span class="hljs-built_in">wait</span>();<br><span class="hljs-built_in">delete</span> (*it);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>除了创建线程及 redis 连接池外，上面的例子与示例 1） 的代码与功能无异。</p><h3 id="3-3、下面对上面的示例2）稍作修改，使之可以支持-redis-集群连接池的方式，示例代码如下："><a href="#3-3、下面对上面的示例2）稍作修改，使之可以支持-redis-集群连接池的方式，示例代码如下：" class="headerlink" title="3.3、下面对上面的示例2）稍作修改，使之可以支持 redis 集群连接池的方式，示例代码如下："></a>3.3、下面对上面的示例2）稍作修改，使之可以支持 redis 集群连接池的方式，示例代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * @param conn &#123;acl::redis_client&amp;&#125; redis 连接对象</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 操作过程是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">test_redis_string</span><span class="hljs-params">(acl::redis_client&amp; conn, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* key)</span> </span>&#123;<br>......  <span class="hljs-comment">// 与上面示例代码相同，略去</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 子线程处理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test_thread</span> : <span class="hljs-keyword">public</span> acl::thread &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">test_thread</span>(acl::redis_cluster&amp; cluster) : <span class="hljs-built_in">cluster_</span>(cluster) &#123;&#125;<br><br>~<span class="hljs-built_in">test_thread</span>() &#123;&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类（acl::thread）纯虚函数</span><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>acl::string key;<br>acl::redis_client_pool* pool;<br>acl::redis_client* conn;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br><span class="hljs-comment">// 从连接池集群管理器中获得一个 redis-server 的连接池对象</span><br>pool = (acl::redis_client_pool*) cluster_.<span class="hljs-built_in">peek</span>();<br><span class="hljs-keyword">if</span> (pool == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;peek connection pool failed\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 从 redis 客户端连接池中获取一个 redis 连接对象</span><br>conn = (acl::redis_client*) pool_.<span class="hljs-built_in">peek</span>();<br><span class="hljs-keyword">if</span> (conn == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;peek redis connection error\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 给每个线程一个自己的 key，以便以测试，其中 thread_id()</span><br><span class="hljs-comment">// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号</span><br>key.format(<span class="hljs-string">&quot;test_key: %lu_%d&quot;</span>, <span class="hljs-built_in">thread_id</span>(), i);<br><span class="hljs-comment">// 进行 redis 客户端命令操作过程</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">test_redis_string</span>(*conn, key.<span class="hljs-built_in">c_str</span>()) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;redis operation error\r\n&quot;</span>);<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 回收连接对象至连接池中</span><br>pool_.<span class="hljs-built_in">put</span>(conn, <span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::redis_cluster&amp; cluster_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_redis_manager</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* redis_addr, <span class="hljs-type">int</span> max_threads,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">int</span> conn_timeout, <span class="hljs-type">int</span> rw_timeout)</span> </span>&#123;<br><span class="hljs-comment">// 创建 redis 集群连接池对象</span><br>acl::redis_client_cluster cluster;<br><br><span class="hljs-comment">// 添加多个 redis-server 的服务器实例地址</span><br>cluster.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>, max_threads, conn_timeout, rw_timeout);<br>cluster.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;127.0.0.1:6380&quot;</span>, max_threads, conn_timeout, rw_timeout);<br>cluster.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;127.0.0.1:6381&quot;</span>, max_threads, conn_timeout, rw_timeout);<br><br><span class="hljs-comment">// 创建一组子线程</span><br>std::vector&lt;test_thread*&gt; threads;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max_threads; i++) &#123;<br>test_thread* thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">test_thread</span>(cluster);<br>threads.<span class="hljs-built_in">push_back</span>(thread);<br>thread-&gt;<span class="hljs-built_in">set_detachable</span>(<span class="hljs-literal">false</span>);<br>thread-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-comment">// 等待所有子线程正常退出</span><br>std::vector&lt;test_thread*&gt;::iterator it = threads.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != threads.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>(*it)-&gt;<span class="hljs-built_in">wait</span>();<br><span class="hljs-built_in">delete</span> (*it);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该示例只修改了几处代码便支持了集群 redis 连接池方式，其处理过程是：创建集群连接池对象（可以添加多个 redis-server 服务地址） –&gt; 从集群连接池对象中取得一个连接池对象 —&gt; 从该连接池对象中取得一个连接 —&gt; 该连接对象与 redis 操作类对象绑定后进行操作。</p><p>上述示例的集群模式并非是 redis3.0 的集群模式，这种集群中的 redis-server 之间是不互联的， 集群的建立是由客户端来维护的，由客户决定数据存储在哪个 redis-server 实例上；而 redis3.0 的集群方式则与之大不同，在 redis3.0 中，redis-server 之间是互联互通的，而且支持数据的冗余备份，数据的存储位置是由服务端决定的，下面的例子是支持 redis3.0 集群模式的客户端例子：</p><h3 id="3-4、支持-redis3-0-集群模式的示例代码如下："><a href="#3-4、支持-redis3-0-集群模式的示例代码如下：" class="headerlink" title="3.4、支持 redis3.0 集群模式的示例代码如下："></a>3.4、支持 redis3.0 集群模式的示例代码如下：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 统一的键值前缀</span><br><span class="hljs-type">static</span> acl::string __keypre(<span class="hljs-string">&quot;test_key_cluster&quot;</span>);<br><br><span class="hljs-comment">// 测试 redis 字符串添加功能</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">test_redis_string</span><span class="hljs-params">(acl::redis_string&amp; cmd, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>acl::string key;<br>key.format(<span class="hljs-string">&quot;%s_%d&quot;</span>, __keypre.<span class="hljs-built_in">c_str</span>(), i);<br><br>acl::string value;<br>value.format(<span class="hljs-string">&quot;value_%s&quot;</span>, key.<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-type">bool</span> ret = cmd.<span class="hljs-built_in">set</span>(key.<span class="hljs-built_in">c_str</span>(), value.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">return</span> ret;<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;set key: %s, value: %s %s\r\n&quot;</span>, key.<span class="hljs-built_in">c_str</span>(),<br>value.<span class="hljs-built_in">c_str</span>(), ret ? <span class="hljs-string">&quot;ok&quot;</span> : <span class="hljs-string">&quot;error&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-comment">// 测试 redis 键是否存在功能</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">test_redis_exists</span><span class="hljs-params">(acl::redis_key&amp; cmd, <span class="hljs-type">int</span> i)</span> </span>&#123;<br>acl::string key;<br><br>key.format(<span class="hljs-string">&quot;%s_%d&quot;</span>, __keypre.<span class="hljs-built_in">c_str</span>(), i);<br><br><span class="hljs-keyword">if</span> (cmd.<span class="hljs-built_in">exists</span>(key.<span class="hljs-built_in">c_str</span>()) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;no exists key: %s\r\n&quot;</span>, key.<span class="hljs-built_in">c_str</span>());<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">10</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;exists key: %s\r\n&quot;</span>, key.<span class="hljs-built_in">c_str</span>());<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 子线程处理类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">test_thread</span> : <span class="hljs-keyword">public</span> acl::thread &#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">test_thread</span>(acl::redis_cluster&amp; cluster) : <span class="hljs-built_in">cluster_</span>(cluster) &#123;&#125;<br><br>~<span class="hljs-built_in">test_thread</span>() &#123;&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类（acl::thread）纯虚函数</span><br><span class="hljs-comment">// @override</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>acl::redis_string cmd_string;<br>acl::redis_key  cmd_key;<br><br><span class="hljs-comment">// 设置 redis 客户端命令的集群操作模式</span><br>cmd_key.<span class="hljs-built_in">set_cluster</span>(&amp;cluster_);<br>cmd_string.<span class="hljs-built_in">set_cluster</span>(&amp;cluster_);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;<br><span class="hljs-comment">// 进行 redis 客户端命令操作过程</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">test_redis_string</span>(cmd_string, i) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">test_redis_exists</span>(cmd_key, i) == <span class="hljs-literal">false</span>) &#123;<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 重置客户端命令状态</span><br><br>cmd_string.<span class="hljs-built_in">clear</span>();<br>cmd_key.<span class="hljs-built_in">clear</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::redis_cluster&amp; cluster_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test_redis_cluster</span><span class="hljs-params">(<span class="hljs-type">int</span> max_threads <span class="hljs-type">int</span> conn_timeout, <span class="hljs-type">int</span> rw_timeout)</span> </span>&#123;<br><span class="hljs-comment">// 创建 redis 集群连接池对象</span><br>acl::redis_client_cluster cluster;<br><br><span class="hljs-comment">// 添加一个或多个 redis-server 的服务器实例地址，不必一次加载所有</span><br><span class="hljs-comment">// 的 redis-server 服务器地址，redis_cluster 及相关类具有自动发现</span><br><span class="hljs-comment">// 及动态添加 redis-server 服务实例的功能</span><br><br>cluster.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>, max_threads, conn_timeout, rw_timeout);<br><span class="hljs-comment">// cluster.set(&quot;127.0.0.1:6380&quot;, max_threads, conn_timeout, rw_timeout);</span><br><span class="hljs-comment">// cluster.set(&quot;127.0.0.1:6381&quot;, max_threads, conn_timeout, rw_timeout);</span><br><br><span class="hljs-comment">// 创建一组子线程</span><br>std::vector&lt;test_thread*&gt; threads;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; max_threads; i++) &#123;<br>test_thread* thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">test_thread</span>(cluster);<br>threads.<span class="hljs-built_in">push_back</span>(thread);<br>thread-&gt;<span class="hljs-built_in">set_detachable</span>(<span class="hljs-literal">false</span>);<br>thread-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-comment">// 等待所有子线程正常退出</span><br>std::vector&lt;test_thread*&gt;::iterator it = threads.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; it != threads.<span class="hljs-built_in">end</span>(); ++it) &#123;<br>(*it)-&gt;<span class="hljs-built_in">wait</span>();<br><span class="hljs-built_in">delete</span> (*it);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面例子可以看出，使用 acl redis 客户端库操作 redis3.0 集群时，只需要将集群的句柄注入到每个 redis 客户端命令即（如上面黄色部分所示）；至于如何与 redis 集群交互将由 redis_cluster 及 redis 客户端命令类的基类 redis_command 进行处理；此外，还需要注意示例 4）与示例 3）所支持的集群方式的不同点如下：</p><ul><li>示例3 的集群模式下实际上是由客户端根据所连接的所有 redis 服务器的集合来决定数据存储结点，而实际上 redis 服务器之间并不互联；而示例 4 则是真正意义的 redis 服务端的集群模式，所有 redis 服务结点之间是互联互通的（可以配置数据结点存储的冗余数量）；</li><li>示例3 的客户端必须在开始初始化时添加所有的 redis 服务结点，以便于采用轮循或者哈希访问模式；而示例4 在初始化时只需添加至少一个集群中的服务结点即可，随着访问次数的增加，会根据需要动态添加 redis 服务结点（ redis3.0 采用的重定向机制，即当访问某个 redis 结点时，若 key 值不存在于该结点上，则其会返回给客户端一个重定向指令，告诉客户端存储该 key 的 redis 服务结点，因此，根据此特性，acl redis 集群会根据重定向信息动态添加 redis 集群中的服务结点）；</li><li>此外，示例4 是兼容示例3 的。</li></ul><h3 id="3-5、使用-redis-pipeline-方式连接-redis3-0-集群"><a href="#3-5、使用-redis-pipeline-方式连接-redis3-0-集群" class="headerlink" title="3.5、使用 redis pipeline 方式连接 redis3.0 集群"></a>3.5、使用 redis pipeline 方式连接 redis3.0 集群</h3><p>虽然在 <strong>3.4）</strong> 节中提到的使用 redis 集群的通信方式具有非常高的性能，但 redis-server 支持的 pipeline 模式具有更高的性能，为此 Acl redis client 也增加了以 pipeline 方式访问 redis-server 的模式，若要使用 pipeline 方式，仅需创建 <code>acl::redis_client_pipeline</code> 通信对象，并将其传递给 redis 命令对象即可。</p><p>下面是创建并启动 redis pipeline 方式的过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* redis_addr = <span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>;<br><br><span class="hljs-function">acl::redis_client_pipeline <span class="hljs-title">pipeline</span><span class="hljs-params">(redis_addr)</span></span>;<br>pipeline.<span class="hljs-built_in">start</span>();  <span class="hljs-comment">// 创建独立线程并启动 pipeline 模式</span><br></code></pre></td></tr></table></figure><p>redis pipeline 对象传入 redis 命令对象后，就可以使用了，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">(acl::redis_client_pipeline&amp; pipeline)</span> </span>&#123;<br><span class="hljs-function">acl::redis <span class="hljs-title">cmd</span><span class="hljs-params">(&amp;pipeline)</span></span>;<br>...<br><span class="hljs-comment">// 或：</span><br><span class="hljs-comment">// acl::redis cmd;</span><br><span class="hljs-comment">// cmd.set_pipeline(&amp;pipeline);</span><br></code></pre></td></tr></table></figure><p>对比以上所有例子可以看出，Acl redis client 这种将命令对象与通信对象分离的设计方式具有很好的灵活性和通用性，每个命令对象只需根据需要设置不同的通信对象后，则后面的操作就完全相同了，这样给初期使用 acl::redis_client_cluster 类对象的用户迁移到使用 acl::redis_client_pipeline 提供了便利。</p><p>在实践中相较于 acl::redis_client_cluster 而言，acl::redis_client_pipeline 的优势为：</p><ul><li><strong>具有更高的性能：</strong> 在高并发环境中使用 pipeline 方式，性能获得数倍的提升；</li><li><strong>更少的连接数：</strong> 在 pipeline 方式下，应用程序与每个 redis-server 节点仅维护一个连接；</li><li><strong>redis-server性能更高：</strong> 在 pipeline 方式下，每个 redis-server 的客户端 TCP 连接数更少，通信能力更强，所以 redis-server 的性能也更高。</li></ul><p>但 pipeline 方式也有一些局限性，对于一些可能的“持久性”等待类的 redis 命令是不能用 pipeline 方式的，因为在 Acl pipeline 的实现中，与每个 redis-server 节点仅维护一个连接，则如果发送的 redis 命令中存在阻塞式操作，则会挂起该连接，另外该阻塞式命令的响应返回顺序可能与请求的顺序不同，导致无法区分 redis 服务端返回的结果对应哪个请求命令。目前在 Acl redis 库中不能使用 pipeline 的函数有：</p><ul><li>acl::redis_pubsub: get_message();</li><li>acl::redis_list: blpop(), brpop(), brpoplpush();</li><li>acl::redis_stream: xread(), xreadgroup(), xreadgroup_with_noack();</li></ul><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>以上介绍了 acl 框架中新增加的 redis 库的使用方法及处理过程，该库将复杂的协议及网络处理过程隐藏在实现内部，使用户使用起来感觉象是在调用本的函数。在示例 2）、3） 中提到了 acl 线程的使用，有关 acl 库中更为详细地使用线程的文章参见：《使用 acl_cpp 库编写多线程程序》。</p><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>redis使用</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl 服务器框架编写负载均衡的应用服务</title>
    <link href="/2014/09/20/server_loadbalance/"/>
    <url>/2014/09/20/server_loadbalance/</url>
    
    <content type="html"><![CDATA[<p>acl 服务器框架的几种服务器模型（进程模型，多线程模型，非阻塞模型，协程模型，触发器模型，UDP通信模型）中，使用比较多的是多线程模型、协程模块及非阻塞模型，这三种模型可以配置成启动多个进程实例（即成为：多进程多线程、多进程多协程及多进程非阻塞），但在实际应用中因为系统 TCP 连接分配的不均匀性，会导致每个进程实例的 TCP 连接数极不均匀甚至相差很大的问题（便出现了有的进程“撑死”，有的进程“饿死“的现象），acl 服务器框架提供了一个 TCP 连接分配器，该分配器负责接收外来 TCP 连接，然后将该 TCP 连接的文件句柄通过 UNIX 域套接字”平均传递给“后端的每一个子进程，从而保证了应用服务器进程池中的每个进程实例都能获得相等数量的 TCP 连接，从而达到负载均衡的目的。<br><img src="/img/loadbalance.png" alt="server_loadbalance"><br>如上图所示，整个网络连接处理过程如下：</p><ul><li><p>在 acl_master 服务器框架下启动两个服务：TCP连接分配器和应用服务进程</p></li><li><p>TCP 连接分配器监听两个地址：一个是网络地址（如：192.168.188.1:80)和一个本机的 UNIX 域套接字（如：&#x2F;opt&#x2F;acl&#x2F;var&#x2F;private&#x2F;dispatch.sock）</p><p>注：acl 服务器框架支持同时监听多个网络地址或 UNIX 域套口地址，参见：使用 acl 服务器框架编写监听多个地址的服务器程序</p></li><li><p>应用服务的每个进程通过该 UNIX 域套接口连接 TCP 连接分配器：</p><ul><li>通过该连接向TCP连接分配器报告自己当前的 TCP 连接数</li><li>在该UNIX套接口接收TCP连接分配器发送的客户端TCP连接的套接字句柄</li></ul></li><li><p>客户端通过网络连接 TCP 连接分配器监听的网络地址</p></li><li><p>TCP 连接分配器从后端进程池中选取一个连接数最少的进程，并通过与该进程的 UNIX 套接字将客户端的 TCP 连接句柄传递给该进程</p></li><li><p>后端获得 TCP 连接分配器传递来的 TCP 连接句柄，从而与前端客户端建立联系，开始处理客户端的请求。</p></li></ul><p>通过以上处理流程，就可以保证客户端连接可以均匀地分配给后端服务进程池中的每一个进程实例，这样，每个进程实例占用的系统资源（如：CPU、内存、IO 等）就相对比较均匀。</p><p>在 UNIX&#x2F;LINUX 平台下，通过 UNIX 域套接字传递描述字过程是由内核完成的，应用层只需负责相关的系统 API 调用即可，如何使用系统 API 传递描述字可以参考 acl 库中的 lib_acl&#x2F;src&#x2F;stdlib&#x2F;sys&#x2F;unix&#x2F;acl_transfer_fd.c 源文件。</p><p>另外，上面所提的 TCP 连接分配器是使用 acl 服务器框架中的非阻塞服务模型编写的一个服务器程序，具体实现在 app&#x2F;master_dispatch&#x2F;server 目录下；应用服务器程序可以使用 acl 服务器框架中的线程池模型或非阻塞模型编写。</p><p>在部署时，需要将 TCP 连接分配器(app&#x2F;master_dispatch&#x2F;server&#x2F;master_dispatch) 及用户自己写的服务器程序拷贝到执行目录下，在应用自己的服务器程序中需要将配置文件中的域接口连接地址打开（对于线程池模型需要打开 ioctl_dispatch_addr 配置项，对于非阻塞模型需要打开 aio_dispatch_addr 配置项）</p>]]></content>
    
    
    <categories>
      
      <category>服务编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl 库编写数据库应用程序</title>
    <link href="/2014/09/03/db/"/>
    <url>/2014/09/03/db/</url>
    
    <content type="html"><![CDATA[<p>acl 的 C++ 版本库（lib_acl_cpp.a）的 db 模块主要与数据库编程相关，通过这些模块库，开发者可以快速地写出支持数据库连接池的数据库应用程序，目前该 db 模块支持 mysql、sqlite 数据库。本文将以 mysql 应用为例讲述如何使用这些 API 接口编程数据库应用。</p><p>在 lib_acl_cpp&#x2F;include&#x2F;acl_cpp&#x2F;db 目录下，可以看到主要分三个部分：数据库操作句柄类（db_handle，db_mysql，db_sqlite）、数据库连接池类（db_pool，mysql_pool，sqlite_pool）及数据库服务类（db_service，db_service_mysql，db_service_sqlite，这些类主要用在阻塞非阻塞结合的应用中，如：MFC界面过程与数据库过程的结合，非阻塞 IO 过程与数据库过程结合）。</p><h2 id="一、数据库操作句柄"><a href="#一、数据库操作句柄" class="headerlink" title="一、数据库操作句柄"></a>一、数据库操作句柄</h2><p>下图显示了数据库句柄的类继承关系：db_handle 为基础类，db_mysql&#x2F;db_sqlite 类均继承于 db_handle 类。</p><p><img src="/img/db.png" alt="db_handle基类"></p><p>在 db_mysql.hpp&#x2F;db_sqlite.hpp 两个头文件中可以看出，这两个子类仅是实现了基础类 db_handle 的一些虚函数而已，大量关于数据的操作函数都集中于 db_handle.hpp 头文件中，下图为 db_handle 类的功能协作图（其中的 db_rows&#x2F;db_row 两个类为数据库查询结果类）：<br><img src="/img/db2.png" alt="db继承关系"></p><p>下面给出了一个简单的数据库查询示例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从数据库中查询表数据</span><br><span class="hljs-comment"> * @param db &#123;acl::db_handle&amp;&#125; acl 中的数据库连接句柄引用</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">tbl_select</span><span class="hljs-params">(acl::db_handle&amp; db)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建 sql 查询语句</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* sql = <span class="hljs-string">&quot;select * from group_tbl where&quot;</span><br><span class="hljs-string">&quot; group_name=&#x27;test_name&#x27; and uvip_tbl=&#x27;test&#x27;&quot;</span>;<br><span class="hljs-comment">// 查询数据库</span><br><span class="hljs-keyword">if</span> (db.<span class="hljs-built_in">sql_select</span>(sql) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;select sql: %s error\r\n&quot;</span>, sql);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n---------------------------------------------------\r\n&quot;</span>);<br><span class="hljs-comment">// 列出查询结果方法一：从数据库句柄中获得查询结果集合</span><br><span class="hljs-type">const</span> acl::db_rows* result = db.<span class="hljs-built_in">get_result</span>();<br><span class="hljs-keyword">if</span> (result)<br>&#123;<br><span class="hljs-comment">// 遍历查询结果集</span><br><span class="hljs-type">const</span> std::vector&lt;acl::db_row*&gt;&amp; rows = result-&gt;<span class="hljs-built_in">get_rows</span>();<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; rows.<span class="hljs-built_in">size</span>(); i++)<br>&#123;<br><span class="hljs-type">const</span> acl::db_row* row = rows[i];<br><span class="hljs-comment">// 打印一行结果中的所有结果</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; row-&gt;<span class="hljs-built_in">length</span>(); j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s, &quot;</span>, (*row)[j]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br>&#125;<br><span class="hljs-comment">// 列出查询结果方法二：根据数组下标遍历数据库句柄的查询结果集</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; db.<span class="hljs-built_in">length</span>(); i++)<br>&#123;<br><span class="hljs-type">const</span> acl::db_row* row = db[i];<br><br><span class="hljs-comment">// 取出该行记录中某个字段的值</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = (*row)[<span class="hljs-string">&quot;group_name&quot;</span>];<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;error, no group name\r\n&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;group_name=%s: &quot;</span>, ptr);<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; row-&gt;<span class="hljs-built_in">length</span>(); j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s, &quot;</span>, (*row)[j]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br><span class="hljs-comment">// 列出查询结果方法三：直接从数据库句柄中获得结果数组</span><br><span class="hljs-type">const</span> std::vector&lt;acl::db_row*&gt;* rows = db.<span class="hljs-built_in">get_rows</span>();<br><span class="hljs-keyword">if</span> (rows)<br>&#123;<br>std::vector&lt;acl::db_row*&gt;::const_iterator cit = rows-&gt;<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; cit != rows-&gt;<span class="hljs-built_in">end</span>(); cit++)<br>&#123;<br><span class="hljs-type">const</span> acl::db_row* row = *cit;<br><span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> j = <span class="hljs-number">0</span>; j &lt; row-&gt;<span class="hljs-built_in">length</span>(); j++)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s, &quot;</span>, (*row)[j]);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br><br>&#125;<br><span class="hljs-comment">// 必须释放查询结果</span><br>db.<span class="hljs-built_in">free_result</span>();<br>&#125;<br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打开 mysql 数据库连接句柄</span><br><span class="hljs-comment"> * @return &#123;acl::db_handle*&#125; 返回值为 NULL 表示连接数据库失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> acl::db_handle* <span class="hljs-title">open_mysql</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbaddr = <span class="hljs-string">&quot;127.0.0.1:3306&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbname = <span class="hljs-string">&quot;acl_test_db&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbuser = <span class="hljs-string">&quot;acl_user&quot;</span>, *dbpass = <span class="hljs-string">&quot;111111&quot;</span>;<br>acl::db_handle* db = <span class="hljs-keyword">new</span> acl::<span class="hljs-built_in">db_mysql</span>(dbaddr, dbname, dbuser, dbpass);<br><br><span class="hljs-keyword">if</span> (db-&gt;<span class="hljs-built_in">open</span>() == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open mysql db error\r\n&quot;</span>);<br><span class="hljs-keyword">delete</span> db;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> db;<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打开 sqlite 数据库句柄</span><br><span class="hljs-comment"> * @return &#123;acl::db_handle*&#125; 返回值为 NULL 表示连接数据库失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> acl::db_handle* <span class="hljs-title">open_sqlite</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbfile = <span class="hljs-string">&quot;test.db&quot;</span>;<br>acl::db_handle* db = <span class="hljs-keyword">new</span> acl::<span class="hljs-built_in">db_sqlite</span>(dbfile);<br><br><span class="hljs-keyword">if</span> (db-&gt;<span class="hljs-built_in">open</span>() == flase)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open mysql db error\r\n&quot;</span>);<br><span class="hljs-keyword">delete</span> db;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><span class="hljs-keyword">return</span> db;<br>&#125;<br><span class="hljs-comment">////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">db_demo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>acl::db_handle* db;<br><br><span class="hljs-comment">// 操作 mysql 数据库过程</span><br>db = <span class="hljs-built_in">open_mysql</span>();<br><span class="hljs-keyword">if</span> (db)<br>&#123;<br><span class="hljs-built_in">tbl_select</span>(*db);<br><span class="hljs-keyword">delete</span> db;<br>&#125;<br><br><span class="hljs-comment">// 操作 sqlite 数据库过程</span><br>db = <span class="hljs-built_in">open_sqlite</span>();<br><span class="hljs-keyword">if</span> (db)<br>&#123;<br><span class="hljs-built_in">tbl_select</span>(*db);<br><span class="hljs-keyword">delete</span> db;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的例子可以看出，虽然操作的数据库不同，但数据库查询方式却是完全一样的，因为 acl 类内部屏蔽了数据库操作的差异性。下面还有几点需要注意：</p><ul><li>对于数据库查询结果集有多种操作方式，开发者可以根据需要进行选择；</li><li>其中生成的 sql 查询语句比较简单，所以没有做特殊字符转义，真正生产环境中开发者应注意对 sql 中的一些变化查询字段进行转义（可以使用 acl::db_handle 类中的 escape_string 方法），以防止 sql 注入攻击；</li><li>如果查询的数据库结果集非空，则在处理结果完毕毕竟调用 acl::db_handle 类中的 free_result() 方法释放中间动态分配的内存；</li><li>在使用 acl 数据库类编写代码时不需要包含 mysql 和 sqlite 的头文件，但在程序连接阶段必须将 mysql&#x2F;sqlite 的静态库加上。</li></ul><h2 id="二、数据库连接池"><a href="#二、数据库连接池" class="headerlink" title="二、数据库连接池"></a>二、数据库连接池</h2><p>为了避免建立数据库连接开销对数据造成冲击，一般的数据库连接都建议使用连接池方式（尤其是在JAVA、PHP等应用中）；连接池在保持与数据库的长连接过程中，必须要处理连接中断的重连情况，使上层使用者忽略连接中断的情况。</p><p>下图为 acl 的数据库连接池中各类的继承关系及连接池基础类的函数接口：</p><p>从 mysql_pool.hpp&#x2F;sqlite_pool.hpp 头文件中可以看出，二者的主要区别是构造函数略有不同：<br>db_pool 类为数据库连接池基类，其中主要有两个方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 从数据库中连接池获得一个数据库连接，该函数返回的数据库</span><br><span class="hljs-comment"> * 连接对象用完后必须调用 db_pool-&gt;put(db_handle*) 将连接</span><br><span class="hljs-comment"> * 归还至数据库连接池，由该函数获得的连接句柄不能 delete，</span><br><span class="hljs-comment"> * 否则会造成连接池的内部计数器出错</span><br><span class="hljs-comment"> * @return &#123;db_handle*&#125; 返回空，则表示出错</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">db_handle* <span class="hljs-title">peek</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将数据库连接放回至连接池中，当从数据库连接池中获得连接</span><br><span class="hljs-comment"> * 句柄用完后应该通过该函数放回，不能直接 delete，因为那样</span><br><span class="hljs-comment"> * 会导致连接池的内部记数发生错误</span><br><span class="hljs-comment"> * @param conn &#123;db_handle*&#125; 数据库连接句柄，该连接句柄可以</span><br><span class="hljs-comment"> *  是由 peek 创建的，也可以单独动态创建的</span><br><span class="hljs-comment"> * @param keep &#123;bool&#125; 归还给连接池的数据库连接句柄是否继续</span><br><span class="hljs-comment"> *  保持连接，如果否，则内部会自动删除该连接句柄</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">put</span><span class="hljs-params">(db_handle* conn, <span class="hljs-type">bool</span> keep = <span class="hljs-literal">true</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>mysql 数据库连接池的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 采用 mysql 数据库时的构造函数</span><br><span class="hljs-comment"> * @param dbaddr &#123;const char*&#125; mysql 服务器地址，格式：IP:PORT，</span><br><span class="hljs-comment"> *  在 UNIX 平台下可以为 UNIX 域套接口</span><br><span class="hljs-comment"> * @param dbname &#123;const char*&#125; 数据库名</span><br><span class="hljs-comment"> * @param dbuser &#123;const char*&#125; 数据库用户</span><br><span class="hljs-comment"> * @param dbpass &#123;const char*&#125; 数据库用户密码</span><br><span class="hljs-comment"> * @param dblimit &#123;int&#125; 数据库连接池的最大连接数限制</span><br><span class="hljs-comment"> * @param dbflags &#123;unsigned long&#125; mysql 标记位</span><br><span class="hljs-comment"> * @param auto_commit &#123;bool&#125; 是否自动提交</span><br><span class="hljs-comment"> * @param conn_timeout &#123;int&#125; 连接数据库超时时间(秒)</span><br><span class="hljs-comment"> * @param rw_timeout &#123;int&#125; 与数据库通信时的IO时间(秒)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">mysql_pool</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbaddr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbname,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbuser, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbpass,<br><span class="hljs-type">int</span> dblimit = <span class="hljs-number">64</span>, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> dbflags = <span class="hljs-number">0</span>,<br><span class="hljs-type">bool</span> auto_commit = <span class="hljs-literal">true</span>, <span class="hljs-type">int</span> conn_timeout = <span class="hljs-number">60</span>,<br><span class="hljs-type">int</span> rw_timeout = <span class="hljs-number">60</span>);<br></code></pre></td></tr></table></figure><p>下面以 mysql 为例写一个简单的使用连接池的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">dbpool_demo</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbaddr = <span class="hljs-string">&quot;127.0.0.1:3306&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbname = <span class="hljs-string">&quot;acl_test_db&quot;</span>;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* dbuser = <span class="hljs-string">&quot;acl_user&quot;</span>, *dbpass = <span class="hljs-string">&quot;111111&quot;</span>;<br>acl::db_pool* dbp = <span class="hljs-keyword">new</span> acl::<span class="hljs-built_in">mysql_pool</span>(dbaddr, dbname, dbuser, dbpass);  <span class="hljs-comment">// 创建 mysql 连接池</span><br>acl::db_handle* dbh = dbp-&gt;<span class="hljs-built_in">peek</span>(); <span class="hljs-comment">// 从连接池中获取一个数据库连接</span><br><span class="hljs-keyword">if</span> (dbh == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;peek db connection error\r\n&quot;</span>);<br><span class="hljs-keyword">delete</span> dbp;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><span class="hljs-built_in">tbl_select</span>(*dbh);  <span class="hljs-comment">// 从数据库中查询数据（使用上面的查询例子）</span><br>dbh-&gt;<span class="hljs-built_in">put</span>(dbh);<span class="hljs-comment">// 归还数据库连接给连接池</span><br><span class="hljs-keyword">delete</span> dbh; <span class="hljs-comment">// 删除连接池对象</span><br>&#125;<br></code></pre></td></tr></table></figure><p>由上面示例可以看出 acl 中的数据库连接池还是比较简单易用的，不过需要注意以下几点：</p><ul><li>在创建数据库连接池对象时并不立刻连接后端的数据库，数据库的连接过程一般发生在 acl::db_pool::peek() 过程，但在调用 peek 时如果连接池有可用连接则直接使用之；</li><li>在使用数据库连接操作数据库时，如果因为网络意外导致连接断开，内部会根据数据库连接的返回错误号决定是否需要重试该数据库操作；</li><li>在用完数据库连接后需要调用 acl::db_pool::put() 过程归还数据库连；</li><li>在编译 lib_acl_cpp 库时必须需要指定 Makefile.db 为工程文件(make -f Makefile.db)，这样才能使 lib_acl_cpp.a 库内部的数据库功能生效；同时在编译自己的应用程序时必须指定 libmysqlclient_r.a 的链接位置。</li></ul><p>好了，关于如何使用 acl 库编写数据库应用先写到此，欢迎读者批评指正。</p><p>其它有关数据库使用例子请参考：</p><ul><li>acl\lib_acl_cpp\samples\mysql</li><li>acl\lib_acl_cpp\samples\sqlite</li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl_cpp 库中的 http_request 类实现一个 HTTP 客户端请求的例子</title>
    <link href="/2014/06/02/http_request/"/>
    <url>/2014/06/02/http_request/</url>
    
    <content type="html"><![CDATA[<p>之前写过几篇如何使用 acl 库来实现 HTTP 客户端的例子都是基于 C 语言(使用 acl 较为底层的 HTTP 协议库写 HTTP 下载客户端举例, 使用 acl 库开发一个 HTTP 下载客户端)，其实在 acl 的 C++ 库(lib_acl_cpp) 中 HTTP 类功能更为强大，本节将介绍如何使用 acl::http_request 类来写一些简单的 HTTP 客户端示例。</p><h2 id="一、-acl-http-request-类的一些常用接口"><a href="#一、-acl-http-request-类的一些常用接口" class="headerlink" title="一、 acl::http_request 类的一些常用接口"></a>一、 acl::http_request 类的一些常用接口</h2><p>该 HTTP 请求类有两个构造函数，如下 ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造函数：通过该构造函数传入的 socket_stream 流对象并</span><br><span class="hljs-comment"> * 不会被关闭，需要调用者自己关闭</span><br><span class="hljs-comment"> * @param client &#123;socket_stream*&#125; 数据连接流，非空，</span><br><span class="hljs-comment"> *  在本类对象被销毁时该流对象并不会被销毁，所以用户需自行释放</span><br><span class="hljs-comment"> * @param conn_timeout &#123;int&#125; 如果传入的流关闭，则内部会</span><br><span class="hljs-comment"> *  自动重试，此时需要该值表示连接服务器的超时时间(秒)，</span><br><span class="hljs-comment"> *  至于重连流的 IO 读写超时时间是从 输入的流中继承的</span><br><span class="hljs-comment"> * @param unzip &#123;bool&#125; 是否对服务器响应的数据自动进行解压</span><br><span class="hljs-comment"> * 注：当该类实例被多次使用时，用户应该在每次调用前调用</span><br><span class="hljs-comment"> * request_header::http_header::reset()</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">http_request</span>(socket_stream* client, <span class="hljs-type">int</span> conn_timeout = <span class="hljs-number">60</span>,<br><span class="hljs-type">bool</span> unzip = <span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造函数：该构造函数内部创建的 socket_stream 流会自行关闭</span><br><span class="hljs-comment"> * @param addr &#123;const char*&#125; WEB 服务器地址</span><br><span class="hljs-comment"> * @param conn_timeout &#123;int&#125; 远程连接服务器超时时间(秒)</span><br><span class="hljs-comment"> * @param rw_timeout &#123;int&#125; IO 读写超时时间(秒)</span><br><span class="hljs-comment"> * @param unzip &#123;bool&#125; 是否对服务器响应的数据自动进行解压</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">http_request</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr, <span class="hljs-type">int</span> conn_timeout = <span class="hljs-number">60</span>,<br><span class="hljs-type">int</span> rw_timeout = <span class="hljs-number">60</span>, <span class="hljs-type">bool</span> unzip = <span class="hljs-literal">true</span>);<br></code></pre></td></tr></table></figure><p>第一个是以已经连接成功的套接字流为参数的构造函数，该构造函数把连接 HTTP 服务器的工作交给用户来完成；第二个是以 HTTP 服务器地址为参数的构造函数，使用该构造函数，则该类对象内部会自动连接 HTTP 服务器。</p><p>下面的几个函数接口与 HTTP 发送相关：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得 HTTP 请求头对象，然后在返回的 HTTP 请求头对象中添加</span><br><span class="hljs-comment"> * 自己的请求头字段或 http_header::reset()重置请求头状态，</span><br><span class="hljs-comment"> * 参考：http_header 类</span><br><span class="hljs-comment"> * @return &#123;http_header&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">http_header&amp; <span class="hljs-title">request_header</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向 HTTP 服务器发送 HTTP 请求头及 HTTP 请求体，同时从</span><br><span class="hljs-comment"> * HTTP 服务器读取 HTTP 响应头，对于长连接，当连接中断时</span><br><span class="hljs-comment"> * 会再重试一次，在调用下面的几个 get_body 函数前必须先</span><br><span class="hljs-comment"> * 调用本函数(或调用 write_head/write_body)；</span><br><span class="hljs-comment"> * 正常情况下，该函数在发送完请求数据后会读 HTTP 响应头，</span><br><span class="hljs-comment"> * 所以用户在本函数返回 true 后可以调用：get_body() 或</span><br><span class="hljs-comment"> * http_request::get_clinet()-&gt;read_body(char*, size_t)</span><br><span class="hljs-comment"> * 继续读 HTTP 响应的数据体</span><br><span class="hljs-comment"> * @param data &#123;const void*&#125; 发送的数据体地址，非空时自动按</span><br><span class="hljs-comment"> *  POST 方法发送，否则按 GET 方法发送</span><br><span class="hljs-comment"> * @param len &#123;size_&#125; data 非空时指定 data 数据长度</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 发送请求数据及读 HTTP 响应头数据是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">request</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span> len)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当采用流式写数据时，需要首先调用本函数发送 HTTP 请求头</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 是否成功，如果成功才可以继续调用 write_body</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">write_head</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当采用流式写数据时，在调用 write_head 后，可以循环调用本函数</span><br><span class="hljs-comment"> * 发送 HTTP 请求体数据；当输入的两个参数为空值时则表示数据写完；</span><br><span class="hljs-comment"> * 当发送完数据后，该函数内部会自动读取 HTTP 响应头数据，用户可</span><br><span class="hljs-comment"> * 继续调用 get_body/read_body 获取 HTTP 响应体数据</span><br><span class="hljs-comment"> * @param data &#123;const void*&#125; 数据地址指针，当该值为空指针时表示</span><br><span class="hljs-comment"> *  数据发送完毕</span><br><span class="hljs-comment"> * @param len &#123;size_t&#125; data 非空指针时表示数据长度</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 发送数据体是否成功</span><br><span class="hljs-comment"> *  注：当应用发送完数据后，必须再调用一次本函数，同时将两个参数都赋空</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">write_body</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">void</span>* data, <span class="hljs-type">size_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure><p>构建及发送 HTTP 请求的过程如下：</p><ul><li>1、使用两个构造函数之一创建 acl::http_request 请求对象</li><li>2、调用 http_request::request_header 获得 HTTP 请求头对象的引用（http_header&amp;），然后对该 HTTP 请求头设置 HTTP 请求的参数</li><li>3、http_request 类提供了两种 HTTP 请求调用 方式：<ul><li>3.1、当 HTTP 请求方法为 HTTP GET 方法或为 HTTP POST 但数据体可以一次性写入时，可以使用 http_request::request 方法，在调用 http_request::request 时会将 HTTP 请求头及请求体一次性发给 HTTP 服务器；</li><li>3.2   如果为 HTTP POST 请求方法，且 HTTP 数据体内容是流式的（即每次只是要发送部分数据），则应该使用 http_request::write_head 和 http_request::write_body 两个函数，即使用流式方式发送数据时，应首先调用 http_request::write_head 发送 HTTP 请求头，当该函数返回成功后，可以循环调用 http_request::write_body 来发送 HTTP 请求数据体，为了表示 HTTP 请求体数据完毕，必须最后调用一次 http_request::write_body 且两个参数为 0 时以表示数据体发送完毕。</li></ul></li></ul><p>在调用以上 3.1 或 3.2 过程成功发送完 HTTP 请求数据后，这两个过程内部会自动读取 HTTP 服务器发来的 HTTP 响应头。</p><p>在上面的步骤 2 获得 HTTP 请求头对象（http_header）后，应该先调用下面的方法设置 HTTP 请求头中的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置请求的 URL，url 格式示例如下：</span><br><span class="hljs-comment"> * 1、http://www.test.com/</span><br><span class="hljs-comment"> * 2、/cgi-bin/test.cgi</span><br><span class="hljs-comment"> * 3、http://www.test.com/cgi-bin/test.cgi</span><br><span class="hljs-comment"> * 3、http://www.test.com/cgi-bin/test.cgi?name=value</span><br><span class="hljs-comment"> * 4、/cgi-bin/test.cgi?name=value</span><br><span class="hljs-comment"> * 5、http://www.test.com</span><br><span class="hljs-comment"> * 如果该 url 中有主机字段，则内部自动添加主机；</span><br><span class="hljs-comment"> * 如果该 url 中有参数字段，则内部自动进行处理并调用 add_param 方法；</span><br><span class="hljs-comment"> * 调用该函数后用户仍可以调用 add_param 等函数添加其它参数；</span><br><span class="hljs-comment"> * 当参数字段只有参数名没有参数值时，该参数将会被忽略，所以如果想</span><br><span class="hljs-comment"> * 单独添加参数名，应该调用 add_param 方法来添加</span><br><span class="hljs-comment"> * @param url &#123;const char*&#125; 请求的 url，非空指针</span><br><span class="hljs-comment"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">http_header&amp; <span class="hljs-title">set_url</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* url)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 HTTP 请求头的 HOST 字段</span><br><span class="hljs-comment"> * @param value &#123;const char*&#125; 请求头的 HOST 字段值</span><br><span class="hljs-comment"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">http_header&amp; <span class="hljs-title">set_host</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向请求的 URL 中添加参数对，当只有参数名没有参数值时则：</span><br><span class="hljs-comment"> * 1、参数名非空串，但参数值为空指针，则 URL 参数中只有：&#123;name&#125;</span><br><span class="hljs-comment"> * 2、参数名非空串，但参数值为空串，则 URL参数中为：&#123;name&#125;=</span><br><span class="hljs-comment"> * @param name &#123;const char*&#125; 参数名，不能为空指针</span><br><span class="hljs-comment"> * @param value &#123;const char*&#125; 参数值，当为空指针时，仅添加参数名，</span><br><span class="hljs-comment"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">http_header&amp; <span class="hljs-title">add_param</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* value)</span></span>;<br><span class="hljs-function">http_header&amp; <span class="hljs-title">add_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">short</span> value)</span></span>;<br><span class="hljs-function">http_header&amp; <span class="hljs-title">add_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">int</span> value)</span></span>;<br><span class="hljs-function">http_header&amp; <span class="hljs-title">add_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">long</span> value)</span></span>;<br><span class="hljs-function">http_header&amp; <span class="hljs-title">add_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">unsigned</span> <span class="hljs-type">short</span> value)</span></span>;<br><span class="hljs-function">http_header&amp; <span class="hljs-title">add_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> value)</span></span>;<br><span class="hljs-function">http_header&amp; <span class="hljs-title">add_int</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> value)</span></span>;<br><span class="hljs-function">http_header&amp; <span class="hljs-title">add_format</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* fmt, ...)</span></span><br><span class="hljs-function"><span class="hljs-title">ACL_CPP_PRINTF</span><span class="hljs-params">(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向 HTTP 头中添加 cookie</span><br><span class="hljs-comment"> * @param name &#123;const char*&#125; cookie 名</span><br><span class="hljs-comment"> * @param value &#123;const char*&#125; cookie 值</span><br><span class="hljs-comment"> * @param domain &#123;const char*&#125; 所属域</span><br><span class="hljs-comment"> * @param path &#123;const char*&#125; 存储路径</span><br><span class="hljs-comment"> * @param expires &#123;time_t&#125; 过期时间，当该值为 0 时表示不过期，</span><br><span class="hljs-comment"> *  &gt; 0 时，则从现在起再增加 expires 即为过期时间，单位为秒</span><br><span class="hljs-comment"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">http_header&amp; <span class="hljs-title">add_cookie</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* value,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* domain = <span class="hljs-literal">NULL</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path = <span class="hljs-literal">NULL</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">time_t</span> expires = <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 HTTP 头中的 Connection 字段，是否保持长连接</span><br><span class="hljs-comment"> * 不过，目前并未真正支持长连接，即使设置了该标志位，</span><br><span class="hljs-comment"> * 则得到响应数据后也会主动关闭连接</span><br><span class="hljs-comment"> * @param on &#123;bool&#125; 是否保持长连接</span><br><span class="hljs-comment"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">http_header&amp; <span class="hljs-title">set_keep_alive</span><span class="hljs-params">(<span class="hljs-type">bool</span> on)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 HTTP 头中的 Content-Length 字段</span><br><span class="hljs-comment"> * @param n &#123;long long int&#125; 设置值</span><br><span class="hljs-comment"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">http_header&amp; <span class="hljs-title">set_content_length</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> n)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 HTTP 头中的 Content-Type 字段</span><br><span class="hljs-comment"> * @param value &#123;const char*&#125; 设置值</span><br><span class="hljs-comment"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">http_header&amp; <span class="hljs-title">set_content_type</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value)</span></span>;<br></code></pre></td></tr></table></figure><p>以上仅列出了 http_header 类设置 HTTP 请求参数的一些常用方法，其它的方法请参考 http_header.hpp 头文件中的说明。</p><h2 id="二、acl-http-request-类获得-HTTP-服务器响应数据的常用方法"><a href="#二、acl-http-request-类获得-HTTP-服务器响应数据的常用方法" class="headerlink" title="二、acl::http_request 类获得 HTTP 服务器响应数据的常用方法"></a>二、acl::http_request 类获得 HTTP 服务器响应数据的常用方法</h2><p>上面介绍了使用 acl::http_request 构建 HTTP 请求头及发送请求的接口方法，下面介绍使用 acl::http_request 类中的方法来接收 HTTP 服务器响应过程，在调用 http_request 类中的 request 或 write_body 成功发送完请求数据后，该类对象在这两个方法内部会首先自动接收 HTTP 服务器的响应头数据，若接收过程失败，这两个方法也会返回 false 表示失败，若返回成功，则可以调用 http_request 类对象的 http_status 方法获得 HTTP 服务器的响应状态码（2xx, 3xx, 4xx, 5xx），还可调用 body_length 方法获得 HTTP 响应数据体的长度（当 HTTP 服务器返回的数据格式为 HTTP 块传输时，该函数会返回 -1，所以一般不用显示调用该方法）。下面介绍了主要的与 HTTP 响应相关的方法：</p><p>首先是与 HTTP 响应头相关的接口函数，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当发送完请求数据后，内部会自动调用读 HTTP 响应头过程，可以通过此函数获得服务端</span><br><span class="hljs-comment"> * 响应的 HTTP 状态字(2xx, 3xx, 4xx, 5xx)；</span><br><span class="hljs-comment"> * 其实该函数内部只是调用了 http_client::response_status 方法</span><br><span class="hljs-comment"> * @return &#123;int&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">http_status</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得 HTTP 响应的数据体长度</span><br><span class="hljs-comment"> * @return &#123;int64) 返回值若为 -1 则表明 HTTP 头不存在或没有长度字段</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br><span class="hljs-function">__int64 <span class="hljs-title">body_length</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">body_length</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HTTP 数据流(响应流是否允许保持长连接)</span><br><span class="hljs-comment"> * @return &#123;bool&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">keep_alive</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得 HTTP 响应头中某个字段名的字段值</span><br><span class="hljs-comment"> * @param name &#123;const char*&#125; 字段名</span><br><span class="hljs-comment"> * @return &#123;const char*&#125; 字段值，为空时表示不存在</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">header_value</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得服务器返回的 Set-Cookie 设置的某个 cookie 对象</span><br><span class="hljs-comment"> * @param name &#123;const char*&#125; cookie 名</span><br><span class="hljs-comment"> * @param case_insensitive &#123;bool&#125; 是否区分大小写，true 表示</span><br><span class="hljs-comment"> *  不区分大小写</span><br><span class="hljs-comment"> * @return &#123;const HttpCookie*&#125; 返回 NULL 表示不存在</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> HttpCookie* <span class="hljs-title">get_cookie</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">bool</span> case_insensitive = <span class="hljs-literal">true</span>)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>然后是与读 HTTP 响应数据体相关的接口函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 是否读完了数据体</span><br><span class="hljs-comment"> * @return &#123;bool&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">body_finish</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当调用 request 成功后调用本函数，读取服务器响应体数据</span><br><span class="hljs-comment"> * 并将结果存储于规定的 xml 对象中</span><br><span class="hljs-comment"> * @param out &#123;xml&amp;&#125; HTTP 响应体数据存储于该 xml 对象中</span><br><span class="hljs-comment"> * @param to_charset &#123;const char*&#125; 当该项非空，内部自动</span><br><span class="hljs-comment"> *  将数据转成该字符集存储于 xml 对象中</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 读数据是否成功</span><br><span class="hljs-comment"> * 注：当响应数据体特别大时不应用此函数，以免内存耗光</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">get_body</span><span class="hljs-params">(xml&amp; out, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* to_charset = <span class="hljs-literal">NULL</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当调用 request 成功后调用本函数，读取服务器响应体数据</span><br><span class="hljs-comment"> * 并将结果存储于规定的 json 对象中</span><br><span class="hljs-comment"> * @param out &#123;json&amp;&#125; HTTP 响应体数据存储于该 json 对象中</span><br><span class="hljs-comment"> * @param to_charset &#123;const char*&#125; 当该项非空，内部自动</span><br><span class="hljs-comment"> *  将数据转成该字符集存储于 json 对象中</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 读数据是否成功</span><br><span class="hljs-comment"> * 注：当响应数据体特别大时不应用此函数，以免内存耗光</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">get_body</span><span class="hljs-params">(json&amp; out, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* to_charset = <span class="hljs-literal">NULL</span>)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当调用 request 成功后调用本函数，读取服务器全部响应数据</span><br><span class="hljs-comment"> * 存储于输入的缓冲区中</span><br><span class="hljs-comment"> * @param out &#123;string&amp;&#125; 存储响应数据体</span><br><span class="hljs-comment"> * @param to_charset &#123;const char*&#125; 当该项非空，内部自动</span><br><span class="hljs-comment"> *  将数据转成该字符集存储于 out 对象中</span><br><span class="hljs-comment"> * 注：当响应数据体特别大时不应用此函数，以免内存耗光</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">get_body</span><span class="hljs-params">(string&amp; out, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* to_charset = <span class="hljs-literal">NULL</span>)</span></span>;<br><br><span class="hljs-comment">/*</span><br><span class="hljs-comment"> * 当调用 request 成功后调用本函数，读取服务器响应数据并</span><br><span class="hljs-comment"> * 存储于输入的缓冲区中，可以循环调用本函数，直至数据读完了，</span><br><span class="hljs-comment"> * @param buf &#123;char*&#125; 存储部分响应数据体</span><br><span class="hljs-comment"> * @param size &#123;size_t&#125; buf 缓冲区大小</span><br><span class="hljs-comment"> * @return &#123;int&#125; 返回值 == 0 表示正常读完毕，&lt; 0 表示服务器</span><br><span class="hljs-comment"> *  关闭连接，&gt; 0 表示已经读到的数据，用户应该一直读数据直到</span><br><span class="hljs-comment"> *  返回值 &lt;= 0 为止</span><br><span class="hljs-comment"> *  注：该函数读到的是原始 HTTP 数据体数据，不做解压和字符集</span><br><span class="hljs-comment"> *  解码，用户自己根据需要进行处理</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_body</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当调用 request 成功后调用本函数读 HTTP 响应数据体，可以循环调用</span><br><span class="hljs-comment"> * 本函数，本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用</span><br><span class="hljs-comment"> * set_charset 设置了本地字符集，则还同时对数据进行字符集转码操作</span><br><span class="hljs-comment"> * @param out &#123;string&amp;&#125; 存储结果数据</span><br><span class="hljs-comment"> * @param clean &#123;bool&#125; 每次调用本函数时，是否要求先自动将缓冲区 out</span><br><span class="hljs-comment"> *  的数据清空</span><br><span class="hljs-comment"> * @param real_size &#123;int*&#125; 当该指针非空时，存储解压前读到的真正数据</span><br><span class="hljs-comment"> *  长度，如果在构造函数中指定了非自动解压模式且读到的数据 &gt; 0，则该</span><br><span class="hljs-comment"> *  值存储的长度值应该与本函数返回值相同；当读出错或未读到任何数据时，</span><br><span class="hljs-comment"> *  该值存储的长度值为 0</span><br><span class="hljs-comment"> * @return &#123;int&#125; == 0 表示读完毕，可能连接并未关闭；&gt;0 表示本次读操作</span><br><span class="hljs-comment"> *  读到的数据长度(当为解压后的数据时，则表示为解压之后的数据长度，</span><br><span class="hljs-comment"> *  与真实读到的数据不同，真实读到的数据长度应该通过参数 real_size 来</span><br><span class="hljs-comment"> *  获得); &lt; 0 表示数据流关闭，此时若 real_size 非空，则 real_size 存</span><br><span class="hljs-comment"> *  储的值应该为 0</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">read_body</span><span class="hljs-params">(string&amp; out, <span class="hljs-type">bool</span> clean = <span class="hljs-literal">false</span>, <span class="hljs-type">int</span>* real_size = <span class="hljs-literal">NULL</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当调用 request 成功后调用本函数来从 HTTP 服务端读一行数据，可以循环调用</span><br><span class="hljs-comment"> * 本函数，直到返回 false 或 body_finish() 返回 true 为止；</span><br><span class="hljs-comment"> * 本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用 set_charset 设置了</span><br><span class="hljs-comment"> * 本地字符集，则还同时对数据进行字符集转码操作</span><br><span class="hljs-comment"> * @param out &#123;string&amp;&#125; 存储结果数据</span><br><span class="hljs-comment"> * @param nonl &#123;bool&#125; 读到的一行数据是否自动去掉尾部的 &quot;\r\n&quot; 或 &quot;\n&quot;</span><br><span class="hljs-comment"> * @param size &#123;size_t*&#125; 该指针非空时存放读到的数据长度</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 是否读到了一行数据：当返回 true 时表示读到了一行数据，可以</span><br><span class="hljs-comment"> *  通过 body_finish() 是否为 true 来判断是否读数据体已经结束，当读到一个空行</span><br><span class="hljs-comment"> *  且 nonl = true 时，则 *size = 0；当返回 false 时表示未读完整行且读完毕，</span><br><span class="hljs-comment"> *  *size 中存放着读到的数据长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">body_gets</span><span class="hljs-params">(string&amp; out, <span class="hljs-type">bool</span> nonl = <span class="hljs-literal">true</span>, <span class="hljs-type">size_t</span>* size = <span class="hljs-literal">NULL</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>虽然上面提供了多个读 HTTP 响应体数据的方法，但可以分为两大类：1、一次性读所有的数据体；2、以流式方式循环读数据体。 其中，对于“一次性读取所有数据体”的读方法，适合于响应数据体比较小的情形，当响应数据为 xml 或 json 格式时，还提供了直接将响应数据体转为 xml 或 json 对象的读方法；如果响应数据体非常大（如几兆甚至几十兆以上）则应该采用流式方法循环读数据体。</p><p>有一点需要注意，除了 “ int read_body(char* buf, size_t size);” 可以直接读原生的响应数据体外，其它的读方法会将读到数据体自动进行解压、字符集转换操作后将最终结果返回调用者。</p><p>此外，为了方便一些文本类应用，在 http_request 类中还提供了 body_gets 方法，用来以行为单位读取 HTTP 响应数据体（当服务器也是以行为单位发送响应数据时才可使用 body_gets 方法）。</p><p>acl::http_request 类除了以上接口外，还提供了其它丰富的接口（如：支持 HTTP 断点续传的 Range 相关的方法），如果您觉得这些接口依然不能满足要求，不妨通过 “http_request::get_client” 获得 acl::http_client 类对象（该类对象是 acl 有关 http 协议处理中比较基础的 HTTP 通信类），然后再在 acl::http_client 类中查找您所希望的功能接口。</p><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><p>下面用一个简单的例子来说明上面一些方法的使用过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// http_servlet.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;getopt.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> acl;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">http_request_test</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">http_request_test</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* server_addr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* file,<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* stype, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* charset)<br>&#123;<br>server_addr_= server_addr;<br>file_ = file;<br>stype_ = stype;<br>charset_ = charset;<br>to_charset_ = <span class="hljs-string">&quot;gb2312&quot;</span>;<br>&#125;<br><br>~<span class="hljs-built_in">http_request_test</span>() &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>string body;<br><span class="hljs-keyword">if</span> (ifstream::<span class="hljs-built_in">load</span>(file_, &amp;body) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;load %s error&quot;</span>, file_.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-function">http_request <span class="hljs-title">req</span><span class="hljs-params">(server_addr_)</span></span>;<br><br><span class="hljs-comment">// 添加 HTTP 请求头字段</span><br><br><span class="hljs-function">string <span class="hljs-title">ctype</span><span class="hljs-params">(<span class="hljs-string">&quot;text/&quot;</span>)</span></span>;<br>ctype &lt;&lt; stype_ &lt;&lt; <span class="hljs-string">&quot;; charset=&quot;</span> &lt;&lt; charset_;<br><br>http_header&amp; hdr = req.<span class="hljs-built_in">request_header</span>();  <span class="hljs-comment">// 请求头对象的引用</span><br>hdr.<span class="hljs-built_in">set_url</span>(<span class="hljs-string">&quot;/&quot;</span>);<br>hdr.<span class="hljs-built_in">set_content_type</span>(ctype);<br>hdr.<span class="hljs-built_in">add_param</span>(<span class="hljs-string">&quot;name1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br>hdr.<span class="hljs-built_in">add_param</span>(<span class="hljs-string">&quot;name2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>);<br><span class="hljs-comment">// 发送 HTTP 请求数据</span><br><span class="hljs-keyword">if</span> (req.<span class="hljs-built_in">request</span>(body.<span class="hljs-built_in">c_str</span>(), body.<span class="hljs-built_in">length</span>()) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;send http request to %s error&quot;</span>,<br>server_addr_.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 取出 HTTP 响应头的 Content-Type 字段</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* p = req.<span class="hljs-built_in">header_value</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>);<br><span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span> || *p == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;no Content-Type&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 分析 HTTP 响应头的数据类型</span><br>http_ctype content_type;<br>content_type.<span class="hljs-built_in">parse</span>(p);<br><br><span class="hljs-comment">// 响应头数据类型的子类型</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* stype = content_type.<span class="hljs-built_in">get_stype</span>();<br><br><span class="hljs-type">bool</span> ret;<br><span class="hljs-keyword">if</span> (stype == <span class="hljs-literal">NULL</span>)<br>ret = <span class="hljs-built_in">do_plain</span>(req);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>(stype, <span class="hljs-string">&quot;xml&quot;</span>) == <span class="hljs-number">0</span>)<br>ret = <span class="hljs-built_in">do_xml</span>(req);<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcasecmp</span>(stype, <span class="hljs-string">&quot;json&quot;</span>) == <span class="hljs-number">0</span>)<br>ret = <span class="hljs-built_in">do_json</span>(req);<br><span class="hljs-keyword">else</span><br>ret = <span class="hljs-built_in">do_plain</span>(req);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-literal">true</span>)<br><span class="hljs-built_in">logger</span>(<span class="hljs-string">&quot;read ok!\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> ret;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-comment">// 处理 text/plain 类型数据</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">do_plain</span><span class="hljs-params">(http_request&amp; req)</span></span><br><span class="hljs-function"></span>&#123;<br>string body;<br><span class="hljs-keyword">if</span> (req.<span class="hljs-built_in">get_body</span>(body, to_charset_) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;get http body error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;body:\r\n(%s)\r\n&quot;</span>, body.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 处理 text/xml 类型数据</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">do_xml</span><span class="hljs-params">(http_request&amp; req)</span></span><br><span class="hljs-function"></span>&#123;<br>xml body;<br><span class="hljs-keyword">if</span> (req.<span class="hljs-built_in">get_body</span>(body, to_charset_) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;get http body error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>xml_node* node = body.<span class="hljs-built_in">first_node</span>();<br><span class="hljs-keyword">while</span> (node)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* tag = node-&gt;<span class="hljs-built_in">tag_name</span>();<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = node-&gt;<span class="hljs-built_in">attr_value</span>(<span class="hljs-string">&quot;name&quot;</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* pass = node-&gt;<span class="hljs-built_in">attr_value</span>(<span class="hljs-string">&quot;pass&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;tag: %s, name: %s, pass: %s\r\n&quot;</span>,<br>tag ? tag : <span class="hljs-string">&quot;null&quot;</span>,<br>name ? name : <span class="hljs-string">&quot;null&quot;</span>,<br>pass ? pass : <span class="hljs-string">&quot;null&quot;</span>);<br>node = body.<span class="hljs-built_in">next_node</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 处理 text/json 类型数据</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">do_json</span><span class="hljs-params">(http_request&amp; req)</span></span><br><span class="hljs-function"></span>&#123;<br>json body;<br><span class="hljs-keyword">if</span> (req.<span class="hljs-built_in">get_body</span>(body, to_charset_) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;get http body error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br>json_node* node = body.<span class="hljs-built_in">first_node</span>();<br><span class="hljs-keyword">while</span> (node)<br>&#123;<br><span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">tag_name</span>())<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;tag: %s&quot;</span>, node-&gt;<span class="hljs-built_in">tag_name</span>());<br><span class="hljs-keyword">if</span> (node-&gt;<span class="hljs-built_in">get_text</span>())<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;, value: %s\r\n&quot;</span>, node-&gt;<span class="hljs-built_in">get_text</span>());<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\r\n&quot;</span>);<br>&#125;<br>node = body.<span class="hljs-built_in">next_node</span>();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>string server_addr_;<span class="hljs-comment">// web 服务器地址</span><br>string file_;<span class="hljs-comment">// 本地请求的数据文件</span><br>string stype_;<span class="hljs-comment">// 请求数据的子数据类型</span><br>string charset_;<span class="hljs-comment">// 本地请求数据文件的字符集</span><br>string to_charset_;<span class="hljs-comment">// 将服务器响应数据转为本地字符集</span><br>&#125;;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* procname)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s -h[help]\r\n&quot;</span>, procname);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;options:\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t-f request file\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t-t request stype[xml/json/plain]\r\n&quot;</span>);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\t-c request file&#x27;s charset[gb2312/utf-8]\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>   ch;<br><span class="hljs-function">string <span class="hljs-title">server_addr</span><span class="hljs-params">(<span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>)</span>, <span class="hljs-title">file</span><span class="hljs-params">(<span class="hljs-string">&quot;./xml.txt&quot;</span>)</span></span>;<br><span class="hljs-function">string <span class="hljs-title">stype</span><span class="hljs-params">(<span class="hljs-string">&quot;xml&quot;</span>)</span>, <span class="hljs-title">charset</span><span class="hljs-params">(<span class="hljs-string">&quot;gb2312&quot;</span>)</span></span>;<br><br><span class="hljs-keyword">while</span> ((ch = <span class="hljs-built_in">getopt</span>(argc, argv, <span class="hljs-string">&quot;hs:f:t:c:&quot;</span>)) &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-keyword">switch</span> (ch)<br>&#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br><span class="hljs-built_in">usage</span>(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br>file = optarg;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br>stype = optarg;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>:<br>charset = optarg;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">usage</span>(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br><br>log::<span class="hljs-built_in">stdout_open</span>(<span class="hljs-literal">true</span>);   <span class="hljs-comment">// 允许日志输出至屏幕上</span><br><span class="hljs-function">http_request_test <span class="hljs-title">test</span><span class="hljs-params">(server_addr, file, stype, charset)</span></span>;<br>test.<span class="hljs-built_in">run</span>();  <span class="hljs-comment">// 开始运行</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure><p>上面的例子来自于 lib_acl_cpp&#x2F;samples&#x2F;http_request。</p><p>如果查看 http_request::request 源码实现，会发现 try_open()、reuse_conn、need_retry_ 等方法或变量来表示 HTTP 客户端连接的重试过程，这是因为 http_request 类的设计是支持长连接及可重用的，对于 HTTP 客户端连接池来说这些功能非常重要，在下一节介绍使用 acl 的 http 客户端连接池功能类时将会用到 http 请求客户端连接的重连及重试机制。</p><h2 id="四、参考"><a href="#四、参考" class="headerlink" title="四、参考"></a>四、参考</h2><p>http_request 类的头文件位置：lib_acl_cpp&#x2F;include&#x2F;acl_cpp&#x2F;http&#x2F;http_request.hpp<br>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>http开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl 库开发简单的客户端与服务器程序</title>
    <link href="/2014/05/18/network_simple/"/>
    <url>/2014/05/18/network_simple/</url>
    
    <content type="html"><![CDATA[<p>acl 的 C++ 库部分也提供了一些简单的服务器类，本文将介绍如何使用这些简单的类来实现一些服务器程序和网络客户端程序。</p><p>首先介绍 acl 中的服务器类：server_socket。该类定义了如下几个简单方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 开始监听给定服务端地址</span><br><span class="hljs-comment"> * @param addr &#123;const char*&#125; 服务器监听地址，格式为：</span><br><span class="hljs-comment"> *  ip:port；在 unix 环境下，还可以是域套接口，格式为：</span><br><span class="hljs-comment"> *   /path/xxx</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 监听是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 关闭已经打开的监听套接口</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 是否正常关闭</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">close</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 接收客户端连接并创建客户端连接流</span><br><span class="hljs-comment"> * @param timeout &#123;int&#125; 在阻塞模式下，当该值 &gt; 0 时，采用超时</span><br><span class="hljs-comment"> *  方式接收客户端连接，若在指定时间内未获得客户端连接，则返回 NULL</span><br><span class="hljs-comment"> * @return &#123;socket_stream*&#125; 返回空表示接收失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">socket_stream* <span class="hljs-title">accept</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout = <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得监听的地址</span><br><span class="hljs-comment"> * @return &#123;const char*&#125; 返回值非空指针</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">get_addr</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> addr_;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用上述网络服务类的步骤是：调用 open 监听本机的一个网络地址（如果是UNIX平台，还可以监听UNIX域套接口）——&gt; 调用 accept 方法等待远程客户端连接本服务器 ——&gt; 当服务器程序接收到客户端连接时 accept 方法返回客户端连接网络流(socket_stream) ——&gt; 启动一个线程处理这个客户端连接。下面为一个简单的服务器程序：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class="hljs-comment">// 处理客户端连接的线程类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">client_thread</span> : <span class="hljs-keyword">public</span> acl::thread<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">client_thread</span>(acl::socket_stream* client)<br>: <span class="hljs-built_in">client_</span>(client)<br>&#123;<br>&#125;<br><br>~<span class="hljs-built_in">client_thread</span>()<br>&#123;<br><span class="hljs-keyword">delete</span> client_;<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 实现基类 acl::thread 中定义的纯虚方法</span><br><span class="hljs-function"><span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>acl::string buf;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// 从客户端连接读一行数据，第二个参数为 false 意思是希望</span><br><span class="hljs-comment">// socket_stream 在读到一行数据时保留 \r\n</span><br><span class="hljs-keyword">if</span> (client_-&gt;<span class="hljs-built_in">gets</span>(buf, <span class="hljs-literal">false</span>) == <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;gets one line: %s&quot;</span>, buf.<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-comment">// 回写所读到的一行数据</span><br><span class="hljs-keyword">if</span> (client_-&gt;<span class="hljs-built_in">write</span>(buf) == <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>acl::socket_stream* client_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr = <span class="hljs-string">&quot;0.0.0.0:8080&quot;</span>;<br>acl::socket_server server;<br><br><span class="hljs-comment">// 监听本机网络地址</span><br><span class="hljs-keyword">if</span> (server.<span class="hljs-built_in">open</span>(addr) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listen addr: %s error: %s\r\n&quot;</span>, addr, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span><br>&#125;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// 等待客户端连接本服务器程序</span><br>acl::socket_stream* client = server.<span class="hljs-built_in">accept</span>();<br><span class="hljs-keyword">if</span> (client == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;accept error: %s\r\n&quot;</span>, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 创建一个子线程用来处理该客户端连接</span><br>client_thread* thread = <span class="hljs-keyword">new</span> <span class="hljs-built_in">client_thread</span>(client);<br><br><span class="hljs-comment">// 将线程设为分离模式，这样当线程退出时会自行释放线程相关资源</span><br>thread-&gt;<span class="hljs-built_in">set_detachable</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">// 启动该线程</span><br>thread-&gt;<span class="hljs-built_in">start</span>();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面例子非常简单，毋庸详述，关于如何使用 acl 编写多线程程序，请参照：使用 acl_cpp 库编写多线程程序。下面再给出一个简单的网络客户端例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* server_addr = <span class="hljs-string">&quot;127.0.0.1:8080&quot;</span>;<br><span class="hljs-type">int</span>   conn_timeout = <span class="hljs-number">10</span> <span class="hljs-comment">/* 连接服务器超时时间，单位：秒 */</span><br><span class="hljs-type">int</span>   rw_timeout = <span class="hljs-number">10</span> <span class="hljs-comment">/* 网络 IO 超时时间，单位：秒 */</span>;<br>acl::socket_stream conn;<br><br><span class="hljs-comment">// 连接远程服务器</span><br><span class="hljs-keyword">if</span> (conn.<span class="hljs-built_in">open</span>(server_addr, conn_timeout, rw_timeout) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect server: %s error: %s\r\n&quot;</span>,<br>server_addr, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* req = <span class="hljs-string">&quot;hello world!\r\n&quot;</span>;<br><br>acl::string buf;<br><br><span class="hljs-comment">// 向服务器写一行数据，同时从服务器读一行数据，循环 10 次</span><br><span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++)<br>&#123;<br><span class="hljs-comment">// 向服务器发送一行数据</span><br><span class="hljs-keyword">if</span> (conn.<span class="hljs-built_in">write</span>(req, <span class="hljs-built_in">strlen</span>(req)) == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write request to server error: %s\r\n&quot;</span>,<br>acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-comment">// 从服务器读一行数据，注：第二个参数为默认的 true，意思是获得</span><br><span class="hljs-comment">// 一行数据后自动将尾部的 \r\n 去掉</span><br><span class="hljs-keyword">if</span> (conn.<span class="hljs-built_in">gets</span>(buf) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;gets one line from server error: %s\r\n&quot;</span>,<br>acl::<span class="hljs-built_in">last_serror</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;response: %s\r\n&quot;</span>, buf.<span class="hljs-built_in">c_str</span>());<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>网络编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>线程池设计中的惊群问题</title>
    <link href="/2014/03/09/threads_shock/"/>
    <url>/2014/03/09/threads_shock/</url>
    
    <content type="html"><![CDATA[<p>多线程编程已经是现在网络编程中常用的编程技术，设计一个良好的线程池库显得尤为重要。在 UNIX（WIN32下可以采用类似的方法，acl 库中的线程池是跨平台的） 环境下设计线程池库主要是如何用好如下系统 API：</p><ul><li>1、pthread_cond_signal&#x2F;pthread_cond_broadcast：生产者线程通知线程池中的某个或一些消费者线程池，接收处理任务；</li><li>2、pthread_cond_wait：线程池中的消费者线程等待线程条件变量被通知；</li><li>3、pthread_mutex_lock&#x2F;pthread_mutex_unlock：线程互斥锁的加锁及解锁函数。</li></ul><p>下面的代码示例是大家常见的线程池的设计方式：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// 线程任务类型定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_job</span> &#123;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_job</span> *<span class="hljs-title">next</span>;</span>  <span class="hljs-comment">// 指向下一个线程任务</span><br><span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span>*);      <span class="hljs-comment">// 应用回调处理函数 </span><br><span class="hljs-type">void</span> *arg;                <span class="hljs-comment">// 回调函数的参数</span><br>...<br>&#125;;<br><br><span class="hljs-comment">// 线程池类型定义</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_pool</span> &#123;</span><br><span class="hljs-type">int</span>   max_threads;        <span class="hljs-comment">// 线程池中最大线程数限制</span><br><span class="hljs-type">int</span>   curr_threads;       <span class="hljs-comment">// 当前线程池中总的线程数</span><br><span class="hljs-type">int</span>   idle_threads;       <span class="hljs-comment">// 当前线程池中空闲的线程数</span><br><span class="hljs-type">pthread_mutex_t</span> mutex;    <span class="hljs-comment">// 线程互斥锁</span><br><span class="hljs-type">pthread_cond_t</span>  cond;     <span class="hljs-comment">// 线程条件变量</span><br>thread_job *first;        <span class="hljs-comment">// 线程任务链表的表头</span><br>thread_job *last;         <span class="hljs-comment">// 线程任务链表的表尾</span><br>...<br>&#125;<br><br><span class="hljs-comment">// 线程池中的消费者线程处理过程</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> *<span class="hljs-title function_">consumer_thread</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_pool</span> *<span class="hljs-title">pool</span> =</span> (<span class="hljs-keyword">struct</span> thread_pool*) arg;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_job</span>  *<span class="hljs-title">job</span>;</span><br><span class="hljs-type">int</span>   status;<br><br><span class="hljs-comment">// 该消费者线程需要先加锁</span><br>pthread_mutex_lock(&amp;pool-&gt;mutex);<br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-keyword">if</span> (pool-&gt;first != <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-comment">// 有线程任务时，则取出并在下面进行处理</span><br>job = pool-&gt;first;<br>pool-&gt;first = job-&gt;next;<br><span class="hljs-keyword">if</span> (pool-&gt;last == job)<br>pool-&gt;last = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">// 解锁，允许其它消费者线程加锁或生产者线程添加新的任务</span><br>pthread_mutex_unlock(&amp;pool-&gt;mutex);<br><br><span class="hljs-comment">// 回调应用的处理函数</span><br>job-&gt;func(job-&gt;arg);<br><br><span class="hljs-comment">// 释放动态分配的内存</span><br><span class="hljs-built_in">free</span>(job);<br><br><span class="hljs-comment">// 重新去加锁</span><br>pthread_mutex_lock(&amp;pool-&gt;mutex);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>pool-&gt;idle_threads++;<br><br><span class="hljs-comment">// 在调用 pthread_cond_wait 等待线程条件变量被通知且自动解锁</span><br>status = pthread_cond_wait(&amp;pool-&gt;cond, &amp;pool-&gt;mutex);<br><br>pool-&gt;idle_threads--;<br><br><span class="hljs-keyword">if</span> (status == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">continue</span>;<br><br><span class="hljs-comment">// 等待线程条件变量异常，则该线程需要退出</span><br>pool-&gt;curr_threads--;<br>pthread_mutex_unlock(&amp;pool-&gt;mutex);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br><br><span class="hljs-comment">// 生产者线程调用此函数添加新的处理任务</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">add_thread_job</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> thread_pool *pool, <span class="hljs-type">void</span> (*func)(<span class="hljs-type">void</span>*), <span class="hljs-type">void</span> *arg)</span><br>&#123;<br><span class="hljs-comment">// 动态分配任务对象</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_job</span> *<span class="hljs-title">job</span> =</span> (<span class="hljs-keyword">struct</span> thread_job*) <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(*job));<br><br>job-&gt;func = func;<br>job-&gt;arg = arg;<br><br>pthread_mutex_lock(&amp;pool-&gt;mutex);<br><br><span class="hljs-comment">// 将新任务添加进线程池的任务链表中</span><br><span class="hljs-keyword">if</span> (pool-&gt;first == <span class="hljs-literal">NULL</span>)<br>pool-&gt;first = job;<br><span class="hljs-keyword">else</span><br>pool-&gt;last-&gt;next = job;<br>pool-&gt;last = job;<br>job-&gt;next = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-keyword">if</span> (pool-&gt;idle_threads &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 如果有空闲消费者线程，则通知空闲线程进行处理，同时需要解锁</span><br><br>pthread_mutex_unlock(&amp;pool-&gt;mutex);<br>pthread_cond_signal(&amp;pool-&gt;cond);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (pool-&gt;curr_threads &lt; pool-&gt;max_threads) &#123;<br><span class="hljs-comment">// 如果未超过最大线程数限制，则创建一个新的消费者线程</span><br><br><span class="hljs-type">pthread_t</span> id;<br><span class="hljs-type">pthread_attr_t</span> attr;<br><br>pthread_attr_init(&amp;attr);<br><br><span class="hljs-comment">// 将线程属性设为分离模式，这样当线程退出时其资源自动由系统回收</span><br>pthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);<br><br><span class="hljs-comment">// 创建一个消费者线程</span><br><span class="hljs-keyword">if</span> (pthread_create(&amp;id, &amp;attr, consumer_thread, pool) == <span class="hljs-number">0</span>)<br>pool-&gt;curr_threads++;<br><br>pthread_mutex_unlock(&amp;pool-&gt;mutex);<br>pthread_attr_destroy(&amp;attr);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 创建线程池对象</span><br><span class="hljs-keyword">struct</span> thread_pool *<span class="hljs-title function_">create_thread_pool</span><span class="hljs-params">(<span class="hljs-type">int</span> max_threads)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_pool</span> *<span class="hljs-title">pool</span> =</span> (<span class="hljs-keyword">struct</span> thread_pool*) <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(*pool));<br><br>pool-&gt;max_threads = max_threads;<br>pthread_mutex_init(&amp;pool-&gt;mutex);<br>pthread_cond_init(&amp;pool-&gt;cond);<br>...<br><br><span class="hljs-keyword">return</span> pool;<br>&#125;<br><br><span class="hljs-comment">///////////////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">// 使用上面线程池的示例如下：</span><br><br><span class="hljs-comment">// 由消费者线程回调的处理过程</span><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">thread_callback</span><span class="hljs-params">(<span class="hljs-type">void</span>* arg)</span><br>&#123;<br>      ...<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">thread_pool</span> *<span class="hljs-title">pool</span> =</span> create_thread_pool(<span class="hljs-number">100</span>);<br><span class="hljs-type">int</span>   i;<br><br><span class="hljs-comment">// 循环添加 1000000 次线程处理任务</span><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000000</span>; i++)<br>add_thread_job(pool, thread_callback, <span class="hljs-literal">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>乍一看去，似乎也没有什么问题，象很多经典的开源代码中也是这样设计的，但有一个重要问题被忽视了：线程池设计中的惊群现象。大家可以看到，整个线程池只有一个线程条件变量和线程互斥锁，生产者线程和消费者线程（即线程池中的子线程）正是通过这两个变量进行同步的。生产者线程每添加一个新任务，都会调用 pthread_cond_signal 一次，由操作系统唤醒一个在线程条件变量等待的消费者线程，但如果查看 pthread_cond_signal API 的系统帮助，你会发现其中有一句话：调用此函数后，系统会唤醒在相同条件变量上等待的一个或多个线程。而正是这句模棱两可的话没有引起很多线程池设计者的注意，这也是整个线程池中消费者线程收到信号通知后产生惊群现象的根源所在，并且是消费者线程数量越多，惊群现象越严重—-意味着 CPU 占用越高，线程池的调度性能越低。</p><p>要想避免如上线程池设计中的惊群问题，在仍然共用一个线程互斥锁的条件下，给每一个消费者线程创建一个线程条件变量，生产者线程在添加任务时，找到空闲的消费者线程，将任务置入该消费者的任务队列中同时只通知 (pthread_cond_signal) 该消费者的线程条件变量，消费者线程与生产者线程虽然共用相同的线程互斥锁（因为有全局资源及调用 pthread_cond_wait 所需），但线程条件变量的通知过程却是定向通知的，未被通知的消费者线程不会被唤醒，这样惊群现象也就不会产生了。</p><p>当然，还有一些设计上的细节需要注意，比如：当没有空闲消费者线程时，需要将任务添加进线程池的全局任务队列中，消费者线程处理完自己的任务后需要查看一下线程池中的全局任务队列中是否还有未处理的任务。</p><p>更多的线程池的设计细节请参考 acl (<a href="https://sourceforge.net/projects/acl/">https://sourceforge.net/projects/acl/</a>) 库中 lib_acl&#x2F;src&#x2F;thread&#x2F;acl_pthread_pool.c 中的代码。</p><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee： <a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>线程编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl_cpp 库编写多线程程序</title>
    <link href="/2013/10/26/threads_cpp/"/>
    <url>/2013/10/26/threads_cpp/</url>
    
    <content type="html"><![CDATA[<p>在 《利用ACL库开发高并发半驻留式线程池程序》中介绍了如何使用 C 版本的 acl 线程库编写多线程程序，本文将会介绍如何使用 C++ 版本的 acl 线程库编写多线程程序，虽然 C++ 版 acl 线程库基于 C 版的线程库，但却提供了更为清晰简洁的接口定义（很多地方参考了 JAVA 的线程接口定义）。下面是一个简单的使用线程的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-comment">// 子线程类定义</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mythread</span> : <span class="hljs-keyword">public</span> acl::thread<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">mythread</span>() &#123;&#125;<br>~<span class="hljs-built_in">mythread</span>() &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类纯虚函数，当在主线程中调用线程实例的 start 函数时</span><br><span class="hljs-comment">// 该虚函数将会被调用</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* myname = <span class="hljs-string">&quot;run&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: thread id: %lu, %lu\r\n&quot;</span>,<br>myname, <span class="hljs-built_in">thread_id</span>(), acl::thread::<span class="hljs-built_in">thread_self</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">test_thread</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* myname = <span class="hljs-string">&quot;test_thread&quot;</span>;<br>mythread thr;  <span class="hljs-comment">// 子线程对象实例</span><br><br><span class="hljs-comment">// 设置线程的属性为非分离方式，以便于下面可以调用 wait</span><br><span class="hljs-comment">// 等待线程结束</span><br>thr.<span class="hljs-built_in">set_detachable</span>(<span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 启动一个子线程</span><br><span class="hljs-keyword">if</span> (thr.<span class="hljs-built_in">start</span>() == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;start thread failed\r\n&quot;</span>);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: thread id is %lu, main thread id: %lu\r\n&quot;</span>,<br>myname, thr.<span class="hljs-built_in">thread_id</span>(), acl::thread::<span class="hljs-built_in">thread_self</span>());<br><br><span class="hljs-comment">// 等待子线程运行结束</span><br><span class="hljs-keyword">if</span> (thr.<span class="hljs-built_in">wait</span>(<span class="hljs-literal">NULL</span>) == <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wait thread failed\r\n&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;wait thread ok\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 初始化 acl 库</span><br>acl::<span class="hljs-built_in">acl_cpp_init</span>();<br><span class="hljs-built_in">test_thread</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter any key to exit ...\r\n&quot;</span>);<br><span class="hljs-built_in">getchar</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>从上面的示例来看，使用 acl 的线程库创建使用线程还是非常简单的。打开 lib_acl_cpp&#x2F;include&#x2F;acl_cpp&#x2F;stdlib&#x2F;thread.hpp 文件，可以看到线程类的声明，其中有两个基类：acl::thread 与 acl::thread_job，在 基类 acl::thread_job 中有一个纯虚函数 run（），acl::thread 也继承自 acl::thread_job，用户的线程类需要继承 acl::thread，并且需要实现基类 acl::thread_job 的纯虚函数： run（）。当应用在主线程中调用线程实例的 start() 函数时，acl 线程库内部便创建一个子线程，子线程被创建后线程对象的 run()　函数便被调用。下面是 acl::thread 类中几个主要的方法定义：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_job</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">thread_job</span>() &#123;&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">thread_job</span>() &#123;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 纯虚函数，子类必须实现此函数，该函数在子线程中执行</span><br><span class="hljs-comment"> * @return &#123;void*&#125; 线程退出前返回的参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread</span> : <span class="hljs-keyword">public</span> thread_job<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">thread</span>();<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">thread</span>();<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 开始启动线程过程，一旦该函数被调用，则会立即启动一个新的</span><br><span class="hljs-comment"> * 子线程，在子线程中执行基类 thread_job::run 过程</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 是否成功创建线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当创建线程时为非 detachable 状态，则可以调用此函数</span><br><span class="hljs-comment"> * 等待线程结束；否则，若创建线程时为 detachable 状态</span><br><span class="hljs-comment"> * 在调用本函数时将会报错</span><br><span class="hljs-comment"> * @param out &#123;void**&#125; 当该参数非空指针时，该参数用来存放</span><br><span class="hljs-comment"> *  线程退出前返回的参数</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">wait</span><span class="hljs-params">(<span class="hljs-type">void</span>** out = <span class="hljs-literal">NULL</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在调用 start 前调用此函数可以设置所创建线程是否为</span><br><span class="hljs-comment"> * 分离 (detachable) 状态；如果未调用此函数，则所创建</span><br><span class="hljs-comment"> * 的线程默认为分离状态</span><br><span class="hljs-comment"> * @param yes &#123;bool&#125; 是否为分离状态</span><br><span class="hljs-comment"> * @return &#123;thread&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">thread&amp; <span class="hljs-title">set_detachable</span><span class="hljs-params">(<span class="hljs-type">bool</span> yes)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小</span><br><span class="hljs-comment"> * @param size &#123;size_t&#125; 线程堆栈大小，当该值为 0 或未</span><br><span class="hljs-comment"> *  调用此函数，则所创建的线程堆栈大小为系统的默认值</span><br><span class="hljs-comment"> * @return &#123;thread&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">thread&amp; <span class="hljs-title">set_stacksize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在调用 start 后调用此函数可以获得所创建线程的 id 号</span><br><span class="hljs-comment"> * @return &#123;unsigned long&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">thread_id</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前调用者所在线程的线程 id 号</span><br><span class="hljs-comment"> * @return &#123;unsigned long&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">unsigned</span> <span class="hljs-type">long</span> <span class="hljs-title">thread_self</span><span class="hljs-params">()</span></span>;<br>        ....<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>从上面的线程示例及 acl::thread 的类定义，也许有人会觉得应该把 acl::thread_job 的纯虚方法：run() 放在 acl::thread 类中，甚至觉得 acl::thread_job 类是多余的，但是因为 acl 库中还支持线程池方式，则 acl::thread_job 就显得很有必要了。在 lib_acl_cpp\include\acl_cpp\stdlib\thread_pool.hpp 头文件中可以看到 acl 的线程池类 acl::thread_pool 的声明，该类的主要函数接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">thread_pool</span><br>&#123;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 启动线程池，在创建线程池对象后，必须首先调用此函数以启动线程池</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 停止并销毁线程池，并释放线程池资源，调用此函数可以使所有子线程退出，</span><br><span class="hljs-comment"> * 但并不释放本实例，如果该类实例是动态分配的则用户应该自释放类实例，</span><br><span class="hljs-comment"> * 在调用本函数后，如果想重启线程池过程，则必须重新调用 start 过程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等待线程池中的所有线程池执行完所有任务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">wait</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将一个任务交给线程池中的一个线程去执行，线程池中的</span><br><span class="hljs-comment"> * 线程会执行该任务中的 run 函数</span><br><span class="hljs-comment"> * @param job &#123;thread_job*&#125; 线程任务</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">run</span><span class="hljs-params">(thread_job* job)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将一个任务交给线程池中的一个线程去执行，线程池中的</span><br><span class="hljs-comment"> * 线程会执行该任务中的 run 函数；该函数功能与 run 功能完全相同，只是为了</span><br><span class="hljs-comment"> * 使 JAVA 程序员看起来更为熟悉才提供了此接口</span><br><span class="hljs-comment"> * @param job &#123;thread_job*&#125; 线程任务</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">execute</span><span class="hljs-params">(thread_job* job)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小</span><br><span class="hljs-comment"> * @param size &#123;size_t&#125; 线程堆栈大小，当该值为 0 或未</span><br><span class="hljs-comment"> *  调用此函数，则所创建的线程堆栈大小为系统的默认值</span><br><span class="hljs-comment"> * @return &#123;thread&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">thread_pool&amp; <span class="hljs-title">set_stacksize</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置线程池最大线程个数限制</span><br><span class="hljs-comment"> * @param max &#123;size_t&#125; 最大线程数，如果不调用此函数，则内部缺省值为 100</span><br><span class="hljs-comment"> * @return &#123;thread_pool&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">thread_pool&amp; <span class="hljs-title">set_limit</span><span class="hljs-params">(<span class="hljs-type">size_t</span> max)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置线程池中空闲线程的超时退出时间</span><br><span class="hljs-comment"> * @param ttl &#123;int&#125; 空闲超时时间(秒)，如果不调用此函数，则内部缺省为 0</span><br><span class="hljs-comment"> * @return &#123;thread_pool&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">thread_pool&amp; <span class="hljs-title">set_idle</span><span class="hljs-params">(<span class="hljs-type">int</span> ttl)</span></span>;<br>        ......<br>&#125;;<br></code></pre></td></tr></table></figure><p>这些接口定义也相对简单，下面给出一个使用线程池的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 线程工作类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">myjob</span> : <span class="hljs-keyword">public</span> acl::thread_job<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">myjob</span>() &#123;&#125;<br>~<span class="hljs-built_in">myjob</span>() &#123;&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类中的纯虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span>* <span class="hljs-title">run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* myname = <span class="hljs-string">&quot;run&quot;</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: thread id: %lu\r\n&quot;</span>,<br>myname, acl::thread::<span class="hljs-built_in">thread_self</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-comment">// 线程池类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">mythread_pool</span> : <span class="hljs-keyword">public</span> acl::thread_pool<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">mythread_pool</span>() &#123;&#125;<br>~<span class="hljs-built_in">mythread_pool</span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread pool destroy now, tid: %lu\r\n&quot;</span>,<br>acl::thread::<span class="hljs-built_in">thread_self</span>());<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类虚函数，当子线程被创建时该虚函数将被调用</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">thread_on_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* myname = <span class="hljs-string">&quot;thread_on_init&quot;</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: curr tid: %lu\r\n&quot;</span>, myname,<br>acl::thread::<span class="hljs-built_in">thread_self</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 基类虚函数，当子线程退出前该虚函数将被调用</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">thread_on_exit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* myname = <span class="hljs-string">&quot;thread_on_exit&quot;</span>;<br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: curr tid: %lu\r\n&quot;</span>, myname,<br>acl::thread::<span class="hljs-built_in">thread_self</span>());<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>acl::thread_pool* threads = <span class="hljs-keyword">new</span> <span class="hljs-built_in">mythread_pool</span>();<br>threads-&gt;<span class="hljs-built_in">start</span>();  <span class="hljs-comment">// 启动线程池过程</span><br><br>acl::thread_job *job1= <span class="hljs-keyword">new</span> myjob, *job2 = <span class="hljs-keyword">new</span> myjob;<br>threads-&gt;<span class="hljs-built_in">execute</span>(job1);<br>threads-&gt;<span class="hljs-built_in">execute</span>(job2);<br><br><span class="hljs-comment">// 为了保证 job1, job2动态内存被正确释放，</span><br><span class="hljs-comment">// 必须调用 threads-&gt;stop 等待子线程运行结束后在</span><br><span class="hljs-comment">// 主线程中将其释放</span><br>threads-&gt;<span class="hljs-built_in">stop</span>();<br><span class="hljs-keyword">delete</span> threads;<br><br><span class="hljs-comment">// 在主线程中释放动态分配的对象</span><br><span class="hljs-keyword">delete</span> job1;<br><span class="hljs-keyword">delete</span> job2;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上例所示，在使用 acl 的C++版本线程池类库时，必须定义一个线程工作类（继承自 acl::thread_job）并实现基类的纯虚函数：run()；另外，在使用线程池时，如果想要在线程创建时初始化一些线程局部变量以及在线程退出前释放一些线程局部变量，则可以定义 acl::thread_pool 的子类，实现基类中的 thread_on_init 和 thread_on_exit 方法，如果不需要，则可以直接使用 acl::thread_pool 类对象。</p><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>线程编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>acl 日志记录方式介绍</title>
    <link href="/2013/06/23/log/"/>
    <url>/2013/06/23/log/</url>
    
    <content type="html"><![CDATA[<p>在使用 acl 库编写应用过程中，记录日志是一个非常重要的过程，acl 从几个层面提供了日志的不同记录方式。在 acl 的 C 库部分(lib_acl.a)，有三个源文件与日志记录相关：acl_msg.c&#x2F;acl_msg.h, acl_mylog.c&#x2F;acl_mylog.h, acl_debug.c&#x2F;acl_debug.h。其中，acl_mylog.c 是真正记录日志的源文件，acl_msg.c 则是在 acl_mylog.c 基础之上的二次封装，acl_debug.c 是在 acl_msg.c 基础之上的再次封装。下面根据此三个日志源文件从三个层次描述日志记录的过程。</p><h2 id="一、ac-mylog-c-x2F-acl-mylog-h"><a href="#一、ac-mylog-c-x2F-acl-mylog-h" class="headerlink" title="一、ac_mylog.c&#x2F;acl_mylog.h"></a>一、ac_mylog.c&#x2F;acl_mylog.h</h2><p>打开 acl_mylog.h 头文件，可以看到主要有三个函数：acl_open_log（打开日志文件），acl_write_to_log（写日志）以及acl_close_log（关闭日志）—（这三个函数是最基础的日志记录过程，当然我们不必直接使用）。该库支持两类日志记录方式：1、本地文件记录方式，2、与 syslog-ng 结合的网络日志记录方式。本地文件记录方式是 acl 日志库对外提供的最简单的日志记录方式，此方式不依赖于第三方日志库，但不应用在生产环境中，因为该方式不支持日志回滚等高级特性，为了便于生产上使用，所以产生了第二种方式（与 syslog-ng 结合），查看日志打开接口（如下）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打开日志文件</span><br><span class="hljs-comment"> * @param recipients &#123;const char*&#125; 日志接收器列表，由 &quot;|&quot; 分隔，接收器</span><br><span class="hljs-comment"> *  可以是本地文件或远程套接口，如:</span><br><span class="hljs-comment"> *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock</span><br><span class="hljs-comment"> *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,</span><br><span class="hljs-comment"> *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象</span><br><span class="hljs-comment"> * @param plog_pre &#123;const char*&#125; 日志记录信息前的提示信息，建议用进程</span><br><span class="hljs-comment"> *  名填写此值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">int</span> <span class="hljs-title">acl_open_log</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *recipients, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *plog_pre)</span></span>;<br></code></pre></td></tr></table></figure><p>从上面的函数声明可以看出，acl 的日志记录允许同时输出至多个日志管道中（最简单的方式就是直接写入本地磁盘文件：&#x2F;tmp&#x2F;test.log），同时更应看到，其中有三个奇怪的日志文件表达方式：UDP:IP:PORT, TCP:IP:PORT, UNIX:&#x2F;xxx，其实这三种方式均是与 syslog-ng 相关，即分别表示：</p><ul><li>1、以 UDP 方式发送日志至 syslog-ng；</li><li>2、以 TCP 方式发送日志至 syslog-ng；</li><li>3、以 UNIX 域套接字方式发送日志至 syslog-ng。</li></ul><p>因为日志管理是一个非常复杂的过程，所以在 acl 除了提供最简单的日志文件记录外，更建议用户将日志输出至 syslog-ng 中（作者自己的项目也往往是这样做的）。</p><h2 id="二、acl-msg-c-x2F-acl-msg-h"><a href="#二、acl-msg-c-x2F-acl-msg-h" class="headerlink" title="二、acl_msg.c&#x2F;acl_msg.h"></a>二、acl_msg.c&#x2F;acl_msg.h</h2><p>该日志库提供了更为高级的日志记录方法，不仅提供了灵活的日志记录函数，同时还允许用户注册自己的日志记录函数库，该日志库主要函数接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 日志打开函数</span><br><span class="hljs-comment"> * @param log_file &#123;const char*&#125; 日志接收者集合，由 &quot;|&quot; 分隔，接收器</span><br><span class="hljs-comment"> *  可以是本地文件或远程套接口，如:</span><br><span class="hljs-comment"> *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock</span><br><span class="hljs-comment"> *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,</span><br><span class="hljs-comment"> *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象</span><br><span class="hljs-comment"> * @param plog_pre &#123;const char*&#125; 日志记录信息前的提示信息，建议用进程</span><br><span class="hljs-comment"> * @param info_pre &#123;const char*&#125; 日志记录信息前的提示信息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_msg_open</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *log_file, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *info_pre)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 关闭日志函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_msg_close</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br>       上面是日志打开与关闭的函数，看上去算是相对简单。下面是几个日志记录的函数接口：<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 一般级别日志信息记录函数</span><br><span class="hljs-comment"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class="hljs-comment"> * @param ... 变参序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>WIN32</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_msg_info</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>ACL_API <span class="hljs-type">void</span> __attribute__((format(printf,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)))<br><span class="hljs-built_in">acl_msg_info</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 警告级别日志信息记录函数</span><br><span class="hljs-comment"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class="hljs-comment"> * @param ... 变参序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>WIN32</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_msg_warn</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>ACL_API <span class="hljs-type">void</span> __attribute__((format(printf,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)))<br><span class="hljs-built_in">acl_msg_warn</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 错误级别日志信息记录函数</span><br><span class="hljs-comment"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class="hljs-comment"> * @param ... 变参序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>WIN32</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_msg_error</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>ACL_API <span class="hljs-type">void</span> __attribute__((format(printf,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)))<br><span class="hljs-built_in">acl_msg_error</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 致命级别日志信息记录函数</span><br><span class="hljs-comment"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class="hljs-comment"> * @param ... 变参序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>WIN32</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_msg_fatal</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>ACL_API <span class="hljs-type">void</span> __attribute__((format(printf,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)))<br><span class="hljs-built_in">acl_msg_fatal</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 恐慌级别日志信息记录函数</span><br><span class="hljs-comment"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class="hljs-comment"> * @param ... 变参序列</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span>WIN32</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_msg_panic</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...)</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>ACL_API <span class="hljs-type">void</span> __attribute__((format(printf,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>)))<br><span class="hljs-built_in">acl_msg_panic</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *fmt,...);<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br></code></pre></td></tr></table></figure><p>可以看到，这些函数的使用方式与 printf 类似，另外，在 UNIX 下使用 GCC 编译时前面还有一个修饰符：<strong>attribute</strong>((format(printf,m,n)))，这主要是方便 gcc 编译器针对变参进行语法检查（大家应该知道变参是如此方便灵活而又如此容易出错）。</p><p>为了方便程序开发过程中的调试，下面的函数当用户未调用 acl_msg_open 打开日志而直接使用 acl_msg_xxx 写日志时，决定是否将日志信息输出至屏幕（这个函数应该在程序初始化时调用）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当未调用 acl_msg_open 方式打开日志时，调用了 acl_msg_info/error/fatal/warn</span><br><span class="hljs-comment"> * 的操作，是否允许信息输出至标准输出屏幕上，通过此函数来设置该开关，该开关</span><br><span class="hljs-comment"> * 仅影响是否需要将信息输出至终端屏幕而不影响是否输出至文件中</span><br><span class="hljs-comment"> * @param onoff &#123;int&#125; 非 0 表示允许输出至屏幕</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_msg_stdout_enable</span><span class="hljs-params">(<span class="hljs-type">int</span> onoff)</span></span>;<br><br>       前面曾说过，acl 的日志库还允许用户使用自己的日志记录过程，但要求用户必须在程序初始化时注册自己的日志处理函数，如下：<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在打开日志前调用此函数注册应用自己的日志打开函数、日志关闭函数、日志记录函数</span><br><span class="hljs-comment"> * @param open_fn &#123;ACL_MSG_OPEN_FN&#125; 自定义日志打开函数</span><br><span class="hljs-comment"> * @param close_fn &#123;ACL_MSG_CLOSE_FN&#125; 自定义日志关闭函数</span><br><span class="hljs-comment"> * @param write_fn &#123;ACL_MSG_WRITE_FN&#125; 自定义日志记录函数</span><br><span class="hljs-comment"> * @param ctx &#123;void*&#125; 自定义参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_msg_register</span><span class="hljs-params">(ACL_MSG_OPEN_FN open_fn, ACL_MSG_CLOSE_FN close_fn,</span></span><br><span class="hljs-params"><span class="hljs-function">        ACL_MSG_WRITE_FN write_fn, <span class="hljs-type">void</span> *ctx)</span></span>;<br></code></pre></td></tr></table></figure><p>调用此函数后，以后的日志记录过程（即当用户调用：acl_msg_xxx 相关过程时）的内容便输出便由用户的日志库控制。</p><p>除了以上主要的日志函数接口，在 acl_msg 中还提供了以下几个函数，便于用户知晓程序出错原因：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得上次系统调用出错时的错误描述信息，该函数内部采用了线程局部变量，所以是线程</span><br><span class="hljs-comment"> * 安全的，但使用起来更简单些</span><br><span class="hljs-comment"> * @return &#123;const char *&#125; 返回错误提示信息 </span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">const</span> <span class="hljs-type">char</span> *<span class="hljs-title">acl_last_serror</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得上次系统调用出错时的错误号</span><br><span class="hljs-comment"> * @return &#123;int&#125; 错误号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">int</span> <span class="hljs-title">acl_last_error</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="三、acl-debug-c-x2F-acl-debug-h"><a href="#三、acl-debug-c-x2F-acl-debug-h" class="headerlink" title="三、acl_debug.c&#x2F;acl_debug.h"></a>三、acl_debug.c&#x2F;acl_debug.h</h2><p>该日志函数库是在 acl_msg 之上的再一次封装，该库的思想来源于 squid 的日志记录方式，可以将日志分成不同的类别，每一个类别又分成不同的级别，这样用户就可以非常方便地通过配置文件来记录不同类别的不同级别的日志信息了。在程序初始化时需先调用如此函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化日志调试调用接口</span><br><span class="hljs-comment"> * @param pStr &#123;const char*&#125; 调试类别（建议值在100至1000之间）标签及级别字符串，</span><br><span class="hljs-comment"> *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_debug_init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pStr)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化日志调试调用接口</span><br><span class="hljs-comment"> * @param pStr &#123;const char*&#125; 调试标签及级别字符串，</span><br><span class="hljs-comment"> *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...</span><br><span class="hljs-comment"> * @param max_debug_level &#123;int&#125; 最大调试标签值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_debug_init2</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *pStr, <span class="hljs-type">int</span> max_debug_level)</span></span>;<br></code></pre></td></tr></table></figure><p>其中，第一个参数是一个由日志记录类别与级别组成的字符串，格式为：类别1:最大记录级别, 类别2:最大记录级别, …。例如：100:2; 102:3; 103:4，其含义是日志将会记录类别为 100 的所有级别值小于2、类别为 101 的所有级别值小于 3 以及类别为 103 的所有级别值小于 4 的日志信息。关于记录类别需要注意：类别值最好是 &gt;&#x3D; 100，且 &lt; 1000（当使用 acl_debug_init2 初始化时只要类别值 &gt;&#x3D; 100 即可，因为第二个参数指定了最大类别值），这是因为 acl 库内部一些保留的类别值都在 0 – 100 之间。</p><p>那么具体的使用这些类别与级别记录日志的接口是什么呢？如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 日志调试宏接口</span><br><span class="hljs-comment"> * @param SECTION &#123;int&#125; 调试标签值</span><br><span class="hljs-comment"> * @param LEVEL &#123;int&#125; 对应于SECTION调试标签的级别</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> acl_debug(SECTION, LEVEL) \</span><br><span class="hljs-meta">!acl_do_debug((SECTION), (LEVEL)) ? (void) 0 : acl_msg_info</span><br><br>        看到了吧，用户其实只需要调用一个宏即可，如下面的例子： <br><br><span class="hljs-comment">/* 初始化日志类别记录 */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *str = <span class="hljs-string">&quot;101:2; 103:4; 105:3&quot;</span>;<br><span class="hljs-comment">/* 记录所有类别值为 101 级别小于等于 2、类别值为 102 级别小于等于 4、类别值为 105 级别小于等于 3 的日志内容 */</span><br><span class="hljs-built_in">acl_debug_init</span>(str);<br><br>......<br><span class="hljs-comment">/* 下面的日志因符合类别值 101 级别值 &lt;= 2 而被记录 */</span><br><span class="hljs-built_in">acl_debug</span>(<span class="hljs-number">101</span>, <span class="hljs-number">2</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><br><span class="hljs-comment">/* 下面日志符合类别 105 的记录级别 */</span><br><span class="hljs-built_in">acl_debug</span>(<span class="hljs-number">105</span>, <span class="hljs-number">1</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><br><span class="hljs-comment">/* 下面的日志因不符合类别值 103 的记录级别条件而被忽略 */</span><br><span class="hljs-built_in">acl_debug</span>(<span class="hljs-number">103</span>, <span class="hljs-number">5</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br><br><span class="hljs-comment">/* 下面日志的类别值 102 因不存在而被忽略 */</span><br><span class="hljs-built_in">acl_debug</span>(<span class="hljs-number">102</span>, <span class="hljs-number">1</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class="hljs-built_in">time</span>(<span class="hljs-literal">NULL</span>));<br></code></pre></td></tr></table></figure><p>此外，为了方便，还可以传给 acl_debug_init 的参数写为：”all:1”，意思是所有类别的级别值 &lt;&#x3D; 1 的日志都将被记录，如下面的内容都会被记录：</p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs perl">acl_debug_init(<span class="hljs-string">&quot;all:1&quot;</span>);<br>......<br>acl_debug(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class="hljs-number">_</span>, __LINE_<span class="hljs-number">_</span>, <span class="hljs-keyword">time</span>(NULL));<br>acl_debug(<span class="hljs-number">101</span>, <span class="hljs-number">1</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class="hljs-number">_</span>, __LINE_<span class="hljs-number">_</span>, <span class="hljs-keyword">time</span>(NULL));<br>acl_debug(<span class="hljs-number">101</span>, <span class="hljs-number">0</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class="hljs-number">_</span>, __LINE_<span class="hljs-number">_</span>, <span class="hljs-keyword">time</span>(NULL));<br>acl_debug(<span class="hljs-number">102</span>, <span class="hljs-number">1</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class="hljs-number">_</span>, __LINE_<span class="hljs-number">_</span>, <span class="hljs-keyword">time</span>(NULL));<br>acl_debug(<span class="hljs-number">103</span>, <span class="hljs-number">1</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class="hljs-number">_</span>, __LINE_<span class="hljs-number">_</span>, <span class="hljs-keyword">time</span>(NULL));<br>acl_debug(<span class="hljs-number">104</span>, <span class="hljs-number">1</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class="hljs-number">_</span>, __LINE_<span class="hljs-number">_</span>, <span class="hljs-keyword">time</span>(NULL));<br>acl_debug(<span class="hljs-number">105</span>, <span class="hljs-number">1</span>)(<span class="hljs-string">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class="hljs-number">_</span>, __LINE_<span class="hljs-number">_</span>, <span class="hljs-keyword">time</span>(NULL));<br>        ......<br></code></pre></td></tr></table></figure><p>ok，有关日志  acl 日志记录函数就先写这些，使用者可以根据项目需要采用不同的日志记录方式。</p><p>github 地址：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee 地址：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl 库 rpc 功能类实现 阻塞任务过程与MFC 界面过程分离</title>
    <link href="/2013/02/24/aio_rpc_mfc/"/>
    <url>/2013/02/24/aio_rpc_mfc/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>MFC 程序员在编写 Windows 界面程序时经常需要处理一些阻塞任务过程，为了避免阻塞窗口的消息过程，一般会将阻塞过程将由一个子线程处理，该子线程在处理过程中通过向界面线程发送 Windows 窗口消息将处理结果传递给窗口线程。在 acl 库中的 rpc 功能类实现了更为方便的处理方式，通过 rpc 功能类，用户可以在主线程中进行非阻塞过程（如：界面消息过程或网络非阻塞通讯过程），而将阻塞任务交由子线程处理（如：网络阻塞通讯或数据库操作等），子线程可以将任务处理的中间状态和最终状态通过 rpc 功能类传递给主线程。</p><p>acl 的 rpc 类不仅能实现网络通讯方面的阻塞与非阻塞的粘合，同时还实现了阻塞过程与 MFC 界面过程的粘合，本文将以一个具体的 HTTP 下载过程为例来描述这一过程（示例在 acl 库中的 acl&#x2F;lib_acl_cpp&#x2F;samples&#x2F;gui_rpc 目录下）。关于 acl 库中 rpc 相关类的使用，用户可以参考 《acl_cpp 的 rpc 相关类整合阻塞及非阻塞过程》（在该文中的例子描述了非阻塞主线程与阻塞子线程的交互过程，其示例代码适用于 win32 及 linux 平台）。</p><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><h3 id="1、在界面主线程中初始化时创建-rpc-服务对象：acl-rpc-service"><a href="#1、在界面主线程中初始化时创建-rpc-服务对象：acl-rpc-service" class="headerlink" title="1、在界面主线程中初始化时创建 rpc 服务对象：acl::rpc_service"></a>1、在界面主线程中初始化时创建 rpc 服务对象：acl::rpc_service</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 全局静态变量</span><br><span class="hljs-type">static</span> acl::aio_handle* handle_;<br><span class="hljs-type">static</span> acl::rpc_service* service_;<br><br>......<br><br><span class="hljs-comment">// 创建非阻塞框架句柄，并采用 WIN32 消息模式：acl::ENGINE_WINMSG</span><br>handle_ = <span class="hljs-keyword">new</span> acl::<span class="hljs-built_in">aio_handle</span>(acl::ENGINE_WINMSG);<br><br><span class="hljs-comment">// 创建 rpc 服务对象</span><br><span class="hljs-type">int</span> max_threads = <span class="hljs-number">10</span>;  <span class="hljs-comment">// 服务最大子线程数量</span><br>service_ = <span class="hljs-keyword">new</span> acl::<span class="hljs-built_in">rpc_service</span>(max_threads, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 打开消息服务</span><br><span class="hljs-keyword">if</span> (service_-&gt;<span class="hljs-built_in">open</span>(handle_) == <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">logger_fatal</span>(<span class="hljs-string">&quot;open service error: %s&quot;</span>, acl::<span class="hljs-built_in">last_serror</span>());<br></code></pre></td></tr></table></figure><p>在上面代码中，有几点需要注意：1）创建的 rpc 服务对象是全局性的；2）在创建非阻塞句柄时必须指定为 win32 界面消息事件类型：acl::ENGINE_WINMSG；3）在创建 rpc_service 时的第二个参数 win32_gui 必须为 true。</p><h3 id="2、创建-rpc-中-acl-rpc-request-类的子类，以实现阻塞非阻塞粘合过程"><a href="#2、创建-rpc-中-acl-rpc-request-类的子类，以实现阻塞非阻塞粘合过程" class="headerlink" title="2、创建 rpc 中 acl::rpc_request 类的子类，以实现阻塞非阻塞粘合过程"></a>2、创建 rpc 中 acl::rpc_request 类的子类，以实现阻塞非阻塞粘合过程</h3><p>本例中该子类为：http_download，在 http_download 类中必须实现父类 acl::rpc_request 中定义的两个纯虚接口：rpc_run，rpc_onover。</p><p>其中，http_download 的头文件如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * http 请求过程类，该类对象在子线程中发起远程 HTTP 请求过程，将处理结果</span><br><span class="hljs-comment"> * 返回给主线程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">http_download</span> : <span class="hljs-keyword">public</span> acl::rpc_request<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造函数</span><br><span class="hljs-comment"> * @param addr &#123;const char*&#125; HTTP 服务器地址，格式：domain:port</span><br><span class="hljs-comment"> * @param url &#123;const char*&#125; http url 地址</span><br><span class="hljs-comment"> * @param callback &#123;rpc_callback*&#125; http 请求结果通过此类对象</span><br><span class="hljs-comment"> *  通知主线程过程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">http_download</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* url,<br>rpc_callback* callback);<br><span class="hljs-keyword">protected</span>:<br>~<span class="hljs-built_in">http_download</span>() &#123;&#125;<br><br><span class="hljs-comment">// 基类虚函数：子线程处理函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rpc_run</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 基类虚函数：主线程处理过程，收到子线程任务完成的消息</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rpc_onover</span><span class="hljs-params">()</span></span>;<br><br><span class="hljs-comment">// 基类虚函数：主线程处理过程，收到子线程的通知消息</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rpc_wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span>* ctx)</span></span>;<br><br>        ......<br></code></pre></td></tr></table></figure><p>在 http_download 类的构造参数中有一个接口类：rpc_callback，这是一个纯虚类，主要是为了方便将 http 的结果数据返回给主线程，该类的声明如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// 纯虚类，子类须实现该类中的纯虚接口</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">rpc_callback</span><br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">rpc_callback</span>() &#123;&#125;<br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">rpc_callback</span>() &#123;&#125;<br><br><span class="hljs-comment">// 设置 HTTP 请求头数据虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SetRequestHdr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* hdr)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 设置 HTTP 响应头数据虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SetResponseHdr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* hdr)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 下载过程中的回调函数虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnDownloading</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> content_length,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> total_read)</span> </span>= <span class="hljs-number">0</span>;<br><span class="hljs-comment">// 下载完成时的回调函数虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnDownloadOver</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> total_read,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">double</span> spent)</span> </span>= <span class="hljs-number">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure><p>http_download 类的函数实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;http_download.h&quot;</span></span><br><br><span class="hljs-comment">// 由子线程动态创建的 DOWN_CTX 对象的数据类型</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span><br>&#123;<br>CTX_T_REQ_HDR,<span class="hljs-comment">// 为 HTTP 请求头数据</span><br>CTX_T_RES_HDR,<span class="hljs-comment">// 为 HTTP 响应头数据</span><br>CTX_T_CONTENT_LENGTH,<span class="hljs-comment">// 为 HTTP 响应体的长度</span><br>CTX_T_PARTIAL_LENGTH,<span class="hljs-comment">// 为 HTTP 下载数据体的长度</span><br>CTX_T_END<br>&#125; <span class="hljs-type">ctx_t</span>;<br><br><span class="hljs-comment">// 子线程动态创建的数据对象，主线程接收此数据</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DOWN_CTX</span> <br>&#123;<br><span class="hljs-type">ctx_t</span> type;<br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> length;<br>&#125;;<br><br><span class="hljs-comment">// 用来精确计算时间截间隔的函数，精确到毫秒级别</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">double</span> <span class="hljs-title">stamp_sub</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timeval *from,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-keyword">struct</span> timeval *sub_by)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> res;<br><br><span class="hljs-built_in">memcpy</span>(&amp;res, from, <span class="hljs-built_in">sizeof</span>(<span class="hljs-keyword">struct</span> timeval));<br><br>res.tv_usec -= sub_by-&gt;tv_usec;<br><span class="hljs-keyword">if</span> (res.tv_usec &lt; <span class="hljs-number">0</span>)<br>&#123;<br>--res.tv_sec;<br>res.tv_usec += <span class="hljs-number">1000000</span>;<br>&#125;<br><br>res.tv_sec -= sub_by-&gt;tv_sec;<br><span class="hljs-keyword">return</span> (res.tv_sec * <span class="hljs-number">1000.0</span> + res.tv_usec/<span class="hljs-number">1000.0</span>);<br>&#125;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-comment">// 子线程处理函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_download::rpc_run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">acl::http_request <span class="hljs-title">req</span><span class="hljs-params">(addr_)</span></span>;  <span class="hljs-comment">// HTTP 请求对象</span><br><span class="hljs-comment">// 设置 HTTP 请求头信息</span><br>req.<span class="hljs-built_in">request_header</span>().<span class="hljs-built_in">set_url</span>(url_.<span class="hljs-built_in">c_str</span>())<br>.<span class="hljs-built_in">set_content_type</span>(<span class="hljs-string">&quot;text/html&quot;</span>)<br>.<span class="hljs-built_in">set_host</span>(addr_.<span class="hljs-built_in">c_str</span>())<br>.<span class="hljs-built_in">set_method</span>(acl::HTTP_METHOD_GET);<br><br>req.<span class="hljs-built_in">request_header</span>().<span class="hljs-built_in">build_request</span>(req_hdr_);<br>DOWN_CTX* ctx = <span class="hljs-keyword">new</span> DOWN_CTX;<br>ctx-&gt;type = CTX_T_REQ_HDR;<br><span class="hljs-built_in">rpc_signal</span>(ctx);  <span class="hljs-comment">// 通知主线程 HTTP 请求头数据</span><br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">timeval</span> begin, end;;<br><span class="hljs-built_in">gettimeofday</span>(&amp;begin, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-comment">// 发送 HTTP 请求数据</span><br><span class="hljs-keyword">if</span> (req.<span class="hljs-built_in">request</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;send request error&quot;</span>);<br>error_ = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">gettimeofday</span>(&amp;end, <span class="hljs-literal">NULL</span>);<br>total_spent_ = <span class="hljs-built_in">stamp_sub</span>(&amp;end, &amp;begin);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 获得 HTTP 请求的连接对象</span><br>acl::http_client* conn = req.<span class="hljs-built_in">get_client</span>();<br><span class="hljs-built_in">assert</span>(conn);<br><br>(<span class="hljs-type">void</span>) conn-&gt;<span class="hljs-built_in">get_respond_head</span>(&amp;res_hdr_);<br>ctx = <span class="hljs-keyword">new</span> DOWN_CTX;<br>ctx-&gt;type = CTX_T_RES_HDR;<br><span class="hljs-built_in">rpc_signal</span>(ctx);   <span class="hljs-comment">// 通知主线程 HTTP 响应头数据</span><br><br>ctx = <span class="hljs-keyword">new</span> DOWN_CTX;<br>ctx-&gt;type = CTX_T_CONTENT_LENGTH;<br><br>ctx-&gt;length = conn-&gt;<span class="hljs-built_in">body_length</span>();  <span class="hljs-comment">// 获得 HTTP 响应数据的数据体长度</span><br>content_length_ = ctx-&gt;length;<br><span class="hljs-built_in">rpc_signal</span>(ctx);  <span class="hljs-comment">// 通知主线程 HTTP 响应体数据长度</span><br><br><span class="hljs-function">acl::string <span class="hljs-title">buf</span><span class="hljs-params">(<span class="hljs-number">8192</span>)</span></span>;<br><span class="hljs-type">int</span>   real_size;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// 读 HTTP 响应数据体</span><br><span class="hljs-type">int</span> ret = req.<span class="hljs-built_in">read_body</span>(buf, <span class="hljs-literal">true</span>, &amp;real_size);<br><span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>)<br>&#123;<br>ctx = <span class="hljs-keyword">new</span> DOWN_CTX;<br>ctx-&gt;type = CTX_T_END;<br>ctx-&gt;length = ret;<br><span class="hljs-built_in">rpc_signal</span>(ctx);  <span class="hljs-comment">// 通知主线程下载完毕</span><br><span class="hljs-keyword">break</span>;<br>&#125;<br>ctx = <span class="hljs-keyword">new</span> DOWN_CTX;<br>ctx-&gt;type = CTX_T_PARTIAL_LENGTH;<br>ctx-&gt;length = real_size;<br><span class="hljs-comment">// 通知主线程当前已经下载的大小</span><br><span class="hljs-built_in">rpc_signal</span>(ctx);<br>&#125;<br><br><span class="hljs-comment">// 计算下载过程总时长</span><br><span class="hljs-built_in">gettimeofday</span>(&amp;end, <span class="hljs-literal">NULL</span>);<br>total_spent_ = <span class="hljs-built_in">stamp_sub</span>(&amp;end, &amp;begin);<br><br><span class="hljs-comment">// 至此，子线程运行完毕，主线程的 rpc_onover 过程将被调用</span><br>&#125;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br>http_download::<span class="hljs-built_in">http_download</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* url,<br>rpc_callback* callback)<br>: <span class="hljs-built_in">addr_</span>(addr)<br>, <span class="hljs-built_in">url_</span>(url)<br>, <span class="hljs-built_in">callback_</span>(callback)<br>, <span class="hljs-built_in">error_</span>(<span class="hljs-literal">false</span>)<br>, <span class="hljs-built_in">total_read_</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">content_length_</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">total_spent_</span>(<span class="hljs-number">0</span>)<br>&#123;<br><br>&#125;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-comment">// 主线程处理过程，收到子线程任务完成的消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_download::rpc_onover</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">logger</span>(<span class="hljs-string">&quot;http download(%s) over, 共 %I64d 字节，耗时 %.3f 毫秒&quot;</span>,<br>url_.<span class="hljs-built_in">c_str</span>(), total_read_, total_spent_);<br>callback_-&gt;<span class="hljs-built_in">OnDownloadOver</span>(total_read_, total_spent_);<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;  <span class="hljs-comment">// 销毁本对象</span><br>&#125;<br><br><span class="hljs-comment">// 主线程处理过程，收到子线程的通知消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">http_download::rpc_wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span>* ctx)</span></span><br><span class="hljs-function"></span>&#123;<br>DOWN_CTX* down_ctx = (DOWN_CTX*) ctx;<br><br><span class="hljs-comment">// 根据子线程中传来的不同的下载阶段进行处理</span><br><br><span class="hljs-keyword">switch</span> (down_ctx-&gt;type)<br>&#123;<br><span class="hljs-keyword">case</span> CTX_T_REQ_HDR:<br>callback_-&gt;<span class="hljs-built_in">SetRequestHdr</span>(req_hdr_.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> CTX_T_RES_HDR:<br>callback_-&gt;<span class="hljs-built_in">SetResponseHdr</span>(res_hdr_.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> CTX_T_CONTENT_LENGTH:<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> CTX_T_PARTIAL_LENGTH:<br>total_read_ += down_ctx-&gt;length;<br>callback_-&gt;<span class="hljs-built_in">OnDownloading</span>(content_length_, total_read_);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> CTX_T_END:<br><span class="hljs-built_in">logger</span>(<span class="hljs-string">&quot;%s: read over&quot;</span>, addr_.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;%s: ERROR&quot;</span>, addr_.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-comment">// 删除在子线程中动态分配的对象</span><br><span class="hljs-keyword">delete</span> down_ctx;<br>&#125;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br></code></pre></td></tr></table></figure><h3 id="3、在-MFC-界面类中创建-rpc-callback-的子类，接收子线程的-HTTP-处理结果"><a href="#3、在-MFC-界面类中创建-rpc-callback-的子类，接收子线程的-HTTP-处理结果" class="headerlink" title="3、在 MFC 界面类中创建 rpc_callback 的子类，接收子线程的 HTTP 处理结果"></a>3、在 MFC 界面类中创建 rpc_callback 的子类，接收子线程的 HTTP 处理结果</h3><p>本例直接将对话框类继承了 rpc_callback 接口类，其中部分内容如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// Cgui_rpcDlg 对话框</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cgui_rpcDlg</span> : <span class="hljs-keyword">public</span> CDialog<br>, <span class="hljs-keyword">public</span> rpc_callback<br>&#123;<br><span class="hljs-comment">// 构造</span><br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">Cgui_rpcDlg</span>(CWnd* pParent = <span class="hljs-literal">NULL</span>);<span class="hljs-comment">// 标准构造函数</span><br>~<span class="hljs-built_in">Cgui_rpcDlg</span>();<br><br>        ......<br><br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">// 基类 rpc_callback 虚函数</span><br><br><span class="hljs-comment">// 设置 HTTP 请求头数据虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SetRequestHdr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* hdr)</span></span>;<br><span class="hljs-comment">// 设置 HTTP 响应头数据虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">SetResponseHdr</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* hdr)</span></span>;<br><span class="hljs-comment">// 下载过程中的回调函数虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnDownloading</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> content_length,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> total_read)</span></span>;<br><span class="hljs-comment">// 下载完成时的回调函数虚函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">OnDownloadOver</span><span class="hljs-params">(<span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> total_read,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">double</span> spent)</span></span>;<br>        ......<br>&#125;;<br></code></pre></td></tr></table></figure><p>4、用 VC2003 编译该例子，运行可执行程序可以得到如下的界面：<br><img src="/img/aio_rpc_mfc.png" alt="运行界面"></p><p>运行这个例子，在 URL 中输入地址（如：<a href="http://www.sina.com.cn/">http://www.sina.com.cn</a> ），点“开始运行”按钮，在下载 URL 数据的过程中移动界面窗口，可以看到界面窗口的消息过程并未被阻塞（因为 HTTP 阻塞下载过程是在子线程中进行的），同时界面的状态栏还能实时显示当前 URL 下载的进度状态（子线程通过 rpc_request 的消息传递方式将下载状态通知界面主线程）。</p><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>在界面编程中，将阻塞过程与界面过程分离（ 即将阻塞过程交由子线程处理）是一种编程思想，不仅可以用在 PC 机的界面编程中，同时对于手机 APP 开发也有用处，这样做的好处是：一方面可以利用多核，更重要的是使得界面编程更为简单（要比所有模块全部采用非阻塞编程要容易得多）。</p><h2 id="五、参考"><a href="#五、参考" class="headerlink" title="五、参考"></a>五、参考</h2><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>非阻塞编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>acl_cpp 的 rpc 相关类整合阻塞及非阻塞过程</title>
    <link href="/2012/07/13/aio_rpc/"/>
    <url>/2012/07/13/aio_rpc/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>非阻塞网络编程无疑成了高并发、高性能编程的代名词，但现实应用编程中并不是每种应用都需要采用非阻塞编程模式，因为这将大大增加编程的复杂性、开发周期以及出错率，所以我们写的绝大部分网络程序程序都是阻塞的，一般是一个进程一个网络连接或一个线程一个网络连接。即然非阻塞模式可以实现高并发网络连接，阻塞模式可以实现复杂的业务逻辑，那是否有办法将二者结合起来呢？答案是肯定的，其中在 acl_cpp 库中，ipc 目录下的模块就是为了满足这种需求而设计的。</p><h2 id="二、接口设计"><a href="#二、接口设计" class="headerlink" title="二、接口设计"></a>二、接口设计</h2><p>在 rpc.hpp 头文件中有两个类：rpc_service 和 rpc_request，其中 rpc_request 是一个纯虚类，用户需要继承此类并实现该类中规定的纯虚接口，从而实现自己的阻塞操作功能；rpc_service 是阻塞与非阻塞结合的粘合类，通过将 rpc_request 子类实例传递给 rpc_service 类实例的 rpc_fork 方法，实现将阻塞请求过程交给子线程处理的目的。</p><h3 id="1、rpc-service-类"><a href="#1、rpc-service-类" class="headerlink" title="1、rpc_service 类"></a>1、rpc_service 类</h3><h4 id="1-1、构造函数："><a href="#1-1、构造函数：" class="headerlink" title="1.1、构造函数："></a>1.1、构造函数：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造函数</span><br><span class="hljs-comment"> * @param nthread &#123;int&#125; 如果该值 &gt; 1 则内部自动采用线程池，否则</span><br><span class="hljs-comment"> *  则是一个请求一个线程</span><br><span class="hljs-comment"> * @param win32_gui &#123;bool&#125; 是否是窗口类的消息，如果是，则内部的</span><br><span class="hljs-comment"> *  通讯模式自动设置为基于 WIN32 的消息，否则依然采用通用的套接</span><br><span class="hljs-comment"> *  口通讯方式</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">rpc_service</span>(<span class="hljs-type">int</span> nthread, <span class="hljs-type">bool</span> win32_gui = <span class="hljs-literal">false</span>)<br></code></pre></td></tr></table></figure><p>从参数 win32_gui 可以看出，acl_cpp 的阻塞&#x2F;非阻塞结合模式不仅可以用在通常的网络编程中，同时还可以用在阻塞过程与 WINDOWS 界面消息相结合的方面，这无非是经常用 MFC 进行界面编程的福音（例如，用户 VC 写了一个界面程序—当然这个界面窗口是基于 WIN32 消息的，但如果想进行一些数据库操作或文件下载操作，对用户而言阻塞式方法是非常容易实现这两类需求的，但 WIN32 的界面过程不能堵在任何一个数据库操作或文件下载过程，原来 VC 程序员通常的做法也是创建单独的线程进行阻塞操作，然后通过给主窗口传递消息将操作结果通知至主线程，幸运的是 acl_cpp 的 rpc 相关类可以使这一过程更为方便快捷；再如，你写的一个网络服务器程序的主线程是非阻塞的，但其中你不得不调用别人提供的库以实现用户身份验证的功能，同时这个用于用户认证的库又恰恰是阻塞的—一般也是如此，固然，你也许可以费很周折实现这一过程，同样，acl_cpp 的 rpc 相关类可以帮你解决这类问题）。</p><h4 id="1-2、将阻塞处理过程的对象交由子线程处理："><a href="#1-2、将阻塞处理过程的对象交由子线程处理：" class="headerlink" title="1.2、将阻塞处理过程的对象交由子线程处理："></a>1.2、将阻塞处理过程的对象交由子线程处理：</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 主线程中运行：将请求任务放入子线程池的任务请求队列中，当线程池</span><br><span class="hljs-comment"> * 中的一个子线程接收到该任务后便调用 rpc_request::rpc_run 方法调</span><br><span class="hljs-comment"> * 用子类的方法，当任务处理完毕后给主线程发消息，在主线程中再调用</span><br><span class="hljs-comment"> * rpc_request::rpc_callback</span><br><span class="hljs-comment"> * @param req &#123;rpc_request*&#125; rpc_request 子类实例，非空</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rpc_fork</span><span class="hljs-params">(rpc_request* req)</span></span>;<br></code></pre></td></tr></table></figure><p>通过此接口，可以将阻塞请求过程交给子线程处理，子线程处理完后再通知主线程。</p><h3 id="2、rpc-request-类"><a href="#2、rpc-request-类" class="headerlink" title="2、rpc_request 类"></a>2、rpc_request 类</h3><p>在类 rpc_request 中有三个虚接口，用户子类必须实现其中的两个纯虚接口：rpc_run 和 rpc_onover，同时用户可以根据需要实现另一非纯虚接口：rpc_wakeup。是当用户调完 rpc_service::rpc_fork 且子线程接收到此请求任务后 rpc_request::rpc_run 方法会被调用（一定切记：rpc_fork 是在主线程中被调用的，而 rpc_run 是在子线程中被调用的）；当 rpc_request::rpc_run 函数返回后，rpc_reuqest::rpc_onover 会在主线程中被调用以表示子线程已经处理完毕（同样需要严重注意：rpc_request::rpc_onover 方法又回到主线程中被调用），这样，通过这两个过程就实现了将阻塞过程放在子线程中处理，主线程的非阻塞过程（非阻塞网络事件或非阻塞的 WIN32 消息过程）异步地等待子线程完成任务。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在子线程中被调用，子类必须实现此接口，用于处理具体任务</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rpc_run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在主线程中被调用，子类必须实现此接口，</span><br><span class="hljs-comment"> * 当子线程处理完请求任务后该接口将被调用，所以该类对象只能</span><br><span class="hljs-comment"> * 是当本接口调用后才能被释放，禁止在调用本接口前释放本类对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rpc_onover</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>另外，在 rpc_request 类中还有一个非纯虚方法：rpc_wakeup，这是做什么用的呢？可以假设这种应用场景，在子线程中调用 rpc_request::rpc_run 方法内部过程中，用户如果需要通知主线程一些中间状态（比如，文件下载的进度）该怎么办？那就在 rpc_run 方法内先调用 rpc_request::rpc_signal 通知主线程子线程处理的中间状态，则在主线程中用户实现的 rpc_request::rpc_wakeup 虚接口就会被调用。下面是 rpc_signal 和 rpc_wakeup 的接口说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息</span><br><span class="hljs-comment"> * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的</span><br><span class="hljs-comment"> * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法</span><br><span class="hljs-comment"> * @param ctx &#123;void*&#125; 传递的参数指针，一般应该是动态地址</span><br><span class="hljs-comment"> *  比较好，这样可以避免同一个参数被重复覆盖的问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rpc_signal</span><span class="hljs-params">(<span class="hljs-type">void</span>* ctx)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 虚接口：当子线程调用本对象的 rpc_signal 时，在主线程中会</span><br><span class="hljs-comment"> * 调用本接口，通知在任务未完成前(即调用 rpc_onover 前)收到</span><br><span class="hljs-comment"> * 子线程运行的中间状态信息；内部自动支持套接口或 WIN32 窗口</span><br><span class="hljs-comment"> * 消息；应用场景，例如，对于 HTTP 下载应用，在子线程中可以</span><br><span class="hljs-comment"> * 一边下载，一边向主线程发送(调用 rpc_signal 方法)下载进程，</span><br><span class="hljs-comment"> * 则主线程会调用本类实例的此方法来处理此消息</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">rpc_wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span>* ctx)</span> </span>&#123; (<span class="hljs-type">void</span>) ctx; &#125;<br></code></pre></td></tr></table></figure><p>紧接着这个应用场景，假设在子线程调用 rpc_run 的内部通过 rpc_signal 通知主线程的中间状态后，希望主线程能收到此通知消息并且希望得到主线程下一步希望执行的指令才会进一步继续执行。于是便有了 rpc_request::cond_wait 和 rpc_request::cond_signal 两个方法的产生，即子线程通过 cond_wait 阻塞地等待主线程的下一步操作指令，主线程则调用 cond_signal 通知子线程下步指令，下面是这两个方法的说明：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当子线程调用 rpc_signal 给主线程后，调用本方法可以等待</span><br><span class="hljs-comment"> * 主线程发来下一步指令</span><br><span class="hljs-comment"> * @param timeout &#123;int&#125; 等待超时时间(毫秒)，当该值为 0 时</span><br><span class="hljs-comment"> *  则采用非阻塞等待模式，当该值为 &lt; 0 时，则采用完全阻塞</span><br><span class="hljs-comment"> *  等待模式(即一直等到主线程发送 cond_signal 通知)，当该</span><br><span class="hljs-comment"> *  值 &gt; 0 时，则等待的最大超时时间为 timeout 毫秒</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示收到主线程发来的通知信号，</span><br><span class="hljs-comment"> *  否则，需要调用 cond_wait_timeout 判断是否是超时引起的</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">cond_wait</span><span class="hljs-params">(<span class="hljs-type">int</span> timeout = <span class="hljs-number">-1</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息</span><br><span class="hljs-comment"> * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的</span><br><span class="hljs-comment"> * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法</span><br><span class="hljs-comment"> * @param ctx &#123;void*&#125; 传递的参数指针，一般应该是动态地址</span><br><span class="hljs-comment"> *  比较好，这样可以避免同一个参数被重复覆盖的问题</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rpc_signal</span><span class="hljs-params">(<span class="hljs-type">void</span>* ctx)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><p>如果您能大体明白上面有关 rpc_service 和 rpc_request 类的功能说明，相信下面的例子您也一定能看明白：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// rpc_download.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.hpp&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> acl;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span><br>&#123;<br>CTX_T_CONTENT_LENGTH,<br>CTX_T_PARTIAL_LENGTH,<br>CTX_T_END<br>&#125; <span class="hljs-type">ctx_t</span>;<br><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">DOWN_CTX</span> <br>&#123;<br><span class="hljs-type">ctx_t</span> type;<br><span class="hljs-type">int</span> length;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> __download_count = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">http_download</span> : <span class="hljs-keyword">public</span> rpc_request<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">http_download</span>(aio_handle&amp; handle, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* url)<br>: <span class="hljs-built_in">handle_</span>(handle)<br>, <span class="hljs-built_in">addr_</span>(addr)<br>, <span class="hljs-built_in">url_</span>(url)<br>, <span class="hljs-built_in">error_</span>(<span class="hljs-literal">false</span>)<br>, <span class="hljs-built_in">total_read_</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">content_length_</span>(<span class="hljs-number">0</span>)<br>&#123;&#125;<br>~<span class="hljs-built_in">http_download</span>() &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br><br><span class="hljs-comment">// 子线程处理函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rpc_run</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-function">http_request <span class="hljs-title">req</span><span class="hljs-params">(addr_)</span></span>;  <span class="hljs-comment">// HTTP 请求对象</span><br><br><span class="hljs-comment">// 设置 HTTP 请求头信息</span><br>req.<span class="hljs-built_in">request_header</span>().<span class="hljs-built_in">set_url</span>(url_.<span class="hljs-built_in">c_str</span>())<br>.<span class="hljs-built_in">set_content_type</span>(<span class="hljs-string">&quot;text/html&quot;</span>)<br>.<span class="hljs-built_in">set_host</span>(addr_.<span class="hljs-built_in">c_str</span>())<br>.<span class="hljs-built_in">set_method</span>(HTTP_METHOD_GET);<br><br><span class="hljs-comment">// 测试用，显示 HTTP 请求头信息内容</span><br>string header;<br>req.<span class="hljs-built_in">request_header</span>().<span class="hljs-built_in">build_request</span>(header);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;request: %s\r\n&quot;</span>, header.<span class="hljs-built_in">c_str</span>());<br><br><span class="hljs-comment">// 发送 HTTP 请求数据</span><br><span class="hljs-keyword">if</span> (req.<span class="hljs-built_in">request</span>(<span class="hljs-literal">NULL</span>, <span class="hljs-number">0</span>) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;send request error\r\n&quot;</span>);<br>error_ = <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 获得 HTTP 请求的连接对象</span><br>http_client* conn = req.<span class="hljs-built_in">get_client</span>();<br><span class="hljs-built_in">assert</span>(conn);<br>DOWN_CTX* ctx = <span class="hljs-keyword">new</span> DOWN_CTX;<br>ctx-&gt;type = CTX_T_CONTENT_LENGTH;<br><br><span class="hljs-comment">// 获得 HTTP 响应数据的数据体长度</span><br>ctx-&gt;length = (<span class="hljs-type">int</span>) conn-&gt;<span class="hljs-built_in">body_length</span>();<br>content_length_ = ctx-&gt;length;<br><br><span class="hljs-comment">// 通知主线程</span><br><span class="hljs-built_in">rpc_signal</span>(ctx);<br><br><span class="hljs-type">char</span> buf[<span class="hljs-number">8192</span>];<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// 读 HTTP 响应数据体</span><br><span class="hljs-type">int</span> ret = req.<span class="hljs-built_in">get_body</span>(buf, <span class="hljs-built_in">sizeof</span>(buf));<br><span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>)<br>&#123;<br>ctx = <span class="hljs-keyword">new</span> DOWN_CTX;<br>ctx-&gt;type = CTX_T_END;<br>ctx-&gt;length = ret;<br><span class="hljs-comment">// 通知主线程</span><br><span class="hljs-built_in">rpc_signal</span>(ctx);<br><span class="hljs-keyword">break</span>;<br>&#125;<br>ctx = <span class="hljs-keyword">new</span> DOWN_CTX;<br>ctx-&gt;type = CTX_T_PARTIAL_LENGTH;<br>ctx-&gt;length = ret;<br><span class="hljs-comment">// 通知主线程</span><br><span class="hljs-built_in">rpc_signal</span>(ctx);<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 主线程处理过程，收到子线程任务完成的消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rpc_onover</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: read over now, total read: %d, content-length: %d\r\n&quot;</span>,<br>addr_.<span class="hljs-built_in">c_str</span>(), total_read_, content_length_);<br><br><span class="hljs-comment">// 当 HTTP 响应都完成时，通知主线程停止事件循环过程</span><br>__download_count--;<br><span class="hljs-keyword">if</span> (__download_count == <span class="hljs-number">0</span>)<br>handle_.<span class="hljs-built_in">stop</span>();<br>&#125;<br><br><span class="hljs-comment">// 主线程处理过程，收到子线程的通知消息</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">rpc_wakeup</span><span class="hljs-params">(<span class="hljs-type">void</span>* ctx)</span></span><br><span class="hljs-function"></span>&#123;<br>DOWN_CTX* down_ctx = (DOWN_CTX*) ctx;<br><span class="hljs-keyword">switch</span> (down_ctx-&gt;type)<br>&#123;<br><span class="hljs-keyword">case</span> CTX_T_CONTENT_LENGTH:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: content-length: %d\r\n&quot;</span>,<br>addr_.<span class="hljs-built_in">c_str</span>(), down_ctx-&gt;length);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> CTX_T_PARTIAL_LENGTH:<br>total_read_ += down_ctx-&gt;length;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: partial-length: %d, total read: %d\r\n&quot;</span>,<br>addr_.<span class="hljs-built_in">c_str</span>(), down_ctx-&gt;length, total_read_);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> CTX_T_END:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: read over\r\n&quot;</span>, addr_.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: ERROR\r\n&quot;</span>, addr_.<span class="hljs-built_in">c_str</span>());<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">delete</span> down_ctx;<br>&#125;<br><span class="hljs-keyword">private</span>:<br>aio_handle&amp; handle_;<br>string addr_;<br>string url_;<br><span class="hljs-type">bool</span>  error_;<br><span class="hljs-type">int</span>   total_read_;<br><span class="hljs-type">int</span>   content_length_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">run</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br>aio_handle handle;<br>rpc_service* service = <span class="hljs-keyword">new</span> <span class="hljs-built_in">rpc_service</span>(<span class="hljs-number">10</span>);  <span class="hljs-comment">// 创建 rpc 服务对象</span><br><br><span class="hljs-comment">// 打开消息服务器</span><br><span class="hljs-keyword">if</span> (service-&gt;<span class="hljs-built_in">open</span>(&amp;handle) == <span class="hljs-literal">false</span>)<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open service error: %s\r\n&quot;</span>, <span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">// 下载页面内容</span><br><br><span class="hljs-function">http_download <span class="hljs-title">down1</span><span class="hljs-params">(handle, <span class="hljs-string">&quot;www.sina.com.cn:80&quot;</span>, <span class="hljs-string">&quot;http://www.sina.com.cn/&quot;</span>)</span></span>;<br>service-&gt;<span class="hljs-built_in">rpc_fork</span>(&amp;down1);  <span class="hljs-comment">// 发起一个阻塞会话过程</span><br>__download_count++;<br><br><span class="hljs-function">http_download <span class="hljs-title">down2</span><span class="hljs-params">(handle, <span class="hljs-string">&quot;www.hexun.com:80&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>)</span></span>;<br>service-&gt;<span class="hljs-built_in">rpc_fork</span>(&amp;down2);  <span class="hljs-comment">// 发起第二个阻塞会话过程</span><br>__download_count++;<br><br><span class="hljs-comment">// 异步事件循环过程</span><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (handle.<span class="hljs-built_in">check</span>() == <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">delete</span> service;<br>handle.<span class="hljs-built_in">check</span>(); <span class="hljs-comment">// 保证释放所有延迟关闭的异步对象</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br><span class="hljs-built_in">acl_cpp_init</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-built_in">run</span>();<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Enter any key to continue\r\n&quot;</span>);<br><span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>acl 下载:</p><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>非阻塞编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>用 acl::master_aio 类编写高并发非阻塞服务器程序</title>
    <link href="/2012/05/30/master_aio/"/>
    <url>/2012/05/30/master_aio/</url>
    
    <content type="html"><![CDATA[<p>在文章《使用 acl::master_threads 类编写多进程多线程服务器程序》讲述了如何编写 LINUX 平台下阻塞式服务器程序的多线程。虽然这种模式都可以处理并发任务，并且效率也不低，但是毕竟线程和进程资源是操作系统的宝贵资源，如果要支持非常高的并发请求，则会因为系统限制而不能创建更多的进程或线程。大家常见的 webserver Nginx 就是以支持高并发而闻名，Nginx 本身就是非阻塞设计的典型应用，当然还有很多其它服务器程序也是非阻塞的：ircd、Squid、Varnish、Bind 等。</p><p>因为非阻塞程序编写有一定难度，所以现在有人在写非阻塞程序时不得不转向 Erlang、Nodejs 等一些脚本式语言，要想用 C&#x2F;C++ 来实现非阻塞程序还是有些难度：系统级 API 过于底层、容易出错、难于调试。虽然也有一些 C++ 库（象ACE）提供了非阻塞库，但这些库的入门门槛还是挺高的。根据本人多年在非阻塞编程方面的经验，总结出一套比较实用的 C&#x2F;C++ 非阻塞函数库，本文就讲述如果使用 acl_cpp 库中的 master_aio 类来编写非阻塞服务器程序（该服务器程序可以规定启动最大进程的个数，其中每个进程是一个独立的非阻塞进程）。在文章《非阻塞网络编程实例讲解》中给出了一个非阻塞网络程序的示例，您可以参考一下。</p><h2 id="一、类接口定义"><a href="#一、类接口定义" class="headerlink" title="一、类接口定义"></a>一、类接口定义</h2><p>master_aio 是一个纯虚类，其中定义的接口需要子类实现，子类实例必须只能创建一个实例，接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 纯虚函数：当接收到一个客户端连接时调用此函数</span><br><span class="hljs-comment"> * @param stream &#123;aio_socket_stream*&#125; 新接收到的客户端异步流对象</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 该函数如果返回 false 则通知服务器框架不再接收</span><br><span class="hljs-comment"> *  远程客户端连接，否则继续接收客户端连接</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">on_accept</span><span class="hljs-params">(aio_socket_stream* stream)</span> </span>= <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>master_aio 提供了四个外部方法，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架</span><br><span class="hljs-comment"> * 控制之下运行，一般用于生产机状态</span><br><span class="hljs-comment"> * @param argc &#123;int&#125; 从 main 中传递的第一个参数，表示参数个数</span><br><span class="hljs-comment"> * @param argv &#123;char**&#125; 从 main 中传递的第二个参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run_daemon</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作</span><br><span class="hljs-comment"> * @param addr &#123;const char*&#125; 服务监听地址</span><br><span class="hljs-comment"> * @param conf &#123;const char*&#125; 配置文件全路径</span><br><span class="hljs-comment"> * @param ht &#123;aio_handle_type&#125; 事件引擎的类型</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 监听是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">run_alone</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* conf = <span class="hljs-literal">NULL</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">aio_handle_type ht = ENGINE_SELECT)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得异步IO的事件引擎句柄，通过此句柄，用户可以设置定时器等功能</span><br><span class="hljs-comment"> * @return &#123;aio_handle*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">aio_handle* <span class="hljs-title">get_handle</span><span class="hljs-params">()</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在 run_alone 模式下，通知服务器框架关闭引擎，退出程序</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><p>从上面两个函数，可以看出 master_aio 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。</p><p>master_aio 的基类 master_base 的几个虚接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些</span><br><span class="hljs-comment"> * 用户身份为 root 的权限操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">proc_pre_jail</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程</span><br><span class="hljs-comment"> * 的权限为普通受限级别</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">proc_on_init</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当进程退出前调用的回调函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">proc_on_exit</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-comment">// 在 run_alone 状态下运行前，调用此函数初始化一些配置</span><br></code></pre></td></tr></table></figure><p>基类的这几个虚函数用户可以根据需要调用。</p><p>另外，基类 master_base 还提供了几个用来读配置选项的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 bool 类型的配置项</span><br><span class="hljs-comment"> * @param table &#123;master_bool_tbl*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cfg_bool</span><span class="hljs-params">(master_bool_tbl* table)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 int 类型的配置项</span><br><span class="hljs-comment"> * @param table &#123;master_int_tbl*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cfg_int</span><span class="hljs-params">(master_int_tbl* table)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 int64 类型的配置项</span><br><span class="hljs-comment"> * @param table &#123;master_int64_tbl*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cfg_int64</span><span class="hljs-params">(master_int64_tbl* table)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 字符串 类型的配置项</span><br><span class="hljs-comment"> * @param table &#123;master_str_tbl*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cfg_str</span><span class="hljs-params">(master_str_tbl* table)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="二、示例源程序"><a href="#二、示例源程序" class="headerlink" title="二、示例源程序"></a>二、示例源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// master_aio.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;stdafx.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.hpp&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *var_cfg_debug_msg;<br><br><span class="hljs-type">static</span> acl::master_str_tbl var_conf_str_tab[] = &#123;<br>&#123; <span class="hljs-string">&quot;debug_msg&quot;</span>, <span class="hljs-string">&quot;test_msg&quot;</span>, &amp;var_cfg_debug_msg &#125;,<br><br>&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_debug_enable;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_keep_alive;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_send_banner;<br><br><span class="hljs-type">static</span> acl::master_bool_tbl var_conf_bool_tab[] = &#123;<br>&#123; <span class="hljs-string">&quot;debug_enable&quot;</span>, <span class="hljs-number">1</span>, &amp;var_cfg_debug_enable &#125;,<br>&#123; <span class="hljs-string">&quot;keep_alive&quot;</span>, <span class="hljs-number">1</span>, &amp;var_cfg_keep_alive &#125;,<br>&#123; <span class="hljs-string">&quot;send_banner&quot;</span>, <span class="hljs-number">1</span>, &amp;var_cfg_send_banner &#125;,<br><br>&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_io_timeout;<br><br><span class="hljs-type">static</span> acl::master_int_tbl var_conf_int_tab[] = &#123;<br>&#123; <span class="hljs-string">&quot;io_timeout&quot;</span>, <span class="hljs-number">120</span>, &amp;var_cfg_io_timeout, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<br><br>&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> , <span class="hljs-number">0</span> , <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-title">void</span> <span class="hljs-params">(*format)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span> </span>= acl::log::msg1;<br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> acl;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 延迟读回调处理类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">timer_reader</span>: <span class="hljs-keyword">public</span> aio_timer_reader<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">timer_reader</span>(<span class="hljs-type">int</span> delay)<br>&#123;<br>delay_ = delay;<br>format(<span class="hljs-string">&quot;timer_reader init, delay: %d\r\n&quot;</span>, delay);<br>&#125;<br><br>~<span class="hljs-built_in">timer_reader</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-comment">// aio_timer_reader 的子类必须重载 destroy 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;timer_reader delete, delay: %d\r\n&quot;</span>, delay_);<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 重载基类回调方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">timer_callback</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;timer_reader(%u): timer_callback, delay: %d\r\n&quot;</span>, id, delay_);<br><br><span class="hljs-comment">// 调用基类的处理过程</span><br>aio_timer_reader::<span class="hljs-built_in">timer_callback</span>(id);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>   delay_;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 延迟写回调处理类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">timer_writer</span>: <span class="hljs-keyword">public</span> aio_timer_writer<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">timer_writer</span>(<span class="hljs-type">int</span> delay)<br>&#123;<br>delay_ = delay;<br>format(<span class="hljs-string">&quot;timer_writer init, delay: %d\r\n&quot;</span>, delay);<br>&#125;<br><br>~<span class="hljs-built_in">timer_writer</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-comment">// aio_timer_reader 的子类必须重载 destroy 方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;timer_writer delete, delay: %d\r\n&quot;</span>, delay_);<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">// 重载基类回调方法</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">timer_callback</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;timer_writer(%u): timer_callback, delay: %u\r\n&quot;</span>, id, delay_);<br><br><span class="hljs-comment">// 调用基类的处理过程</span><br>aio_timer_writer::<span class="hljs-built_in">timer_callback</span>(id);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">int</span>   delay_;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">timer_test</span> : <span class="hljs-keyword">public</span> aio_timer_callback<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">timer_test</span>() &#123;&#125;<br>~<span class="hljs-built_in">timer_test</span>() &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类纯虚函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">timer_callback</span><span class="hljs-params">(<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;id: %u\r\n&quot;</span>, id);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>format(<span class="hljs-string">&quot;timer delete now\r\n&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步客户端流的回调类的子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io_callback</span> : <span class="hljs-keyword">public</span> aio_callback<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">io_callback</span>(aio_socket_stream* client)<br>: <span class="hljs-built_in">client_</span>(client)<br>, <span class="hljs-built_in">i_</span>(<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br>~<span class="hljs-built_in">io_callback</span>()<br>&#123;<br>format(<span class="hljs-string">&quot;delete io_callback now ...\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现父类中的虚函数，客户端流的读成功回调过程</span><br><span class="hljs-comment"> * @param data &#123;char*&#125; 读到的数据地址</span><br><span class="hljs-comment"> * @param len &#123;int&#125; 读到的数据长度</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">read_callback</span><span class="hljs-params">(<span class="hljs-type">char</span>* data, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (++i_ &lt; <span class="hljs-number">10</span>)<br>format(<span class="hljs-string">&quot;&gt;&gt;gets(i: %d): %s\r\n&quot;</span>, i_, data);<br><br><span class="hljs-comment">// 如果远程客户端希望退出，则关闭之</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(data, <span class="hljs-string">&quot;quit&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>client_-&gt;format(<span class="hljs-string">&quot;Bye!\r\n&quot;</span>);<br>client_-&gt;<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-comment">// 如果远程客户端希望服务端也关闭，则中止异步事件过程</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(data, <span class="hljs-string">&quot;stop&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>client_-&gt;format(<span class="hljs-string">&quot;Stop now!\r\n&quot;</span>);<br>client_-&gt;<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 关闭远程异步流</span><br><br><span class="hljs-comment">// 通知异步引擎关闭循环过程</span><br>client_-&gt;<span class="hljs-built_in">get_handle</span>().<span class="hljs-built_in">stop</span>();<br>&#125;<br><br><span class="hljs-comment">// 向远程客户端回写收到的数据</span><br><br><span class="hljs-type">int</span>   delay = <span class="hljs-number">0</span>;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(data, <span class="hljs-string">&quot;write_delay&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;write_delay&quot;</span>)) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 延迟写过程</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = data + <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;write_delay&quot;</span>);<br>delay = <span class="hljs-built_in">atoi</span>(ptr);<br><span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span>)<br>&#123;<br>format(<span class="hljs-string">&quot;&gt;&gt; write delay %d second ...\r\n&quot;</span>, delay);<br>timer_writer* timer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">timer_writer</span>(delay);<br>client_-&gt;<span class="hljs-built_in">write</span>(data, len, delay * <span class="hljs-number">1000000</span>, timer);<br>client_-&gt;<span class="hljs-built_in">gets</span>(<span class="hljs-number">10</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(data, <span class="hljs-string">&quot;read_delay&quot;</span>, <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;read_delay&quot;</span>)) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 延迟读过程</span><br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = data + <span class="hljs-built_in">strlen</span>(<span class="hljs-string">&quot;read_delay&quot;</span>);<br>delay = <span class="hljs-built_in">atoi</span>(ptr);<br><span class="hljs-keyword">if</span> (delay &gt; <span class="hljs-number">0</span>)<br>&#123;<br>client_-&gt;<span class="hljs-built_in">write</span>(data, len);<br>format(<span class="hljs-string">&quot;&gt;&gt; read delay %d second ...\r\n&quot;</span>, delay);<br>timer_reader* timer = <span class="hljs-keyword">new</span> <span class="hljs-built_in">timer_reader</span>(delay);<br>client_-&gt;<span class="hljs-built_in">gets</span>(<span class="hljs-number">10</span>, <span class="hljs-literal">false</span>, delay * <span class="hljs-number">1000000</span>, timer);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;<br><br>client_-&gt;<span class="hljs-built_in">write</span>(data, len);<br><span class="hljs-comment">//client_-&gt;gets(10, false);</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现父类中的虚函数，客户端流的写成功回调过程</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">write_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现父类中的虚函数，客户端流的关闭回调过程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 必须在此处删除该动态分配的回调类对象以防止内存泄露</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现父类中的虚函数，客户端流的超时回调过程</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">timeout_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;Timeout ...\r\n&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>aio_socket_stream* client_;<br><span class="hljs-type">int</span>   i_;<br>&#125;;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">master_aio_test</span> : <span class="hljs-keyword">public</span> master_aio<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">master_aio_test</span>() &#123; timer_test_ = <span class="hljs-keyword">new</span> <span class="hljs-built_in">timer_test</span>(); &#125;<br><br>~<span class="hljs-built_in">master_aio_test</span>() &#123; handle_-&gt;<span class="hljs-built_in">keep_timer</span>(<span class="hljs-literal">false</span>); &#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类纯虚函数：当接收到一个新的连接时调用此函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">on_accept</span><span class="hljs-params">(aio_socket_stream* client)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建异步客户端流的回调对象并与该异步流进行绑定</span><br>io_callback* callback = <span class="hljs-keyword">new</span> <span class="hljs-built_in">io_callback</span>(client);<br><br><span class="hljs-comment">// 注册异步流的读回调过程</span><br>client-&gt;<span class="hljs-built_in">add_read_callback</span>(callback);<br><br><span class="hljs-comment">// 注册异步流的写回调过程</span><br>client-&gt;<span class="hljs-built_in">add_write_callback</span>(callback);<br><br><span class="hljs-comment">// 注册异步流的关闭回调过程</span><br>client-&gt;<span class="hljs-built_in">add_close_callback</span>(callback);<br><br><span class="hljs-comment">// 注册异步流的超时回调过程</span><br>client-&gt;<span class="hljs-built_in">add_timeout_callback</span>(callback);<br><br><span class="hljs-comment">// 写欢迎信息</span><br><span class="hljs-keyword">if</span> (var_cfg_send_banner)<br>client-&gt;format(<span class="hljs-string">&quot;hello, you&#x27;re welcome\r\n&quot;</span>);<br><br><span class="hljs-comment">// 从异步流读一行数据</span><br>client-&gt;<span class="hljs-built_in">gets</span>(<span class="hljs-number">10</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-comment">//client-&gt;read();</span><br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：服务进程切换用户身份前调用此函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">proc_pre_jail</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;proc_pre_jail\r\n&quot;</span>);<br><span class="hljs-comment">// 只有当程序启动后才能获得异步引擎句柄</span><br>handle_ = <span class="hljs-built_in">get_handle</span>();<br>handle_-&gt;<span class="hljs-built_in">keep_timer</span>(<span class="hljs-literal">true</span>); <span class="hljs-comment">// 允许定时器被重复触发</span><br><span class="hljs-comment">// 设置第一个定时任务，每隔1秒触发一次，定时任务ID为0</span><br>handle_-&gt;<span class="hljs-built_in">set_timer</span>(timer_test_, <span class="hljs-number">1000000</span>, <span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：服务进程切换用户身份后调用此函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">proc_on_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;proc init\r\n&quot;</span>);<br><span class="hljs-comment">// 设置第二个定时任务，每隔2秒触发一次，定时任务ID为1</span><br>handle_-&gt;<span class="hljs-built_in">set_timer</span>(timer_test_, <span class="hljs-number">2000000</span>, <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：服务进程退出前调用此函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">proc_on_exit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;proc exit\r\n&quot;</span>);<br>&#125;<br><span class="hljs-keyword">private</span>:<br>timer_test* timer_test_;<br>aio_handle* handle_;<br>&#125;;<br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>master_aio_test ma;  <span class="hljs-comment">// master_aio 要求只能起一个实例</span><br><br><span class="hljs-comment">// 设置配置参数表</span><br>ma.<span class="hljs-built_in">set_cfg_int</span>(var_conf_int_tab);<br>ma.<span class="hljs-built_in">set_cfg_int64</span>(<span class="hljs-literal">NULL</span>);<br>ma.<span class="hljs-built_in">set_cfg_str</span>(var_conf_str_tab);<br>ma.<span class="hljs-built_in">set_cfg_bool</span>(var_conf_bool_tab);<br><br><span class="hljs-comment">// 开始运行</span><br><br><span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;alone&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr = <span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>;<br><br><span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">3</span>)<br>addr = argv[<span class="hljs-number">2</span>];<br><br>format = (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)) printf;<br>format(<span class="hljs-string">&quot;listen: %s now\r\n&quot;</span>, addr);<br>ma.<span class="hljs-built_in">run_alone</span>(addr);  <span class="hljs-comment">// 单独运行方式</span><br>&#125;<br><span class="hljs-keyword">else</span><br>ma.<span class="hljs-built_in">run_daemon</span>(argc, argv);  <span class="hljs-comment">// acl_master 控制模式运行</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>该示例主要实现几个功能：接收一行数据并回写该数据、延迟回写所读的数据、延迟读下一行数据、设置定时器的定时任务。因为 master_aio 类是按非阻塞模式设计的（其实，该类主要对 acl 库中的非阻塞框架库用 C++ 进行了封装），所以该例子可以支持非常大的并发请求。可以通过配置文件指定系统事件 API 选择采用 select&#x2F;poll&#x2F;epoll 中的一种、规定进程的空闲退出时间、预先启动子进程的数量等参数。该例子所在目录：acl_cpp&#x2F;samples&#x2F;master_aio。</p><p>在这个例子中，当服务端接收到客户端连接后，非阻塞框架会通过虚函数  on_accept 回调子类处理过程，子类需要在这个虚函数中需要将一个处理 IO 过程的类实例与这个非阻塞连接流进行绑定（通过 add_xxx_callback 方式），其中处理 IO 过程的类的基类定义为：aio_callback，子类需要实现其中的虚方法。</p><h2 id="三、配置文件及程序安装"><a href="#三、配置文件及程序安装" class="headerlink" title="三、配置文件及程序安装"></a>三、配置文件及程序安装</h2><p>打开 acl_cpp&#x2F;samples&#x2F;master_aio&#x2F;aio_echo.cf 配置文件，就其中几个配置参数说明一下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">## 由 acl_master 用来控制服务进程池的配置项</span><br><span class="hljs-comment"># 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程</span><br><span class="hljs-attr">master_disable</span> = <span class="hljs-literal">no</span><br><br><span class="hljs-comment"># 表示本服务器进程监听 127.0.0.1 的 8888 端口</span><br><span class="hljs-attr">master_service</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">8888</span><br><br><span class="hljs-comment"># 表示是 TCP 套接口服务类型</span><br><span class="hljs-attr">master_type</span> = inet<br><br><span class="hljs-comment"># 表示该服务进程池的最大进程数为 2</span><br><span class="hljs-attr">master_maxproc</span> = <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 需要预先启动的进程数，该值不应大于 master_maxproc</span><br><span class="hljs-attr">master_prefork</span> = <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 进程程序名</span><br><span class="hljs-attr">master_command</span> = aio_echo<br><br><span class="hljs-comment"># 进程日志记录文件，其中 &#123;install_path&#125; 需要用实际的安装路径代替</span><br><span class="hljs-attr">master_log</span> = &#123;install_path&#125;/var/log/aio_echo.log<br> <br><span class="hljs-comment"># 用 select 进行循环时的时间间隔</span><br><span class="hljs-comment"># 单位为秒</span><br><span class="hljs-attr">aio_delay_sec</span> = <span class="hljs-number">1</span><br><span class="hljs-comment"># 单位为微秒</span><br><span class="hljs-attr">aio_delay_usec</span> = <span class="hljs-number">500</span><br><span class="hljs-comment"># 采用事件循环的方式: select(default), poll, kernel(epoll/devpoll/kqueue)</span><br><span class="hljs-attr">aio_event_mode</span> = select<br><span class="hljs-comment"># 是否将 socket 接收与IO功能分开: yes/no, 如果为 yes 可以大大提高 accept() 速度</span><br><span class="hljs-attr">aio_accept_alone</span> = <span class="hljs-literal">yes</span><br><span class="hljs-comment"># 线程池的最大线程数, 如果该值为0则表示采用单线程非阻塞模式.</span><br><span class="hljs-attr">aio_max_threads</span> = <span class="hljs-number">0</span><br><span class="hljs-comment"># 每个线程的空闲时间.</span><br><span class="hljs-attr">aio_thread_idle_limit</span> = <span class="hljs-number">60</span><br><span class="hljs-comment"># 允许访问的客户端IP地址范围</span><br><span class="hljs-attr">aio_access_allow</span> = <span class="hljs-number">10.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">255.255</span>.<span class="hljs-number">255.255</span>, <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><span class="hljs-comment"># 当 acl_master 退出时，如果该值置1则该程序不等所有连接处理完毕便立即退出</span><br><span class="hljs-attr">aio_quick_abort</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure><p>例如当 acl_master 服务器框架程序的安装目录为：&#x2F;opt&#x2F;acl，则：</p><ul><li>&#x2F;opt&#x2F;acl&#x2F;libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；</li><li>&#x2F;opt&#x2F;acl&#x2F;conf：该目录存放 acl_master 程序配置文件 main.cf；</li><li>&#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；</li><li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;log：该目录存放日志文件；</li><li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;pid：该目录存放进程号文件。</li></ul><p>该程序编译通过后，需要把可执行程序放在 &#x2F;opt&#x2F;acl&#x2F;libexec 目录下，把配置文件放在 &#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service 目录下。</p><p>在 &#x2F;opt&#x2F;acl&#x2F;sh 下有启动&#x2F;停止 acl_master 服务进程的控制脚本；运行脚本：.&#x2F;start.sh，然后请用下面方法检查服务是否已经启动：</p><p>ps -ef|grep acl_master # 查看服务器控制进程是否已经启动</p><p>netstat -nap|grep LISTEN|grep 5001 # 查看服务端口号是否已经被监听</p><p>当然，您也可以查看 &#x2F;opt&#x2F;acl&#x2F;var&#x2F;log&#x2F;acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。</p><p>可以命令行如下测试：telnet 127.0.0.1 8888</p><p>github: <a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee: <a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>服务编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl::master_threads 类编写多进程多线程服务器程序</title>
    <link href="/2012/05/26/master_threads/"/>
    <url>/2012/05/26/master_threads/</url>
    
    <content type="html"><![CDATA[<p>本文主要讲述如何使用 acl_cpp 中的 master_threads 类编写可以由 acl_master 服务器父进程控制的服务器应用程序。</p><h2 id="一、类接口说明"><a href="#一、类接口说明" class="headerlink" title="一、类接口说明"></a>一、类接口说明</h2><p>master_threads 是一个纯虚类，其中定义的接口需要子类实现，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 纯虚函数：当某个客户端连接有数据可读或关闭或出错时调用此函数</span><br><span class="hljs-comment"> * @param stream &#123;socket_stream*&#125;</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 false 则表示当函数返回后需要关闭连接，</span><br><span class="hljs-comment"> *  否则表示需要保持长连接，如果该流出错，则应用应该返回 false</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">thread_on_read</span><span class="hljs-params">(socket_stream*)</span> </span>= <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当线程池中的某个线程获得一个连接时的回调函数，</span><br><span class="hljs-comment"> * 子类可以做一些初始化工作</span><br><span class="hljs-comment"> * @param stream &#123;socket_stream*&#125;</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 如果返回 false 则表示子类要求关闭连接，而不</span><br><span class="hljs-comment"> *  必将该连接再传递至 thread_main 过程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">thread_on_accept</span><span class="hljs-params">(socket_stream*)</span> </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; &#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当与某个线程绑定的连接关闭时的回调函数</span><br><span class="hljs-comment"> * @param stream &#123;socket_stream*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">thread_on_close</span><span class="hljs-params">(socket_stream* )</span> </span>&#123;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当线程池中一个新线程被创建时的回调函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">thread_on_init</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当线程池中一个线程退出时的回调函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">thread_on_exit</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><p>master_threads 类提供了两个函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架</span><br><span class="hljs-comment"> * 控制之下运行，一般用于生产机状态</span><br><span class="hljs-comment"> * @param argc &#123;int&#125; 从 main 中传递的第一个参数，表示参数个数</span><br><span class="hljs-comment"> * @param argv &#123;char**&#125; 从 main 中传递的第二个参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">run_daemon</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作</span><br><span class="hljs-comment"> * @param addr &#123;const char*&#125; 服务监听地址</span><br><span class="hljs-comment"> * @param conf &#123;const char*&#125; 配置文件全路径</span><br><span class="hljs-comment"> * @param count &#123;unsigned int&#125; 循环服务的次数，达到此值后函数自动返回；</span><br><span class="hljs-comment"> *  若该值为 0 则表示程序一直循环处理外来请求而不返回</span><br><span class="hljs-comment"> * @param threads_count &#123;int&#125; 当该值大于 1 时表示自动采用线程池方式，</span><br><span class="hljs-comment"> *  该值只有当 count != 1 时才有效，即若 count == 1 则仅运行一次就返回</span><br><span class="hljs-comment"> *  且不会启动线程处理客户端请求</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 监听是否成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">run_alone</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* conf = <span class="hljs-literal">NULL</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> count = <span class="hljs-number">1</span>, <span class="hljs-type">int</span> threads_count = <span class="hljs-number">1</span>)</span></span>;<br></code></pre></td></tr></table></figure><p>从上面两个函数，可以看出 master_threads 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。</p><p>master_threads 的基类 master_base 的几个虚接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些</span><br><span class="hljs-comment"> * 用户身份为 root 的权限操作</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">proc_pre_jail</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程</span><br><span class="hljs-comment"> * 的权限为普通受限级别</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">proc_on_init</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当进程退出前调用的回调函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">proc_on_exit</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><pre><code class="hljs">// 在 run_alone 状态下运行前，调用此函数初始化一些配置</code></pre><p>基类的这几个虚函数用户可以根据需要调用。</p><p>另外，基类 master_base 还提供了几个用来读配置选项的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 bool 类型的配置项</span><br><span class="hljs-comment"> * @param table &#123;master_bool_tbl*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cfg_bool</span><span class="hljs-params">(master_bool_tbl* table)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 int 类型的配置项</span><br><span class="hljs-comment"> * @param table &#123;master_int_tbl*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cfg_int</span><span class="hljs-params">(master_int_tbl* table)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 int64 类型的配置项</span><br><span class="hljs-comment"> * @param table &#123;master_int64_tbl*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cfg_int64</span><span class="hljs-params">(master_int64_tbl* table)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 字符串 类型的配置项</span><br><span class="hljs-comment"> * @param table &#123;master_str_tbl*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_cfg_str</span><span class="hljs-params">(master_str_tbl* table)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="二、示例源程序"><a href="#二、示例源程序" class="headerlink" title="二、示例源程序"></a>二、示例源程序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// master_threads.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;log.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;util.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;master_threads.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;socket_stream.hpp&quot;</span></span><br><br><span class="hljs-comment">// 字符串类型的配置项</span><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *var_cfg_debug_msg;<br><br><span class="hljs-type">static</span> acl::master_str_tbl var_conf_str_tab[] = &#123;<br>&#123; <span class="hljs-string">&quot;debug_msg&quot;</span>, <span class="hljs-string">&quot;test_msg&quot;</span>, &amp;var_cfg_debug_msg &#125;,<br><br>&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 布尔类型的配置项</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_debug_enable;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_keep_alive;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_loop;<br><br><span class="hljs-type">static</span> acl::master_bool_tbl var_conf_bool_tab[] = &#123;<br>&#123; <span class="hljs-string">&quot;debug_enable&quot;</span>, <span class="hljs-number">1</span>, &amp;var_cfg_debug_enable &#125;,<br>&#123; <span class="hljs-string">&quot;keep_alive&quot;</span>, <span class="hljs-number">1</span>, &amp;var_cfg_keep_alive &#125;,<br>&#123; <span class="hljs-string">&quot;loop_read&quot;</span>, <span class="hljs-number">1</span>, &amp;var_cfg_loop &#125;,<br><br>&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 整数类型的配置项</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_io_timeout;<br><br><span class="hljs-type">static</span> acl::master_int_tbl var_conf_int_tab[] = &#123;<br>&#123; <span class="hljs-string">&quot;io_timeout&quot;</span>, <span class="hljs-number">120</span>, &amp;var_cfg_io_timeout, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<br><br>&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> , <span class="hljs-number">0</span> , <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-title">void</span> <span class="hljs-params">(*format)</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)</span> </span>= acl::log::msg1;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">master_threads_test</span> : <span class="hljs-keyword">public</span> acl::master_threads<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">master_threads_test</span>()<br>&#123;<br>&#125;<br><br>~<span class="hljs-built_in">master_threads_test</span>()<br>&#123;<br>&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示</span><br><span class="hljs-comment">// 继续与客户端保持长连接，否则表示需要关闭客户端连接</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">thread_on_read</span><span class="hljs-params">(acl::socket_stream* stream)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">on_read</span>(stream) == <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">if</span> (var_cfg_loop == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">on_read</span><span class="hljs-params">(acl::socket_stream* stream)</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;%s(%d)&quot;</span>, __FILE__, __LINE__);<br>acl::string buf;<br><span class="hljs-keyword">if</span> (stream-&gt;<span class="hljs-built_in">gets</span>(buf) == <span class="hljs-literal">false</span>) <span class="hljs-comment">// 读一行数据</span><br>&#123;<br>format(<span class="hljs-string">&quot;gets error: %s&quot;</span>, acl::<span class="hljs-built_in">last_serror</span>());<br>format(<span class="hljs-string">&quot;%s(%d)&quot;</span>, __FILE__, __LINE__);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">if</span> (buf == <span class="hljs-string">&quot;quit&quot;</span>)  <span class="hljs-comment">// 如果客户端要求关闭连接，则返回 false 通知服务器框架关闭连接</span><br>&#123;<br>stream-&gt;<span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;bye!&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (buf.<span class="hljs-built_in">empty</span>())<br>&#123;<br><span class="hljs-keyword">if</span> (stream-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\r\n&quot;</span>) == <span class="hljs-number">-1</span>)<br>&#123;<br>format(<span class="hljs-string">&quot;write 1 error: %s&quot;</span>, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stream-&gt;<span class="hljs-built_in">write</span>(buf) == <span class="hljs-number">-1</span>)<br>&#123;<br>format(<span class="hljs-string">&quot;write 2 error: %s, buf(%s), len: %d&quot;</span>,<br>acl::<span class="hljs-built_in">last_serror</span>(), buf.<span class="hljs-built_in">c_str</span>(), (<span class="hljs-type">int</span>) buf.<span class="hljs-built_in">length</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (stream-&gt;<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;\r\n&quot;</span>) == <span class="hljs-number">-1</span>)<br>&#123;<br>format(<span class="hljs-string">&quot;write 3 client error: %s&quot;</span>, acl::<span class="hljs-built_in">last_serror</span>());<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许</span><br><span class="hljs-comment">// 子类事先对客户端连接进行处理，返回 true 表示继续，否则</span><br><span class="hljs-comment">// 要求关闭该客户端连接</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">thread_on_accept</span><span class="hljs-params">(acl::socket_stream* stream)</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;accept one client, peer: %s, local: %s, var_cfg_io_timeout: %d\r\n&quot;</span>,<br>stream-&gt;<span class="hljs-built_in">get_peer</span>(), stream-&gt;<span class="hljs-built_in">get_local</span>(), var_cfg_io_timeout);<br><span class="hljs-keyword">if</span> (stream-&gt;format(<span class="hljs-string">&quot;hello, you&#x27;re welcome!\r\n&quot;</span>) == <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：当客户端连接关闭时调用此函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_on_close</span><span class="hljs-params">(acl::socket_stream*)</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;client closed now\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：当线程池创建一个新线程时调用此函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">thread_on_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br>format(<span class="hljs-string">&quot;thread init: tid: %lu\r\n&quot;</span>, <span class="hljs-built_in">GetCurrentThreadId</span>());<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>format(<span class="hljs-string">&quot;thread init: tid: %lu\r\n&quot;</span>, <span class="hljs-built_in">pthread_self</span>());<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：当线程池中的一个线程退出时调用此函数</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">thread_on_exit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br>format(<span class="hljs-string">&quot;thread exit: tid: %lu\r\n&quot;</span>, <span class="hljs-built_in">GetCurrentThreadId</span>());<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>format(<span class="hljs-string">&quot;thread exit: tid: %lu\r\n&quot;</span>, <span class="hljs-built_in">pthread_self</span>());<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：服务进程切换用户身份前调用此函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">proc_pre_jail</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;proc_pre_jail\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：服务进程切换用户身份后调用此函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">proc_on_init</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;proc init\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：服务进程退出前调用此函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">proc_on_exit</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>format(<span class="hljs-string">&quot;proc exit\r\n&quot;</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>master_threads_test mt;<br><br><span class="hljs-comment">// 设置配置参数表</span><br>mt.<span class="hljs-built_in">set_cfg_int</span>(var_conf_int_tab);<br>mt.<span class="hljs-built_in">set_cfg_int64</span>(<span class="hljs-literal">NULL</span>);<br>mt.<span class="hljs-built_in">set_cfg_str</span>(var_conf_str_tab);<br>mt.<span class="hljs-built_in">set_cfg_bool</span>(var_conf_bool_tab);<br><br><span class="hljs-comment">// 开始运行</span><br><br><span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;alone&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>format = (<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">const</span> <span class="hljs-type">char</span>*, ...)) printf;<br>format(<span class="hljs-string">&quot;listen: 127.0.0.1:8888\r\n&quot;</span>);<br>mt.<span class="hljs-built_in">run_alone</span>(<span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 单独运行方式</span><br>&#125;<br><span class="hljs-keyword">else</span><br>mt.<span class="hljs-built_in">run_daemon</span>(argc, argv);  <span class="hljs-comment">// acl_master 控制模式运行</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>这是一个简单的提供 echo 行服务的服务器程序，可以支持多个并发连接，而且可以通过配置文件控制所启动的最大进程数、每个进程的最大线程数、进程空闲时间、线程空闲时间等控制参数，因为 acl 中的服务器框架都是半驻留的，所以既可以保证运行效率，又能够在空闲释放系统资源。该例子所在目录：acl_cpp&#x2F;samples&#x2F;master_threads。</p><p>需要指出的一点是，master_threads 内部是单例的，即要求该类的对象只能有一个，否则内部自动产生断言。只所以没有采用单例模板来设计单例，主要是为了不对外暴露 acl 库中的接口，使使用 acl_cpp 库的用户不必关心 acl 库的头文件在哪儿。</p><h2 id="三、配置文件及程序安装"><a href="#三、配置文件及程序安装" class="headerlink" title="三、配置文件及程序安装"></a>三、配置文件及程序安装</h2><p>打开 acl_cpp&#x2F;samples&#x2F;master_threads&#x2F;ioctl_echo.cf 配置文件，就其中几个配置参数说明一下：</p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-comment">## 由 acl_master 用来控制服务进程池的配置项</span><br><span class="hljs-comment"># 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程</span><br><span class="hljs-attr">master_disable</span> = <span class="hljs-literal">no</span><br><br><span class="hljs-comment"># 表示本服务器进程监听 127.0.0.1 的 5001 端口</span><br><span class="hljs-attr">master_service</span> = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">5001</span><br><br><span class="hljs-comment"># 表示是 TCP 套接口服务类型</span><br><span class="hljs-attr">master_type</span> = inet<br><br><span class="hljs-comment"># 表示该服务进程池的最大进程数为 2</span><br><span class="hljs-attr">master_maxproc</span> = <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 进程日志记录文件，其中 &#123;install_path&#125; 需要用实际的安装路径代替</span><br><span class="hljs-attr">master_log</span> = &#123;install_path&#125;/var/log/ioctl_echo.log<br><br><span class="hljs-comment">## 与该服务器框架模板相关的配置参数项</span><br><span class="hljs-comment"># 每个服务进程中最大的线程数为 250</span><br><span class="hljs-attr">ioctl_max_threads</span> = <span class="hljs-number">250</span><br><br><span class="hljs-comment"># 线程的堆栈空间大小，单位为字节，0表示使用系统缺省值</span><br><span class="hljs-attr">ioctl_stacksize</span> = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># 每个进程实例处理连接数的最大次数，超过此值后进程实例主动退出</span><br><span class="hljs-attr">ioctl_use_limit</span> = <span class="hljs-number">100</span><br><br><span class="hljs-comment"># 每个进程实例的空闲超时时间，超过此值后进程实例主动退出</span><br><span class="hljs-attr">ioctl_idle_limit</span> = <span class="hljs-number">120</span><br><br><span class="hljs-comment"># 进程运行时的用户身份</span><br><span class="hljs-attr">ioctl_owner</span> = root<br><br><span class="hljs-comment"># 采用事件循环的方式: select(default)/poll/kernel(epoll/devpoll/kqueue)</span><br><span class="hljs-attr">ioctl_event_mode</span> = select<br><br><span class="hljs-comment"># 允许访问 udserver 的客户端IP地址范围</span><br><span class="hljs-attr">ioctl_access_allow</span> = <span class="hljs-number">10.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">10.0</span>.<span class="hljs-number">0.255</span>, <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span>:<span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br></code></pre></td></tr></table></figure><p>例如当 acl_master 服务器框架程序的安装目录为：&#x2F;opt&#x2F;acl，则：</p><ul><li>&#x2F;opt&#x2F;acl&#x2F;libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；</li><li>&#x2F;opt&#x2F;acl&#x2F;conf：该目录存放 acl_master 程序配置文件 main.cf；</li><li>&#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；</li><li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;log：该目录存放日志文件；</li><li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;pid：该目录存放进程号文件。</li></ul><p>该程序编译通过后，需要把可执行程序放在 &#x2F;opt&#x2F;acl&#x2F;libexec 目录下，把配置文件放在 &#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service 目录下。</p><p>在 &#x2F;opt&#x2F;acl&#x2F;sh 下有启动&#x2F;停止 acl_master 服务进程的控制脚本；运行脚本：.&#x2F;start.sh，然后请用下面方法检查服务是否已经启动：</p><p><code>$ps -ef|grep acl_master</code>  查看服务器控制进程是否已经启动</p><p><code>$netstat -nap|grep LISTEN|grep 5001</code> 查看服务端口号是否已经被监听</p><p>当然，您也可以查看 &#x2F;opt&#x2F;acl&#x2F;var&#x2F;log&#x2F;acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。</p><p>可以命令行如下测试：<code>$telnet 127.0.0.1 5001</code></p>]]></content>
    
    
    <categories>
      
      <category>服务编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Web 编程中实现文件上传的服务端实例</title>
    <link href="/2012/05/22/http_upload/"/>
    <url>/2012/05/22/http_upload/</url>
    
    <content type="html"><![CDATA[<p>在文章《用C++实现类似于JAVA HttpServlet 的编程接口 》中讲了如何用 acl_cpp 的 HttpServlet 等类来实现 WEB CGI 的功能，同时在文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中也举例说明如何将基于 HttpServlet 编写的 CGI 程序快速地转为服务器程序的过程。本文主要讲如何用 acl_cpp 的 WEB 编程类实现 HTTP 文件上传过程。为了实现 HTTP 协议的文件上传过程，引入了两个类：http_mime 和 http_mime_node。</p><p>http_mime 类是有关 HTTP 协议中 mime 格式的流式解析器（即每次仅输入部分 HTTP MIME 数据，等数据输入完毕时，该解析器也解析完毕，流式解析的好处是它可以适用于阻塞或非阻塞的IO模式）；http_mime_node 类对象表示 http mime 数据中每一个 mime 结点对象，该结点的数据可能是文件内容数据，也可能是参数数据。</p><h2 id="一、http-mime-类"><a href="#一、http-mime-类" class="headerlink" title="一、http_mime 类"></a>一、http_mime 类</h2><p>该类一般由 HttpServletRequest 类内部自动管理（负责分配与释放 http_mide 类对象），当然用户可以在测试 http_mime 类时，自己创建与释放该类对象。下面是该类的构造函数及常用方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构建函数</span><br><span class="hljs-comment"> * @param boundary &#123;const char*&#125; 分隔符，不能为空</span><br><span class="hljs-comment"> * @param local_charset &#123;const char*&#125; 本地字符集，非空时会自动将</span><br><span class="hljs-comment"> *  参数内容转为本地字符集</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">http_mime</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* boundary, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* local_charset  = <span class="hljs-string">&quot;gb2312&quot;</span>);<br></code></pre></td></tr></table></figure><p>尤其需要指出的是 http mime 的 boundary(分隔符）与邮件的 mime 的分隔符规则略有不同，如邮件的相关头部字段为：Content-Type: multipart&#x2F;mixed; charset&#x3D;”GB2312”; boundary&#x3D;”0_11119_1331286082”，HTTP MIME 的相关头部字段为：Content-Type: multipart&#x2F;form-data; boundary&#x3D;”–0_11119_1331286082”。其中，最大的区别就是在 HTTP 头中获得的分隔符与 HTTP 数据体的分隔符（除结尾分隔符多了两个 ‘-‘ 后缀）完全相同，而邮件的 mime 的分隔符在头部和 mime 体中是不一样的，mime 体中的分隔符是由头部的分隔符加两个 ‘-‘ 作为前导符（结尾分隔符为头部分隔符前面加两个 ‘-‘，尾部加两个 ‘-‘），一定得注意这些不同。在 acl_cpp 中的 http mime 解析模块原来主要是作邮件 mime 解析的，现在依然支持 HTTP 的 mime 解析，唯一不同就是区分分隔符的不同。（当然，邮件的 MIME 数据体还与 HTTP MIME 数据体有另外一个区别：邮件的 MIME 数据一般都是要经过 BASE64 来编码的，而 HTTP MIME 却很少编码）。</p><p>http_mime 的几个常用方法接口如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 MIME 数据的存储路径，当分析完 MIME 数据后，如果想要从中提取数据，</span><br><span class="hljs-comment">    * 则必须给出该 MIME 的原始数据的存储位置，否则无法获得相应数据，即</span><br><span class="hljs-comment">    * save_xxx/get_nodes/get_node 函数均无法正常使用</span><br><span class="hljs-comment"> * @param path &#123;const char*&#125; 文件路径名, 如果该参数为空, 则不能</span><br><span class="hljs-comment"> *  获得数据体数据, 也不能调用 save_xxx 相关的接口</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">set_saved_path</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 调用此函数进行流式方式解析数据体内容</span><br><span class="hljs-comment"> * @param data &#123;const char*&#125; 数据体(可能是数据头也可能是数据体, </span><br><span class="hljs-comment"> *  并且不必是完整的数据行)</span><br><span class="hljs-comment"> * @param len &#123;size_t&#125; data 数据长度</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 针对 multipart 数据, 返回 true 表示解析完毕;</span><br><span class="hljs-comment"> *  对于非 multipart 文件, 该返回值永远为 false, 没有任何意义, </span><br><span class="hljs-comment"> *  需要调用者自己判断数据体的结束位置</span><br><span class="hljs-comment"> * 注意: 调用完此函数后一定需要调用 update_end 函数通知解析器解析完毕</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* data, <span class="hljs-type">size_t</span> len)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得所有的 MIME 结点</span><br><span class="hljs-comment"> * @return &#123;const std::list&lt;http_mimde_node*&gt;&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> std::list&lt;http_mime_node*&gt;&amp; <span class="hljs-title">get_nodes</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 根据变量名取得 HTTP MIME 结点</span><br><span class="hljs-comment"> * @param param name &#123;const char*&#125; 变量名</span><br><span class="hljs-comment"> * @return &#123;http_mime_node*&#125; 返回空则说明对应变量名的结点不存在</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> http_mime_node* <span class="hljs-title">get_node</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><h2 id="二、http-mime-node-类"><a href="#二、http-mime-node-类" class="headerlink" title="二、http_mime_node 类"></a>二、http_mime_node 类</h2><p>该类实例存储 HTTP MIME 数据体中每个数据结点，同时该类的实例是由 http_mime 类对象自动维护的，所以您一般不必关心该类对象的创建与销毁；另外，http_mime_node 类的继承关系为：http_mime_node -&gt; mime_attach -&gt; mime_node。</p><p>该类的构造函数如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 原始文件存放路径，不能为空</span><br><span class="hljs-comment"> * @param node &#123;MIME_NODE*&#125; 对应的 MIME 结点，非空</span><br><span class="hljs-comment"> * @param decodeIt &#123;bool&#125; 是否对 MIME 结点的头部数据</span><br><span class="hljs-comment"> *  或数据体数据进行解码</span><br><span class="hljs-comment"> * @param toCharset &#123;const char*&#125; 本机的字符集</span><br><span class="hljs-comment"> * @param off &#123;off_t&#125; 偏移数据位置</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">http_mime_node</span>(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path, <span class="hljs-type">const</span> MIME_NODE* node,<br><span class="hljs-type">bool</span> decodeIt = <span class="hljs-literal">true</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* toCharset = <span class="hljs-string">&quot;gb2312&quot;</span>, <span class="hljs-type">off_t</span> off = <span class="hljs-number">0</span>);<br></code></pre></td></tr></table></figure><p> 该类的常用方法为：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得该结点的类型</span><br><span class="hljs-comment"> * @return &#123;http_mime_t&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">http_mime_t</span> <span class="hljs-title">get_mime_type</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当 get_mime_type 返回的类型为 HTTP_MIME_PARAM 时，可以</span><br><span class="hljs-comment"> * 调用此函数获得参数值；参数名可以通过基类的 get_name() 获得</span><br><span class="hljs-comment"> * @return &#123;const char*&#125; 返回 NULL 表示参数不存在</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">get_value</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>http_mime_t 为枚举类型，如：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">enum</span><br>&#123;<br>HTTP_MIME_PARAM,        <span class="hljs-comment">// http mime 结点为参数类型</span><br>HTTP_MIME_FILE          <span class="hljs-comment">// http mime 结点为文件类型</span><br>&#125; <span class="hljs-type">http_mime_t</span>;<br></code></pre></td></tr></table></figure><p>加上两个基类的一些方法，有几个方法也是比较常用的，如下：</p><ul><li>mime_node::get_name: 获得该 mime 结点的名称</li><li>mime_attach::get_filename: 当结点为上传文件类型时，此函数获得上传文件的文件名</li></ul><h2 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.hpp&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> acl;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">http_servlet</span> : <span class="hljs-keyword">public</span> HttpServlet<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">http_servlet</span>()<br>&#123;<br>...<br>&#125;<br><br>...<br><span class="hljs-comment">// 基类虚方法：HTTP POST 方法接口</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class="hljs-function"></span>&#123;<br>...<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">doUpload</span>(req, res);<br>&#125;<br><br><span class="hljs-comment">// 处理文件上传的函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">doUpload</span><span class="hljs-params">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 先获得 Content-Type 对应的 http_ctype 对象</span><br>http_mime* mime = req.<span class="hljs-built_in">getHttpMime</span>();<br><span class="hljs-keyword">if</span> (mime == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;http_mime null&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 获得数据体的长度</span><br><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> len = req.<span class="hljs-built_in">getContentLength</span>();<br><span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;body empty&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-comment">// 获得输入流</span><br>istream&amp; in = req.<span class="hljs-built_in">getInputStream</span>();<br><span class="hljs-type">char</span>  buf[<span class="hljs-number">8192</span>];<br><span class="hljs-type">int</span>   ret;<br><span class="hljs-type">bool</span>  n = <span class="hljs-literal">false</span>;<br><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* filepath = <span class="hljs-string">&quot;./var/mime_file&quot;</span>;<br>ofstream out;<br><span class="hljs-comment">// 只写方式打开存储上传文件的临时文件句柄</span><br>out.<span class="hljs-built_in">open_write</span>(filepath);<br><br><span class="hljs-comment">// 设置原始文件存入路径</span><br>mime-&gt;<span class="hljs-built_in">set_saved_path</span>(filepath);<br><br><span class="hljs-comment">// 读取 HTTP 客户端请求数据</span><br><span class="hljs-keyword">while</span> (len &gt; <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 从 HTTP 输入流中读取数据</span><br>ret = in.<span class="hljs-built_in">read</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">-1</span>)<br>&#123;<br><span class="hljs-built_in">logger_error</span>(<span class="hljs-string">&quot;read POST data error&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><span class="hljs-comment">// 将数据写入临时文件中</span><br>out.<span class="hljs-built_in">write</span>(buf, ret);<br>len -= ret;<br><br><span class="hljs-comment">// 将读得到的数据输入至解析器进行解析</span><br><span class="hljs-keyword">if</span> (mime-&gt;<span class="hljs-built_in">update</span>(buf, ret) == <span class="hljs-literal">true</span>)<br>&#123;<br>n = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br>out.<span class="hljs-built_in">close</span>();<br><br><span class="hljs-keyword">if</span> (len != <span class="hljs-number">0</span> || n == <span class="hljs-literal">false</span>)<br><span class="hljs-built_in">logger_warn</span>(<span class="hljs-string">&quot;not read all data from client&quot;</span>);<br><br>string path;<br><br><span class="hljs-comment">// 遍历所有的 MIME 结点，找出其中为文件结点的部分进行转储</span><br><span class="hljs-type">const</span> std::list&lt;http_mime_node*&gt;&amp; nodes = mime-&gt;<span class="hljs-built_in">get_nodes</span>();<br>std::list&lt;http_mime_node*&gt;::const_iterator cit = nodes.<span class="hljs-built_in">begin</span>();<br><span class="hljs-keyword">for</span> (; cit != nodes.<span class="hljs-built_in">end</span>(); ++cit)<br>&#123;<br><span class="hljs-comment">// HTTP MIME 结点的变量名</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* name = (*cit)-&gt;<span class="hljs-built_in">get_name</span>();<br><br><span class="hljs-comment">// HTTP MIME 结点的类型</span><br><span class="hljs-type">http_mime_t</span> mime_type = (*cit)-&gt;<span class="hljs-built_in">get_mime_type</span>();<br><span class="hljs-keyword">if</span> (mime_type == HTTP_MIME_FILE)<br>&#123;<br><span class="hljs-comment">// 当该结点为文件数据结点时</span><br><span class="hljs-comment">// 取得上传文件名</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* filename = (*cit)-&gt;<span class="hljs-built_in">get_filename</span>();<br><span class="hljs-keyword">if</span> (filename == <span class="hljs-literal">NULL</span>)<br>&#123;<br><span class="hljs-built_in">logger</span>(<span class="hljs-string">&quot;filename null&quot;</span>);<br><span class="hljs-keyword">continue</span>;<br>&#125;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;file1&quot;</span>) == <span class="hljs-number">0</span>)<br>file1_ = filename;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;file2&quot;</span>) == <span class="hljs-number">0</span>)<br>file2_ = filename;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(name, <span class="hljs-string">&quot;file3&quot;</span>) == <span class="hljs-number">0</span>)<br>file3_ = filename;<br><br><span class="hljs-comment">// 将文件内容转存</span><br>path.format(<span class="hljs-string">&quot;./var/%s&quot;</span>, filename);<br>(<span class="hljs-type">void</span>) (*cit)-&gt;<span class="hljs-built_in">save</span>(path.<span class="hljs-built_in">c_str</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 查找上载的某个文件并转储</span><br><span class="hljs-type">const</span> http_mime_node* node = mime-&gt;<span class="hljs-built_in">get_node</span>(<span class="hljs-string">&quot;file1&quot;</span>);<br><span class="hljs-keyword">if</span> (node &amp;&amp; node-&gt;<span class="hljs-built_in">get_mime_type</span>() == HTTP_MIME_FILE)<br>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* ptr = node-&gt;<span class="hljs-built_in">get_filename</span>();<br><span class="hljs-keyword">if</span> (ptr)<br>&#123;<br>path.format(<span class="hljs-string">&quot;./var/1_%s&quot;</span>, ptr);<br>(<span class="hljs-type">void</span>) node-&gt;<span class="hljs-built_in">save</span>(path.<span class="hljs-built_in">c_str</span>());<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 删除临时文件</span><br>:<span class="hljs-built_in">unlink</span>(filepath);<br><br><span class="hljs-comment">// 发送 http 响应头</span><br><span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">sendHeader</span>() == <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 发送 http 响应体</span><br><span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">getOutputStream</span>().<span class="hljs-built_in">write</span>(<span class="hljs-string">&quot;ok&quot;</span>) == <span class="hljs-number">-1</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* file1_;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* file2_;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* file3_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br>acl::<span class="hljs-built_in">acl_cpp_init</span>();<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">// 开始运行</span><br>http_servlet servlet;<br>servlet.<span class="hljs-built_in">doRun</span>(<span class="hljs-string">&quot;127.0.0.1:11211&quot;</span>); <span class="hljs-comment">// 开始运行，并假设 memcached 监听于 127.0.0.1:11211</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>与上面例子对应的 HTML 页面如下：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;text/html; charset=gb2312&quot;</span> <span class="hljs-attr">http-equiv</span>=<span class="hljs-string">&quot;Content-Type&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">enctype</span>=<span class="hljs-string">&quot;multipart/form-data&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">POST</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/cgi-bin/test/upload?name1=中国人&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">hidden</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;美国人&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">hidden</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name3&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;英国人&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">submit</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span>, <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>文件一：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">file</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file1&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>文件二：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">file</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file2&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br>文件三：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">file</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;file3&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">br</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>上面例子比较简单地说明了如果使用 acl_cpp 中的 HttpServlet&#x2F;http_mime 等类来实现文件上传的功能，完整的例子请参考：acl_cpp&#x2F;samples&#x2F;cig_upload。该例子虽然是一个 CGI 程序，但您依然可以不费吹灰之力将其改变成一个服务器程序，转换方法可参考：《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》。</p>]]></content>
    
    
    <categories>
      
      <category>http开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序</title>
    <link href="/2012/05/21/http_web/"/>
    <url>/2012/05/21/http_web/</url>
    
    <content type="html"><![CDATA[<p>在 《用C++实现类似于JAVA HttpServlet 的编程接口 》 文章中讲了如何用 HttpServlet 等相关类编写 CGI 程序，于是有网友提出了 CGI 程序低效性，不错，确实 CGI 程序的进程开销是比较大的，本文就将说明依然是这些 HTTP 相关的类，如果在使用 acl_cpp&#x2F;src&#x2F;master 下的服务器框架类的条件下，可以非常方便地转为服务器程序。现在依然是使用 《用C++实现类似于JAVA HttpServlet 的编程接口 》示例中的 http_servlet 类，只是稍微修改一下 main 函数，就变成下面的情形：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">master_service</span> : <span class="hljs-keyword">public</span> acl::master_proc<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">master_service</span>() &#123;&#125;<br>~<span class="hljs-built_in">master_service</span>() &#123;&#125;<br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类虚函数，当接收到一个 HTTP 客户端请求时，服务器</span><br><span class="hljs-comment">// 框架回调此函数将连接流传入</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">on_accept</span><span class="hljs-params">(acl::socket_stream* stream)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// HttpServlet 的子类实例</span><br><span class="hljs-function">http_servlet <span class="hljs-title">servlet</span><span class="hljs-params">(<span class="hljs-string">&quot;127.0.0.1:11211&quot;</span>)</span></span>;<br>servlet.<span class="hljs-built_in">setLocalCharset</span>(<span class="hljs-string">&quot;gb2312&quot;</span>);  <span class="hljs-comment">// 设置本地字符集</span><br>servlet.<span class="hljs-built_in">doRun</span>(stream);  <span class="hljs-comment">// 开始处理浏览器请求过程</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>acl::<span class="hljs-built_in">acl_cpp_init</span>();  <span class="hljs-comment">// 初始化 acl_cpp 库</span><br>master_service service;  <span class="hljs-comment">// 半驻留进程池服务类对象</span><br><br><span class="hljs-comment">// 开始运行</span><br><br><span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;alone&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 当在手工调试时一般采用此方式</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listen: 127.0.0.1:8888 ...\r\n&quot;</span>);<br>service.<span class="hljs-built_in">run_alone</span>(<span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">1</span>);  <span class="hljs-comment">// 单独运行方式</span><br>&#125;<br><span class="hljs-keyword">else</span>  <span class="hljs-comment">// 生产环境中以半驻留进程池模式运行</span><br>service.<span class="hljs-built_in">run_daemon</span>(argc, argv);  <span class="hljs-comment">// acl_master 控制模式运行</span><br><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>上面的例子是一个结合 HttpServlet 类及 master_service 进程池服务类的 HTTP 服务器程序，关于进程池的例子，可以先结合本人原来写过的基于C语言库 acl 的一篇文章《快速创建你的服务器程序－－single进程池模型 》。</p><p>不仅可以非常容易地将 HttpServlet 写成进程池方式，同时还可以结合 acl_cpp 的线程池框架模板，将 HttpServlet 类实现为半驻留线程池实例，下面就显示了这一过程：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">master_threads_test</span> : <span class="hljs-keyword">public</span> acl::master_threads<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">master_threads_test</span>() &#123;&#125;<br><br>~<span class="hljs-built_in">master_threads_test</span>() &#123;&#125;<br><br><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示</span><br><span class="hljs-comment">// 继续与客户端保持长连接，否则表示需要关闭客户端连接</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">thread_on_read</span><span class="hljs-params">(acl::socket_stream* stream)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// HttpServlet 的子类实例</span><br>http_servlet servlet;<br>servlet.<span class="hljs-built_in">setLocalCharset</span>(<span class="hljs-string">&quot;gb2312&quot;</span>);  <span class="hljs-comment">// 设置本地字符集</span><br>servlet.<span class="hljs-built_in">doRun</span>(“<span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span>：<span class="hljs-number">11211</span>”， stream);  <span class="hljs-comment">// 开始处理浏览器请求过程，同时设置 memcached 的监听地址及客户端连接流</span><br>&#125;<br><br><span class="hljs-comment">// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许</span><br><span class="hljs-comment">// 子类事先对客户端连接进行处理，返回 true 表示继续，否则</span><br><span class="hljs-comment">// 要求关闭该客户端连接</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">thread_on_accept</span><span class="hljs-params">(acl::socket_stream*)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;  <span class="hljs-comment">// 返回 true 以允许服务器框架继续调用 thread_on_read 过程</span><br>&#125;<br>&#125;;<br><br><span class="hljs-comment">// 字符串类配置参数项</span><br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *var_cfg_debug_msg;<br><br><span class="hljs-type">static</span> acl::master_str_tbl var_conf_str_tab[] = &#123;<br>&#123; <span class="hljs-string">&quot;debug_msg&quot;</span>, <span class="hljs-string">&quot;test_msg&quot;</span>, &amp;var_cfg_debug_msg &#125;,<br><br>&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 布尔配置参数项</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_debug_enable;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_keep_alive;<br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_loop;<br><br><span class="hljs-type">static</span> acl::master_bool_tbl var_conf_bool_tab[] = &#123;<br>&#123; <span class="hljs-string">&quot;debug_enable&quot;</span>, <span class="hljs-number">1</span>, &amp;var_cfg_debug_enable &#125;,<br>&#123; <span class="hljs-string">&quot;keep_alive&quot;</span>, <span class="hljs-number">1</span>, &amp;var_cfg_keep_alive &#125;,<br>&#123; <span class="hljs-string">&quot;loop_read&quot;</span>, <span class="hljs-number">1</span>, &amp;var_cfg_loop &#125;,<br><br>&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-comment">// 整数配置参数项</span><br><span class="hljs-type">static</span> <span class="hljs-type">int</span>  var_cfg_io_timeout;<br><br><span class="hljs-type">static</span> acl::master_int_tbl var_conf_int_tab[] = &#123;<br>&#123; <span class="hljs-string">&quot;io_timeout&quot;</span>, <span class="hljs-number">120</span>, &amp;var_cfg_io_timeout, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<br><br>&#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> , <span class="hljs-number">0</span> , <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br>master_threads_test mt;  <span class="hljs-comment">// 半驻留线程池服务器实例</span><br><br><span class="hljs-comment">// 设置配置参数表</span><br>mt.<span class="hljs-built_in">set_cfg_int</span>(var_conf_int_tab);<br>mt.<span class="hljs-built_in">set_cfg_int64</span>(<span class="hljs-literal">NULL</span>);<br>mt.<span class="hljs-built_in">set_cfg_str</span>(var_conf_str_tab);<br>mt.<span class="hljs-built_in">set_cfg_bool</span>(var_conf_bool_tab);<br><br><span class="hljs-comment">// 开始运行</span><br><br><span class="hljs-keyword">if</span> (argc &gt;= <span class="hljs-number">2</span> &amp;&amp; <span class="hljs-built_in">strcmp</span>(argv[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;alone&quot;</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 当在手工调试时一般采用此方式</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;listen: 127.0.0.1:8888\r\n&quot;</span>);<br>mt.<span class="hljs-built_in">run_alone</span>(<span class="hljs-string">&quot;127.0.0.1:8888&quot;</span>, <span class="hljs-literal">NULL</span>, <span class="hljs-number">2</span>, <span class="hljs-number">10</span>);  <span class="hljs-comment">// 单独运行方式</span><br>&#125;<br><span class="hljs-keyword">else</span>  <span class="hljs-comment">// 生产环境中以半驻留线程池模式运行</span><br>mt.<span class="hljs-built_in">run_daemon</span>(argc, argv);  <span class="hljs-comment">// acl_master 控制模式运行</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>http开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用C++实现类似于JAVA HttpServlet 的编程接口</title>
    <link href="/2012/05/20/http_servlet/"/>
    <url>/2012/05/20/http_servlet/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>互联网刚兴起时，很多项目都是用 C &#x2F;Perl 语言写的一大堆 CGI，一些老程序员可谓是偿尽了编程的苦，因为那时国内的技术水平普遍比较低，如果你会 CGI 编程，就已经算是行业中人了，如果你对 CGI 编程比较熟练，则就可以称得是“专家”了，后来技术不断进步，各种国外的新技术都进入中国并不断得到普及，CGI 就逐渐沦为一种落后的技术，后来的 PHP, JSP&#x2F;Servlet, ASP 逐渐占领了 WEB 编程的技术市场，这个时候如果你说再用 C 写 CGI，别人会感觉是在和古人对话。现在主流的 WEB 开发语言一个很大的优势就是有各种相对成熟的基础库和框架，开发效率很高，而 CGI 则就逊色很多。当然，这些语言也得有执行效率相对较低的问题，毕竟它们都是脚本语言或半编译语言，需要虚拟机解释执行，象 facebook 的 WEB 前端基本都是用 PHP 写的，他们为了解决执行效率问题，在一位华人的领导下开发了可以将 PHP 代码转成 C++ 代码的工具（hiphop)，从而使执行效率大大提高，这也从另一个侧面反映出技术人员还是希望他们的程序能够运行的更快些。</p><p>本文主要描述了 acl_cpp 库中有关 WEB 编程的方法类，为了使大家容易上手，其中的接口设计及命名尽量模仿 JAVA HttpServlet 等相关的类（希望 Oracle 不会告我侵权，呵呵）。如果您会用C&#x2F;C++编程，同时又有使用 Java Servlet 进行 WEB 编程的经验，则该文您读起来一点不会费力，当然如果您多年从事 WEB 开发，我想理解这些类的设计及用法也不应该有什么难度。好了，下面就开始讲如何使用 acl_cpp 库中的 http&#x2F; 模块下的类进行 web 编程。</p><p>在 acl_cpp&#x2F;src&#x2F;http 模块下，有几个类与 WEB 编程相关：HttpServlet，HttpServletRequest, HttpServletResponse, HttpSession, http_header, http_mime, http_client。如果您掌握了这几个类的用法，则进行 WEB 编程就不会有什么问题了，下面一一介绍这几个类：</p><h2 id="二、HttpServlet-类"><a href="#二、HttpServlet-类" class="headerlink" title="二、HttpServlet 类"></a>二、HttpServlet 类</h2><p>构造函数及析构函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">HttpServlet</span>(<span class="hljs-type">void</span>);<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 纯虚析构函数，即该类必须由子类进行实例化</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">HttpServlet</span>(<span class="hljs-type">void</span>) = <span class="hljs-number">0</span>;<br></code></pre></td></tr></table></figure><p>在构建函数中，为了支持 HttpSession 数据的存储，需要用户给出 memcached 的服务器地址（目前仅支持采用 memcached 来存储 session 数据，将来应该会扩展至可以支持 redis 等），同时用户还需要给出 session 的 cookie ID 标识符以发给浏览器。</p><p>四个虚接口，需要子类实现以应对不同的浏览器的 HTTP 请求：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当 HTTP 请求为 GET 方式时的虚函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当 HTTP 请求为 POST 方式时的虚函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当 HTTP 请求为 PUT 方式时的虚函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">doPut</span><span class="hljs-params">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当 HTTP 请求为 CONNECT 方式时的虚函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">doConnect</span><span class="hljs-params">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当 HTTP 请求为 PURGE 方式时的虚函数，该方法在清除 SQUID 的缓存</span><br><span class="hljs-comment"> * 时会用到</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">doPurge</span><span class="hljs-params">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br></code></pre></td></tr></table></figure><p>用户实现的 HttpServlet 子类中可以实现以上几个虚接口的一个或者几个，以满足不同的 HTTP 请求。</p><p>下面的函数为 HttpServlet 类开始运行的函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数</span><br><span class="hljs-comment"> * @param session &#123;session&amp;&#125; 存储 session 数据的对象</span><br><span class="hljs-comment"> * @param stream &#123;socket_stream*&#125; 当在 acl_master 服务器框架控制下</span><br><span class="hljs-comment"> *  运行时，该参数必须非空；当在 apache 下以 CGI 方式运行时，该参数</span><br><span class="hljs-comment"> *  设为 NULL；另外，该函数内部不会关闭流连接，应用应自行处理流对象</span><br><span class="hljs-comment"> *  的关闭情况，这样可以方便与 acl_master 架构结合</span><br><span class="hljs-comment"> * @param body_parse &#123;bool&#125; 针对 POST 方法，该参数指定是否需要</span><br><span class="hljs-comment"> *  读取 HTTP 请求数据体并按 n/v 方式进行分析；当为 true 则内</span><br><span class="hljs-comment"> *  部会读取 HTTP 请求体数据，并进行分析，当用户调用 getParameter</span><br><span class="hljs-comment"> *  时，不仅可以获得 URL 中的参数，同时可以获得 POST 数据体中</span><br><span class="hljs-comment"> *  的参数；当该参数为 false 时则不读取数据体</span><br><span class="hljs-comment"> * @param body_limit &#123;int&#125; 针对 POST 方法，当数据体为文本参数</span><br><span class="hljs-comment"> *  类型时，此参数限制数据体的长度；当数据体为数据流或 MIME</span><br><span class="hljs-comment"> *  格式或 body_read 为 false，此参数无效</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回处理结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">doRun</span><span class="hljs-params">(session&amp; session, socket_stream* stream = <span class="hljs-literal">NULL</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">bool</span> body_parse = <span class="hljs-literal">true</span>, <span class="hljs-type">int</span> body_limit = <span class="hljs-number">102400</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数，</span><br><span class="hljs-comment"> * 调用本函数意味着采用 memcached 来存储 session 数据</span><br><span class="hljs-comment"> * @param memcached_addr &#123;const char*&#125; memcached 服务器地址，格式：IP:PORT</span><br><span class="hljs-comment"> * @param stream &#123;socket_stream*&#125; 含义同上</span><br><span class="hljs-comment"> * @param body_parse &#123;bool&#125; 含义同上</span><br><span class="hljs-comment"> * @param body_limit &#123;int&#125; 含义同上</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回处理结果</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">doRun</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* memcached_addr = <span class="hljs-string">&quot;127.0.0.1:11211&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">socket_stream* stream = <span class="hljs-literal">NULL</span>,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">bool</span> body_parse = <span class="hljs-literal">true</span>, <span class="hljs-type">int</span> body_limit = <span class="hljs-number">102400</span>)</span></span>;<br><br></code></pre></td></tr></table></figure><p>从上面五个虚方法中，可以看到两个重要的类：HttpServletRequest 和 HttpServletResponse。这两个类分别表示 http 请求类及 http 响应类，这两个类都是由 HttpServlet 类对象创建并释放的，所以用户不必创建和销毁这两个类对象实例。下面分别介绍这两个类：</p><h2 id="三、HttpServletRequest-类"><a href="#三、HttpServletRequest-类" class="headerlink" title="三、HttpServletRequest 类"></a>三、HttpServletRequest 类</h2><p>该类主要是与浏览器的请求过程相关，您可以通过该类的方法获得浏览器的请求数据。该类的方法比较多（基本上是参照了 java HttpServlet 的功能方法及名称），所以下面仅介绍几个主要的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得 HTTP 请求中的参数值，该值已经被 URL 解码且</span><br><span class="hljs-comment"> * 转换成本地要求的字符集；针对 GET 方法，则是获得</span><br><span class="hljs-comment"> * URL 中 ? 后面的参数值；针对 POST 方法，则可以获得</span><br><span class="hljs-comment"> * URL 中 ? 后面的参数值或请求体中的参数值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getParameter</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得 HTTP 客户端请求的某个 cookie 值</span><br><span class="hljs-comment"> * @param name &#123;const char*&#125; cookie 名称，必须非空</span><br><span class="hljs-comment"> * @return &#123;const char*&#125; cookie 值，当返回 NULL 时表示</span><br><span class="hljs-comment"> *  cookie 值不存在</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getCookieValue</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得与该 HTTP 会话相关的 HttpSession 对象引用</span><br><span class="hljs-comment"> * @return &#123;HttpSession&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">HttpSession&amp; <span class="hljs-title">getSession</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得与 HTTP 客户端连接关联的输入流对象引用</span><br><span class="hljs-comment"> * @return &#123;istream&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">istream&amp; <span class="hljs-title">getInputStream</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得 HTTP 请求数据的数据长度</span><br><span class="hljs-comment"> * @return &#123;acl_int64&#125; 返回 -1 表示可能为 GET 方法，</span><br><span class="hljs-comment"> *  或 HTTP 请求头中没有 Content-Length 字段</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br><span class="hljs-function">__int64 <span class="hljs-title">getContentLength</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br><span class="hljs-function"><span class="hljs-type">long</span> <span class="hljs-type">long</span> <span class="hljs-type">int</span> <span class="hljs-title">getContentLength</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当 HTTP 请求头中的 Content-Type 为</span><br><span class="hljs-comment"> * multipart/form-data; boundary=xxx 格式时，说明为文件上传</span><br><span class="hljs-comment"> * 数据类型，则可以通过此函数获得 http_mime 对象</span><br><span class="hljs-comment"> * @return &#123;const http_mime*&#125; 返回 NULL 则说明没有 MIME 对象，</span><br><span class="hljs-comment"> *  返回的值用户不能手工释放，因为在 HttpServletRequest 的析</span><br><span class="hljs-comment"> *  构中会自动释放</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">http_mime* <span class="hljs-title">getHttpMime</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得 HTTP 请求数据的类型</span><br><span class="hljs-comment"> * @return &#123;http_request_t&#125;，一般对 POST 方法中的上传</span><br><span class="hljs-comment"> *  文件应用而言，需要调用该函数获得是否是上传数据类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">http_request_t</span> <span class="hljs-title">getRequestType</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><p>以上方法一般都是我们在实际对 HttpServletRequest 类方法使用过程中用得较多的。如：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">getParmeter： 用来获得 <span class="hljs-keyword">http</span> 请求参数<br>getCookieValue：获得浏览器的 cookie 值<br>getSession：获得该 HttpServlet 类对象的 session 会话<br>getInputStream：获得 <span class="hljs-keyword">http</span> 连接的输入流<br>getContentLength：针对 HTTP POST 请求，此函数获得 HTTP 请求数据体的长度<br>getRequestType：针对 HTTP POST 请求，此函数返回 HTTP 请求数据体的传输方式（普通的 name=<span class="hljs-built_in">value</span> 方式，multipart 上传文件格式以及数据流格式）<br></code></pre></td></tr></table></figure><h2 id="四、HttpServletResponse-类"><a href="#四、HttpServletResponse-类" class="headerlink" title="四、HttpServletResponse 类"></a>四、HttpServletResponse 类</h2><p>该类主要与将您写的程序将处理数据结果返回给浏览器的过程相关，下面也仅介绍该类的一些常用的函数，如果您需要更多的功能，请参数 HttpServletResponse.hpp 头文件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 HTTP 响应数据体的 Content-Type 字段值，可字段值可以为：</span><br><span class="hljs-comment"> * text/html 或 text/html; charset=utf8 格式</span><br><span class="hljs-comment"> * @param value &#123;const char*&#125; 字段值</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setContentType</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* value)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 HTTP 响应数据体中字符集，当已经在 setContentType 设置</span><br><span class="hljs-comment"> * 了字符集，则就不必再调用本函数设置字符集</span><br><span class="hljs-comment"> * @param charset &#123;const char*&#125; 响应体数据的字符集</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setCharacterEncoding</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* charset)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 HTTP 响应头中的状态码：1xx, 2xx, 3xx, 4xx, 5xx</span><br><span class="hljs-comment"> * @param status &#123;int&#125; HTTP 响应状态码, 如：200</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">setStatus</span><span class="hljs-params">(<span class="hljs-type">int</span> status)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加 cookie</span><br><span class="hljs-comment"> * @param name &#123;const char*&#125; cookie 名</span><br><span class="hljs-comment"> * @param value &#123;const char*&#125; cookie 值</span><br><span class="hljs-comment"> * @param domain &#123;const char*&#125; cookie 存储域</span><br><span class="hljs-comment"> * @param path &#123;const char*&#125; cookie 存储路径</span><br><span class="hljs-comment"> * @param expires &#123;time_t&#125; cookie 过期时间间隔，当当前时间加</span><br><span class="hljs-comment"> *  该值为 cookie 的过期时间截(秒)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">addCookie</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* value,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span>* domain = <span class="hljs-literal">NULL</span>, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* path = <span class="hljs-literal">NULL</span>, <span class="hljs-type">time_t</span> expires = <span class="hljs-number">0</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送 HTTP 响应头，用户应该发送数据体前调用此函数将 HTTP</span><br><span class="hljs-comment"> * 响应头发送给客户端</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">sendHeader</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得 HTTP 响应对象的输出流对象，用户在调用 sendHeader 发送</span><br><span class="hljs-comment"> * 完 HTTP 响应头后，通过该输出流来发送 HTTP 数据体</span><br><span class="hljs-comment"> * @return &#123;ostream&amp;&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ostream&amp; <span class="hljs-title">getOutputStream</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> <span class="hljs-type">const</span></span>;<br></code></pre></td></tr></table></figure><ul><li>setCharacterEncoding：该方法设置 HTTP 响应头的 HTTP 数据体的字符集，如果通过该函数设置了字符集，即使您在返回的 html 数据中重新设置了其它的字符集，浏览器也会优先使用 HTTP 响应头中设置的字符集，所以用户一定得注意这点；</li><li>setContentType：该方法用来设置 HTTP 响应头中的 Content-Type 字段，对于 xml 数据则设置 text&#x2F;xml，对 html 数据则设置 text&#x2F;html，当然您也可以设置 image&#x2F;jpeg 等数据类型；当然，您也可以直接通过该方法在设置数据类型的同时指定数据的字符集，如可以直接写：setContentType(“text&#x2F;html; charset&#x3D;utf8”)，这个用法等同于：setContentType(“text&#x2F;html”); setCharacterEncoding(“utf8”)。</li><li>setStatus：设置 HTTP 响应头的状态码（一般不用设置状态码，除非是您确实需要单独设置）；</li><li>addCookie：在 HTTP 响应头中添加 cookie 内容；</li><li>sendHeader：发送 HTTP 响应头；</li><li>getOutputStream：该函数返回输出流对象，您可以向输出流中直接写 HTTP 响应的数据体（关于 ostream 类的使用请参数头文件：include&#x2F;ostream.hpp）。</li></ul><p>除了以上三个类外，还有一个类比较重要：HttpSession 类，该类主要实现与 session 会话相关的功能：</p><h2 id="五、HttpSession-类"><a href="#五、HttpSession-类" class="headerlink" title="五、HttpSession 类"></a>五、HttpSession 类</h2><p>该类对象实例用户也不必创建与释放，在 HttpServet 类对象内容自动管理该类对象实例。主要用的方法有：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获得客户端在服务端存储的对应 session 变量名，子类可以重载该方法</span><br><span class="hljs-comment"> * @param name &#123;const char*&#125; session 名，非空</span><br><span class="hljs-comment"> * @return &#123;const char*&#125; session 值，为空说明不存在或内部</span><br><span class="hljs-comment"> *  查询失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">const</span> <span class="hljs-type">char</span>* <span class="hljs-title">getAttribute</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name)</span> <span class="hljs-type">const</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置服务端对应 session 名的 session 值，子类可以重载该方法</span><br><span class="hljs-comment"> * @param name &#123;const char*&#125; session 名，非空</span><br><span class="hljs-comment"> * @param name &#123;const char*&#125; session 值，非空</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 false 说明设置失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">bool</span> <span class="hljs-title">setAttribute</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* name, <span class="hljs-type">const</span> <span class="hljs-type">char</span>* value)</span></span>;<br></code></pre></td></tr></table></figure><p>只所以将这两个方法声明为虚方法，是因为 HttpSession 的 session 数据存储目前仅支持 memcached，您如果有精力的话可以实现一个子类用来支持其它的数据存储方式。当然您也可以在您实现的子类中实现自己的产生唯一 session id 的方法，即实现如下虚方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">protected</span>:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建某个 session 会话的唯一 ID 号，子类可以重载该方法</span><br><span class="hljs-comment"> * @param buf &#123;char*&#125; 存储结果缓冲区</span><br><span class="hljs-comment"> * @param len &#123;size_t&#125; buf 缓冲区大小，buf 缓冲区大小建议</span><br><span class="hljs-comment"> *  64 字节左右</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">createSid</span><span class="hljs-params">(<span class="hljs-type">char</span>* buf, <span class="hljs-type">size_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure><p>好了，上面说了一大堆类及类函数，下面还是以一个具体的示例来说明这些类的用法：</p><h2 id="六、示例"><a href="#六、示例" class="headerlink" title="六、示例"></a>六、示例</h2><p>下面的例子是一个 CGI 例子，编译后可执行程序可以直接放在 apache 的 cgi-bin&#x2F; 目录，用户可以用浏览器访问。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">// http_servlet.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.hpp&quot;</span></span><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> acl;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">http_servlet</span> : <span class="hljs-keyword">public</span> HttpServlet<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">http_servlet</span>(<span class="hljs-type">void</span>)<br>&#123;<br>&#125;<br><br>~<span class="hljs-built_in">http_servlet</span>(<span class="hljs-type">void</span>)<br>&#123;<br>&#125;<br><br><span class="hljs-comment">// 实现处理 HTTP GET 请求的功能函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">doPost</span>(req, res);<br>&#125;<br><br><span class="hljs-comment">// 实现处理 HTTP POST 请求的功能函数</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">doPost</span><span class="hljs-params">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 获得某浏览器用户的 session 的某个变量值，如果不存在则设置一个</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* sid = req.<span class="hljs-built_in">getSession</span>().<span class="hljs-built_in">getAttribute</span>(<span class="hljs-string">&quot;sid&quot;</span>);<br><span class="hljs-keyword">if</span> (sid == <span class="hljs-literal">NULL</span> || *sid == <span class="hljs-number">0</span>)<br>req.<span class="hljs-built_in">getSession</span>().<span class="hljs-built_in">setAttribute</span>(<span class="hljs-string">&quot;sid&quot;</span>, <span class="hljs-string">&quot;xxxxxx&quot;</span>);<br><br><span class="hljs-comment">// 再取一次该浏览器用户的 session 的某个属性值</span><br>sid = req.<span class="hljs-built_in">getSession</span>().<span class="hljs-built_in">getAttribute</span>(<span class="hljs-string">&quot;sid&quot;</span>);<br><br><span class="hljs-comment">// 取得浏览器发来的两个 cookie 值</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cookie1 = req.<span class="hljs-built_in">getCookieValue</span>(<span class="hljs-string">&quot;name1&quot;</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* cookie2 = req.<span class="hljs-built_in">getCookieValue</span>(<span class="hljs-string">&quot;name2&quot;</span>);<br><br><span class="hljs-comment">// 开始创建 HTTP 响应头</span><br><br><span class="hljs-comment">// 设置 cookie</span><br>  res.<span class="hljs-built_in">addCookie</span>(<span class="hljs-string">&quot;name1&quot;</span>, <span class="hljs-string">&quot;value1&quot;</span>);<br><br><span class="hljs-comment">// 设置具有作用域和过期时间的 cookie</span><br>res.<span class="hljs-built_in">addCookie</span>(<span class="hljs-string">&quot;name2&quot;</span>, <span class="hljs-string">&quot;value2&quot;</span>, <span class="hljs-string">&quot;.test.com&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-number">3600</span> * <span class="hljs-number">24</span>);<br><span class="hljs-comment">// res.setStatus(200);  // 可以设置返回的状态码</span><br><br><span class="hljs-comment">// 两种方式都可以设置字符集</span><br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>)<br>res.<span class="hljs-built_in">setContentType</span>(<span class="hljs-string">&quot;text/xml; charset=gb2312&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 先设置数据类型</span><br>res.<span class="hljs-built_in">setContentType</span>(<span class="hljs-string">&quot;text/xml&quot;</span>);<br><br><span class="hljs-comment">// 再设置数据字符集</span><br>res.<span class="hljs-built_in">setCharacterEncoding</span>(<span class="hljs-string">&quot;gb2312&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">// 获得浏览器请求的两个参数值</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* param1 = req.<span class="hljs-built_in">getParameter</span>(<span class="hljs-string">&quot;name1&quot;</span>);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* param2 = req.<span class="hljs-built_in">getParameter</span>(<span class="hljs-string">&quot;name2&quot;</span>);<br><br><span class="hljs-comment">// 创建 xml 格式的数据体</span><br>xml body;<br>body.<span class="hljs-built_in">get_root</span>().<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;root&quot;</span>, <span class="hljs-literal">true</span>)<br>.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;sessions&quot;</span>, <span class="hljs-literal">true</span>)<br>.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;session&quot;</span>, <span class="hljs-literal">true</span>)<br>.<span class="hljs-built_in">add_attr</span>(<span class="hljs-string">&quot;sid&quot;</span>, sid ? sid : <span class="hljs-string">&quot;null&quot;</span>)<br>.<span class="hljs-built_in">get_parent</span>()<br>.<span class="hljs-built_in">get_parent</span>()<br>.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;cookies&quot;</span>, <span class="hljs-literal">true</span>)<br>.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;cookie&quot;</span>, <span class="hljs-literal">true</span>)<br>.<span class="hljs-built_in">add_attr</span>(<span class="hljs-string">&quot;name1&quot;</span>, cookie1 ? cookie1 : <span class="hljs-string">&quot;null&quot;</span>)<br>.<span class="hljs-built_in">get_parent</span>()<br>.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;cookie&quot;</span>, <span class="hljs-literal">true</span>)<br>.<span class="hljs-built_in">add_attr</span>(<span class="hljs-string">&quot;name2&quot;</span>, cookie2 ? cookie2 : <span class="hljs-string">&quot;null&quot;</span>)<br>.<span class="hljs-built_in">get_parent</span>()<br>.<span class="hljs-built_in">get_parent</span>()<br>.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;params&quot;</span>, <span class="hljs-literal">true</span>)<br>.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-literal">true</span>)<br>.<span class="hljs-built_in">add_attr</span>(<span class="hljs-string">&quot;name1&quot;</span>, param1 ? param1 : <span class="hljs-string">&quot;null&quot;</span>)<br>.<span class="hljs-built_in">get_parent</span>()<br>.<span class="hljs-built_in">add_child</span>(<span class="hljs-string">&quot;param&quot;</span>, <span class="hljs-literal">true</span>)<br>.<span class="hljs-built_in">add_attr</span>(<span class="hljs-string">&quot;name2&quot;</span>, param2 ? param2 : <span class="hljs-string">&quot;null&quot;</span>);<br>string buf;<br>body.<span class="hljs-built_in">build_xml</span>(buf);<br><span class="hljs-comment">// 在http 响应头中设置数据体长度</span><br>res.<span class="hljs-built_in">setContentLength</span>(buf.<span class="hljs-built_in">length</span>());<br><span class="hljs-comment">// 发送 http 响应头</span><br><span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">sendHeader</span>() == <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-comment">// 发送 http 响应体</span><br><span class="hljs-keyword">if</span> (res.<span class="hljs-built_in">write</span>(buf) == <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>&#125;<br>&#125;;<br><br><span class="hljs-comment">//////////////////////////////////////////////////////////////////////////</span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br>acl::<span class="hljs-built_in">acl_cpp_init</span>();  <span class="hljs-comment">// win32 环境下需要初始化库</span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>http_servlet servle;<br><br><span class="hljs-comment">// cgi 开始运行</span><br>servlet.<span class="hljs-built_in">doRun</span>(<span class="hljs-string">&quot;127.0.0.1:11211&quot;</span>);  <span class="hljs-comment">// 开始运行，并设定 memcached 的服务地址为：127.0.0.1:11211</span><br><br><span class="hljs-comment">// 运行完毕，程序退出</span><br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>经常使用 Java HttpServlet 等类进行 web 编程的用户对上面的代码一定不会感到陌生，但它的的确确是一个 CGI 程序，可以放在 Apache 及支持 CGI 的 Webserver 下运行。当然，大家应该都清楚 CGI 在运行时因进程切换而导致了效率较为低下，在另一篇文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中展示了用上面的 http_servlet 类并结合 acl_cpp 的服务器模型实现的一个WEB服务器的例子，效率比 CGI 要高的多(效率也应比 FCGI高，因为其少了 Webserver 层的过滤)；文章《acl_cpp web 编程之文件上传 》中举例讲述了在服务端如何使用 acl_cpp 库处理浏览器上传文件的功能。</p><p>acl 下载<br>github: <a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee: <a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>http开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>非阻塞网络编程实例讲解</title>
    <link href="/2012/04/04/aio/"/>
    <url>/2012/04/04/aio/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>acl 库的 C 库(lib_acl) 的 aio 模块设计了完整的非阻塞异步 IO 通信过程，在 acl 的C++库(lib_acl_cpp) 中封装并增强了异步通信的功能，本文主要描述了 acl C++ 库之非阻塞IO库的设计及使用方法，该异步流的设计思路为：异步流类与异步流接口类，其中异步流类对象完成网络套接口监听、连接、读写的操作，异步流接口类对象定义了网络读写成功&#x2F;超时回调、连接成功回调、接收客户端连接回调等接口；用户在进行异步编程时，首先必须实现接口类中定义的纯方法，然后将接口类对象在异步流对象中进行注册，这样当满足接口类对象的回调条件时 acl_cpp 的异步框架便自动调用用户定义的接口方法。</p><p>在 acl_cpp 中异步流的类继续关系如下图所示：<br><img src="/img/aio_inherit.png" alt="异步流类继承关系图"></p><p>由上图可以看出，基类 aio_stream 中定义了流关闭，注册&#x2F;取消流关闭回调和流超时回调等基础方法；aio_istream 和 aio_ostream 分别定义了异步流读及写的基本方法，aio_istream 中包含添加&#x2F;删除流读成功回调接口类对象的方法，aio_ostream 中包含添加&#x2F;删除流写成功回调接口类对象的方法；aio_socket_stream 类对象为连接服务器成功后的客户端流，或服务器接收到客户端连接创建的客户端连接流，其中定义了做为连接流时远程连接的方法及添加连接成功回调接口的方法；aio_listen_stream 类为监听流类，其中定义了监听某个网络地址（或UNIX下的域套接口地址）方法，以及注册接收成功接口的方法。</p><p>acl_cpp 异步流接口类继承关系图如下图：<br><img src="/img/aio_callback.png" alt="异步流类继承关系图"></p><p>异步流接口类的设计中：aio_accept_callback 为监听流的回调接口类，用户应继承该类以获得外来客户端连接流，同时还需要定义继承于 aio_callback 的类，用于获得网络读写操作等结果信息；aio_open_callback 只有当客户端连接远程服务器时，用户需要实现其子类获得连接成功的结果。</p><h2 id="二、实例"><a href="#二、实例" class="headerlink" title="二、实例"></a>二、实例</h2><h3 id="1、异步服务器"><a href="#1、异步服务器" class="headerlink" title="1、异步服务器"></a>1、异步服务器</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aio_handle.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aio_istream.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aio_listen_stream.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aio_socket_stream.hpp&quot;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> acl;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步客户端流的回调类的子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io_callback</span> : <span class="hljs-keyword">public</span> aio_callback<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">io_callback</span>(aio_socket_stream* client)<br>: <span class="hljs-built_in">client_</span>(client)<br>, <span class="hljs-built_in">i_</span>(<span class="hljs-number">0</span>)<br>&#123;<br>&#125;<br><br>~<span class="hljs-built_in">io_callback</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;delete io_callback now ...&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现父类中的虚函数，客户端流的读成功回调过程</span><br><span class="hljs-comment"> * @param data &#123;char*&#125; 读到的数据地址</span><br><span class="hljs-comment"> * @param len &#123;int&#125; 读到的数据长度</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">read_callback</span><span class="hljs-params">(<span class="hljs-type">char</span>* data, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>i_++;<br><span class="hljs-keyword">if</span> (i_ &lt; <span class="hljs-number">10</span>)<br>std::cout &lt;&lt; <span class="hljs-string">&quot;&gt;&gt;gets(i:&quot;</span> &lt;&lt; i_ &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; data;<br><br><span class="hljs-comment">// 如果远程客户端希望退出，则关闭之</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncasecmp</span>(data, <span class="hljs-string">&quot;quit&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>client_-&gt;format(<span class="hljs-string">&quot;Bye!\r\n&quot;</span>);<br>client_-&gt;<span class="hljs-built_in">close</span>();<br>&#125;<br><br><span class="hljs-comment">// 如果远程客户端希望服务端也关闭，则中止异步事件过程</span><br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncasecmp</span>(data, <span class="hljs-string">&quot;stop&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<br>&#123;<br>client_-&gt;format(<span class="hljs-string">&quot;Stop now!\r\n&quot;</span>);<br>client_-&gt;<span class="hljs-built_in">close</span>();  <span class="hljs-comment">// 关闭远程异步流</span><br><br><span class="hljs-comment">// 通知异步引擎关闭循环过程</span><br>client_-&gt;<span class="hljs-built_in">get_handle</span>().<span class="hljs-built_in">stop</span>();<br>&#125;<br><br><span class="hljs-comment">// 向远程客户端回写收到的数据</span><br><br>client_-&gt;<span class="hljs-built_in">write</span>(data, len);<br><br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现父类中的虚函数，客户端流的写成功回调过程</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">write_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现父类中的虚函数，客户端流的超时回调过程</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 必须在此处删除该动态分配的回调类对象以防止内存泄露</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 实现父类中的虚函数，客户端流的超时回调过程</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">timeout_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Timeout ...&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>aio_socket_stream* client_;<br><span class="hljs-type">int</span>   i_;<br>&#125;;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 异步监听流的回调类的子类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">io_accept_callback</span> : <span class="hljs-keyword">public</span> aio_accept_callback<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-built_in">io_accept_callback</span>() &#123;&#125;<br>~<span class="hljs-built_in">io_accept_callback</span>()<br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt;&gt;io_accept_callback over!\n&quot;</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基类虚函数，当有新连接到达后调用此回调过程</span><br><span class="hljs-comment"> * @param client &#123;aio_socket_stream*&#125; 异步客户端流</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回 true 以通知监听流继续监听</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">accept_callback</span><span class="hljs-params">(aio_socket_stream* client)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 创建异步客户端流的回调对象并与该异步流进行绑定</span><br>io_callback* callback = <span class="hljs-keyword">new</span> <span class="hljs-built_in">io_callback</span>(client);<br><br><span class="hljs-comment">// 注册异步流的读回调过程</span><br>client-&gt;<span class="hljs-built_in">add_read_callback</span>(callback);<br><br><span class="hljs-comment">// 注册异步流的写回调过程</span><br>client-&gt;<span class="hljs-built_in">add_write_callback</span>(callback);<br><br><span class="hljs-comment">// 注册异步流的关闭回调过程</span><br>client-&gt;<span class="hljs-built_in">add_close_callback</span>(callback);<br><br><span class="hljs-comment">// 注册异步流的超时回调过程</span><br>client-&gt;<span class="hljs-built_in">add_timeout_callback</span>(callback);<br><br><span class="hljs-comment">// 从异步流读一行数据</span><br>client-&gt;<span class="hljs-built_in">gets</span>(<span class="hljs-number">10</span>, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 初始化ACL库(尤其是在WIN32下一定要调用此函数，在UNIX平台下可不调用)</span><br><span class="hljs-built_in">acl_cpp_init</span>();<br><br><span class="hljs-comment">// 构建异步引擎类对象</span><br><span class="hljs-function">aio_handle <span class="hljs-title">handle</span><span class="hljs-params">(ENGINE_KERNEL)</span></span>;<br><br><span class="hljs-comment">// 创建监听异步流</span><br>aio_listen_stream* sstream = <span class="hljs-keyword">new</span> <span class="hljs-built_in">aio_listen_stream</span>(&amp;handle);<br><span class="hljs-type">const</span> <span class="hljs-type">char</span>* addr = <span class="hljs-string">&quot;127.0.0.1:9001&quot;</span>;<br><br><span class="hljs-comment">// 监听指定的地址</span><br><span class="hljs-keyword">if</span> (sstream-&gt;<span class="hljs-built_in">open</span>(addr) == <span class="hljs-literal">false</span>)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;open &quot;</span> &lt;&lt; addr &lt;&lt; <span class="hljs-string">&quot; error!&quot;</span> &lt;&lt; std::endl;<br>sstream-&gt;<span class="hljs-built_in">close</span>();<br><span class="hljs-comment">// <span class="hljs-doctag">XXX:</span> 为了保证能关闭监听流，应在此处再 check 一下</span><br>handle.<span class="hljs-built_in">check</span>();<br><br><span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建回调类对象，当有新连接到达时自动调用此类对象的回调过程</span><br>io_accept_callback callback;<br>sstream-&gt;<span class="hljs-built_in">add_accept_callback</span>(&amp;callback);<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Listen: &quot;</span> &lt;&lt; addr &lt;&lt; <span class="hljs-string">&quot; ok!&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// 如果返回 false 则表示不再继续，需要退出</span><br><span class="hljs-keyword">if</span> (handle.<span class="hljs-built_in">check</span>() == <span class="hljs-literal">false</span>)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;aio_server stop now ...&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 关闭监听流并释放流对象</span><br>sstream-&gt;<span class="hljs-built_in">close</span>();<br><br><span class="hljs-comment">// <span class="hljs-doctag">XXX:</span> 为了保证能关闭监听流，应在此处再 check 一下</span><br>handle.<span class="hljs-built_in">check</span>();<br><br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>简要说明一下，上面代码的基本思路是：</p><ul><li>创建异步通信框架对象 aio_handle –&gt; 创建异步监听流 aio_listen_stream 并注册回调类对象 io_accept_callback–&gt;进入异步通信框架的事件循环中；</li><li>当接收到客户端连接后，异步框架回调 io_accept_callback 类对象的 accept_callback 接口并将客户端异步流输入–&gt;创建异步流接口类对象，并将该对象注册至客户端异步流对象中;</li><li>当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 –&gt; 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的close_callback –&gt; 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。</li></ul><p>异步监听流的接口类的纯虚函数：virtual bool accept_callback(aio_socket_stream* client)  需要子类实现，子类在该函数中获得客户端连接异步流对象。</p><p>客户端异步流接口类 aio_callback 有四个虚函数：</p><ul><li><code>virtual bool read_callback(char* data, int len)</code>  当客户端异步流读到数据时的回调虚函数；</li><li><code>virtual bool write_callback()</code> 当客户端异步流写数据成功后的回调虚函数；</li><li><code>virtual void close_callback()</code> 当异步流(客户端流或监听流)关闭时的回调虚函数；</li><li><code>virtual bool timeout_callback()</code> 当异步流（客户端流在读写超时或监听流在监听超时）超时时的回调函数虚函数。</li></ul><h3 id="2、异步客户端"><a href="#2、异步客户端" class="headerlink" title="2、异步客户端"></a>2、异步客户端</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;string.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;util.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aio_handle.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;acl_cpp_init.hpp&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;aio_socket_stream.hpp&quot;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> WIN32</span><br><span class="hljs-meta"># <span class="hljs-keyword">ifndef</span> snprintf</span><br><span class="hljs-meta">#  <span class="hljs-keyword">define</span> snprintf _snprintf</span><br><span class="hljs-meta"># <span class="hljs-keyword">endif</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> acl;<br><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span><br>&#123;<br><span class="hljs-type">char</span>  addr[<span class="hljs-number">64</span>];<br>aio_handle* handle;<br><span class="hljs-type">int</span>   connect_timeout;<br><span class="hljs-type">int</span>   read_timeout;<br><span class="hljs-type">int</span>   nopen_limit;<br><span class="hljs-type">int</span>   nopen_total;<br><span class="hljs-type">int</span>   nwrite_limit;<br><span class="hljs-type">int</span>   nwrite_total;<br><span class="hljs-type">int</span>   nread_total;<br><span class="hljs-type">int</span>   id_begin;<br><span class="hljs-type">bool</span>  debug;<br>&#125; IO_CTX;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">connect_server</span><span class="hljs-params">(IO_CTX* ctx, <span class="hljs-type">int</span> id)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 客户端异步连接流回调函数类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">client_io_callback</span> : <span class="hljs-keyword">public</span> aio_open_callback<br>&#123;<br><span class="hljs-keyword">public</span>:<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 构造函数</span><br><span class="hljs-comment"> * @param ctx &#123;IO_CTX*&#125;</span><br><span class="hljs-comment"> * @param client &#123;aio_socket_stream*&#125; 异步连接流</span><br><span class="hljs-comment"> * @param id &#123;int&#125; 本流的ID号</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">client_io_callback</span>(IO_CTX* ctx, aio_socket_stream* client, <span class="hljs-type">int</span> id)<br>: <span class="hljs-built_in">client_</span>(client)<br>, <span class="hljs-built_in">ctx_</span>(ctx)<br>, <span class="hljs-built_in">nwrite_</span>(<span class="hljs-number">0</span>)<br>, <span class="hljs-built_in">id_</span>(id)<br>&#123;<br>&#125;<br><br>~<span class="hljs-built_in">client_io_callback</span>()<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;&gt;&gt;&gt;ID: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class="hljs-string">&quot;, io_callback deleted now!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基类虚函数, 当异步流读到所要求的数据时调用此回调函数</span><br><span class="hljs-comment"> * @param data &#123;char*&#125; 读到的数据地址</span><br><span class="hljs-comment"> * @param len &#123;int｝ 读到的数据长度</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">read_callback</span><span class="hljs-params">(<span class="hljs-type">char</span>* data, <span class="hljs-type">int</span> len)</span></span><br><span class="hljs-function"></span>&#123;<br>(<span class="hljs-type">void</span>) data;<br>(<span class="hljs-type">void</span>) len;<br><br>ctx_-&gt;nread_total++;<br><br><span class="hljs-keyword">if</span> (ctx_-&gt;debug)<br>&#123;<br><span class="hljs-keyword">if</span> (nwrite_ &lt; <span class="hljs-number">10</span>)<br>std::cout &lt;&lt; <span class="hljs-string">&quot;gets(&quot;</span> &lt;&lt; nwrite_ &lt;&lt; <span class="hljs-string">&quot;): &quot;</span> &lt;&lt; data;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nwrite_ % <span class="hljs-number">2000</span> == <span class="hljs-number">0</span>)<br>std::cout &lt;&lt; <span class="hljs-string">&quot;&gt;&gt;ID: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class="hljs-string">&quot;, I: &quot;</span><br>&lt;&lt; nwrite_ &lt;&lt; <span class="hljs-string">&quot;; &quot;</span>&lt;&lt;  data;<br>&#125;<br><br><span class="hljs-comment">// 如果收到服务器的退出消息，则也应退出</span><br><span class="hljs-keyword">if</span> (acl::<span class="hljs-built_in">strncasecmp_</span>(data, <span class="hljs-string">&quot;quit&quot;</span>, <span class="hljs-number">4</span>) == <span class="hljs-number">0</span>)<br>&#123;<br><span class="hljs-comment">// 向服务器发送数据</span><br>client_-&gt;format(<span class="hljs-string">&quot;Bye!\r\n&quot;</span>);<br><span class="hljs-comment">// 关闭异步流连接</span><br>client_-&gt;<span class="hljs-built_in">close</span>();<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (nwrite_ &gt;= ctx_-&gt;nwrite_limit)<br>&#123;<br><span class="hljs-keyword">if</span> (ctx_-&gt;debug)<br>std::cout &lt;&lt; <span class="hljs-string">&quot;ID: &quot;</span> &lt;&lt; id_<br>&lt;&lt; <span class="hljs-string">&quot;, nwrite: &quot;</span> &lt;&lt; nwrite_<br>&lt;&lt; <span class="hljs-string">&quot;, nwrite_limit: &quot;</span> &lt;&lt; ctx_-&gt;nwrite_limit<br>&lt;&lt; <span class="hljs-string">&quot;, quiting ...&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-comment">// 向服务器发送退出消息</span><br>client_-&gt;format(<span class="hljs-string">&quot;quit\r\n&quot;</span>);<br>client_-&gt;<span class="hljs-built_in">close</span>();<br>&#125;<br><span class="hljs-keyword">else</span><br>&#123;<br><span class="hljs-type">char</span>  buf[<span class="hljs-number">256</span>];<br><span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;hello world: %d\n&quot;</span>, nwrite_);<br>client_-&gt;<span class="hljs-built_in">write</span>(buf, (<span class="hljs-type">int</span>) <span class="hljs-built_in">strlen</span>(buf));<br><br><span class="hljs-comment">// 向服务器发送数据</span><br><span class="hljs-comment">//client_-&gt;format(&quot;hello world: %d\n&quot;, nwrite_);</span><br>&#125;<br><br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基类虚函数, 当异步流写成功时调用此回调函数</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">write_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>ctx_-&gt;nwrite_total++;<br>nwrite_++;<br><br><span class="hljs-comment">// 从服务器读一行数据</span><br>client_-&gt;<span class="hljs-built_in">gets</span>(ctx_-&gt;read_timeout, <span class="hljs-literal">false</span>);<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基类虚函数, 当该异步流关闭时调用此回调函数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">close_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-keyword">if</span> (client_-&gt;<span class="hljs-built_in">is_opened</span>() == <span class="hljs-literal">false</span>)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Id: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class="hljs-string">&quot; connect &quot;</span><br>&lt;&lt; ctx_-&gt;addr &lt;&lt; <span class="hljs-string">&quot; error: &quot;</span><br>&lt;&lt; acl::<span class="hljs-built_in">last_serror</span>();<br><br><span class="hljs-comment">// 如果是第一次连接就失败，则退出</span><br><span class="hljs-keyword">if</span> (ctx_-&gt;nopen_total == <span class="hljs-number">0</span>)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;, first connect error, quit&quot;</span>;<br><span class="hljs-comment">/* 获得异步引擎句柄，并设置为退出状态 */</span><br>client_-&gt;<span class="hljs-built_in">get_handle</span>().<span class="hljs-built_in">stop</span>();<br>&#125;<br>std::cout &lt;&lt; std::endl;<br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* 获得异步引擎中受监控的异步流个数 */</span><br><span class="hljs-type">int</span> nleft = client_-&gt;<span class="hljs-built_in">get_handle</span>().<span class="hljs-built_in">length</span>();<br><span class="hljs-keyword">if</span> (ctx_-&gt;nopen_total == ctx_-&gt;nopen_limit &amp;&amp; nleft == <span class="hljs-number">1</span>)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Id: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class="hljs-string">&quot; stop now! nstream: &quot;</span><br>&lt;&lt; nleft &lt;&lt; std::endl;<br><span class="hljs-comment">/* 获得异步引擎句柄，并设置为退出状态 */</span><br>client_-&gt;<span class="hljs-built_in">get_handle</span>().<span class="hljs-built_in">stop</span>();<br>&#125;<br><br><span class="hljs-comment">// 必须在此处删除该动态分配的回调类对象以防止内存泄露</span><br><span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基类虚函数，当异步流超时时调用此函数</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">timeout_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;Connect &quot;</span> &lt;&lt; ctx_-&gt;addr &lt;&lt; <span class="hljs-string">&quot; Timeout ...&quot;</span> &lt;&lt; std::endl;<br>client_-&gt;<span class="hljs-built_in">close</span>();<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基类虚函数, 当异步连接成功后调用此函数</span><br><span class="hljs-comment"> * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">bool</span> <span class="hljs-title">open_callback</span><span class="hljs-params">()</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 连接成功，设置IO读写回调函数</span><br>client_-&gt;<span class="hljs-built_in">add_read_callback</span>(<span class="hljs-keyword">this</span>);<br>client_-&gt;<span class="hljs-built_in">add_write_callback</span>(<span class="hljs-keyword">this</span>);<br>ctx_-&gt;nopen_total++;<br><br>acl::<span class="hljs-built_in">assert_</span>(id_ &gt; <span class="hljs-number">0</span>);<br><span class="hljs-keyword">if</span> (ctx_-&gt;nopen_total &lt; ctx_-&gt;nopen_limit)<br>&#123;<br><span class="hljs-comment">// 开始进行下一个连接过程</span><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect_server</span>(ctx_, id_ + <span class="hljs-number">1</span>) == <span class="hljs-literal">false</span>)<br>std::cout &lt;&lt; <span class="hljs-string">&quot;connect error!&quot;</span> &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-comment">// 异步向服务器发送数据</span><br><span class="hljs-comment">//client_-&gt;format(&quot;hello world: %d\n&quot;, nwrite_);</span><br><span class="hljs-type">char</span>  buf[<span class="hljs-number">256</span>];<br><span class="hljs-built_in">snprintf</span>(buf, <span class="hljs-built_in">sizeof</span>(buf), <span class="hljs-string">&quot;hello world: %d\n&quot;</span>, nwrite_);<br>client_-&gt;<span class="hljs-built_in">write</span>(buf, (<span class="hljs-type">int</span>) <span class="hljs-built_in">strlen</span>(buf));<br><br><span class="hljs-comment">// 异步从服务器读取一行数据</span><br>client_-&gt;<span class="hljs-built_in">gets</span>(ctx_-&gt;read_timeout, <span class="hljs-literal">false</span>);<br><br><span class="hljs-comment">// 表示继续异步过程</span><br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-keyword">private</span>:<br>aio_socket_stream* client_;<br>IO_CTX* ctx_;<br><span class="hljs-type">int</span>   nwrite_;<br><span class="hljs-type">int</span>   id_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">bool</span> <span class="hljs-title">connect_server</span><span class="hljs-params">(IO_CTX* ctx, <span class="hljs-type">int</span> id)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">// 开始异步连接远程服务器</span><br>aio_socket_stream* stream = aio_socket_stream::<span class="hljs-built_in">open</span>(ctx-&gt;handle,<br>ctx-&gt;addr, ctx-&gt;connect_timeout);<br><span class="hljs-keyword">if</span> (stream == <span class="hljs-literal">NULL</span>)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;connect &quot;</span> &lt;&lt; ctx-&gt;addr &lt;&lt; <span class="hljs-string">&quot; error!&quot;</span> &lt;&lt; std::endl;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;stoping ...&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-keyword">if</span> (id == <span class="hljs-number">0</span>)<br>ctx-&gt;handle-&gt;<span class="hljs-built_in">stop</span>();<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">false</span>);<br>&#125;<br><br><span class="hljs-comment">// 创建连接后的回调函数类</span><br>client_io_callback* callback = <span class="hljs-keyword">new</span> <span class="hljs-built_in">client_io_callback</span>(ctx, stream, id);<br><br><span class="hljs-comment">// 添加连接成功的回调函数类</span><br>stream-&gt;<span class="hljs-built_in">add_open_callback</span>(callback);<br><br><span class="hljs-comment">// 添加连接失败后回调函数类</span><br>stream-&gt;<span class="hljs-built_in">add_close_callback</span>(callback);<br><br><span class="hljs-comment">// 添加连接超时的回调函数类</span><br>stream-&gt;<span class="hljs-built_in">add_timeout_callback</span>(callback);<br><span class="hljs-keyword">return</span> (<span class="hljs-literal">true</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>* argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">bool</span> use_kernel = <span class="hljs-literal">false</span>;<br><span class="hljs-type">int</span>   ch;<br>IO_CTX ctx;<br><br><span class="hljs-built_in">memset</span>(&amp;ctx, <span class="hljs-number">0</span>, <span class="hljs-built_in">sizeof</span>(ctx));<br>ctx.connect_timeout = <span class="hljs-number">5</span>;<br>ctx.nopen_limit = <span class="hljs-number">10</span>;<br>ctx.id_begin = <span class="hljs-number">1</span>;<br>ctx.nwrite_limit = <span class="hljs-number">10</span>;<br>ctx.debug = <span class="hljs-literal">false</span>;<br><span class="hljs-built_in">snprintf</span>(ctx.addr, <span class="hljs-built_in">sizeof</span>(ctx.addr), <span class="hljs-string">&quot;127.0.0.1:9001&quot;</span>);<br><br><span class="hljs-built_in">acl_cpp_init</span>();<br><br><span class="hljs-function">aio_handle <span class="hljs-title">handle</span><span class="hljs-params">(ENGINE_KERNEL)</span></span>;<br>ctx.handle = &amp;handle;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">connect_server</span>(&amp;ctx, ctx.id_begin) == <span class="hljs-literal">false</span>)<br>&#123;<br>std::cout &lt;&lt; <span class="hljs-string">&quot;enter any key to exit.&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-built_in">getchar</span>();<br><span class="hljs-keyword">return</span> (<span class="hljs-number">1</span>);<br>&#125;<br><br>std::cout &lt;&lt; <span class="hljs-string">&quot;Connect &quot;</span> &lt;&lt; ctx.addr &lt;&lt; <span class="hljs-string">&quot; ...&quot;</span> &lt;&lt; std::endl;<br><br><span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>)<br>&#123;<br><span class="hljs-comment">// 如果返回 false 则表示不再继续，需要退出</span><br><span class="hljs-keyword">if</span> (handle.<span class="hljs-built_in">check</span>() == <span class="hljs-literal">false</span>)<br><span class="hljs-keyword">break</span>;<br>&#125;<br><br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>异步客户端的基本流程为：</p><ul><li>创建异步框架对象 aio_handle –&gt; 异步连接远程服务器，创建连接成功&#x2F;失败&#x2F;超时的异步接口类对象并注册至异步连接流中 –&gt; 异步框架进行事件循环中；</li><li>连接成功后，异步接口类对象中的 open_callback 被调用，启动下一个异步连接过程（未达限制连接数前） –&gt; 添加异步读及异步写的回调接口类  –&gt; 异步写入数据，同时开始异步读数据过程；</li><li>当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 –&gt; 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的 close_callback –&gt; 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。</li></ul><p>客户端异步连接流的接口类 aio_open_callback 的纯虚函数 virtual bool open_callback() 需要子类实现，在连接服务器成功后调用此函数，允许子类在该函数中做进一步操作，如：注册客户端流的异步读回调接口类对象及异步写回调类对象；如果连接超时或连接失败而导致的关闭，则基础接口类中的 timeout_callback() 或 close_callback() 将会被调用，以通知用户应用程序。</p><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>以上的示例演示了基本的非阻塞异步流的监听、读写、连接等过程，类的设计中也提供了基本的操作方法，为了应对实践中的多样性及复杂性，acl_cpp 的异步流还设计了更多的接口和方法，如：延迟读写操作（这对于限流的服务器比较有用处）、定时器操作等。</p><p>更多例子参见：lib_acl_cpp&#x2F;samples&#x2F;aio&#x2F; 目录<br>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>非阻塞编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl 较为底层的 HTTP 协议库写 HTTP 下载客户端举例</title>
    <link href="/2010/01/13/http_dowload2/"/>
    <url>/2010/01/13/http_dowload2/</url>
    
    <content type="html"><![CDATA[<p>在《使用 acl 库开发一个 HTTP 下载客户端》文章中介绍利用ACL库中的 HTTP 高级API函数编写HTTP下载客户端的简单的例子，本文介绍一下如何使用稍微底层的API来编写同样功能的例子。在这个例子中，可以看到那些高级API是如何封装底层API的。</p><p>请先看一个例子如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_protocol.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">get_url</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *method, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *url,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *proxy, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dump)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 创建 HTTP 请求头 */</span><br>HTTP_HDR_REQ *hdr_req = <span class="hljs-built_in">http_hdr_req_create</span>(url, method, <span class="hljs-string">&quot;HTTP/1.1&quot;</span>);<br>ACL_VSTREAM *stream;  <span class="hljs-comment">/* 网络连接流 */</span><br>ACL_VSTRING *buf = <span class="hljs-built_in">acl_vstring_alloc</span>(<span class="hljs-number">256</span>);  <span class="hljs-comment">/* 分配内存缓冲区 */</span><br>HTTP_HDR_RES *hdr_res;  <span class="hljs-comment">/* HTTP 响应头 */</span><br>HTTP_RES *res;  <span class="hljs-comment">/* HTTP响应体 */</span><br>ACL_FILE *fp = <span class="hljs-literal">NULL</span>;  <span class="hljs-comment">/* 转储文件句柄 */</span><br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *ptr;<br><span class="hljs-type">int</span>   ret;<br><br><span class="hljs-comment">/* 输出 HTTP 请求头内容 */</span><br><br><span class="hljs-built_in">http_hdr_print</span>(&amp;hdr_req-&gt;hdr, <span class="hljs-string">&quot;---request hdr---&quot;</span>);<br><br><span class="hljs-comment">/* 如果设定代理服务器，则连接代理服务器地址，</span><br><span class="hljs-comment"> * 否则使用 HTTP 请求头里指定的地址</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> (*proxy)<br><span class="hljs-built_in">acl_vstring_strcpy</span>(buf, proxy);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">acl_vstring_strcpy</span>(buf, <span class="hljs-built_in">http_hdr_req_host</span>(hdr_req));<br><br><span class="hljs-comment">/* 获得远程 HTTP 服务器的连接地址 */</span><br><br>ptr = <span class="hljs-built_in">acl_vstring_memchr</span>(buf, <span class="hljs-string">&#x27;:&#x27;</span>);<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">acl_vstring_strcat</span>(buf, <span class="hljs-string">&quot;:80&quot;</span>);<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-type">int</span>   port;<br>ptr++;<br>port = <span class="hljs-built_in">atoi</span>(ptr);<br><span class="hljs-keyword">if</span> (port &lt;= <span class="hljs-number">0</span> || port &gt;= <span class="hljs-number">65535</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;http server&#x27;s addr(%s) invalid\n&quot;</span>, <span class="hljs-built_in">acl_vstring_str</span>(buf));<br><span class="hljs-built_in">acl_vstring_free</span>(buf);<br><span class="hljs-built_in">http_hdr_req_free</span>(hdr_req);<br><span class="hljs-keyword">return</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-comment">/* 连接远程 http 服务器 */</span><br><br>stream = <span class="hljs-built_in">acl_vstream_connect</span>(<span class="hljs-built_in">acl_vstring_str</span>(buf) <span class="hljs-comment">/* 服务器地址 */</span>,<br>ACL_BLOCKING <span class="hljs-comment">/* 采用阻塞方式 */</span>,<br><span class="hljs-number">10</span> <span class="hljs-comment">/* 连接超时时间为 10 秒 */</span>,<br><span class="hljs-number">10</span> <span class="hljs-comment">/* 网络 IO 操作超时时间为 10 秒 */</span>,<br><span class="hljs-number">4096</span> <span class="hljs-comment">/* stream 流缓冲区大小为 4096 字节 */</span>);<br><span class="hljs-keyword">if</span> (stream == <span class="hljs-literal">NULL</span>) &#123;<br><span class="hljs-comment">/* 连接服务器失败 */</span><br><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;connect addr(%s) error(%s)\n&quot;</span>,<br><span class="hljs-built_in">acl_vstring_str</span>(buf), <span class="hljs-built_in">acl_last_serror</span>());<br><span class="hljs-built_in">acl_vstring_free</span>(buf);<br><span class="hljs-built_in">http_hdr_req_free</span>(hdr_req);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* 构建 HTTP 请求头数据 */</span><br><br><span class="hljs-built_in">http_hdr_build_request</span>(hdr_req, buf);<br><br><span class="hljs-comment">/* 向 HTTP 服务器发送请求 */</span><br><br>ret = <span class="hljs-built_in">acl_vstream_writen</span>(stream, <span class="hljs-built_in">acl_vstring_str</span>(buf), <span class="hljs-built_in">ACL_VSTRING_LEN</span>(buf));<br><span class="hljs-keyword">if</span> (ret == ACL_VSTREAM_EOF) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write to server error(%s)\n&quot;</span>, <span class="hljs-built_in">acl_last_serror</span>());<br><span class="hljs-built_in">acl_vstream_close</span>(stream);<br><span class="hljs-built_in">acl_vstring_free</span>(buf);<br><span class="hljs-built_in">http_hdr_req_free</span>(hdr_req);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* 创建一个 HTTP 响应头对象 */</span><br><br>hdr_res = <span class="hljs-built_in">http_hdr_res_new</span>();<br><br><span class="hljs-comment">/* 读取 HTTP 服务器响应头*/</span><br><br>ret = <span class="hljs-built_in">http_hdr_res_get_sync</span>(hdr_res, stream, <span class="hljs-number">10</span> <span class="hljs-comment">/* IO 超时时间为 10 秒 */</span>);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get http reply header error(%s)\n&quot;</span>, <span class="hljs-built_in">acl_last_serror</span>());<br><span class="hljs-built_in">http_hdr_res_free</span>(hdr_res);<br><span class="hljs-built_in">acl_vstream_close</span>(stream);<br><span class="hljs-built_in">acl_vstring_free</span>(buf);<br><span class="hljs-built_in">http_hdr_req_free</span>(hdr_req);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* 分析HTTP服务器响应头 */</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">http_hdr_res_parse</span>(hdr_res) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;parse http reply header error\n&quot;</span>);<br><span class="hljs-built_in">http_hdr_print</span>(&amp;hdr_res-&gt;hdr, <span class="hljs-string">&quot;--- reply http header ---&quot;</span>);<br><span class="hljs-built_in">http_hdr_res_free</span>(hdr_res);<br><span class="hljs-built_in">acl_vstream_close</span>(stream);<br><span class="hljs-built_in">acl_vstring_free</span>(buf);<br><span class="hljs-built_in">http_hdr_req_free</span>(hdr_req);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* 如果需要转储至磁盘则需要先打开文件 */</span><br><br><span class="hljs-keyword">if</span> (dump != <span class="hljs-literal">NULL</span>) &#123;<br>fp = <span class="hljs-built_in">acl_fopen</span>(dump, <span class="hljs-string">&quot;w+&quot;</span>);<br><span class="hljs-keyword">if</span> (fp == <span class="hljs-literal">NULL</span>)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open file(%s) error(%s)\n&quot;</span>,<br>dump, <span class="hljs-built_in">acl_last_serror</span>());<br>&#125;<br><br><span class="hljs-comment">/* 如果 HTTP 响应没有数据体则仅输出 HTTP 响应头即可 */</span><br><br><span class="hljs-keyword">if</span> (hdr_res-&gt;hdr.content_length == <span class="hljs-number">0</span><br>|| (hdr_res-&gt;hdr.content_length == <span class="hljs-number">-1</span><br>&amp;&amp; !hdr_res-&gt;hdr.chunked<br>&amp;&amp; hdr_res-&gt;reply_status &gt; <span class="hljs-number">300</span><br>&amp;&amp; hdr_res-&gt;reply_status &lt; <span class="hljs-number">400</span>))<br>&#123;<br><span class="hljs-keyword">if</span> (fp)<br><span class="hljs-built_in">http_hdr_fprint</span>(<span class="hljs-built_in">ACL_FSTREAM</span>(fp), &amp;hdr_res-&gt;hdr,<br><span class="hljs-string">&quot;--- reply http header ---&quot;</span>);<br><span class="hljs-keyword">else</span><br><span class="hljs-built_in">http_hdr_fprint</span>(ACL_VSTREAM_OUT, &amp;hdr_res-&gt;hdr,<br><span class="hljs-string">&quot;--- reply http header ---&quot;</span>);<br><span class="hljs-built_in">http_hdr_res_free</span>(hdr_res);<br><span class="hljs-built_in">acl_vstream_close</span>(stream);<br><span class="hljs-built_in">acl_vstring_free</span>(buf);<br><span class="hljs-built_in">http_hdr_req_free</span>(hdr_req);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* 输出 HTTP 响应头 */</span><br><br><span class="hljs-built_in">http_hdr_print</span>(&amp;hdr_res-&gt;hdr, <span class="hljs-string">&quot;--- reply http header ---&quot;</span>);<br><br><span class="hljs-comment">/* 创建 HTTP 响应体对象 */</span><br><br>res = <span class="hljs-built_in">http_res_new</span>(hdr_res);<br><br><span class="hljs-comment">/* 如果有数据体则开始读取 HTTP 响应数据体部分 */</span><br><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">http_off_t</span>  n;<br><span class="hljs-type">char</span>  buf2[<span class="hljs-number">4096</span>];<br><br><span class="hljs-comment">/* 以同步方式读取HTTP响应数据 */</span><br><br>n = <span class="hljs-built_in">http_res_body_get_sync</span>(res, stream, buf2, <span class="hljs-built_in">sizeof</span>(buf2) - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><br><span class="hljs-keyword">if</span> (fp) &#123;<br><span class="hljs-comment">/* 转储至文件中 */</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">acl_fwrite</span>(buf2, (<span class="hljs-type">size_t</span>) n, <span class="hljs-number">1</span>, fp) == (<span class="hljs-type">size_t</span>) EOF) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;write to dump file(%s) error(%s)\n&quot;</span>,<br>dump, <span class="hljs-built_in">acl_last_serror</span>());<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>buf2[n] = <span class="hljs-number">0</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf2);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (fp)<br><span class="hljs-built_in">acl_fclose</span>(fp);  <span class="hljs-comment">/* 关闭转储文件句柄 */</span><br><span class="hljs-built_in">http_res_free</span>(res);  <span class="hljs-comment">/* 释放 HTTP 响应对象, hdr_res 会在此函数内部自动被释放 */</span><br><span class="hljs-built_in">acl_vstream_close</span>(stream);  <span class="hljs-comment">/* 关闭网络流 */</span><br><span class="hljs-built_in">acl_vstring_free</span>(buf);  <span class="hljs-comment">/* 释放内存区 */</span><br><span class="hljs-built_in">http_hdr_req_free</span>(hdr_req);  <span class="hljs-comment">/* 释放 HTTP 请求头对象 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *procname)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s -h[help] -t method -r url -f dump_file -X proxy_addr\n&quot;</span><br><span class="hljs-string">&quot;example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\n&quot;</span>,<br>procname, procname);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>   ch;<br><span class="hljs-type">char</span>  url[<span class="hljs-number">256</span>], dump[<span class="hljs-number">256</span>], proxy[<span class="hljs-number">256</span>], method[<span class="hljs-number">32</span>];<br><br><span class="hljs-built_in">acl_init</span>();  <span class="hljs-comment">/* 初始化 acl 库 */</span><br><br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(method, <span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-built_in">sizeof</span>(method));<br>url[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dump[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>proxy[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((ch = <span class="hljs-built_in">getopt</span>(argc, argv, <span class="hljs-string">&quot;hr:t:f:X:&quot;</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">switch</span> (ch) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br><span class="hljs-built_in">usage</span>(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(url, optarg, <span class="hljs-built_in">sizeof</span>(url));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(method, optarg, <span class="hljs-built_in">sizeof</span>(method));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(dump, optarg, <span class="hljs-built_in">sizeof</span>(dump));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:<br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(proxy, optarg, <span class="hljs-built_in">sizeof</span>(proxy));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (url[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">usage</span>(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-built_in">get_url</span>(method, url, proxy, dump);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>可以明显地看出，该例子的实现代码量要比 使用 acl 库开发一个 HTTP 下载客户端 麻烦许多，但它却比较清晰地展示了 HTTP 协议的请求与响应过程。该例子可以在 acl_project&#x2F;samples&#x2F;http&#x2F;get_url1&#x2F; 目录下找到。</p>]]></content>
    
    
    <categories>
      
      <category>http开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 acl 库开发一个 HTTP 下载客户端</title>
    <link href="/2010/01/11/http_dowload/"/>
    <url>/2010/01/11/http_dowload/</url>
    
    <content type="html"><![CDATA[<p>在 acl 的协议库(lib_protocol) 中有专门针对 HTTP 协议和 ICMP 协议的，本文主要介绍如何使用 lib_protocol 协议库来开发一个简单的 http 客户端。下面首先介绍一下几个本文用到的函数接口。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个 HTTP_UTIL 请求对象</span><br><span class="hljs-comment"> * @param url &#123;const char*&#125; 完整的请求 url</span><br><span class="hljs-comment"> * @param method &#123;const char*&#125; 请求方法，有效的请求方法有：GET, POST, HEAD, CONNECT</span><br><span class="hljs-comment"> * @return &#123;HTTP_UTIL*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">HTTP_API HTTP_UTIL *<span class="hljs-title">http_util_req_new</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *url, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *method)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 HTTP 代理服务器地址</span><br><span class="hljs-comment"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class="hljs-comment"> * @param proxy &#123;const char*&#125; 代理服务器地址，有效格式为: IP:PORT, DOMAIN:PORT,</span><br><span class="hljs-comment"> *  如: 192.168.0.1:80, 192.168.0.2:8088, www.g.cn:80</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">HTTP_API <span class="hljs-type">void</span> <span class="hljs-title">http_util_set_req_proxy</span><span class="hljs-params">(HTTP_UTIL *http_util, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *proxy)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置 HTTP 响应体的转储文件，设置后 HTTP 响应体数据便会转储于该文件</span><br><span class="hljs-comment"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class="hljs-comment"> * @param filename &#123;const char*&#125; 转储文件名</span><br><span class="hljs-comment"> * @return &#123;int&#125; 如果返回值 &lt; 0 则表示无法打开该文件, 否则表示打开文件成功</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">HTTP_API <span class="hljs-type">int</span> <span class="hljs-title">http_util_set_dump_file</span><span class="hljs-params">(HTTP_UTIL *http_util, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *filename)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 打开远程 HTTP 服务器或代理服务器连接，同时构建 HTTP 请求头数据并且将该数据</span><br><span class="hljs-comment"> * 发给新建立的网络连接</span><br><span class="hljs-comment"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class="hljs-comment"> * @return &#123;int&#125; 0: 成功; -1: 无法打开连接或发送请求头数据失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">HTTP_API <span class="hljs-type">int</span> <span class="hljs-title">http_util_req_open</span><span class="hljs-params">(HTTP_UTIL *http_util)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 发送完请求数据后调用此函数从 HTTP 服务器读取完整的 HTTP 响应头</span><br><span class="hljs-comment"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class="hljs-comment"> * @return &#123;int&#125; 0: 成功; -1: 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">HTTP_API <span class="hljs-type">int</span> <span class="hljs-title">http_util_get_res_hdr</span><span class="hljs-params">(HTTP_UTIL *http_util)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 读完 HTTP 响应头后调用此函数从 HTTP 服务器读取 HTTP 数据体数据，需要连续调用</span><br><span class="hljs-comment"> * 此函数，直至返回值 &lt;= 0, 如果之前设置了转储文件或转储则在读取数据过程中同时会</span><br><span class="hljs-comment"> * 拷贝一份数据给转储文件或转储流</span><br><span class="hljs-comment"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class="hljs-comment"> * @param buf &#123;char *&#125; 存储 HTTP 响应体的缓冲区</span><br><span class="hljs-comment"> * @param size &#123;size_t&#125; buf 的空间大小</span><br><span class="hljs-comment"> * @return &#123;int&#125; &lt;= 0: 表示读结束; &gt; 0: 表示本次读到的数据长度</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">HTTP_API <span class="hljs-type">int</span> <span class="hljs-title">http_util_get_res_body</span><span class="hljs-params">(HTTP_UTIL *http_util, <span class="hljs-type">char</span> *buf, <span class="hljs-type">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure><p>以上仅是 lib_http_util.h 函数接口中的一部分，下面就写一个简单的例子：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_protocol.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">get_url</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *method, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *url,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-type">const</span> <span class="hljs-type">char</span> *proxy, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dump, <span class="hljs-type">int</span> out)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-comment">/* 创建 HTTP_UTIL 请求对象 */</span><br>HTTP_UTIL *http = <span class="hljs-built_in">http_util_req_new</span>(url, method);<br><span class="hljs-type">int</span>   ret;<br><br><span class="hljs-comment">/* 如果设定代理服务器，则连接代理服务器地址，</span><br><span class="hljs-comment"> * 否则使用 HTTP 请求头里指定的地址</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">if</span> (proxy &amp;&amp; *proxy)<br><span class="hljs-built_in">http_util_set_req_proxy</span>(http, proxy);<br><br><span class="hljs-comment">/* 设置转储文件 */</span><br><span class="hljs-keyword">if</span> (dump &amp;&amp; *dump)<br><span class="hljs-built_in">http_util_set_dump_file</span>(http, dump);<br><br><span class="hljs-comment">/* 输出 HTTP 请求头内容 */</span><br><br><span class="hljs-built_in">http_hdr_print</span>(&amp;http-&gt;hdr_req-&gt;hdr, <span class="hljs-string">&quot;---request hdr---&quot;</span>);<br><br><span class="hljs-comment">/* 连接远程 http 服务器 */</span><br><br><span class="hljs-keyword">if</span> (<span class="hljs-built_in">http_util_req_open</span>(http) &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;open connection(%s) error\n&quot;</span>, http-&gt;server_addr);<br><span class="hljs-built_in">http_util_free</span>(http);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* 读取 HTTP 服务器响应头*/</span><br><br>ret = <span class="hljs-built_in">http_util_get_res_hdr</span>(http);<br><span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;get reply http header error\n&quot;</span>);<br><span class="hljs-built_in">http_util_free</span>(http);<br><span class="hljs-keyword">return</span>;<br>&#125;<br><br><span class="hljs-comment">/* 输出 HTTP 响应头 */</span><br><br><span class="hljs-built_in">http_hdr_print</span>(&amp;http-&gt;hdr_res-&gt;hdr, <span class="hljs-string">&quot;--- reply http header ---&quot;</span>);<br><br><span class="hljs-comment">/* 如果有数据体则开始读取 HTTP 响应数据体部分 */</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">char</span>  buf[<span class="hljs-number">4096</span>];<br><br>ret = <span class="hljs-built_in">http_util_get_res_body</span>(http, buf, <span class="hljs-built_in">sizeof</span>(buf) - <span class="hljs-number">1</span>);<br><span class="hljs-keyword">if</span> (ret &lt;= <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br>buf[ret] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">if</span> (out)<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s&quot;</span>, buf);<br>&#125;<br><span class="hljs-built_in">http_util_free</span>(http);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">usage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *procname)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s -h[help] -t method -r url -f dump_file -o[output] -X proxy_addr\n&quot;</span><br><span class="hljs-string">&quot;example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\n&quot;</span>,<br>procname, procname);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">int</span>   ch, out = <span class="hljs-number">0</span>;<br><span class="hljs-type">char</span>  url[<span class="hljs-number">256</span>], dump[<span class="hljs-number">256</span>], proxy[<span class="hljs-number">256</span>], method[<span class="hljs-number">32</span>];<br><br><span class="hljs-built_in">acl_init</span>();  <span class="hljs-comment">/* 初始化 acl 库 */</span><br><br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(method, <span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-built_in">sizeof</span>(method));<br>url[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>dump[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>proxy[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> ((ch = <span class="hljs-built_in">getopt</span>(argc, argv, <span class="hljs-string">&quot;hor:t:f:X:&quot;</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">switch</span> (ch) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br><span class="hljs-built_in">usage</span>(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;o&#x27;</span>:<br>out = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;r&#x27;</span>:<br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(url, optarg, <span class="hljs-built_in">sizeof</span>(url));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;t&#x27;</span>:<br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(method, optarg, <span class="hljs-built_in">sizeof</span>(method));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(dump, optarg, <span class="hljs-built_in">sizeof</span>(dump));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;X&#x27;</span>:<br><span class="hljs-built_in">ACL_SAFE_STRNCPY</span>(proxy, optarg, <span class="hljs-built_in">sizeof</span>(proxy));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">default</span>:<br><span class="hljs-keyword">break</span>;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (url[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">usage</span>(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-built_in">get_url</span>(method, url, proxy, dump, out);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译成功后，运行 .&#x2F;url_get -h 会给出如下提示：</p><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">usage: ./url_get -h[help] -t <span class="hljs-keyword">method</span> -<span class="hljs-title function_">r</span> <span class="hljs-title function_">url</span> -<span class="hljs-title function_">f</span> <span class="hljs-title function_">dump_file</span> -<span class="hljs-title function_">o</span>[<span class="hljs-title function_">output</span>] -<span class="hljs-title function_">X</span> <span class="hljs-title function_">proxy_addr</span><br><span class="hljs-title function_">example</span>: ./url_get -t GET -r http:<span class="hljs-comment">//www.sina.com.cn/ -f url_dump.txt</span><br></code></pre></td></tr></table></figure><p>输入: .&#x2F;url_get -t GET -r <a href="http://www.sina.com/">http://www.sina.com</a> -o， 该命令是获取 <a href="http://www.sina.com/">www.sina.com</a> 页面并输出至标准输出，得到的结果为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml">HTTP/1.0 301 Moved Permanently<br>Date: Tue, 12 Jan 2010 01:54:39 GMT<br>Server: Apache<br>Location: http://www.sina.com.cn/<br>Cache-Control: max-age=3600<br>Expires: Tue, 12 Jan 2010 02:54:39 GMT<br>Vary: Accept-Encoding<br>Content-Length: 231<br>Content-Type: text/html; charset=iso-8859-1<br>Age: 265<br>X-Cache: HIT from tj175-135.sina.com.cn<br>Connection: close<br>--------------- end -----------------<br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">HTML</span> <span class="hljs-keyword">PUBLIC</span> <span class="hljs-string">&quot;-//IETF//DTD HTML 2.0//EN&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>301 Moved Permanently<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Moved Permanently<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>The document has moved <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;http://www.sina.com.cn/&quot;</span>&gt;</span>here<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>.<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>如果想把页面转存至文件中，可以输入：.&#x2F;url_get -t GET -r <a href="http://www.sina.com/">http://www.sina.com</a> -f dump.txt, 这样就会把新浪的首页下载并存储于 dump.txt 文件中。</p><p>这个例子非常简单，其实如果查看 http_util.c 源码，会看到这个文件是对 lib_http.h 里一些更为底层 API 的封装。</p><p>如果仅是下载一个页面至某个文件中，其实还有更为简单的方法，只需要调用接口：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 将某个 url 的响应体数据转储至某个文件中</span><br><span class="hljs-comment"> * @param url &#123;const char*&#125; 完整请求 url, 如: http://www.g.cn</span><br><span class="hljs-comment"> * @param dump &#123;const char*&#125; 转储文件名</span><br><span class="hljs-comment"> * @param &#123;int&#125; 读到的响应体数据长度, &gt;=0: 表示成功, -1: 表示失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">HTTP_API <span class="hljs-type">int</span> <span class="hljs-title">http_util_dump_url</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *url, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *dump)</span></span>;<br></code></pre></td></tr></table></figure><p>这一个函数便可以达到与上一个例子相同的效果。</p>]]></content>
    
    
    <categories>
      
      <category>http开发</category>
      
    </categories>
    
    
    <tags>
      
      <tag>http</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>配置文件的读取</title>
    <link href="/2009/11/03/configure/"/>
    <url>/2009/11/03/configure/</url>
    
    <content type="html"><![CDATA[<p>配置文件的读取是程序中必要部分，虽然不算复杂，但如果每次都写配置文件的分析提取代码也是件烦人的事。现在流行的配置文件格式有：ini，xml ，简单name-value对等格式，ACL库中实现了最简单的 name-value对格式的配置文件，该文件格式有点类似于 xinetd.conf 的格式，文件格式如下：</p><p>test.cf:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">service myapp &#123;<br><br>    my_addr = <span class="hljs-number">127.0</span>.<span class="hljs-number">0.1</span><br><br>    my_port = <span class="hljs-number">80</span><br><br>    my_list = www<span class="hljs-selector-class">.test1</span><span class="hljs-selector-class">.com</span>, www<span class="hljs-selector-class">.test2</span><span class="hljs-selector-class">.com</span>, www<span class="hljs-selector-class">.test3</span><span class="hljs-selector-class">.com</span>, \<br><br>                   www<span class="hljs-selector-class">.test4</span><span class="hljs-selector-class">.com</span>, www<span class="hljs-selector-class">.test5</span><span class="hljs-selector-class">.com</span>, www<span class="hljs-selector-class">.test6</span><span class="hljs-selector-class">.com</span><br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure><p>其中的 “&quot;  是连接符，可以把折行的数据连接起来。</p><p>下面的例子读取该配置文件并进行解析：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">static</span> <span class="hljs-type">int</span> var_cfg_my_port;<br><br><span class="hljs-type">static</span> ACL_CFG_INT_TABLE __conf_int_tab[] = &#123;<br>  <span class="hljs-comment">/* 配置项名称, 配置项缺省值, 存储配置项值的地址, 保留字, 保留字 */</span><br>  &#123; <span class="hljs-string">&quot;my_port&quot;</span>, <span class="hljs-number">8080</span>, &amp;var_cfg_my_port, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;,<br>  &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span> , <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *var_cfg_my_addr;<br><span class="hljs-type">static</span> <span class="hljs-type">char</span> *var_cfg_my_list;<br><br><span class="hljs-type">static</span> ACL_CFG_STR_TABLE __conf_str_tab[] = &#123;<br>  <span class="hljs-comment">/* 配置项名称, 配置项缺省值, 存储配置项值的地址 */</span><br>  &#123; <span class="hljs-string">&quot;my_addr&quot;</span>, <span class="hljs-string">&quot;192.168.0.1&quot;</span>, &amp;var_cfg_my_addr &#125;,<br>  &#123; <span class="hljs-string">&quot;my_list&quot;</span>, <span class="hljs-string">&quot;www.test.com&quot;</span>, &amp;var_cfg_my_list &#125;,<br>  &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-type">static</span> <span class="hljs-type">int</span> var_cfg_my_check;<br><br><span class="hljs-type">static</span> ACL_CFG_BOOL_TABLE __conf_bool_tab[] = &#123;<br>  <span class="hljs-comment">/* 配置项名称, 配置项缺省值, 存储配置项值的地址 */</span><br>  &#123; <span class="hljs-string">&quot;my_check&quot;</span>, <span class="hljs-number">0</span>, &amp;var_cfg_my_check &#125;,<br>  &#123; <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span> &#125;<br>&#125;;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>  ACL_XINETD_CFG_PARSER *cfg;  <span class="hljs-comment">// 配置解析对象</span><br><br>  cfg = acl_xinetd_cfg_load(<span class="hljs-string">&quot;test.cf&quot;</span>);  <span class="hljs-comment">// 读取并解析配置文件</span><br>  acl_xinetd_params_int_table(cfg, __conf_int_tab);  <span class="hljs-comment">// 读取所有 int 类型的配置项</span><br>  acl_xinetd_params_str_table(cfg, __conf_str_tab);  <span class="hljs-comment">// 读取所有字符串类型的配置项</span><br>  acl_xinetd_params_bool_table(cfg, __conf_bool_tab);  <span class="hljs-comment">// 读取所有 bool 型的配置项</span><br><br>  acl_xinetd_cfg_free(cfg);  <span class="hljs-comment">// 释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure><p>通过调用 acl_xinetd_params_xxx_table() 函数，直接将配置项的值赋给变量，这样省去了很多麻烦。</p>]]></content>
    
    
    <categories>
      
      <category>配置文件</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>协作半驻留式服务器程序开发框架</title>
    <link href="/2009/08/15/server_framework/"/>
    <url>/2009/08/15/server_framework/</url>
    
    <content type="html"><![CDATA[<h1 id="协作半驻留式服务器程序开发框架-—-基于-Postfix-服务器框架改造"><a href="#协作半驻留式服务器程序开发框架-—-基于-Postfix-服务器框架改造" class="headerlink" title="协作半驻留式服务器程序开发框架 — 基于 Postfix 服务器框架改造"></a>协作半驻留式服务器程序开发框架 — 基于 Postfix 服务器框架改造</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>现在大家在和 Java, PHP, #C 写应用程序时，都会用到一些成熟的服务框架，所以开发效率是比较高的。而在用C&#x2F;C++写服务器程序时，用的就五花八门了，有些人用ACE等等，这类服务器框架及库比较丰富，但入门门槛比较高，所以更多的人是自己直接写服务器程序，初始写时觉得比较简单，可时间久了，便会觉得难以扩展，性能低，容易出错。其实，Postfix 作者为我们提供了一个高效、稳定、安全的服务器框架模型，虽然Postfix主要用作邮件系统的 MTA，但其框架设计却非常具有通用性。ACL 库的作者将 Postfix 的服务器框架模型抽取出来，形成了更加通用的服务器程序开发框架，使程序员在编写服务器程序时可以达到事半功倍的效果。本文主要介 绍了 ACL 库中 acl_master 服务器程序（基于Postifx服务器程序框架）的设计及功能。</p><h2 id="2-框架设计图"><a href="#2-框架设计图" class="headerlink" title="2. 框架设计图"></a>2. 框架设计图</h2><img src=/img/server_framework.webp /><p>master主进程为控制进程，刚启动时其负责监听所有端口服务，当有新的客户端连接到达时，master便会启动子进程进行服务，而自己依然监控服务端 口，同时监控子进程的工作状态；而提供对外服务的子进程在master启动时，若没有请求任务则不会被启动，只有当有连接或任务到达时才会被master 启动，当该服务子进程处理完某个连接服务后并不立即退出，而是驻留在系统一段时间，等待可能的新连接到达，这样当有新的连接到达时master就不会启动 新的子进程，因为已经有处于空闲的子进程在等待下一个连接请求；当服务子进程空闲时间达一定阀值后，就会选择退出，将资源全部归还操作系统（当然，也可以 配置成服务子进程永不退出的模式）。因此，可以称这种服务器框架为协作式半驻留式服务器框架，下面将会对协作式和半驻留作进一步介绍。</p><h2 id="3-协作方式"><a href="#3-协作方式" class="headerlink" title="3. 协作方式"></a>3. 协作方式</h2><p>Postfix服务器框架设计的非常巧妙，因为master毕竟属于用户空间进程，不能象操作系统那样可以控制每个进程的运行时间片，所以master主进程必须与其服务子进程之间协作好，以处理好以下几个过程：</p><ul><li>新连接到达时，master是该启动新的子进程接管该连接还是由空闲子进程直接接管</li><li>master何时应该启动新的子进程</li><li>新连接到达，空闲子进程池中的子进程如何竞争接管该连接</li><li>子进程异常退出时，master如何处理新连接</li><li>空闲子进程如何选择退出时间（空闲时间或服务次数应决定子进程的退出）</li><li>master如何知道各个子进程的工作状态（是死了还是活着？）</li><li>在不停止服务的前提下，服务子进程程序如果在线更新、如何添加新的服务、如何在线更新子进程配置</li><li>如何减少所有子进程与master之间的通讯次数从而降低master的负载</li></ul><h2 id="4-流程图"><a href="#4-流程图" class="headerlink" title="4. 流程图"></a>4. 流程图</h2><h3 id="4-1-master主进程流程图"><a href="#4-1-master主进程流程图" class="headerlink" title="4.1. master主进程流程图"></a>4.1. master主进程流程图</h3><img src=/img/master_proc.webp /><p>Postifx 中的 master 主进程与各个子进程之间的IPC通讯方式为管道，所以管道的个数与子进程数是成正比的。如果管道中断，则 master 认为该管道所对应的子进程已经退出，如果是异常退出，master还需要标记该服务类子进程池以防止该类子进程异常退出频繁而启动也异常频繁（如果子进程 启动过于频繁则会给操作系统造成巨大负载）；另外，如果某类服务的子进程在服务第一个连接时就异常退出，则master认为该服务有可能是不可用的，所以 当有新的连接再到达时就会延迟启动该服务子进程。</p><p>当服务子进程池中有空闲子进程时，master便会把该服务端口的监听权让出，从而该服务 的空闲子进程在该服务端口上接收新的连接。当某个子进程获得新的连接后便会立即通知master其已经处于忙状态，master便立即查找该服务的子进程 进程池还有无空闲子进程，如果有则master依然不会接管该服务端口的监听任务；如果没有了，则master立即接管该服务端口的监听任务，当有新的连 接到达时，master先检查有没有该服务的空闲进程，若有便让出该服务端口的监听权，若没有便会启动新的子进程，然后让出监听权。</p><h3 id="4-2-服务子进程流程图"><a href="#4-2-服务子进程流程图" class="headerlink" title="4.2. 服务子进程流程图"></a>4.2. 服务子进程流程图</h3><img src=/img/child_proc.webp /><p>在master主进程刚启动时，因为没有任何服务请求，所以子进程是不随master一起启动的，此时所有服务端口的监控工作是由master统一负责， 当有客户端连接到达时，服务子进程才由master启动，进而接收该新连接，在进一步处理客户端请求前，子进程必须让master进程知道它已经开始” 忙”了，好由master来决定是否再次接管该服务端口的监控任务，所以子进程首先向master发送“忙”消息，然后才开始接收并处理该客户端请求，当 子进程完成了对该客户端的请求任务后，需向master发送“空闲”消息，以表明自己又可以继续处理新的客户端连接任务了。这一“忙”一“闲”两个消息， 便体现了服务子进程与master主进程的协作特点。</p><p>当然，服务子进程可以选择合适的退出时机：如果自己的服务次数达到配置的阀值，或自己空闲时间达到阀值，或与master主进程之间的IPC管道中断(一 般是由master停止服务要求所有服务子进程退出时或master要求所有服务子进程重读配置时而引起的)，则服务子进程便应该结束运行了。这个停止过 程，一方面体现了子进程与master主进程之间的协作特点，另一方面也体现了子进程半驻留的特点，从而体现子进程进程池的半驻留特性，这一特性的最大好 处就是：按需分配，当请求连接比较多时，所启动运行的子进程就多，当请求连接任务较少时，只有少数的子进程在运行，其它的都退出了。</p><h3 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3. 小结"></a>4.3. 小结</h3><p>以上从整体上介绍了Postfix服务器框架模型中master主进程与服务子进程的逻辑流程图，当然，其内部实现要点与细节远比上面介绍的要复杂，只是 这些复杂层面别人已经帮我们屏蔽了，我们所要做的是在此基础上写出自己的应用服务来，下面简要介绍了基于Postfix的服务器框架改造抽象的ACL库中 服务器程序的开发方式，以使大家比较容易上手。</p><h2 id="5-五类服务器编程模型"><a href="#5-五类服务器编程模型" class="headerlink" title="5. 五类服务器编程模型"></a>5. 五类服务器编程模型</h2><p>要想使用ACL服务器框架库开发服务器程序，首先介绍两个个小名词：acl_master服务器主进程与服务器模板。acl_master服务器主进程与 Postfix中的master主进程功能相似，它的主要作用是启动并控制所有的服务子进程，这个程序不用我们写，是ACL服务器框架中已经写好的；所谓 服务器模板，就是我们需要根据自己的需要从ACL服务器框架中选择一种服务器模型(即服务器模板)，然后在编写服务器时按该服务器模板的方式写即可。为什 么还要选择合适的服务器框架模板？这是因为Postfix本身就提供了三类服务器应用形式(单进程单连接进程池、单进程多连接进程池、触发器进程池)，这 三类应用形式便分别使用了Postfix中的三种服务器模板，此外，ACL中又增加了两种服务器应用形式(多线程进程池、单进程非阻塞进程池)。下面分别 就这五种服务器框架模板一一做简介：</p><ul><li><strong>多进程模型：</strong> 由 acl_master 主进程启动多个进程组成进程池提供某类服务，但每个进程每次只能处理一个客户端连接请求；</li><li><strong>多线程模型：</strong> 由 acl_master 主进程启动多个进程组成进程池提供某类服务，而每个进程是由多个线程组成，每个线程处理一个客户端连接请求；</li><li><strong>非阻塞模型：</strong> 由 acl_master 主进程启动多个进程组成进程池提供某类服务，每个进程可以并发处理多个连接(类似于Nginx, Lighttpd, Squid, Ircd)，由于采用非阻塞技术，该模型服务器的并发处理能力大大提高，同时系统资源消耗也最小；当然，该模型与单进程多连接进程池采用的技术都是非阻塞 技术，但该模型进行更多的应用封装与高级处理，使编写非阻塞程序更加容易；</li><li><strong>协程模型：</strong> 该模型采用协程方式，将阻塞IO模式在底层转变为非阻塞模式，这样既可以象编写多线程一样简单，又可以象非阻塞程序一样高效，从而使技术人员快速地编写出高并发、高性能的网络服务程序；</li><li><strong>触发器模型：</strong> 由 acl_master 主进程启动多个进程组成进程池提供定时器类服务(类似于UNIX中的crond)，当某个定时器时间到达时，便由一个进程开始运行处理任务。</li></ul><p>以上五种服务器方式中，由于可以根据需要配置成多个进程实例，所以可以充分地利用多核的系统。其中，第5种的运行效率是最高的，当然其编程的复杂度要比其 它的高，而第1种是执行效率最低的，其实它也是最安全的(在Postfix中的smtpd&#x2F;smtp 等进程就属于这一类)，而相对来说， 第4种在运行效率与编写复杂度方面是一个比较好的折衷，所以在写一般性服务器时，该服务器模型是作者推荐的方案，此外，第4种方案还有一个好处，可以做到 对于空连接不必占用线程，这样也大大提供了并发度(即线程数可以远小于连接数)。</p><h2 id="6-使用简介"><a href="#6-使用简介" class="headerlink" title="6. 使用简介"></a>6. 使用简介</h2><p>本节暂不介绍具体的编程过程，只是介绍一些配置使用过程。假设已经写好了服务器程序：echo_server, 该程序可以采用上面的 1), 2), 4), 5) 中的任一服务器模型来写，假设采用了第4)种；另外，还假设：acl_master等所有文件安装的根目录为 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F;, 主进程程序 acl_master 及 echo_server 安装在 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F;libexec&#x2F;,  acl_master 主程序配置文件安装在 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F;conf&#x2F;，echo_server 配置文件安装在 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F;conf&#x2F;service&#x2F;, 日志文件目录为 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F;var&#x2F;log&#x2F;, 进程号文件目录为 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F;var&#x2F;pid&#x2F;。比如，你让 echo_server 的服务端口为 6601，服务地址为 127.0.0.1, 它只是提供简单的 echo 服务。</p><p>你可以运行 &#x2F;opt&#x2F;soft&#x2F;acl-master&#x2F;sh&#x2F;start.sh 脚本来启动 acl_master 主进程(用 ps -ef|grep acl_master 会看到 acl_master 进程存在 ，但 ps -ef|grep echo_server 却没有发现它的存在)，然后你在一个Unix终端上 telnet 127.0.0.1 6601, 在另一个终端上 ps -ef|grep echo_server 就会发现有一个 echo_server子进程了，然后在 telnet 6601 的终端上随便输入一些字符串，便会立即得到回复，关闭该 telnet 连接，用 ps -ef|grep echo_server 会发现该进程依然存在，当再次 telnet 127.0.0.1 6601 时，该echo_server进程又继续为新连接提供服务了。可以试着多开几个终端同时 telnet 127.0.0.1 6601，看看运行效果如何？</p><p>注意，服务子进程的配置文件格式需要与其所采用的模板类型一致；进程池中最大进程个数、进程中线程池最大线程个数、进程最大服务次数、空闲时间等都是可以以配置文件中指定的。</p>]]></content>
    
    
    <categories>
      
      <category>服务编程</category>
      
    </categories>
    
    
    <tags>
      
      <tag>服务编程</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ACL编程之父子进程机制，父进程守护子进程以防止子进程异常退出</title>
    <link href="/2009/06/07/process_control/"/>
    <url>/2009/06/07/process_control/</url>
    
    <content type="html"><![CDATA[<p>在WIN32平台进行编程时，经常会遇到工作进程因为程序内部BUG而异常退出的现象，当然为了解决此类问题最好还是找到问题所在并解决它，但如果这类导致程序崩溃的BUG并不是经常出现，只有当某种条件发生时才会有，在我们解决BUG的时间里，为了尽最大可能地为用户提供服务可以采用一种父进程守护机制：当子进程异常退出时，守护父进程可以截获这一消息，并立即重启子进程，这样用户就可以继续使用我们的程序了，当然如果子进程的问题比较严重频繁地 DOWN掉，而父进程却不停地重启子进程的话，势必造成用户机系统资源的大量耗费，那我们的程序就如病毒一样，很快耗尽了用户机资源，所以需要父进程能够智能地控制重启子进程的时间间隔。<br>本文将给出一个具体的例子（利用ACL库），介绍父、子进程的编程方法。</p><h2 id="一、接口介绍"><a href="#一、接口介绍" class="headerlink" title="一、接口介绍"></a>一、接口介绍</h2><h3 id="1-1-以守护进程方式运行的接口"><a href="#1-1-以守护进程方式运行的接口" class="headerlink" title="1.1 以守护进程方式运行的接口"></a>1.1 以守护进程方式运行的接口</h3><p>创建守护进程的方式非常简单，只需要调用 acl_proctl_deamon_init, acl_proctl_daemon_loop 两个函数即可<br>接口说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化进程控制框架（仅 acl_proctl_start 需要）</span><br><span class="hljs-comment"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class="hljs-comment"> */</span><br>ACL_API <span class="hljs-type">void</span> <span class="hljs-title function_">acl_proctl_deamon_init</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 控制进程作为后台服务进程运行，监视所有子进程的运行状态，</span><br><span class="hljs-comment"> * 如果子进程异常退出则会重启该子进程</span><br><span class="hljs-comment"> */</span><br>ACL_API <span class="hljs-type">void</span> <span class="hljs-title function_">acl_proctl_daemon_loop</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;<br></code></pre></td></tr></table></figure><h3 id="1-2-以命令方式来控制守护进程（守护进程即控制进程的意思）"><a href="#1-2-以命令方式来控制守护进程（守护进程即控制进程的意思）" class="headerlink" title="1.2 以命令方式来控制守护进程（守护进程即控制进程的意思）"></a>1.2 以命令方式来控制守护进程（守护进程即控制进程的意思）</h3><p>守护进程启动后，可以以命令方式控制守护进程来启动、停止子进程，或查询显示当前正在运行的子进程。<br>启动子进程：acl_proctl_start_one<br>停止子进程：acl_proctl_stop_one<br>停止所有子进程：acl_proctl_stop_all<br>查询子进程是否在运行：acl_proctl_probe<br>查询当前所有在运行的子进程：acl_proctl_list<br>通过守护进程停止所有子进程且守护进程自身退出：acl_proctl_quit</p><p>接口说明如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以命令方式启动某个子进程</span><br><span class="hljs-comment"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class="hljs-comment"> * @param progchild &#123;const char*&#125; 子进程进程名</span><br><span class="hljs-comment"> * @param argc &#123;int&#125; argv 数组的长度</span><br><span class="hljs-comment"> * @param argv &#123;char* []&#125; 传递给子进程的参数</span><br><span class="hljs-comment"> */</span><br>ACL_API <span class="hljs-type">void</span> <span class="hljs-title function_">acl_proctl_start_one</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *progchild, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以命令方式停止某个子进程</span><br><span class="hljs-comment"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class="hljs-comment"> * @param progchild &#123;const char*&#125; 子进程进程名</span><br><span class="hljs-comment"> * @param argc &#123;int&#125; argv 数组的长度</span><br><span class="hljs-comment"> * @param argv &#123;char* []&#125; 传递给子进程的参数</span><br><span class="hljs-comment"> */</span><br>ACL_API <span class="hljs-type">void</span> <span class="hljs-title function_">acl_proctl_stop_one</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname,</span><br><span class="hljs-params">    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *progchild, <span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以命令方式停止所有的子进程</span><br><span class="hljs-comment"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class="hljs-comment"> */</span><br>ACL_API <span class="hljs-type">void</span> <span class="hljs-title function_">acl_proctl_stop_all</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 探测某个服务进程是否在运行</span><br><span class="hljs-comment"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class="hljs-comment"> * @param progchild &#123;const char*&#125; 子进程进程名</span><br><span class="hljs-comment"> */</span><br>ACL_API <span class="hljs-type">void</span> <span class="hljs-title function_">acl_proctl_probe</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *progchild)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 列出当前所有正在运行的服务进程</span><br><span class="hljs-comment"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class="hljs-comment"> */</span><br>ACL_API <span class="hljs-type">void</span> <span class="hljs-title function_">acl_proctl_list</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname)</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 以命令方式通知控制进程停止所有的子进程，并在子进程退出后控制进程也自动退出</span><br><span class="hljs-comment"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class="hljs-comment"> */</span><br>ACL_API <span class="hljs-type">void</span> <span class="hljs-title function_">acl_proctl_quit</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname)</span>;<br></code></pre></td></tr></table></figure><h3 id="1-3、子进程编写"><a href="#1-3、子进程编写" class="headerlink" title="1.3、子进程编写"></a>1.3、子进程编写</h3><p>子进程编程也比较容易，只需在程序初始化时调用　acl_proctl_child　即可，这样子进程就会在硬盘创建自己的信息并与父进程（即守护进程）建立联系。<br>接口说明：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 子进程调用接口，通过此接口与父进程之间建立控制/被控制关系</span><br><span class="hljs-comment"> * @param progname &#123;const char*&#125; 子进程进程名</span><br><span class="hljs-comment"> * @param onexit_fn &#123;void (*)(void*)&#125; 如果非空则当子进程退出时调用的回调函数</span><br><span class="hljs-comment"> * @param arg &#123;void*&#125; onexit_fn 参数之一</span><br><span class="hljs-comment"> */</span><br>ACL_API <span class="hljs-type">void</span> <span class="hljs-title function_">acl_proctl_child</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname, <span class="hljs-type">void</span> (*onexit_fn)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure><h2 id="二、例子"><a href="#二、例子" class="headerlink" title="二、例子"></a>二、例子</h2><h3 id="2-1、父进程"><a href="#2-1、父进程" class="headerlink" title="2.1、父进程"></a>2.1、父进程</h3><p>程序名：acl_project\samples\proctl\proctld.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proctld.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span><br>&#123;<br>acl_init();  <span class="hljs-comment">// 初始化ACL库  </span><br>&#125;<br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">usage</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span> *progname)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;usage: %s -h [help] -d [START|STOP|QUIT|LIST|PROBE] -f filepath -a args\r\n&quot;</span>,<br>progname);<br>getchar();<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-type">char</span>  ch, filepath[<span class="hljs-number">256</span>], cmd[<span class="hljs-number">256</span>];<br><span class="hljs-type">char</span> **child_argv = <span class="hljs-literal">NULL</span>;<br><span class="hljs-type">int</span>   child_argc = <span class="hljs-number">0</span>, i;<br>ACL_ARGV *argv_tmp;<br><br>filepath[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br>cmd[<span class="hljs-number">0</span>] = <span class="hljs-number">0</span>;<br><br>init();<br><br><span class="hljs-keyword">while</span> ((ch = getopt(argc, argv, <span class="hljs-string">&quot;d:f:a:h&quot;</span>)) &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">switch</span>(ch) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;d&#x27;</span>:<br>ACL_SAFE_STRNCPY(cmd, optarg, <span class="hljs-keyword">sizeof</span>(cmd));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;f&#x27;</span>:<br>ACL_SAFE_STRNCPY(filepath, optarg, <span class="hljs-keyword">sizeof</span>(filepath));<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;a&#x27;</span>:<br>argv_tmp = acl_argv_split(optarg, <span class="hljs-string">&quot;|&quot;</span>);<br>assert(argv_tmp);<br>child_argc = argv_tmp-&gt;argc;<br>child_argv = (<span class="hljs-type">char</span>**) acl_mycalloc(child_argc + <span class="hljs-number">1</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>*));<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; child_argc; i++) &#123;<br>child_argv[i] = acl_mystrdup(argv_tmp-&gt;argv[i]);<br>&#125;<br>child_argv[i] = <span class="hljs-literal">NULL</span>;<br><br>acl_argv_free(argv_tmp);<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;h&#x27;</span>:<br>usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br><span class="hljs-keyword">default</span>:<br>usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">if</span> (strcasecmp(cmd, <span class="hljs-string">&quot;STOP&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 向守护进程发送消息命令，停止某个子进程或所有的子进程</span><br><span class="hljs-keyword">if</span> (filepath[<span class="hljs-number">0</span>])<br>acl_proctl_stop_one(argv[<span class="hljs-number">0</span>], filepath, child_argc, child_argv);<br><span class="hljs-keyword">else</span><br>acl_proctl_stop_all(argv[<span class="hljs-number">0</span>]);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strcasecmp(cmd, <span class="hljs-string">&quot;START&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (filepath[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 向守护进程发送消息命令，启动某个子进程</span><br>acl_proctl_start_one(argv[<span class="hljs-number">0</span>], filepath, child_argc, child_argv);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strcasecmp(cmd, <span class="hljs-string">&quot;QUIT&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 向守护进程发送消息命令，停止所有的子进程同时守护父进程也退出</span><br>acl_proctl_quit(argv[<span class="hljs-number">0</span>]);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strcasecmp(cmd, <span class="hljs-string">&quot;LIST&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">// 向守护进程发送消息命令，列出由守护进程管理的正在运行的所有子进程</span><br>acl_proctl_list(argv[<span class="hljs-number">0</span>]);<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (strcasecmp(cmd, <span class="hljs-string">&quot;PROBE&quot;</span>) == <span class="hljs-number">0</span>) &#123;<br><span class="hljs-keyword">if</span> (filepath[<span class="hljs-number">0</span>] == <span class="hljs-number">0</span>) &#123;<br>usage(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br><span class="hljs-comment">// 向守护进程发送消息命令，探测某个子进程是否在运行</span><br>acl_proctl_probe(argv[<span class="hljs-number">0</span>], filepath);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">// 父进程以守护进程方式启动</span><br><span class="hljs-type">char</span>  buf[MAX_PATH], logfile[MAX_PATH], *ptr;<br><br><span class="hljs-comment">// 获得父进程执行程序所在的磁盘路径</span><br>acl_proctl_daemon_path(buf, <span class="hljs-keyword">sizeof</span>(buf));<br>ptr = <span class="hljs-built_in">strrchr</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;\\&#x27;</span>);<br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br>ptr = <span class="hljs-built_in">strrchr</span>(argv[<span class="hljs-number">0</span>], <span class="hljs-string">&#x27;/&#x27;</span>);<br><br><span class="hljs-keyword">if</span> (ptr == <span class="hljs-literal">NULL</span>)<br>ptr = argv[<span class="hljs-number">0</span>];<br><span class="hljs-keyword">else</span><br>ptr++;<br><br><span class="hljs-built_in">snprintf</span>(logfile, <span class="hljs-keyword">sizeof</span>(logfile), <span class="hljs-string">&quot;%s/%s.log&quot;</span>, buf, ptr);<br><span class="hljs-comment">// 打开日志文件</span><br>acl_msg_open(logfile, <span class="hljs-string">&quot;daemon&quot;</span>);<br><span class="hljs-comment">// 打开调试信息</span><br>acl_debug_init(<span class="hljs-string">&quot;all:2&quot;</span>);<br><br><span class="hljs-comment">// 以服务器模式启动监控进程</span><br>acl_proctl_deamon_init(argv[<span class="hljs-number">0</span>]);<br><span class="hljs-comment">// 父进程作为守护进程启动</span><br>acl_proctl_daemon_loop();<br>&#125;<br><br><span class="hljs-keyword">if</span> (child_argv) &#123;<br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; child_argv[i] != <span class="hljs-literal">NULL</span>; i++) &#123;<br>acl_myfree(child_argv[i]);<br>&#125;<br>acl_myfree(child_argv);<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-2、子进程"><a href="#2-2、子进程" class="headerlink" title="2.2、子进程"></a>2.2、子进程</h3><p>acl_project\samples\proctl\proctlc.cpp</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// proctlc.cpp : 定义控制台应用程序的入口点。</span><br><span class="hljs-comment">//</span><br><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> comment(lib,<span class="hljs-string">&quot;ws2_32&quot;</span>)</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.h&quot;</span></span><br><br><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title function_">onexit_fn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg acl_unused)</span><br>&#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;child exit now\r\n&quot;</span>);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span> *argv[])</span><br>&#123;<br><span class="hljs-type">int</span>   i;<br><br>acl_socket_init();<br>acl_msg_open(<span class="hljs-string">&quot;debug.txt&quot;</span>, <span class="hljs-string">&quot;proctlc&quot;</span>);<br>acl_msg_info(<span class="hljs-string">&quot;&gt;&gt;&gt; in child progname(%s), argc=%d\r\n&quot;</span>, argv[<span class="hljs-number">0</span>], argc);<br><span class="hljs-keyword">if</span> (argc &gt; <span class="hljs-number">1</span>)<br>acl_msg_info(<span class="hljs-string">&quot;&gt;&gt;&gt; in child progname, argv[1]=(%s)\r\n&quot;</span>, argv[<span class="hljs-number">1</span>]);<br><br><span class="hljs-comment">// 子进程启动，同时注册自身信息</span><br>acl_proctl_child(argv[<span class="hljs-number">0</span>], onexit_fn, <span class="hljs-literal">NULL</span>);<br><br><span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; argc; i++) &#123;<br>acl_msg_info(<span class="hljs-string">&quot;&gt;&gt;&gt;argv[%d]:%s\r\n&quot;</span>, i, argv[i]);<br>&#125;<br><br>i = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br>acl_msg_info(<span class="hljs-string">&quot;i = %d\r\n&quot;</span>, i++);<br><span class="hljs-keyword">if</span> (i == <span class="hljs-number">5</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-keyword">else</span><br>sleep(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-keyword">return</span> (<span class="hljs-number">-1</span>);  <span class="hljs-comment">// 返回 -1 是为了让父进程继续启动</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3、编译、运行"><a href="#2-3、编译、运行" class="headerlink" title="2.3、编译、运行"></a>2.3、编译、运行</h3><p>可以打开 acl_project\win32_build\vc\samples\samples_vc2003.sln，编译其中的 proctlc, proctld 两个工程，便会生成两个可执行文件：proctlc.exe(子进程程序），proctld.exe(父进程程序）。<br>先让父进程以守护进程模式启动 proctld.exe，然后运行 proctld.exe -d START {path}&#x2F;proctlc.exe 通知父进程启动子进程；可以运行 proctld.exe -d LIST 列出当前正在运行的子进程，运行 proctld.exe -d PROBE {path}&#x2F;proctld.exe 判断子进程是否在运行，运行 proctld.exe -d STOP {path}&#x2F;proctld.exe 让守护父进程停止子进程，运行 proctld.exe -d QUID 使守护进程停止所有子进程并自动退出。<br>另外，从子进程的程序可以看出，每隔5秒子进程就会异常退出，则守护进程便会立即重启该子进程，如果子进程死的过于频繁，则守护进程会延迟重启子进程，以防止太过耗费系统资源。</p><h2 id="三、小结"><a href="#三、小结" class="headerlink" title="三、小结"></a>三、小结</h2><p>因为有守护进程保护，就不必担心子进程（即你的工作进程）异常崩溃了，这种父子进程模型可以应用于大多数工作子进程偶尔异常崩溃的情形，如果你的程序 BUG太多，每一会儿就崩溃好多次，建议你还是先把主要问题解决后再使用父子进程，毕竟如果你的程序太过脆弱，虽然父进程能不断地重启你的程序，但你还是不能为用户提供正常服务。这种模型适用于在WIN32平台下，你的程序可能写得比较复杂，程序基本上是比较健壮的，只是会因偶尔某些原因而异常退出的情况。</p><p>github：<a href="https://github.com/acl-dev/acl">https://github.com/acl-dev/acl</a><br>gitee：<a href="https://gitee.com/acl-dev/acl">https://gitee.com/acl-dev/acl</a></p>]]></content>
    
    
    <categories>
      
      <category>进程控制</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>利用ACL库开发高并发半驻留式线程池程序</title>
    <link href="/2009/06/07/threads/"/>
    <url>/2009/06/07/threads/</url>
    
    <content type="html"><![CDATA[<h2 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h2><p>在当今强调多核开发的年代，要求程序员能够写出高并发的程序，而利用多个核一般有两种方式：采用多线程方式或多进程方式。每处理一个新任务时如果临时产生一个线程或进程且处理完任务后线程或进程便立即退出，显示这种方式是非常低效的，于是人们一般采用线程池的模型（这在JAVA 或 .NET 中非常普遍）或多进程进程池模型（这一般在UNIX平台应用较多）。此外，对于线程池或进程池模型又分为两种情形：常驻留内存或半驻留内存，常驻内存是指预先产生一批线程或进程，等待新任务到达，这些线程或进程即使在空闲状态也会常驻内存；半驻留内存是指当来新任务时如果线程池或进程池没有可利用线程或进程则启动新的线程或进程来处理新任务，处理完后，线程或进程并不立即退出，而是空闲指定时间，如果在空闲阀值时间到达前有新任务到达则立即处理新任务，如果到达空闲超时后依然没有新任务到达，则这些空闲的线程或进程便退出，以让出系统资源。所以，对比常驻内存方式和半驻留内存方式，不难看出半驻留方式更有按需分配的意味。</p><p>下面仅以ACL框架中的半驻留线程池模型为例介绍了如何写一个半驻留线程池的程序。</p><h2 id="二、半驻留线程池函数接口说明"><a href="#二、半驻留线程池函数接口说明" class="headerlink" title="二、半驻留线程池函数接口说明"></a>二、半驻留线程池函数接口说明</h2><h3 id="2-1）线程池的创建、销毁及任务添加等接口"><a href="#2-1）线程池的创建、销毁及任务添加等接口" class="headerlink" title="2.1）线程池的创建、销毁及任务添加等接口"></a>2.1）线程池的创建、销毁及任务添加等接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建一个线程池对象</span><br><span class="hljs-comment"> * @param attr &#123;acl_pthread_pool_attr_t*&#125; 线程池创建时的属性，如果该参数为空，</span><br><span class="hljs-comment"> *  则采用默认参数: ACL_PTHREAD_POOL_DEF_XXX</span><br><span class="hljs-comment"> * @return &#123;acl_pthread_pool_t*&#125;, 如果不为空则表示成功，否则失败</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function">ACL_API <span class="hljs-type">acl_pthread_pool_t</span> *<span class="hljs-title">acl_pthread_pool_create</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">acl_pthread_pool_attr_t</span> *attr)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 销毁一个线程池对象, 成功销毁后该对象不能再用.</span><br><span class="hljs-comment"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class="hljs-comment"> * @return &#123;int&#125; 0: 成功; != 0: 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">int</span> <span class="hljs-title">acl_pthread_pool_destroy</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_t</span> *thr_pool)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向线程池添加一个任务</span><br><span class="hljs-comment"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class="hljs-comment"> * @param run_fn &#123;void (*)(*)&#125; 当有可用工作线程时所调用的回调处理函数</span><br><span class="hljs-comment"> * @param run_arg &#123;void*&#125; 回调函数 run_fn 所需要的回调参数</span><br><span class="hljs-comment"> * @return &#123;int&#125; 0: 成功; != 0: 失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">int</span> <span class="hljs-title">acl_pthread_pool_add</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_t</span> *thr_pool,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">void</span> (*run_fn)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *run_arg)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 当前线程池中的线程数</span><br><span class="hljs-comment"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class="hljs-comment"> * @return &#123;int&#125; 返回线程池中的总线程数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">int</span> <span class="hljs-title">acl_pthread_pool_size</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_t</span> *thr_pool)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-2）线程池属性设置接口"><a href="#2-2）线程池属性设置接口" class="headerlink" title="2.2）线程池属性设置接口"></a>2.2）线程池属性设置接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 初始化线程池属性值</span><br><span class="hljs-comment"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_pthread_pool_attr_init</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_attr_t</span> *attr)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置线程池属性中的最大堆栈大小(字节)</span><br><span class="hljs-comment"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class="hljs-comment"> * @param size &#123;size_t&#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_pthread_pool_attr_set_stacksize</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_attr_t</span> *attr, <span class="hljs-type">size_t</span> size)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置线程池属性中的最大线程数限制值</span><br><span class="hljs-comment"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class="hljs-comment"> * @param threads_limit &#123;int&#125; 线程池中的最大线程数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_pthread_pool_attr_set_threads_limit</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_attr_t</span> *attr, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> threads_limit)</span></span>;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 设置线程池属性中线程空闲超时值</span><br><span class="hljs-comment"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class="hljs-comment"> * @param idle_timeout &#123;int&#125; 线程空闲超时时间(秒)</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">void</span> <span class="hljs-title">acl_pthread_pool_attr_set_idle_timeout</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_attr_t</span> *attr, </span></span><br><span class="hljs-params"><span class="hljs-function">    <span class="hljs-type">int</span> idle_timeout)</span></span>;<br></code></pre></td></tr></table></figure><h3 id="2-3）线程池中的工作线程创建、退出时设置回调函数接口"><a href="#2-3）线程池中的工作线程创建、退出时设置回调函数接口" class="headerlink" title="2.3）线程池中的工作线程创建、退出时设置回调函数接口"></a>2.3）线程池中的工作线程创建、退出时设置回调函数接口</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加注册函数，在线程创建后立即执行此初始化函数</span><br><span class="hljs-comment"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class="hljs-comment"> * @param init_fn &#123;int (*)(void*)&#125; 工作线程初始化函数, 如果该函数返回 &lt; 0,</span><br><span class="hljs-comment"> *  则该线程自动退出。</span><br><span class="hljs-comment"> * @param init_arg &#123;void*&#125; init_fn 所需要的参数</span><br><span class="hljs-comment"> * @return &#123;int&#125; 0: OK; != 0: Error.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">int</span> <span class="hljs-title">acl_pthread_pool_atinit</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_t</span> *thr_pool,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">int</span> (*init_fn)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *init_arg)</span></span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 添加注册函数，在线程退出立即执行此初函数</span><br><span class="hljs-comment"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class="hljs-comment"> * @param free_fn &#123;void (*)(void*)&#125; 工作线程退出前必须执行的函数</span><br><span class="hljs-comment"> * @param free_arg &#123;void*&#125; free_fn 所需要的参数</span><br><span class="hljs-comment"> * @return &#123;int&#125; 0: OK; != 0: Error.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">int</span> <span class="hljs-title">acl_pthread_pool_atfree</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_t</span> *thr_pool,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-type">void</span> (*free_fn)(<span class="hljs-type">void</span> *), <span class="hljs-type">void</span> *free_arg)</span></span>;<br></code></pre></td></tr></table></figure><h2 id="三、半驻留线程池例子"><a href="#三、半驻留线程池例子" class="headerlink" title="三、半驻留线程池例子"></a>三、半驻留线程池例子</h2><h3 id="3-1）程序代码"><a href="#3-1）程序代码" class="headerlink" title="3.1）程序代码"></a>3.1）程序代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;lib_acl.h&quot;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 用户自定义数据结构</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">THREAD_CTX</span> &#123;<br><span class="hljs-type">acl_pthread_pool_t</span> *thr_pool;<br><span class="hljs-type">int</span>   i;<br>&#125; THREAD_CTX;<br><br><span class="hljs-comment">/* 全局性静态变量 */</span><br><span class="hljs-type">static</span> <span class="hljs-type">acl_pthread_pool_t</span> *__thr_pool = <span class="hljs-literal">NULL</span>;<br><br><span class="hljs-comment">/* 线程局部存储变量(C99支持此种方式声明，方便许多) */</span><br><span class="hljs-type">static</span> __thread <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> __local = <span class="hljs-number">0</span>;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">work_thread_fn</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br>THREAD_CTX *ctx = (THREAD_CTX*) arg; <span class="hljs-comment">/* 获得用户自定义对象 */</span><br><span class="hljs-type">int</span>   i = <span class="hljs-number">5</span>;<br><br><span class="hljs-comment">/* 仅是验证参数传递过程 */</span><br><span class="hljs-built_in">assert</span>(ctx-&gt;thr_pool == __thr_pool);<br><br><span class="hljs-keyword">while</span> (i-- &gt; <span class="hljs-number">0</span>) &#123;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;thread start! tid=%d, i=%d, __local=%d\r\n&quot;</span>,<br><span class="hljs-built_in">acl_pthread_self</span>(), ctx-&gt;i, __local);<br><span class="hljs-comment">/* 在本线程中将线程局部变量加1 */</span><br>__local++;<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-built_in">acl_myfree</span>(ctx);<br><br><span class="hljs-comment">/* 至此，该工作线程进入空闲状态，直到空闲超时退出 */</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">int</span> <span class="hljs-title">on_thread_init</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *myname = <span class="hljs-string">&quot;on_thread_init&quot;</span>;<br><span class="hljs-type">acl_pthread_pool_t</span> *thr_pool = (<span class="hljs-type">acl_pthread_pool_t</span>*) arg;<br><br><span class="hljs-comment">/* 判断一下，仅是为了验证参数传递过程 */</span><br><span class="hljs-built_in">assert</span>(thr_pool == __thr_pool);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: thread(%d) init now\r\n&quot;</span>, myname, <span class="hljs-built_in">acl_pthread_self</span>());<br><br><span class="hljs-comment">/* 返回0表示继续执行该线程获得的新任务，返回-1表示停止执行该任务 */</span><br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">on_thread_exit</span><span class="hljs-params">(<span class="hljs-type">void</span> *arg)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">const</span> <span class="hljs-type">char</span> *myname = <span class="hljs-string">&quot;on_thread_exit&quot;</span>;<br><span class="hljs-type">acl_pthread_pool_t</span> *thr_pool = (<span class="hljs-type">acl_pthread_pool_t</span>*) arg;<br><br><span class="hljs-comment">/* 判断一下，仅是为了验证参数传递过程 */</span><br><span class="hljs-built_in">assert</span>(thr_pool == __thr_pool);<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s: thread(%d) exit now\r\n&quot;</span>, myname, <span class="hljs-built_in">acl_pthread_self</span>());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">run_thread_pool</span><span class="hljs-params">(<span class="hljs-type">acl_pthread_pool_t</span> *thr_pool)</span></span><br><span class="hljs-function"></span>&#123;<br>THREAD_CTX *ctx;  <span class="hljs-comment">/* 用户自定义参数 */</span><br><br><span class="hljs-comment">/* 设置全局静态变量 */</span><br>__thr_pool = thr_pool;<br><br><span class="hljs-comment">/* 设置线程开始时的回调函数 */</span><br>(<span class="hljs-type">void</span>) <span class="hljs-built_in">acl_pthread_pool_atinit</span>(thr_pool, on_thread_init, thr_pool);<br><br><span class="hljs-comment">/* 设置线程退出时的回调函数 */</span><br>(<span class="hljs-type">void</span>) <span class="hljs-built_in">acl_pthread_pool_atfree</span>(thr_pool, on_thread_exit, thr_pool);<br><br>ctx = (THREAD_CTX*) <span class="hljs-built_in">acl_mycalloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(THREAD_CTX));<br><span class="hljs-built_in">assert</span>(ctx);<br>ctx-&gt;thr_pool = thr_pool;<br>ctx-&gt;i = <span class="hljs-number">0</span>;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 向线程池中添加第一个任务，即启动第一个工作线程</span><br><span class="hljs-comment"> * @param thr_pool 线程池句柄</span><br><span class="hljs-comment"> * @param workq_thread_fn 工作线程的回调函数</span><br><span class="hljs-comment"> * @param ctx 用户定义参数</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">acl_pthread_pool_add</span>(thr_pool, work_thread_fn, ctx);<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br><br>ctx = (THREAD_CTX*) <span class="hljs-built_in">acl_mycalloc</span>(<span class="hljs-number">1</span>, <span class="hljs-built_in">sizeof</span>(THREAD_CTX));<br><span class="hljs-built_in">assert</span>(ctx);<br>ctx-&gt;thr_pool = thr_pool;<br>ctx-&gt;i = <span class="hljs-number">1</span>;<br><span class="hljs-comment">/* 向线程池中添加第二个任务，即启动第二个工作线程 */</span><br><span class="hljs-built_in">acl_pthread_pool_add</span>(thr_pool, work_thread_fn, ctx);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc acl_unused, <span class="hljs-type">char</span> *argv[] acl_unused)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">acl_pthread_pool_t</span> *thr_pool;<br><span class="hljs-type">int</span>  max_threads = <span class="hljs-number">20</span>;  <span class="hljs-comment">/* 最多并发20个线程 */</span><br><span class="hljs-type">int</span>  idle_timeout = <span class="hljs-number">10</span>; <span class="hljs-comment">/* 每个工作线程空闲10秒后自动退出 */</span><br><span class="hljs-type">acl_pthread_pool_attr_t</span> attr;<br><br><span class="hljs-built_in">acl_pthread_pool_attr_init</span>(&amp;attr);<br><span class="hljs-built_in">acl_pthread_pool_attr_set_threads_limit</span>(&amp;attr, max_threads);<br><span class="hljs-built_in">acl_pthread_pool_attr_set_idle_timeout</span>(&amp;attr, idle_timeout);<br><br><span class="hljs-comment">/* 创建半驻留线程句柄 */</span><br>thr_pool = <span class="hljs-built_in">acl_pthread_pool_create</span>(&amp;attr);<br><span class="hljs-built_in">assert</span>(thr_pool);<br><span class="hljs-built_in">run_thread_pool</span>(thr_pool);<br><br><span class="hljs-keyword">if</span> (<span class="hljs-number">0</span>) &#123;<br><span class="hljs-comment">/* 如果立即运行 acl_pthread_pool_destroy，则由于调用了线程池销毁函数，</span><br><span class="hljs-comment"> * 主线程便立刻通知空闲线程退出，所有空闲线程不必等待空闲超时时间便可退出,</span><br><span class="hljs-comment"> */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; wait all threads to be idle and free thread pool\r\n&quot;</span>);<br><span class="hljs-comment">/* 立即销毁线程池 */</span><br><span class="hljs-built_in">acl_pthread_pool_destroy</span>(thr_pool);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-comment">/* 因为不立即调用 acl_pthread_pool_destroy，所有所有空闲线程都是当空闲</span><br><span class="hljs-comment"> * 超时时间到达后才退出</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) &#123;<br><span class="hljs-type">int</span>   ret;<br><br>ret = <span class="hljs-built_in">acl_pthread_pool_size</span>(thr_pool);<br><span class="hljs-keyword">if</span> (ret == <span class="hljs-number">0</span>)<br><span class="hljs-keyword">break</span>;<br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; current threads in thread pool is: %d\r\n&quot;</span>, ret);<br><span class="hljs-built_in">sleep</span>(<span class="hljs-number">1</span>);<br>&#125;<br><span class="hljs-comment">/* 线程池中的工作线程数为0时销毁线程池 */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; all worker thread exit now\r\n&quot;</span>);<br><span class="hljs-built_in">acl_pthread_pool_destroy</span>(thr_pool);<br>&#125;<br><br><span class="hljs-comment">/* 主线程等待用户在终端输入任意字符后退出 */</span><br><span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;&gt; enter any key to exit\r\n&quot;</span>);<br><span class="hljs-built_in">getchar</span>();<br><br><span class="hljs-keyword">return</span> (<span class="hljs-number">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-编译链接"><a href="#3-2-编译链接" class="headerlink" title="3.2) 编译链接"></a>3.2) 编译链接</h3><p>从　<a href="http://www.sourceforge.net/projects/acl/">http://www.sourceforge.net/projects/acl/</a> 站点下载 acl_project 代码，在WIN32平台下请用VC2003编译，打开 acl_project\win32_build\vc\acl_project_vc2003.sln 编译后在目录　acl_project\dist\lib_acl\lib\win32　下生成lib_acl_vc2003.lib, 然后在示例的控制台工程中包含该库，并包含acl_project\lib_acl\include　下的 lib_acl.h 头文件，编译上述源代码即可。<br>因为本例子代码在 ACL 的例子里有，所以可以直接编译 acl_project\win32_build\vc\samples\samples_vc2003.sln 中的 thread_pool 项目即可。</p><h3 id="3-3-运行"><a href="#3-3-运行" class="headerlink" title="3.3) 运行"></a>3.3) 运行</h3><p>运行示例程序后，在我的机器的显示结果如下：</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs routeros">on_thread_init: thread(23012) init now<br>thread start! <span class="hljs-attribute">tid</span>=23012, <span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">__local</span>=0<br>thread start! <span class="hljs-attribute">tid</span>=23012, <span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">__local</span>=1<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>on_thread_init: thread(23516) init now<br>thread start! <span class="hljs-attribute">tid</span>=23516, <span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">__local</span>=0<br>thread start! <span class="hljs-attribute">tid</span>=23516, <span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">__local</span>=1<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>thread start! <span class="hljs-attribute">tid</span>=23012, <span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">__local</span>=2<br>thread start! <span class="hljs-attribute">tid</span>=23516, <span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">__local</span>=2<br>thread start! <span class="hljs-attribute">tid</span>=23012, <span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">__local</span>=3<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>thread start! <span class="hljs-attribute">tid</span>=23516, <span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">__local</span>=3<br>thread start! <span class="hljs-attribute">tid</span>=23012, <span class="hljs-attribute">i</span>=0, <span class="hljs-attribute">__local</span>=4<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>thread start! <span class="hljs-attribute">tid</span>=23516, <span class="hljs-attribute">i</span>=1, <span class="hljs-attribute">__local</span>=4<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 2<br>on_thread_exit: thread(23012) exit now<br>&gt; current threads <span class="hljs-keyword">in</span> thread<span class="hljs-built_in"> pool </span>is: 1<br>on_thread_exit: thread(23516) exit now<br>&gt; all worker thread exit now<br>&gt; enter any key <span class="hljs-keyword">to</span> exit<br></code></pre></td></tr></table></figure><h2 id="四、小结"><a href="#四、小结" class="headerlink" title="四、小结"></a>四、小结</h2><p>可以看出，使用ACL库创建半驻留式高并发多线程程序是比较简单的，ACL线程池库的接口定义及实现尽量与POSIX中规定的POSIX线程的实现接口相似，创建与使用ACL线程池库的步骤如下：</p><ul><li>acl_pthread_pool_attr_init: 初始化创建线程池对象所需要属性信息(可以通过 acl_pthread_pool_attr_set_threads_limit 设置线程池最大并发数及用 acl_pthread_pool_attr_set_idle_timeout 设置线程池中工作线程的空闲退出时间间隔)</li><li>acl_pthread_pool_create: 创建线程池对象</li><li>acl_pthread_pool_add: 向线程池中添加新任务，新任务将由线程池中的某一工作线程执行</li><li>acl_pthread_pool_destroy: 通知并等待线程池中的工作线程执行完任务后退出，同时销毁线程池对象</li></ul><p>还可以在选择在创建线程池对象后，调用 acl_pthread_pool_atinit 设置工作线程第一次被创建时回调用户自定义函数过程，或当线程空闲退出后调用 acl_pthread_pool_atfree 中设置的回调函数。<br>另外，可以将创建线程池的过程进行一抽象，写成如下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 创建半驻留线程池的过程</span><br><span class="hljs-comment"> * @return &#123;acl_pthread_pool_t*&#125; 新创建的线程池句柄</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">acl_pthread_pool_t</span> *<span class="hljs-title">create_thread_pool</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span><br><span class="hljs-function"></span>&#123;<br><span class="hljs-type">acl_pthread_pool_t</span> *thr_pool;  <span class="hljs-comment">/* 线程池句柄 */</span><br><span class="hljs-type">int</span>  max_threads = <span class="hljs-number">100</span>;  <span class="hljs-comment">/* 最多并发100个线程 */</span><br><span class="hljs-type">int</span>  idle_timeout = <span class="hljs-number">10</span>;  <span class="hljs-comment">/* 每个工作线程空闲10秒后自动退出 */</span><br><span class="hljs-type">acl_pthread_pool_attr_t</span> attr;  <span class="hljs-comment">/* 线程池初始化时的属性 */</span><br><br><span class="hljs-comment">/* 初始化线程池对象属性 */</span><br><span class="hljs-built_in">acl_pthread_pool_attr_init</span>(&amp;attr);<br><span class="hljs-built_in">acl_pthread_pool_attr_set_threads_limit</span>(&amp;attr, max_threads);<br><span class="hljs-built_in">acl_pthread_pool_attr_set_idle_timeout</span>(&amp;attr, idle_timeout);<br><br><span class="hljs-comment">/* 创建半驻留线程句柄 */</span><br>thr_pool = <span class="hljs-built_in">acl_pthread_pool_create</span>(&amp;attr);<br><span class="hljs-built_in">assert</span>(thr_pool);<br><span class="hljs-keyword">return</span> (thr_pool);<br>&#125;<br></code></pre></td></tr></table></figure><p>其实，利用ACL创建线程池还有一个简化接口（只所以叫 acl_thread_xxx 没有加 p, 是因为这个接口不太遵守 Posix的一些规范），如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 更简单地创建线程对象的方法</span><br><span class="hljs-comment"> * @param threads_limit &#123;int&#125;  线程池中最大并发线程数</span><br><span class="hljs-comment"> * @param idle_timeout &#123;int&#125; 工作线程空闲超时退出时间(秒)，如果为0则工作线程永不退出</span><br><span class="hljs-comment"> * @return &#123;acl_pthread_pool_t*&#125;, 如果不为空则表示成功，否则失败</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function">ACL_API <span class="hljs-type">acl_pthread_pool_t</span> *<span class="hljs-title">acl_thread_pool_create</span><span class="hljs-params">(<span class="hljs-type">int</span> threads_limit, <span class="hljs-type">int</span> idle_timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>这样，用户就可以非常方便地创建自己的线程池了，而且别忘了，这个线程池还是可以是半驻留的（当然也是跨平台的，可以运行在　Linux&#x2F;Solaris&#x2F;FreeBSD&#x2F;Win32 的环境下）。</p><p>github：<a href="https://github.com/acl-dev/acl/">https://github.com/acl-dev/acl/</a><br>gitee：<a href="https://gitee.com/acl-dev/acl/">https://gitee.com/acl-dev/acl/</a></p>]]></content>
    
    
    <categories>
      
      <category>线程编程</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
