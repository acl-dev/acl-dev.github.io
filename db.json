{"meta":{"version":1,"warehouse":"4.0.2"},"models":{"Asset":[{"_id":"themes/landscape/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","path":"fancybox/fancybox_loading.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/blank.gif","path":"fancybox/blank.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","path":"fancybox/fancybox_loading@2x.gif","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","path":"fancybox/fancybox_sprite.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","path":"fancybox/fancybox_overlay.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","path":"fancybox/fancybox_sprite@2x.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","path":"fancybox/jquery.fancybox.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","path":"fancybox/jquery.fancybox.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","path":"fancybox/jquery.fancybox.pack.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/js/script.js","path":"js/script.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","path":"css/fonts/FontAwesome.otf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","path":"css/fonts/fontawesome-webfont.eot","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","path":"css/fonts/fontawesome-webfont.svg","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","path":"css/fonts/fontawesome-webfont.ttf","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","path":"css/fonts/fontawesome-webfont.woff","modified":0,"renderable":1},{"_id":"themes/landscape/source/css/images/banner.jpg","path":"css/images/banner.jpg","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","path":"fancybox/helpers/fancybox_buttons.png","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","path":"fancybox/helpers/jquery.fancybox-buttons.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","path":"fancybox/helpers/jquery.fancybox-media.js","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","path":"fancybox/helpers/jquery.fancybox-buttons.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","path":"fancybox/helpers/jquery.fancybox-thumbs.css","modified":0,"renderable":1},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","path":"fancybox/helpers/jquery.fancybox-thumbs.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/gitalk.css","path":"css/gitalk.css","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight-dark.styl","path":"css/highlight-dark.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/css/main.styl","path":"css/main.styl","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/fluid.png","path":"img/fluid.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/avatar.png","path":"img/avatar.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/default.png","path":"img/default.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/loading.gif","path":"img/loading.gif","modified":0,"renderable":1},{"_id":"themes/fluid/source/img/police_beian.png","path":"img/police_beian.png","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/color-schema.js","path":"js/color-schema.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/boot.js","path":"js/boot.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/img-lazyload.js","path":"js/img-lazyload.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/leancloud.js","path":"js/leancloud.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/local-search.js","path":"js/local-search.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/plugins.js","path":"js/plugins.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/utils.js","path":"js/utils.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/js/events.js","path":"js/events.js","modified":0,"renderable":1},{"_id":"themes/fluid/source/xml/local-search.xml","path":"xml/local-search.xml","modified":0,"renderable":1},{"_id":"source/doc.tgz","path":"doc.tgz","modified":0,"renderable":0},{"_id":"source/img/aio_architecture.png","path":"img/aio_architecture.png","modified":0,"renderable":0},{"_id":"source/img/benchmark.png","path":"img/benchmark.png","modified":0,"renderable":0},{"_id":"source/img/dead_lock.png","path":"img/dead_lock.png","modified":0,"renderable":0},{"_id":"source/img/fiber_depedence.png","path":"img/fiber_depedence.png","modified":0,"renderable":0},{"_id":"source/img/fiber_event.png","path":"img/fiber_event.png","modified":0,"renderable":0},{"_id":"source/img/fiber_cond.png","path":"img/fiber_cond.png","modified":0,"renderable":0},{"_id":"source/img/fiber_lock.png","path":"img/fiber_lock.png","modified":0,"renderable":0},{"_id":"source/img/fiber_running.png","path":"img/fiber_running.png","modified":0,"renderable":0},{"_id":"source/img/fiber_io_switch.png","path":"img/fiber_io_switch.png","modified":0,"renderable":0},{"_id":"source/img/fiber_sem.png","path":"img/fiber_sem.png","modified":0,"renderable":0},{"_id":"source/img/fiber_switch.png","path":"img/fiber_switch.png","modified":0,"renderable":0},{"_id":"source/img/hpdns.png","path":"img/hpdns.png","modified":0,"renderable":0},{"_id":"source/img/fiber_schedule.png","path":"img/fiber_schedule.png","modified":0,"renderable":0},{"_id":"source/img/nio_read.png","path":"img/nio_read.png","modified":0,"renderable":0},{"_id":"source/img/qixun.png","path":"img/qixun.png","modified":0,"renderable":0},{"_id":"source/img/loadbalance.png","path":"img/loadbalance.png","modified":0,"renderable":0},{"_id":"source/img/aio_inherit.jpg","path":"img/aio_inherit.jpg","modified":0,"renderable":0},{"_id":"source/img/aio_inherit.png","path":"img/aio_inherit.png","modified":0,"renderable":0},{"_id":"source/img/aio_callback.png","path":"img/aio_callback.png","modified":0,"renderable":0},{"_id":"source/img/redis_builder.png","path":"img/redis_builder.png","modified":0,"renderable":0},{"_id":"source/img/redis_commands.png","path":"img/redis_commands.png","modified":0,"renderable":0},{"_id":"source/img/redis_commands2.png","path":"img/redis_commands2.png","modified":0,"renderable":0},{"_id":"source/img/redis_help.png","path":"img/redis_help.png","modified":0,"renderable":0},{"_id":"source/img/redis_get.png","path":"img/redis_get.png","modified":0,"renderable":0},{"_id":"source/img/redis_status.png","path":"img/redis_status.png","modified":0,"renderable":0},{"_id":"source/img/redis_hash_get.png","path":"img/redis_hash_get.png","modified":0,"renderable":0},{"_id":"source/img/redis_dbsize.png","path":"img/redis_dbsize.png","modified":0,"renderable":0},{"_id":"source/img/redis_nodes.png","path":"img/redis_nodes.png","modified":0,"renderable":0},{"_id":"source/img/redis_set.png","path":"img/redis_set.png","modified":0,"renderable":0},{"_id":"source/img/db.png","path":"img/db.png","modified":0,"renderable":0},{"_id":"source/img/db2.png","path":"img/db2.png","modified":0,"renderable":0},{"_id":"source/img/aio_rpc_mfc.png","path":"img/aio_rpc_mfc.png","modified":0,"renderable":0}],"Cache":[{"_id":"source/_posts/hello-world.md","hash":"7d98d6592de80fdcd2949bd7401cec12afd98cdf","modified":1674400886647},{"_id":"themes/landscape/.npmignore","hash":"58d26d4b5f2f94c2d02a4e4a448088e4a2527c77","modified":1674400886649},{"_id":"themes/landscape/Gruntfile.js","hash":"71adaeaac1f3cc56e36c49d549b8d8a72235c9b9","modified":1674400886647},{"_id":"themes/landscape/LICENSE","hash":"c480fce396b23997ee23cc535518ffaaf7f458f8","modified":1674400886647},{"_id":"themes/landscape/README.md","hash":"37fae88639ef60d63bd0de22314d7cc4c5d94b07","modified":1674400886647},{"_id":"themes/landscape/_config.yml","hash":"79ac6b9ed6a4de5a21ea53fc3f5a3de92e2475ff","modified":1674400886647},{"_id":"themes/landscape/package.json","hash":"544f21a0b2c7034998b36ae94dba6e3e0f39f228","modified":1674400886647},{"_id":"themes/landscape/layout/category.ejs","hash":"765426a9c8236828dc34759e604cc2c52292835a","modified":1674400886650},{"_id":"themes/landscape/layout/archive.ejs","hash":"2703b07cc8ac64ae46d1d263f4653013c7e1666b","modified":1674400886648},{"_id":"themes/landscape/layout/index.ejs","hash":"aa1b4456907bdb43e629be3931547e2d29ac58c8","modified":1674400886650},{"_id":"themes/landscape/layout/layout.ejs","hash":"f155824ca6130080bb057fa3e868a743c69c4cf5","modified":1674400886651},{"_id":"themes/landscape/layout/post.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1674400886651},{"_id":"themes/landscape/layout/page.ejs","hash":"7d80e4e36b14d30a7cd2ac1f61376d9ebf264e8b","modified":1674400886651},{"_id":"themes/landscape/layout/tag.ejs","hash":"eaa7b4ccb2ca7befb90142e4e68995fb1ea68b2e","modified":1674400886651},{"_id":"themes/landscape/languages/de.yml","hash":"3ebf0775abbee928c8d7bda943c191d166ded0d3","modified":1674400886647},{"_id":"themes/landscape/languages/es.yml","hash":"76edb1171b86532ef12cfd15f5f2c1ac3949f061","modified":1674400886651},{"_id":"themes/landscape/languages/default.yml","hash":"3083f319b352d21d80fc5e20113ddf27889c9d11","modified":1674400886649},{"_id":"themes/landscape/languages/ja.yml","hash":"a73e1b9c80fd6e930e2628b393bfe3fb716a21a9","modified":1674400886649},{"_id":"themes/landscape/languages/fr.yml","hash":"415e1c580ced8e4ce20b3b0aeedc3610341c76fb","modified":1674400886649},{"_id":"themes/landscape/languages/nl.yml","hash":"12ed59faba1fc4e8cdd1d42ab55ef518dde8039c","modified":1674400886650},{"_id":"themes/landscape/languages/no.yml","hash":"965a171e70347215ec726952e63f5b47930931ef","modified":1674400886649},{"_id":"themes/landscape/languages/pt.yml","hash":"57d07b75d434fbfc33b0ddb543021cb5f53318a8","modified":1674400886649},{"_id":"themes/landscape/scripts/fancybox.js","hash":"aa411cd072399df1ddc8e2181a3204678a5177d9","modified":1674400886651},{"_id":"themes/landscape/languages/zh-CN.yml","hash":"ca40697097ab0b3672a80b455d3f4081292d1eed","modified":1674400886650},{"_id":"themes/landscape/languages/ru.yml","hash":"4fda301bbd8b39f2c714e2c934eccc4b27c0a2b0","modified":1674400886650},{"_id":"themes/landscape/languages/zh-TW.yml","hash":"53ce3000c5f767759c7d2c4efcaa9049788599c3","modified":1674400886650},{"_id":"themes/landscape/layout/_partial/after-footer.ejs","hash":"d0d753d39038284d52b10e5075979cc97db9cd20","modified":1674400886652},{"_id":"themes/landscape/layout/_partial/archive-post.ejs","hash":"c7a71425a946d05414c069ec91811b5c09a92c47","modified":1674400886652},{"_id":"themes/landscape/languages/ko.yml","hash":"881d6a0a101706e0452af81c580218e0bfddd9cf","modified":1674400886649},{"_id":"themes/landscape/layout/_partial/article.ejs","hash":"c4c835615d96a950d51fa2c3b5d64d0596534fed","modified":1674400886652},{"_id":"themes/landscape/layout/_partial/footer.ejs","hash":"93518893cf91287e797ebac543c560e2a63b8d0e","modified":1674400886653},{"_id":"themes/landscape/layout/_partial/head.ejs","hash":"5abf77aec957d9445fc71a8310252f0013c84578","modified":1674400886653},{"_id":"themes/landscape/layout/_partial/google-analytics.ejs","hash":"f921e7f9223d7c95165e0f835f353b2938e40c45","modified":1674400886653},{"_id":"themes/landscape/layout/_partial/gauges-analytics.ejs","hash":"aad6312ac197d6c5aaf2104ac863d7eba46b772a","modified":1674400886653},{"_id":"themes/landscape/layout/_partial/mobile-nav.ejs","hash":"e952a532dfc583930a666b9d4479c32d4a84b44e","modified":1674400886654},{"_id":"themes/landscape/layout/_partial/header.ejs","hash":"7e749050be126eadbc42decfbea75124ae430413","modified":1674400886653},{"_id":"themes/landscape/layout/_partial/sidebar.ejs","hash":"930da35cc2d447a92e5ee8f835735e6fd2232469","modified":1674400886654},{"_id":"themes/landscape/layout/_widget/tag.ejs","hash":"2de380865df9ab5f577f7d3bcadf44261eb5faae","modified":1674400886654},{"_id":"themes/landscape/layout/_widget/archive.ejs","hash":"beb4a86fcc82a9bdda9289b59db5a1988918bec3","modified":1674400886652},{"_id":"themes/landscape/layout/_widget/category.ejs","hash":"dd1e5af3c6af3f5d6c85dfd5ca1766faed6a0b05","modified":1674400886653},{"_id":"themes/landscape/layout/_widget/tagcloud.ejs","hash":"b4a2079101643f63993dcdb32925c9b071763b46","modified":1674400886654},{"_id":"themes/landscape/layout/_widget/recent_posts.ejs","hash":"0d4f064733f8b9e45c0ce131fe4a689d570c883a","modified":1674400886653},{"_id":"themes/landscape/source/css/_extend.styl","hash":"222fbe6d222531d61c1ef0f868c90f747b1c2ced","modified":1674400886656},{"_id":"themes/landscape/source/css/style.styl","hash":"a70d9c44dac348d742702f6ba87e5bb3084d65db","modified":1674400886663},{"_id":"themes/landscape/source/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1674400886663},{"_id":"themes/landscape/source/css/_variables.styl","hash":"628e307579ea46b5928424313993f17b8d729e92","modified":1674400886663},{"_id":"themes/landscape/source/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1674400886663},{"_id":"themes/landscape/source/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1674400886655},{"_id":"themes/landscape/layout/_partial/archive.ejs","hash":"950ddd91db8718153b329b96dc14439ab8463ba5","modified":1674400886652},{"_id":"themes/landscape/source/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1674400886655},{"_id":"themes/landscape/source/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1674400886655},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1674400886657},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1674400886655},{"_id":"themes/landscape/source/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1674400886655},{"_id":"themes/landscape/source/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1674400886656},{"_id":"themes/landscape/source/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1674400886663},{"_id":"themes/landscape/layout/_partial/post/date.ejs","hash":"6197802873157656e3077c5099a7dda3d3b01c29","modified":1674400886657},{"_id":"themes/landscape/layout/_partial/post/tag.ejs","hash":"2fcb0bf9c8847a644167a27824c9bb19ac74dd14","modified":1674400886658},{"_id":"themes/landscape/layout/_partial/post/category.ejs","hash":"c6bcd0e04271ffca81da25bcff5adf3d46f02fc0","modified":1674400886655},{"_id":"themes/landscape/layout/_partial/post/nav.ejs","hash":"16a904de7bceccbb36b4267565f2215704db2880","modified":1674400886658},{"_id":"themes/landscape/layout/_partial/post/gallery.ejs","hash":"3d9d81a3c693ff2378ef06ddb6810254e509de5b","modified":1674400886657},{"_id":"themes/landscape/source/css/_util/grid.styl","hash":"0bf55ee5d09f193e249083602ac5fcdb1e571aed","modified":1674400886663},{"_id":"themes/landscape/layout/_partial/post/title.ejs","hash":"2f275739b6f1193c123646a5a31f37d48644c667","modified":1674400886658},{"_id":"themes/landscape/source/css/_util/mixin.styl","hash":"44f32767d9fd3c1c08a60d91f181ee53c8f0dbb3","modified":1674400886663},{"_id":"themes/landscape/source/css/_partial/archive.styl","hash":"db15f5677dc68f1730e82190bab69c24611ca292","modified":1674400886656},{"_id":"themes/landscape/source/css/_partial/article.styl","hash":"10685f8787a79f79c9a26c2f943253450c498e3e","modified":1674400886659},{"_id":"themes/landscape/source/css/_partial/comment.styl","hash":"79d280d8d203abb3bd933ca9b8e38c78ec684987","modified":1674400886658},{"_id":"themes/landscape/source/css/_partial/footer.styl","hash":"e35a060b8512031048919709a8e7b1ec0e40bc1b","modified":1674400886659},{"_id":"themes/landscape/source/css/_partial/mobile.styl","hash":"a399cf9e1e1cec3e4269066e2948d7ae5854d745","modified":1674400886660},{"_id":"themes/landscape/source/css/_partial/header.styl","hash":"85ab11e082f4dd86dde72bed653d57ec5381f30c","modified":1674400886658},{"_id":"themes/landscape/source/css/_partial/sidebar-aside.styl","hash":"890349df5145abf46ce7712010c89237900b3713","modified":1674400886659},{"_id":"themes/landscape/source/css/_partial/highlight.styl","hash":"bf4e7be1968dad495b04e83c95eac14c4d0ad7c0","modified":1674400886658},{"_id":"themes/landscape/source/css/_partial/sidebar.styl","hash":"404ec059dc674a48b9ab89cd83f258dec4dcb24d","modified":1674400886660},{"_id":"themes/landscape/source/css/_partial/sidebar-bottom.styl","hash":"8fd4f30d319542babfd31f087ddbac550f000a8a","modified":1674400886659},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1674400886661},{"_id":"themes/landscape/source/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1674400886657},{"_id":"themes/landscape/source/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1674400886657},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1674400886662},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1674400886662},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1674400886662},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1674400886661},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1674400886662},{"_id":"themes/landscape/source/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1674400886662},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1674400886661},{"_id":"themes/landscape/source/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1674400886662},{"_id":"themes/landscape/source/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1674400886659},{"_id":"public/2023/01/22/hello-world/index.html","hash":"5597627c571b78f4ebfdeb824e397baaa4ec3765","modified":1674442416201},{"_id":"public/archives/index.html","hash":"facda4d3068ab50ae7a1df18f62057efd088e4e0","modified":1674914191248},{"_id":"public/archives/2023/index.html","hash":"f7e867d15c39f454eeb37dfece14092caf1ecabf","modified":1674444388320},{"_id":"public/archives/2023/01/index.html","hash":"967e275297da74aacd2608000255de5ccb58d08a","modified":1674444388320},{"_id":"public/index.html","hash":"c3785277f173c47b1b60adb4fa6f0bcd5c533cc4","modified":1674914191248},{"_id":"public/fancybox/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1674914191248},{"_id":"public/fancybox/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1674914191248},{"_id":"public/fancybox/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1674914191248},{"_id":"public/fancybox/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1674914191248},{"_id":"public/css/fonts/FontAwesome.otf","hash":"b5b4f9be85f91f10799e87a083da1d050f842734","modified":1674914191248},{"_id":"public/fancybox/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1674914191248},{"_id":"public/fancybox/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1674914191248},{"_id":"public/css/fonts/fontawesome-webfont.woff","hash":"04c3bf56d87a0828935bd6b4aee859995f321693","modified":1674914191248},{"_id":"public/css/fonts/fontawesome-webfont.eot","hash":"7619748fe34c64fb157a57f6d4ef3678f63a8f5e","modified":1674914191248},{"_id":"public/fancybox/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1674914191248},{"_id":"public/fancybox/jquery.fancybox.css","hash":"aaa582fb9eb4b7092dc69fcb2d5b1c20cca58ab6","modified":1674914191248},{"_id":"public/js/script.js","hash":"2876e0b19ce557fca38d7c6f49ca55922ab666a1","modified":1674914191248},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.js","hash":"dc3645529a4bf72983a39fa34c1eb9146e082019","modified":1674914191248},{"_id":"public/fancybox/helpers/jquery.fancybox-media.js","hash":"294420f9ff20f4e3584d212b0c262a00a96ecdb3","modified":1674914191248},{"_id":"public/fancybox/helpers/jquery.fancybox-buttons.css","hash":"1a9d8e5c22b371fcc69d4dbbb823d9c39f04c0c8","modified":1674914191248},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.css","hash":"4ac329c16a5277592fc12a37cca3d72ca4ec292f","modified":1674914191248},{"_id":"public/fancybox/helpers/jquery.fancybox-thumbs.js","hash":"47da1ae5401c24b5c17cc18e2730780f5c1a7a0c","modified":1674914191248},{"_id":"public/css/style.css","hash":"5673af1e8e0b02135e5a5ae176fc47916ba2cd12","modified":1674914191248},{"_id":"public/fancybox/jquery.fancybox.js","hash":"d08b03a42d5c4ba456ef8ba33116fdbb7a9cabed","modified":1674914191248},{"_id":"public/fancybox/jquery.fancybox.pack.js","hash":"9e0d51ca1dbe66f6c0c7aefd552dc8122e694a6e","modified":1674914191248},{"_id":"public/css/fonts/fontawesome-webfont.ttf","hash":"7f09c97f333917034ad08fa7295e916c9f72fd3f","modified":1674914191248},{"_id":"public/css/fonts/fontawesome-webfont.svg","hash":"46fcc0194d75a0ddac0a038aee41b23456784814","modified":1674914191248},{"_id":"public/css/images/banner.jpg","hash":"f44aa591089fcb3ec79770a1e102fd3289a7c6a6","modified":1674914191248},{"_id":"themes/fluid/source/css/_pages/_tag/tag.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1670937168000},{"_id":"themes/fluid/.editorconfig","hash":"33218fbd623feb43edf5f99f15965392cecc44a6","modified":1670937168000},{"_id":"themes/fluid/.gitattributes","hash":"a54f902957d49356376b59287b894b1a3d7a003f","modified":1670937168000},{"_id":"themes/fluid/.eslintrc","hash":"4bc2b19ce2b8c4d242f97d4ccf2d741e68ab0097","modified":1670937168000},{"_id":"themes/fluid/LICENSE","hash":"26f9356fd6e84b5a88df6d9014378f41b65ba209","modified":1670937168000},{"_id":"themes/fluid/.gitignore","hash":"ae3bfcb89777657c5dfb5169d91445dcb0e5ab98","modified":1670937168000},{"_id":"themes/fluid/README.md","hash":"6d752df6f2278033dc2512a7d5be22c8a8eb665a","modified":1670937168000},{"_id":"themes/fluid/README_en.md","hash":"8c874f309e346fffa392e174385b5cc08510f218","modified":1670937168000},{"_id":"themes/fluid/_config.yml","hash":"15290867ce0d20499fa58805dbaa1dcedbc7e35c","modified":1674556381213},{"_id":"themes/fluid/package.json","hash":"d2755d616bfad3e74f4067117b6ea834a5cb0893","modified":1674443706858},{"_id":"themes/fluid/languages/de.yml","hash":"0e7d455d9e004ff15d8924b7a0c35cea25ee5b1d","modified":1670937168000},{"_id":"themes/fluid/languages/eo.yml","hash":"a556251cc50a5680578c03f1efbf252b1f4ab860","modified":1670937168000},{"_id":"themes/fluid/languages/en.yml","hash":"cb11b39f44ea069652c9647179606b6cecc98d50","modified":1670937168000},{"_id":"themes/fluid/languages/es.yml","hash":"7112594259c88c04714be152af7fd377687dad40","modified":1670937168000},{"_id":"themes/fluid/languages/ja.yml","hash":"3dd6d20f8d26585a7c154a8e59fe8d5d902f4c6a","modified":1670937168000},{"_id":"themes/fluid/languages/zh-CN.yml","hash":"f96a22f989897ecddc69d5867a206e1cf6b8f610","modified":1670937168000},{"_id":"themes/fluid/languages/ru.yml","hash":"7dc78f22696649a4c68dc65a9b52d9a992fa82a0","modified":1670937168000},{"_id":"themes/fluid/languages/zh-HK.yml","hash":"80ed400a7adaa92ea54fc7f5d534c9af795bed00","modified":1670937168000},{"_id":"themes/fluid/languages/zh-TW.yml","hash":"596d031dff3826ae8e4ffc8931fff28977b73247","modified":1670937168000},{"_id":"themes/fluid/layout/404.ejs","hash":"b84d575c7b7f778b4cb64e89ad3d0aed4a896820","modified":1670937168000},{"_id":"themes/fluid/layout/about.ejs","hash":"163bee643e6a38912d3ae70923c83c48d57222e7","modified":1670937168000},{"_id":"themes/fluid/layout/archive.ejs","hash":"7c1f44005849791feae4abaa10fae4cb983d3277","modified":1670937168000},{"_id":"themes/fluid/layout/categories.ejs","hash":"13859726c27b6c79b5876ec174176d0f9c1ee164","modified":1670937168000},{"_id":"themes/fluid/layout/category.ejs","hash":"f099161b738a16a32253f42085b5444f902018ed","modified":1670937168000},{"_id":"themes/fluid/layout/index.ejs","hash":"db000a6a0cec19d32a6e7e94cd4c478500d9c5ac","modified":1670937168000},{"_id":"themes/fluid/layout/links.ejs","hash":"1cac32ec4579aaf7b9fa39d317497331d4c5e1dd","modified":1670937168000},{"_id":"themes/fluid/layout/layout.ejs","hash":"7e0023474128fbe4d68c467704c41f1712432415","modified":1670937168000},{"_id":"themes/fluid/layout/page.ejs","hash":"ed5007a3feb8f14d3d2843271bfb298eb0c56219","modified":1670937168000},{"_id":"themes/fluid/layout/post.ejs","hash":"505bcc06e55066b7cc5551d9ac0694e7713bfab5","modified":1670937168000},{"_id":"themes/fluid/layout/tag.ejs","hash":"9d686364c4d16a1a9219471623af452035c5b966","modified":1670937168000},{"_id":"themes/fluid/layout/tags.ejs","hash":"1d06af34b6cf1d8a20d2eb565e309326ceba309f","modified":1670937168000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report.md","hash":"554c0d0e086a0784d83ee71c83f8bceeb60aecc8","modified":1670937168000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/bug_report_zh.md","hash":"c8b0d49c49e3c88872fd3b37909345ff5b2b6aa0","modified":1670937168000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question.md","hash":"ab5eab9e3ff889c4ba7fd82846e7f5b7ae15bebc","modified":1670937168000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request_zh.md","hash":"ed08574b196447376dd74411cca664ac9227a5d4","modified":1670937168000},{"_id":"themes/fluid/.github/workflows/limit.yaml","hash":"f8bd2edeb4424ee7a055b31583445d5d5dff91a4","modified":1670937168000},{"_id":"themes/fluid/.github/workflows/publish.yaml","hash":"6f02e6440d88629229556e3fd47d0280fe2240db","modified":1670937168000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/feature_request.md","hash":"c134dd57ffd269b93402ccfffe7dbe0f0b583bec","modified":1670937168000},{"_id":"themes/fluid/.github/ISSUE_TEMPLATE/question_zh.md","hash":"fff07ce0472afc368d388637cb9d438195da9b5b","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/category-chains.ejs","hash":"18309584aab83bc4deb20723ebad832149dd2e24","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments.ejs","hash":"d707c47b2638c94e489bc43d4cfd098b7c58447f","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/archive-list.ejs","hash":"7520fbf91f762207c2ab06b2c293235cd5b23905","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/category-list.ejs","hash":"f8d2f1907450e61968e6d54443e9be8138196a77","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/css.ejs","hash":"85f6e051550907681ab4ed2e268ac8f6e9ebf931","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/head.ejs","hash":"7b7b1d098726e86687a15fe3d520d178577ffcae","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/footer.ejs","hash":"10ccfb8eef4e16182183c9a3e175c90d5b6397d3","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/header.ejs","hash":"0d5e397d30051e5fbabe7b47cfd1f1e6a5820af1","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/markdown-plugins.ejs","hash":"fc4bdf7de0cf1a66d0e5e4fba1b31d6f7ed49468","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/paginator.ejs","hash":"0f38a2c238169edcb63fc46c23bfc529ff3859b7","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/search.ejs","hash":"70e1c929e084ca8a2648cedabf29b372511ea2b8","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/scripts.ejs","hash":"da5810785105e5075861593c7ac22c7aa9665a72","modified":1670937168000},{"_id":"themes/fluid/scripts/events/index.js","hash":"79de5a379b28cad759a49048351c7f6b8915bd7d","modified":1670937168000},{"_id":"themes/fluid/scripts/filters/post-filter.js","hash":"d516b9db63067f9ea9c72cc75ae4ff358417e77d","modified":1670937168000},{"_id":"themes/fluid/scripts/filters/locals.js","hash":"58d0fec976f6b1d35e7ea03edc45414088acf05c","modified":1670937168000},{"_id":"themes/fluid/scripts/generators/local-search.js","hash":"fc2c50405b771b06b7f6cfc4e9de97b992691555","modified":1670937168000},{"_id":"themes/fluid/scripts/generators/pages.js","hash":"d9971f15fbb6b775e3d31a1b9b45011959395010","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/date.js","hash":"9bda6382f61b40a20c24af466fe10c8366ebb74c","modified":1670937168000},{"_id":"themes/fluid/scripts/filters/default-injects.js","hash":"b2013ae8e189cd07ebc8a2ff48a78e153345210f","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/engine.js","hash":"d3a231d106795ce99cb0bc77eb65f9ae44515933","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/import.js","hash":"ca53e8dbf7d44cfd372cfa79ac60f35a7d5b0076","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/export-config.js","hash":"47e6dba7652a621a54067413490a11c8a89e3d7b","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/page.js","hash":"4607607445233b3029ef20ed5e91de0da0a7f9c5","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/scope.js","hash":"d41d9d658fcb54964b388598e996747aadb85b0f","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/injects.js","hash":"1ad2ae6b11bd8806ee7dd6eb7140d8b54a95d613","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/url.js","hash":"2a6a8288176d0e0f6ec008056bf2745a86e8943e","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/utils.js","hash":"226f99b465ff513de075a8e78b321d6cb62592ca","modified":1670937168000},{"_id":"themes/fluid/scripts/tags/button.js","hash":"3eb43a8cdea0a64576ad6b31b4df6c2bf5698d4c","modified":1670937168000},{"_id":"themes/fluid/scripts/helpers/wordcount.js","hash":"4543b8954c5c2ca91191cc0d53cf071b3f26faaa","modified":1670937168000},{"_id":"themes/fluid/scripts/tags/checkbox.js","hash":"4938610c3543a921a341bc074626d511cb1a4b45","modified":1670937168000},{"_id":"themes/fluid/scripts/tags/label.js","hash":"f05a6d32cca79535b22907dc03edb9d3fa2d8176","modified":1670937168000},{"_id":"themes/fluid/scripts/tags/group-image.js","hash":"4aeebb797026f1df25646a5d69f7fde79b1bcd26","modified":1670937168000},{"_id":"themes/fluid/scripts/tags/mermaid.js","hash":"75160561e1ef3603b6d2ad2938464ab1cb77fd38","modified":1670937168000},{"_id":"themes/fluid/scripts/tags/note.js","hash":"f52f3a005b41f48b4da274ac64710177c8d4502f","modified":1670937168000},{"_id":"themes/fluid/scripts/utils/compare-versions.js","hash":"dbbc928c914fc2bd242cd66aa0c45971aec13a5d","modified":1670937168000},{"_id":"themes/fluid/scripts/utils/resolve.js","hash":"8c4a8b62aa8608f12f1e9046231dff04859dc3e9","modified":1670937168000},{"_id":"themes/fluid/scripts/utils/object.js","hash":"33b57e4decdc5e75c518859f168c8ba80b2c665b","modified":1670937168000},{"_id":"themes/fluid/scripts/utils/url-join.js","hash":"718aab5e7b2059a06b093ca738de420d9afa44ba","modified":1670937168000},{"_id":"themes/fluid/source/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1670937168000},{"_id":"themes/fluid/source/css/highlight-dark.styl","hash":"45695ef75c31a4aa57324dd408b7e2327a337018","modified":1670937168000},{"_id":"themes/fluid/source/css/highlight.styl","hash":"a9efc52a646a9e585439c768557e3e3c9e3326dc","modified":1670937168000},{"_id":"themes/fluid/source/css/main.styl","hash":"855ae5fe229c51afa57f7645f6997a27a705d7e4","modified":1670937168000},{"_id":"themes/fluid/source/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1670937168000},{"_id":"themes/fluid/source/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1670937168000},{"_id":"themes/fluid/source/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1670937168000},{"_id":"themes/fluid/source/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1670937168000},{"_id":"themes/fluid/source/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1670937168000},{"_id":"themes/fluid/source/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1670937168000},{"_id":"themes/fluid/source/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1670937168000},{"_id":"themes/fluid/source/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1670937168000},{"_id":"themes/fluid/source/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1670937168000},{"_id":"themes/fluid/source/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1670937168000},{"_id":"themes/fluid/source/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1670937168000},{"_id":"themes/fluid/source/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1670937168000},{"_id":"themes/fluid/source/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/changyan.ejs","hash":"c9b2d68ed3d375f1953e7007307d2a3f75ed6249","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/giscus.ejs","hash":"95f8b866b158eff9352c381c243b332a155a5110","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/disqus.ejs","hash":"aab4a4d24c55231a37db308ae94414319cecdd9b","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/cusdis.ejs","hash":"5f9dc012be27040bbe874d0c093c0d53958cc987","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/gitalk.ejs","hash":"843bc141a4545eb20d1c92fb63c85d459b4271ec","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/livere.ejs","hash":"2264758fed57542a7389c7aa9f00f1aefa17eb87","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/remark42.ejs","hash":"d4e9532feeb02aed61bd15eda536b5b631454dac","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/twikoo.ejs","hash":"e6820fb7f13662c42f8433ec95404238f4c1860c","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/utterances.ejs","hash":"c7ccf7f28308334a6da6f5425b141a24b5eca0e2","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/valine.ejs","hash":"19ba937553dddd317f827d682661a1066a7b1f30","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/comments/waline.ejs","hash":"12727da7cf3ac83443270f550be4d1c06135b52b","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/footer/beian.ejs","hash":"4fb9b5dd3f3e41a586d6af44e5069afe7c81fff2","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/footer/statistics.ejs","hash":"454d8dd4c39f9494ebeb03ca0746f5bc122af76a","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/header/banner.ejs","hash":"e07757b59e7b89eea213d0e595cb5932f812fd32","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/analytics.ejs","hash":"1327395a4dde1ea06c476b047fb110bcd269149f","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/header/navigation.ejs","hash":"870db75e4e403a840c4463dfeed2c9114846e7cc","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/anchorjs.ejs","hash":"40181442d3a2b8734783a0ad7caf2d2522e3f2ab","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/code-widget.ejs","hash":"3a505cba37942badf62a56bbb8b605b72af330aa","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/encrypt.ejs","hash":"e3713fa78e0fc14a239360b020068d8513573ae4","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/highlight.ejs","hash":"7529dd215b09d3557804333942377b9e20fa554e","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/fancybox.ejs","hash":"9d1ea2a46b8c8ad8c168594d578f40764818ef13","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/math.ejs","hash":"dcbf9a381ee76f2f1f75fcbc22c50a502ec85023","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/mermaid.ejs","hash":"e49506e9895e255e0e53f34a11d325f83109c1b0","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/typed.ejs","hash":"51faef29f8e464bcb2e73049b428b88c8dd8b40a","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/plugins/nprogress.ejs","hash":"4c2d39ce816b8a6dcd6b53113c8695f8bd650a23","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/post/category-bar.ejs","hash":"8772bce97ed297e7a88523f4e939ed6436c22f87","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/post/meta-bottom.ejs","hash":"7079b27a7bc15a7dfa9209f6be6051bdec49ebad","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/post/copyright.ejs","hash":"9d13392cea94b66d86422ad17c66e5ae67ce1d32","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/post/meta-top.ejs","hash":"ce6e9f578f4faa45840abddf8f46af3f4b69c177","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/post/sidebar-left.ejs","hash":"9992c99b3eb728ad195970e1b84d665f2c8691c4","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/post/sidebar-right.ejs","hash":"d5fcc9b60e02f869a29a8c17a16a6028ecc1e6d8","modified":1670937168000},{"_id":"themes/fluid/layout/_partials/post/toc.ejs","hash":"635a89060fbf72eeda066fc4bd0a97462f069417","modified":1670937168000},{"_id":"themes/fluid/scripts/events/lib/compatible-configs.js","hash":"ef474d1fa5bbafc52619ced0f9dc7eaf2affb363","modified":1670937168000},{"_id":"themes/fluid/scripts/events/lib/hello.js","hash":"44c5eb97b98813a07c659d6afedd17fad63b1821","modified":1670937168000},{"_id":"themes/fluid/scripts/events/lib/highlight.js","hash":"0f02df2244e275595e72163498d42f42bcf0de5e","modified":1670937168000},{"_id":"themes/fluid/scripts/events/lib/injects.js","hash":"5ae4b07204683e54b5a1b74e931702bbce2ac23e","modified":1670937168000},{"_id":"themes/fluid/scripts/events/lib/merge-configs.js","hash":"7c944c43b2ece5dd84859bd9d1fe955d13427387","modified":1670937168000},{"_id":"themes/fluid/scripts/events/lib/lazyload.js","hash":"9ba0d4bc224e22af8a5a48d6ff13e5a0fcfee2a4","modified":1670937168000},{"_id":"themes/fluid/source/css/_functions/base.styl","hash":"2e46f3f4e2c9fe34c1ff1c598738fc7349ae8188","modified":1670937168000},{"_id":"themes/fluid/scripts/events/lib/footnote.js","hash":"2ec2ae03c79bb1ae7ac3fcf7e00fb52d1af2898d","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/pages.styl","hash":"b8e887bc7fb3b765a1f8ec9448eff8603a41984f","modified":1670937168000},{"_id":"themes/fluid/source/css/_variables/base.styl","hash":"4ed5f0ae105ef4c7dd92eaf652ceda176c38e502","modified":1670937168000},{"_id":"themes/fluid/source/css/_mixins/base.styl","hash":"542e306ee9494e8a78e44d6d7d409605d94caeb3","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/base.styl","hash":"643284c567665f96915f0b64e59934dda315f74d","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/keyframes.styl","hash":"94065ea50f5bef7566d184f2422f6ac20866ba22","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_archive/archive.styl","hash":"c475e6681546d30350eaed11f23081ecae80c375","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/inline.styl","hash":"411a3fa3f924a87e00ff04d18b5c83283b049a4d","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/color-schema.styl","hash":"61279540c2623ea4bf93e40613d41380839b92d3","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_category/category-bar.styl","hash":"cc6df43fef6bb3efecbfdd8b9e467424a1dea581","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_index/index.styl","hash":"0acbd71633bcc7191672ea4e1b2277bea350d73b","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_category/category-list.styl","hash":"7edfe1b571ecca7d08f5f4dbcf76f4ffdcfbf0b5","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_links/links.styl","hash":"5c7f2044e3f1da05a3229537c06bd879836f8d6e","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_post/highlight.styl","hash":"4df764d298fe556e501db4afc2b05686fe6ebcfb","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_post/post-page.styl","hash":"127bb5391370afe7fef2a297084d76406bc5e902","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_post/comment.styl","hash":"780f3788e7357bcd3f3262d781cb91bb53976a93","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_category/category-chain.styl","hash":"0cdf7ef50dfd0669d3b257821384ff31cd81b7c9","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_post/post-tag.styl","hash":"27f70062415ccf66a9b6f4952db124fc1471fda5","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_post/markdown.styl","hash":"1e3d3a82721e7c10bcfcecec6d81cf2979039452","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_about/about.styl","hash":"97fe42516ea531fdad771489b68aa8b2a7f6ae46","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_tag/tags.styl","hash":"65bfc01c76abc927fa1a23bf2422892b0d566c3f","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/anchorjs.styl","hash":"e0cebda4a6f499aff75e71417d88caa7ceb13b94","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/banner.styl","hash":"7a0bd629bc234fc75e3cc8e3715ffada92f09e73","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/board.styl","hash":"4397037fc3f0033dbe546c33cd9dbdabd8cb1632","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/code-widget.styl","hash":"b66ab013f0f37d724a149b85b3c7432afcf460ad","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/copyright.styl","hash":"26f71a9cd60d96bb0cb5bbdf58150b8e524d9707","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footer.styl","hash":"2caaca71dd1ff63d583099ed817677dd267b457e","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/header.styl","hash":"c4459248c66ea1326feed021179b847ae91d465f","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/modal.styl","hash":"adf6c1e5c8e1fb41c77ce6e2258001df61245aa2","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/footnote.styl","hash":"ae9289cc89649af2042907f8a003303b987f3404","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/noscript.styl","hash":"0cf2f2bb44f456150d428016675d5876a9d2e2aa","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/ngrogress.styl","hash":"5d225357b4a58d46118e6616377168336ed44cb2","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/pagination.styl","hash":"8bb1b68e5f3552cb48c2ffa31edbc53646a8fb4c","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/qrcode.styl","hash":"78704a94c0436097abfb0e0a57abeb3429c749b7","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/scroll-btn.styl","hash":"f0e429a27fa8a7658fcbddbb4d4dbe4afa12499a","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/search.styl","hash":"10f7e91a91e681fb9fe46f9df7707b9ef78707c8","modified":1670937168000},{"_id":"themes/fluid/source/css/_pages/_base/_widget/toc.styl","hash":"9e7452aa2372153f25d7a4675c9d36d281a65d24","modified":1670937168000},{"_id":"themes/fluid/source/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1670937168000},{"_id":"public/local-search.xml","hash":"6f2d64d24e343495e4fb3749665fde1b460036b1","modified":1674914191248},{"_id":"public/404.html","hash":"060094a8201bb081d733e915cb4225a1f3a9e1ee","modified":1674914191248},{"_id":"public/tags/index.html","hash":"e5f683a19c8fc2a0dcd04a42ddbff0c12dae7bf4","modified":1674914191248},{"_id":"public/links/index.html","hash":"525311a0f4efc7ae62a100674f876a2e956332f8","modified":1674914191248},{"_id":"public/categories/index.html","hash":"08b7ae12bb7af0f99fee29fd39d73ef94c1afcf2","modified":1674914191248},{"_id":"public/img/avatar.png","hash":"fe739a158cc128f70f780eb5fa96f388b81d478f","modified":1674914191248},{"_id":"public/img/loading.gif","hash":"2d2fc0f947940f98c21afafef39ecf226a2e8d55","modified":1674914191248},{"_id":"public/xml/local-search.xml","hash":"8c96ba6a064705602ce28d096fd7dd9069630a55","modified":1674914191248},{"_id":"public/img/fluid.png","hash":"64b215db2cb3af98fe639e94537cb5209f959c78","modified":1674914191248},{"_id":"public/img/police_beian.png","hash":"90efded6baa2dde599a9d6b1387973e8e64923ea","modified":1674914191248},{"_id":"public/css/gitalk.css","hash":"a57b3cc8e04a0a4a27aefa07facf5b5e7bca0e76","modified":1674914191248},{"_id":"public/css/highlight-dark.css","hash":"2b0daa6e5343da9dbb26d617d224b8397e48556b","modified":1674914191248},{"_id":"public/css/highlight.css","hash":"0f9a477d33d3b15ebe7e163e756fb7c54c7ded6b","modified":1674914191248},{"_id":"public/js/color-schema.js","hash":"76a198f8721352ebeaf5b2ef2f4db00612da4796","modified":1674914191248},{"_id":"public/js/boot.js","hash":"38bd26c6b7acdafda86dda3560e6a3ca488d3c76","modified":1674914191248},{"_id":"public/js/img-lazyload.js","hash":"cbdeca434ec4da51f488c821d51b4d23c73294af","modified":1674914191248},{"_id":"public/js/local-search.js","hash":"cebcda5991b6a9ab9307c69542389ce9013f04f7","modified":1674914191248},{"_id":"public/js/leancloud.js","hash":"eff77c7a5c399fcaefda48884980571e15243fc9","modified":1674914191248},{"_id":"public/js/plugins.js","hash":"c34916291e392a774ff3e85c55badb83e8661297","modified":1674914191248},{"_id":"public/js/utils.js","hash":"45cc86f099db0a2c36ad49711ce66c2d598a2ab1","modified":1674914191248},{"_id":"public/js/events.js","hash":"89e3561488a618ed0caeb9edf18e441978e29c25","modified":1674914191248},{"_id":"public/css/main.css","hash":"4d4a763ef5e9ab2602c46e812d846bba7a277757","modified":1674914191248},{"_id":"public/img/default.png","hash":"167a12978d80371cf578c8a2e45c24a2eb25b6fb","modified":1674914191248},{"_id":"source/about/index.md","hash":"148ed884d25c1e51dd8d91bafffcbaa2a29ae275","modified":1674401481550},{"_id":"source/_posts/fiber.md","hash":"c5630870e84532b1eef90f05123a1ffd982f1974","modified":1674467887112},{"_id":"source/_posts/.ssl.md.swp","hash":"5c83e7301b8cd6b39d0d1824ef5ed4a9ec07d38a","modified":1674467898003},{"_id":"source/_posts/ssl.md","hash":"9505c9141fc9e16809e6e5414f94df5c1aac6690","modified":1674467893986},{"_id":"source/_posts/.fiber.md.swp","hash":"c81e0f5936cc1e547c4ff83fcefd72988a72805a","modified":1674467898003},{"_id":"public/about/index.html","hash":"50910af5fa811bdbec39ca1bf2a18d4b07d5aec0","modified":1674914191248},{"_id":"public/2023/01/22/ssl/index.html","hash":"298f42d13818cc2ff6f9a1e08b4c2ae536accbc6","modified":1674443785104},{"_id":"public/2023/01/22/fiber/index.html","hash":"7dfa09d6ec2875665b933a8feeeede6b49ee30b6","modified":1674444388320},{"_id":"themes/fluid/._config.yml.swp","hash":"5e3597ac1b9989859040c634c4a929c2e74c3148","modified":1674556385226},{"_id":"public/2023/01/23/ssl/index.html","hash":"52c04437e583f81248e69a9b076f6773e9ec6ce4","modified":1674444388320},{"_id":"source/_posts/test.md","hash":"5dc5a8d5a99ab6218810329fc0cfce00b494299f","modified":1674450504816},{"_id":"source/_posts/fiber/fiber.md","hash":"0464ae80cf0d3fca40bff82bc0e82e39fe7471c4","modified":1674403047567},{"_id":"source/_posts/f.md","hash":"d74696d0c4d607951d29ac1871dfedda412f78fe","modified":1674450730364},{"_id":"source/_posts/.f.md.swp","hash":"1287153b9c3d294eedf735bae7fef5391b37b3c9","modified":1674450734378},{"_id":"public/archives/2019/04/index.html","hash":"fe98084a2b7f4c1abf83266e8b3c14b9ac8d33e7","modified":1674914191248},{"_id":"public/archives/2019/index.html","hash":"2833f48e557e9b0cb701cff9627dc2a57ed10e7e","modified":1674914191248},{"_id":"public/archives/2020/index.html","hash":"df38178c8f9a90a1784c97a20ae1382128728d6f","modified":1674914191248},{"_id":"public/archives/2020/01/index.html","hash":"e18ad9c1fa3285d833e4cc16f91425f3d41d4776","modified":1674914191248},{"_id":"public/tags/SSL编程/index.html","hash":"043e192643e8d63987b63d2aed0bf0f1a23fa09f","modified":1674914191248},{"_id":"public/tags/协程编程/index.html","hash":"c6047c17cf5692af176fc4c97cbb539b185fdc64","modified":1674914191248},{"_id":"public/2020/01/15/ssl/index.html","hash":"e24f83057c446c123570c2786f7cf71443da932b","modified":1674914191248},{"_id":"public/2019/04/07/fiber/index.html","hash":"928de4ede1420598051c96343f2517722ffae6ce","modified":1674914191248},{"_id":"source/categories/index.md","hash":"9bceed52c44eac57a4ce072004326df95b754ecd","modified":1674467848032},{"_id":"source/categories/.index.md.swp","hash":"0632f3cd033ff3a651cafdab781df71b4ff3d5b0","modified":1674467852049},{"_id":"public/categories/协程编程/index.html","hash":"89ad61a2cd01cab3fbdc837d2f97e70b85208ed2","modified":1674914191248},{"_id":"public/categories/SSL编程/index.html","hash":"c3643486ea22f6670e6ed99d39bfbee22def5887","modified":1674914191248},{"_id":"source/_posts/img/b04bcf42-ec99-38bf-9c9f-32b31d48317c.png","hash":"5a911ebe844faf7500314b70a158c4c31e79b499","modified":1674476840456},{"_id":"source/_posts/img/fiber_depedence.png","hash":"5a911ebe844faf7500314b70a158c4c31e79b499","modified":1674476900246},{"_id":"source/.DS_Store","hash":"6974ddb0953597b845d10c3aec9016f9ed161fbb","modified":1674476837674},{"_id":"source/_posts/.build_use_fiber.md.swp","hash":"0efdbacc8723bfe58705d589c89a765be58f3aff","modified":1674477178995},{"_id":"source/_posts/build_use_fiber.md","hash":"b9f7055e2cd284e1bd9f4bd551f7f2ea98ef3040","modified":1674477466942},{"_id":"public/archives/2019/03/index.html","hash":"6df3dfb404e236a03b711776f562460728f205bc","modified":1674914191248},{"_id":"public/2019/03/23/build_use_fiber/index.html","hash":"78e2a28a937cc084fbbea78b82e862d96d0fbe4d","modified":1674914191248},{"_id":"source/img/fiber_depedence.png","hash":"5a911ebe844faf7500314b70a158c4c31e79b499","modified":1674476900246},{"_id":"public/img/fiber_depedence.png","hash":"5a911ebe844faf7500314b70a158c4c31e79b499","modified":1674914191248},{"_id":"source/_posts/http_servlet.md","hash":"88bf81c93648ae15cef96497cac079c6688cf164","modified":1674482588806},{"_id":"public/archives/2012/index.html","hash":"2debbd1c764b6ca84e852325bd260cc561fc7e27","modified":1674914191248},{"_id":"public/2012/05/20/http_servlet/index.html","hash":"807b53ebd661f1f535697f181bbd69ba09ba5197","modified":1674914191248},{"_id":"public/archives/2012/05/index.html","hash":"1b5b7e546c361402f973fadb3d8e6d23b57285f0","modified":1674914191248},{"_id":"public/categories/http开发/index.html","hash":"a0308fb9438fece62003bc9cbfed73a0a733c3ab","modified":1674914191248},{"_id":"source/_posts/http_web.md","hash":"45d38d84dfc6bd43f435ac4118ba1ba121cdc5df","modified":1674481218258},{"_id":"public/2012/05/21/http_web/index.html","hash":"053b17ff8cbb21664dcf5d347fea1099d9b90477","modified":1674914191248},{"_id":"source/_posts/http_upload.md","hash":"23ac376fff5ebe22433e8b8da236e5c3bfa5af10","modified":1674481208782},{"_id":"public/2012/05/22/http_upload/index.html","hash":"b6d0d00c0e25f88730ba4839e7e6e127082259b3","modified":1674914191248},{"_id":"public/tags/http/index.html","hash":"50dc3d24bf572a249d418bc0ec7df4ed2d7b0907","modified":1674914191248},{"_id":"source/_posts/faq.md","hash":"5ed9a5d01b3f7b812063424e706dd2090cd9db64","modified":1674482183934},{"_id":"source/_posts/.faq.md.swp","hash":"38d6be4b91a693dac9e5b385ea44782b9119ed27","modified":1674482187949},{"_id":"public/categories/faq/index.html","hash":"265f33342acf43a181438f3aaceda43318a43531","modified":1674914191248},{"_id":"public/archives/2019/06/index.html","hash":"65919629b3cfb09a0a9320449fa5517276aabfba","modified":1674914191248},{"_id":"public/2019/06/30/faq/index.html","hash":"b981370e28003f52f3d8bbb4bf526ffb7316a1a2","modified":1674914191248},{"_id":"source/_posts/.http_servlet.md.swp","hash":"84048e788a65d917b855a77b1bf7d22dcaa427ed","modified":1674482592825},{"_id":"source/_posts/.about_fiber.md.swp","hash":"09b7b6bbaef605a8602577e2d35647d8a477d2a5","modified":1674484518946},{"_id":"source/img/img/benchmark.png","hash":"6cb6c71fb500c4a00f07f7a3b6a758edae2dd025","modified":1591065782000},{"_id":"source/_posts/about_fiber.md","hash":"8b39267b031944f24b9f712803149639db4ba9f9","modified":1674812330149},{"_id":"source/img/img/hpdns.png","hash":"e2111a7d1373c52a55bc984a6d8d0c091ceb3515","modified":1591065782000},{"_id":"source/img/img/aio_architecture.png","hash":"d1490725463d9348c34700ee76941169884f8146","modified":1591065782084},{"_id":"source/img/img/fiber_running.png","hash":"7c0c821b25e3f47c8062abd43a6286ac6915571c","modified":1591065782084},{"_id":"source/img/img/dead_lock.png","hash":"a7146a567348e94ceceaa740e948128c7200993e","modified":1591065782077},{"_id":"source/img/img/fiber_cond.png","hash":"da35fc99079fd71f319bec0d476275e9381dfcc3","modified":1591065782072},{"_id":"source/img/img/fiber_io_switch.png","hash":"f489374e550599d4d64c9ee5a34dd060f0abc7cf","modified":1591065782073},{"_id":"source/img/img/fiber_switch.png","hash":"371dd6cc8de78071744864b1532ce0a525711ec0","modified":1591065782077},{"_id":"source/img/img/nio_read.png","hash":"452716c0a4d31441b2f7416286fb5762ea0a7097","modified":1591065782083},{"_id":"source/img/img/fiber_event.png","hash":"4cf01fd0555b162ea18e5232614978ea3e6704c4","modified":1591065782085},{"_id":"source/img/img/fiber_lock.png","hash":"28f8a0d77d0edb77b9f3659150bc6f814980fadc","modified":1591065782074},{"_id":"source/img/img/fiber_sem.png","hash":"965dd9b7e2931893650a319205097419debcd5b7","modified":1591065782074},{"_id":"source/img/img/fiber_schedule.png","hash":"1558e012b607e72005585a89e49e8eace680e257","modified":1591065782075},{"_id":"source/img/img/qixun.png","hash":"4c55bf3c6cace6d783c34caf0832ef28c47b5c69","modified":1591065782086},{"_id":"source/doc.tgz","hash":"f06b5196313b1344054632734cec9f01e4dedbde","modified":1674483531259},{"_id":"public/archives/2020/06/index.html","hash":"8b0feb7e1b932198816ed9cd1f4b671a621acc72","modified":1674914191248},{"_id":"public/2020/06/05/about_fiber/index.html","hash":"44edf85aeb4dd9c6e5a5bb8d6fae8f6b43ab8a0d","modified":1674914191248},{"_id":"public/img/img/benchmark.png","hash":"6cb6c71fb500c4a00f07f7a3b6a758edae2dd025","modified":1674484079154},{"_id":"public/img/img/hpdns.png","hash":"e2111a7d1373c52a55bc984a6d8d0c091ceb3515","modified":1674484079154},{"_id":"public/img/img/aio_architecture.png","hash":"d1490725463d9348c34700ee76941169884f8146","modified":1674484079154},{"_id":"public/img/img/fiber_running.png","hash":"7c0c821b25e3f47c8062abd43a6286ac6915571c","modified":1674484079154},{"_id":"public/img/img/dead_lock.png","hash":"a7146a567348e94ceceaa740e948128c7200993e","modified":1674484079154},{"_id":"public/img/img/fiber_io_switch.png","hash":"f489374e550599d4d64c9ee5a34dd060f0abc7cf","modified":1674484079154},{"_id":"public/img/img/fiber_cond.png","hash":"da35fc99079fd71f319bec0d476275e9381dfcc3","modified":1674484079154},{"_id":"public/img/img/fiber_switch.png","hash":"371dd6cc8de78071744864b1532ce0a525711ec0","modified":1674484079154},{"_id":"public/img/img/nio_read.png","hash":"452716c0a4d31441b2f7416286fb5762ea0a7097","modified":1674484079154},{"_id":"public/img/img/fiber_event.png","hash":"4cf01fd0555b162ea18e5232614978ea3e6704c4","modified":1674484079154},{"_id":"public/img/img/fiber_lock.png","hash":"28f8a0d77d0edb77b9f3659150bc6f814980fadc","modified":1674484079154},{"_id":"public/img/img/fiber_sem.png","hash":"965dd9b7e2931893650a319205097419debcd5b7","modified":1674484079154},{"_id":"public/img/img/fiber_schedule.png","hash":"1558e012b607e72005585a89e49e8eace680e257","modified":1674484079154},{"_id":"public/img/img/qixun.png","hash":"4c55bf3c6cace6d783c34caf0832ef28c47b5c69","modified":1674484079154},{"_id":"public/doc.tgz","hash":"f06b5196313b1344054632734cec9f01e4dedbde","modified":1674914191248},{"_id":"source/img/benchmark.png","hash":"6cb6c71fb500c4a00f07f7a3b6a758edae2dd025","modified":1591065782000},{"_id":"source/img/hpdns.png","hash":"e2111a7d1373c52a55bc984a6d8d0c091ceb3515","modified":1591065782000},{"_id":"source/img/aio_architecture.png","hash":"d1490725463d9348c34700ee76941169884f8146","modified":1591065782084},{"_id":"source/img/fiber_running.png","hash":"7c0c821b25e3f47c8062abd43a6286ac6915571c","modified":1591065782084},{"_id":"source/img/dead_lock.png","hash":"a7146a567348e94ceceaa740e948128c7200993e","modified":1591065782077},{"_id":"source/img/fiber_cond.png","hash":"da35fc99079fd71f319bec0d476275e9381dfcc3","modified":1591065782072},{"_id":"source/img/fiber_io_switch.png","hash":"f489374e550599d4d64c9ee5a34dd060f0abc7cf","modified":1591065782073},{"_id":"source/img/fiber_switch.png","hash":"371dd6cc8de78071744864b1532ce0a525711ec0","modified":1591065782077},{"_id":"source/img/nio_read.png","hash":"452716c0a4d31441b2f7416286fb5762ea0a7097","modified":1591065782083},{"_id":"source/img/fiber_event.png","hash":"4cf01fd0555b162ea18e5232614978ea3e6704c4","modified":1591065782085},{"_id":"source/img/fiber_lock.png","hash":"28f8a0d77d0edb77b9f3659150bc6f814980fadc","modified":1591065782074},{"_id":"source/img/fiber_sem.png","hash":"965dd9b7e2931893650a319205097419debcd5b7","modified":1591065782074},{"_id":"source/img/fiber_schedule.png","hash":"1558e012b607e72005585a89e49e8eace680e257","modified":1591065782075},{"_id":"source/img/qixun.png","hash":"4c55bf3c6cace6d783c34caf0832ef28c47b5c69","modified":1591065782086},{"_id":"public/img/benchmark.png","hash":"6cb6c71fb500c4a00f07f7a3b6a758edae2dd025","modified":1674914191248},{"_id":"public/img/hpdns.png","hash":"e2111a7d1373c52a55bc984a6d8d0c091ceb3515","modified":1674914191248},{"_id":"public/img/aio_architecture.png","hash":"d1490725463d9348c34700ee76941169884f8146","modified":1674914191248},{"_id":"public/img/fiber_running.png","hash":"7c0c821b25e3f47c8062abd43a6286ac6915571c","modified":1674914191248},{"_id":"public/img/dead_lock.png","hash":"a7146a567348e94ceceaa740e948128c7200993e","modified":1674914191248},{"_id":"public/img/fiber_io_switch.png","hash":"f489374e550599d4d64c9ee5a34dd060f0abc7cf","modified":1674914191248},{"_id":"public/img/fiber_switch.png","hash":"371dd6cc8de78071744864b1532ce0a525711ec0","modified":1674914191248},{"_id":"public/img/nio_read.png","hash":"452716c0a4d31441b2f7416286fb5762ea0a7097","modified":1674914191248},{"_id":"public/img/fiber_cond.png","hash":"da35fc99079fd71f319bec0d476275e9381dfcc3","modified":1674914191248},{"_id":"public/img/fiber_lock.png","hash":"28f8a0d77d0edb77b9f3659150bc6f814980fadc","modified":1674914191248},{"_id":"public/img/fiber_event.png","hash":"4cf01fd0555b162ea18e5232614978ea3e6704c4","modified":1674914191248},{"_id":"public/img/fiber_sem.png","hash":"965dd9b7e2931893650a319205097419debcd5b7","modified":1674914191248},{"_id":"public/img/fiber_schedule.png","hash":"1558e012b607e72005585a89e49e8eace680e257","modified":1674914191248},{"_id":"public/img/qixun.png","hash":"4c55bf3c6cace6d783c34caf0832ef28c47b5c69","modified":1674914191248},{"_id":"source/_posts/fiber_web.md","hash":"39b5e80fa0c5b728bd819b0a07dfa958f44f5145","modified":1674526287284},{"_id":"public/archives/2016/index.html","hash":"43220b41a0bf6fd68cd78b2b914985eb2f5367f5","modified":1674914191248},{"_id":"public/archives/2016/07/index.html","hash":"c98e74c3a020b0f566dbd79391c08f53e1db989e","modified":1674914191248},{"_id":"public/2016/07/06/fiber_web/index.html","hash":"7f8ba3dd2ac91a4f60318bf4f85c9706a72b9e20","modified":1674914191248},{"_id":"source/_posts/http_request.md","hash":"6a648e39cebcd23609c709749d6cc4beda8be7d9","modified":1674528531541},{"_id":"public/archives/2014/index.html","hash":"9b305ce1920e271d10d0f8ed739078a662b5d1f6","modified":1674914191248},{"_id":"public/archives/2014/06/index.html","hash":"e811e7c6c9bea4a08ce675311bdedcb58a616414","modified":1674914191248},{"_id":"public/2014/06/02/http_request/index.html","hash":"c325b52e57b687830bd0bee798f640cfc0604fef","modified":1674914191248},{"_id":"source/_posts/img/benchmark.png","hash":"6cb6c71fb500c4a00f07f7a3b6a758edae2dd025","modified":1674539275610},{"_id":"source/_posts/img/hpdns.png","hash":"e2111a7d1373c52a55bc984a6d8d0c091ceb3515","modified":1674539275615},{"_id":"source/_posts/img/loadbalance.png","hash":"8671bd54ccb31fd44be77a214cba94ef4e483c75","modified":1674539275615},{"_id":"source/_posts/img/aio_architecture.png","hash":"d1490725463d9348c34700ee76941169884f8146","modified":1674539275609},{"_id":"source/_posts/img/fiber_running.png","hash":"7c0c821b25e3f47c8062abd43a6286ac6915571c","modified":1674539275610},{"_id":"source/_posts/img/dead_lock.png","hash":"a7146a567348e94ceceaa740e948128c7200993e","modified":1674539275608},{"_id":"source/_posts/img/fiber_cond.png","hash":"da35fc99079fd71f319bec0d476275e9381dfcc3","modified":1674539275605},{"_id":"source/_posts/img/fiber_io_switch.png","hash":"f489374e550599d4d64c9ee5a34dd060f0abc7cf","modified":1674539275605},{"_id":"source/_posts/img/fiber_switch.png","hash":"371dd6cc8de78071744864b1532ce0a525711ec0","modified":1674539275609},{"_id":"source/_posts/img/nio_read.png","hash":"452716c0a4d31441b2f7416286fb5762ea0a7097","modified":1674539275609},{"_id":"source/_posts/img/fiber_event.png","hash":"4cf01fd0555b162ea18e5232614978ea3e6704c4","modified":1674539275610},{"_id":"source/_posts/img/fiber_lock.png","hash":"28f8a0d77d0edb77b9f3659150bc6f814980fadc","modified":1674539275607},{"_id":"source/_posts/img/fiber_sem.png","hash":"965dd9b7e2931893650a319205097419debcd5b7","modified":1674539275606},{"_id":"source/_posts/img/fiber_schedule.png","hash":"1558e012b607e72005585a89e49e8eace680e257","modified":1674539275608},{"_id":"source/_posts/img/qixun.png","hash":"4c55bf3c6cace6d783c34caf0832ef28c47b5c69","modified":1674539275614},{"_id":"source/images/benchmark.png","hash":"6cb6c71fb500c4a00f07f7a3b6a758edae2dd025","modified":1591065782000},{"_id":"source/images/fiber_depedence.png","hash":"5a911ebe844faf7500314b70a158c4c31e79b499","modified":1674476900246},{"_id":"source/images/hpdns.png","hash":"e2111a7d1373c52a55bc984a6d8d0c091ceb3515","modified":1591065782000},{"_id":"source/images/loadbalance.png","hash":"8671bd54ccb31fd44be77a214cba94ef4e483c75","modified":1674537508014},{"_id":"source/images/aio_architecture.png","hash":"d1490725463d9348c34700ee76941169884f8146","modified":1591065782084},{"_id":"source/images/fiber_running.png","hash":"7c0c821b25e3f47c8062abd43a6286ac6915571c","modified":1591065782084},{"_id":"source/images/dead_lock.png","hash":"a7146a567348e94ceceaa740e948128c7200993e","modified":1591065782077},{"_id":"source/images/fiber_cond.png","hash":"da35fc99079fd71f319bec0d476275e9381dfcc3","modified":1591065782072},{"_id":"source/images/fiber_io_switch.png","hash":"f489374e550599d4d64c9ee5a34dd060f0abc7cf","modified":1591065782073},{"_id":"source/images/fiber_switch.png","hash":"371dd6cc8de78071744864b1532ce0a525711ec0","modified":1591065782077},{"_id":"source/images/nio_read.png","hash":"452716c0a4d31441b2f7416286fb5762ea0a7097","modified":1591065782083},{"_id":"source/images/fiber_event.png","hash":"4cf01fd0555b162ea18e5232614978ea3e6704c4","modified":1591065782085},{"_id":"source/images/fiber_lock.png","hash":"28f8a0d77d0edb77b9f3659150bc6f814980fadc","modified":1591065782074},{"_id":"source/images/fiber_sem.png","hash":"965dd9b7e2931893650a319205097419debcd5b7","modified":1591065782074},{"_id":"source/images/fiber_schedule.png","hash":"1558e012b607e72005585a89e49e8eace680e257","modified":1591065782075},{"_id":"source/images/qixun.png","hash":"4c55bf3c6cace6d783c34caf0832ef28c47b5c69","modified":1591065782086},{"_id":"source/_posts/configure.md","hash":"25ec45c0d6bb8e57e9f5a597b96969265e2df0a8","modified":1674537034103},{"_id":"source/_posts/server_loadbalance.md","hash":"a9851c7c50dd3a935032ef787c330aabfb6af40a","modified":1674540642187},{"_id":"source/_posts/http_dowload2.md","hash":"a9eba6e0df659af2a800d47ef0c0d73c025a0f86","modified":1674529349335},{"_id":"source/_posts/http_dowload.md","hash":"5721259f7f86597927476ba3c2e8ef255a07fdef","modified":1674529092034},{"_id":"source/_posts/process_control.md","hash":"d6e53d34b735d04d0d9993aae1320df6f458ca3d","modified":1674529859805},{"_id":"public/archives/2009/11/index.html","hash":"cf8f74bed20ce798d94e5a25b0f1b7f87e820ada","modified":1674914191248},{"_id":"public/archives/2010/index.html","hash":"2d89535d2d61ee7754d19a8575962b0f56a3aa83","modified":1674914191248},{"_id":"public/archives/2009/index.html","hash":"3a50d3b41ca99663091889cd93df054b894786a7","modified":1674914191248},{"_id":"public/archives/2009/06/index.html","hash":"b5ca9fb89ac9f34e2beab9115ad08b0045c30ffe","modified":1674914191248},{"_id":"public/archives/2010/01/index.html","hash":"5d95840b08dfd671c458ad610d2f09c49e18bfdb","modified":1674914191248},{"_id":"public/archives/page/2/index.html","hash":"93ed61e0eaa1fb0c4e72d23338769ae63481178e","modified":1674914191248},{"_id":"public/archives/2014/09/index.html","hash":"b409fdb8828038f1ede6d1aaf355f05b518a8954","modified":1674914191248},{"_id":"public/categories/进程控制/index.html","hash":"b7138831a0b6f80b3dbae30e5e82e799878dcf70","modified":1674914191248},{"_id":"public/categories/配置文件/index.html","hash":"d71866554f31905c5681332cc80c276c9de2231e","modified":1674914191248},{"_id":"public/categories/服务编程/index.html","hash":"42ace39388729084367e093cf30ba8e178762a96","modified":1674914191248},{"_id":"public/2010/01/13/http_dowload2/index.html","hash":"1d7c9430785f6fe6cc99f3d37e98ed8d849cc701","modified":1674914191248},{"_id":"public/2010/01/11/http_dowload/index.html","hash":"2bafb71e0ae78826b56901aa73869667fc46df31","modified":1674914191248},{"_id":"public/2014/09/20/server_loadbalance/index.html","hash":"1b842dec4df0c0810f8e536a3d9ae90dbf8e2228","modified":1674914191248},{"_id":"public/2009/11/03/configure/index.html","hash":"a29b2f4532a4787cc0e2d0ad53edb2b665d6715a","modified":1674914191248},{"_id":"public/2009/06/07/process_control/index.html","hash":"f33f3138281cc23e85bba3d91d9222a17c85a86a","modified":1674914191248},{"_id":"public/page/2/index.html","hash":"f555230d623b0386ecf07c601ee6ece8546f79c9","modified":1674914191248},{"_id":"public/images/benchmark.png","hash":"6cb6c71fb500c4a00f07f7a3b6a758edae2dd025","modified":1674539318413},{"_id":"public/images/fiber_depedence.png","hash":"5a911ebe844faf7500314b70a158c4c31e79b499","modified":1674539318413},{"_id":"public/images/hpdns.png","hash":"e2111a7d1373c52a55bc984a6d8d0c091ceb3515","modified":1674539318413},{"_id":"public/images/loadbalance.png","hash":"8671bd54ccb31fd44be77a214cba94ef4e483c75","modified":1674539318413},{"_id":"public/images/aio_architecture.png","hash":"d1490725463d9348c34700ee76941169884f8146","modified":1674539318413},{"_id":"public/images/fiber_running.png","hash":"7c0c821b25e3f47c8062abd43a6286ac6915571c","modified":1674539318413},{"_id":"public/images/dead_lock.png","hash":"a7146a567348e94ceceaa740e948128c7200993e","modified":1674539318413},{"_id":"public/images/fiber_io_switch.png","hash":"f489374e550599d4d64c9ee5a34dd060f0abc7cf","modified":1674539318413},{"_id":"public/images/fiber_cond.png","hash":"da35fc99079fd71f319bec0d476275e9381dfcc3","modified":1674539318413},{"_id":"public/images/fiber_switch.png","hash":"371dd6cc8de78071744864b1532ce0a525711ec0","modified":1674539318413},{"_id":"public/images/nio_read.png","hash":"452716c0a4d31441b2f7416286fb5762ea0a7097","modified":1674539318413},{"_id":"public/images/fiber_lock.png","hash":"28f8a0d77d0edb77b9f3659150bc6f814980fadc","modified":1674539318413},{"_id":"public/images/fiber_event.png","hash":"4cf01fd0555b162ea18e5232614978ea3e6704c4","modified":1674539318413},{"_id":"public/images/fiber_sem.png","hash":"965dd9b7e2931893650a319205097419debcd5b7","modified":1674539318413},{"_id":"public/images/fiber_schedule.png","hash":"1558e012b607e72005585a89e49e8eace680e257","modified":1674539318413},{"_id":"public/images/qixun.png","hash":"4c55bf3c6cace6d783c34caf0832ef28c47b5c69","modified":1674539318413},{"_id":"source/img/loadbalance.png","hash":"8671bd54ccb31fd44be77a214cba94ef4e483c75","modified":1674537508014},{"_id":"source/_posts/log.md","hash":"84633632db6452e0c7e1401e46731960b326c2c0","modified":1674547286620},{"_id":"source/_posts/master_threads.md","hash":"e6d9eb92171fca884772b026618c3a22467a507b","modified":1674542043078},{"_id":"source/_posts/master_aio.md","hash":"b995f59e5ba311a93bfc7b4c3f18df657325739c","modified":1674544735563},{"_id":"source/_posts/threads_shock.md","hash":"3d71f41603efefa06cce83e932c21e216292c2e5","modified":1674547976295},{"_id":"source/_posts/network_simple.md","hash":"19e6a7e6a14ad9a98d23ab4fb191e055d941ca0a","modified":1674541182414},{"_id":"source/_posts/aio.md","hash":"79d2889f0fd5edcaf7de1b474aa5ac7c8de71fdd","modified":1674546318978},{"_id":"source/_posts/threads.md","hash":"3f018ebc4026647bd7a739d77386cb8c7c5ad82d","modified":1674546977007},{"_id":"source/img/aio_inherit.jpg","hash":"fbbd9777d08e7003653adebe771168fd7731971a","modified":1674545885250},{"_id":"source/img/aio_callback.png","hash":"ef2208296d38c81a0b0958f92dcd0ee62280e188","modified":1674546276557},{"_id":"source/img/aio_inherit.png","hash":"35a1d9e048d6feff4c77c35f661d0693e7c35ab8","modified":1674546226956},{"_id":"public/archives/2012/04/index.html","hash":"7ea767adb63cb87c83e57bc4273695746681c41b","modified":1674914191248},{"_id":"public/archives/2014/03/index.html","hash":"0813e2a082789eb8ed2699e8cef4b71a62c1d521","modified":1674914191248},{"_id":"public/archives/2014/05/index.html","hash":"ff37e6544fd18db9fa3cd5aa71a5813c62bb5928","modified":1674914191248},{"_id":"public/archives/page/3/index.html","hash":"8a85cb3dc7d10fed3aedca60c0869f7d8c190fc4","modified":1674914191248},{"_id":"public/categories/网络编程/index.html","hash":"2cf280d433b111ef222f30447ce859151484ec53","modified":1674914191248},{"_id":"public/categories/非阻塞编程/index.html","hash":"0e6e0683504d3af1d1083d9b4fde77ca71948cb1","modified":1674914191248},{"_id":"public/categories/线程编程/index.html","hash":"cf4b845a61cbfe443406b669750b523c04c999e0","modified":1674914191248},{"_id":"public/archives/2013/index.html","hash":"81285fe5f9405f61938f426c4ba1d3c78b88e653","modified":1674914191248},{"_id":"public/categories/日志/index.html","hash":"ad8cc7d7e0b1c5391180218366d6a20a03bd743c","modified":1674914191248},{"_id":"public/page/3/index.html","hash":"4204ec902563456bb21241e263d4001a94119fd3","modified":1674914191248},{"_id":"public/archives/2013/06/index.html","hash":"55f3541edcf8b0802a7bcbf756e79fecbad7882c","modified":1674914191248},{"_id":"public/2014/05/18/network_simple/index.html","hash":"1ceb0074accfc64cd6bdda86bdc443e3a9d5619c","modified":1674914191248},{"_id":"public/2014/03/09/threads_shock/index.html","hash":"2af58ab5055dcfc45b82e9f1d0466db2a0bfffa1","modified":1674914191248},{"_id":"public/2013/06/23/log/index.html","hash":"7ca15c61cb9c91108f9fc5292381e403032716aa","modified":1674914191248},{"_id":"public/2012/05/26/master_threads/index.html","hash":"5609120faba13099fe1c9500f111244d1abd535b","modified":1674914191248},{"_id":"public/2012/04/04/aio/index.html","hash":"60be149156e4fdd673c1d1a81e501ced157968d9","modified":1674914191248},{"_id":"public/2009/06/07/threads/index.html","hash":"146862b6b307c9b616b0badf70e3833427290a3e","modified":1674914191248},{"_id":"public/2012/05/30/master_aio/index.html","hash":"3c0286a122346fd75dab40244ccca2be629e9a58","modified":1674914191248},{"_id":"public/img/loadbalance.png","hash":"8671bd54ccb31fd44be77a214cba94ef4e483c75","modified":1674914191248},{"_id":"public/img/aio_inherit.jpg","hash":"fbbd9777d08e7003653adebe771168fd7731971a","modified":1674914191248},{"_id":"public/img/aio_callback.png","hash":"ef2208296d38c81a0b0958f92dcd0ee62280e188","modified":1674914191248},{"_id":"public/img/aio_inherit.png","hash":"35a1d9e048d6feff4c77c35f661d0693e7c35ab8","modified":1674914191248},{"_id":"source/_posts/redis_client.md","hash":"f9d2b75fa62bdd8c6794558e24ac5db645d5bfb3","modified":1674550392775},{"_id":"source/_posts/redis_builder2.md","hash":"69a8bf7cec1e725b6e92921da9fb80c1d52acb04","modified":1674552066221},{"_id":"source/_posts/redis_builder.md","hash":"2605950f55f8d9e0f47f814ef1c6c9ba89475941","modified":1674550931959},{"_id":"source/img/redis_commands.png","hash":"aa9d21f4530be4f7abd861eb43c693b2fdd8d61a","modified":1674551282689},{"_id":"source/img/redis_commands2.png","hash":"f5febff315f9c7e9e7a60e755541c5f1e2614f07","modified":1674551415610},{"_id":"source/img/redis_dbsize.png","hash":"636895468bf66d8b8d8d1f0ebd76779b433a8d5a","modified":1674551861025},{"_id":"source/img/redis_hash_get.png","hash":"363132c39d8962054e06fea9265465f6b96723bb","modified":1674551781560},{"_id":"source/img/redis_get.png","hash":"060f167fc3d52c833e3a4c7e093655adde268ad4","modified":1674551539044},{"_id":"source/img/redis_help.png","hash":"50a9b854a37cb4352de30bf7d9fad8df708b95ad","modified":1674551492125},{"_id":"source/img/redis_set.png","hash":"c4e4eee7287a3dcb63eb193a7ba10abbd3f4d30d","modified":1674551953674},{"_id":"source/img/redis_builder.png","hash":"14f167972c98502606056f1affb1e7e9c474f38a","modified":1674551211959},{"_id":"source/img/redis_status.png","hash":"9c37e553235128f18dfd4fa41e38e140d1100917","modified":1674551649331},{"_id":"source/img/redis_nodes.png","hash":"5071c0266bb5d41e265897f1fef1d4ebbf83e9c2","modified":1674551872690},{"_id":"public/categories/redis使用/index.html","hash":"e2b594c8d6b4b40201790514d09ab6d46df97a8d","modified":1674914191248},{"_id":"public/archives/2015/index.html","hash":"09d25ab22d895cb88d7f26af112f3c9c99b0fbd9","modified":1674914191248},{"_id":"public/archives/2015/02/index.html","hash":"0246ae3fde472a6cd3f3baa758f9c62f2327bf17","modified":1674914191248},{"_id":"public/archives/2015/04/index.html","hash":"dbb3339a1dfacd3409d7fc1a83394892ff8234f1","modified":1674914191248},{"_id":"public/archives/2016/04/index.html","hash":"673475abdbf9ab536f6837068e17dc05602f3a4b","modified":1674914191248},{"_id":"public/2015/04/20/redis_builder/index.html","hash":"c64c36bfb6ffb5ae9a83142507f2fc16c7b8ee9e","modified":1674914191248},{"_id":"public/2015/02/10/redis_client/index.html","hash":"e1d060b942cdddc1b7f761ae6deb5c176872baf6","modified":1674914191248},{"_id":"public/2016/04/23/redis_builder2/index.html","hash":"2898086c3fcd3744a12c52c27a832f3004390ed9","modified":1674914191248},{"_id":"public/img/redis_help.png","hash":"50a9b854a37cb4352de30bf7d9fad8df708b95ad","modified":1674914191248},{"_id":"public/img/redis_commands.png","hash":"aa9d21f4530be4f7abd861eb43c693b2fdd8d61a","modified":1674914191248},{"_id":"public/img/redis_commands2.png","hash":"f5febff315f9c7e9e7a60e755541c5f1e2614f07","modified":1674914191248},{"_id":"public/img/redis_get.png","hash":"060f167fc3d52c833e3a4c7e093655adde268ad4","modified":1674914191248},{"_id":"public/img/redis_dbsize.png","hash":"636895468bf66d8b8d8d1f0ebd76779b433a8d5a","modified":1674914191248},{"_id":"public/img/redis_hash_get.png","hash":"363132c39d8962054e06fea9265465f6b96723bb","modified":1674914191248},{"_id":"public/img/redis_set.png","hash":"c4e4eee7287a3dcb63eb193a7ba10abbd3f4d30d","modified":1674914191248},{"_id":"public/img/redis_builder.png","hash":"14f167972c98502606056f1affb1e7e9c474f38a","modified":1674914191248},{"_id":"public/img/redis_status.png","hash":"9c37e553235128f18dfd4fa41e38e140d1100917","modified":1674914191248},{"_id":"public/img/redis_nodes.png","hash":"5071c0266bb5d41e265897f1fef1d4ebbf83e9c2","modified":1674914191248},{"_id":"source/_posts/memory_pool.md","hash":"20916a5e698e6b97cb626d68fc5c6365b4ef2bc6","modified":1674552774682},{"_id":"source/_posts/aio_rpc.md","hash":"711b0b4728a60c272aa6a6d712cc2105c8eb452d","modified":1674555593783},{"_id":"source/_posts/db.md","hash":"361568f6b349232871bc9a937effda9f939e958c","modified":1674553785815},{"_id":"source/_posts/aio_rpc_mfc.md","hash":"45b521d18c9b72c069f0cb811cfcdf3c4a24a9ca","modified":1674556013568},{"_id":"source/_posts/serialize2.md","hash":"9a551c720874dd31437fb7554d2848bd1d85b459","modified":1674555112152},{"_id":"source/_posts/serialize.md","hash":"abf16a2e426fa785ed1788b885a745b726afb1a1","modified":1674554890069},{"_id":"source/_posts/threads_cpp.md","hash":"3f77b70461844ffc016823dcb4c8e2bf446ba22c","modified":1674553169369},{"_id":"source/img/aio_rpc_mfc.png","hash":"8e28290994e32f75d3474dfb9d596cdf7620b44d","modified":1674555945505},{"_id":"source/img/db2.png","hash":"79103722d277c829d2b7b1e64c924e75b40e4e1f","modified":1674553708132},{"_id":"source/img/db.png","hash":"9e5b58c1c10d797150f1058c2f4de25dc4fdfaa7","modified":1674553684540},{"_id":"public/archives/page/4/index.html","hash":"f8cd48d6165bb13db281b79eaaaf7f77667624c5","modified":1674914191248},{"_id":"public/archives/2012/07/index.html","hash":"b7932f9a80cef535b3bd31727abe5170e98e1afa","modified":1674914191248},{"_id":"public/archives/2016/10/index.html","hash":"50bd5f15146004ef95f065ce4b2d1e6ce3ba38a1","modified":1674914191248},{"_id":"public/archives/2016/11/index.html","hash":"769e9d0a4462d308ed37f7d854fc1074c85217f2","modified":1674914191248},{"_id":"public/archives/2013/02/index.html","hash":"e531af4f4ad0eacb17817c8d1340cd93085294e9","modified":1674914191248},{"_id":"public/page/4/index.html","hash":"3b85706b2689b7f390c668f7eed97050c8bc363e","modified":1674914191248},{"_id":"public/archives/2015/11/index.html","hash":"1df96575bad3be5a89ad152e37bc5fca4015d3a9","modified":1674914191248},{"_id":"public/archives/2013/10/index.html","hash":"c415da6bf346ee080f83e5c5bfedd51f3582e999","modified":1674914191248},{"_id":"public/categories/内存管理/index.html","hash":"d127e3a187999cade82cb81c56de1852a672975c","modified":1674914191248},{"_id":"public/categories/对象序列化/index.html","hash":"24290f9e8628915704c1ac82a3def0be2e0290c4","modified":1674914191248},{"_id":"public/categories/数据库编程/index.html","hash":"7696b2b70c2f9d44a3ea0c40c3d7fc967aa61b2d","modified":1674914191248},{"_id":"public/2016/11/14/serialize2/index.html","hash":"2bf8f42d5e5faa80b205f11a895970e402affab7","modified":1674914191248},{"_id":"public/2016/10/16/serialize/index.html","hash":"2e5c043d4387f30e23cee50dacd8021716747c01","modified":1674914191248},{"_id":"public/2015/11/15/memory_pool/index.html","hash":"7a6c3170cdd85ed38729d85dcedf82eae859e0fa","modified":1674914191248},{"_id":"public/2014/09/03/db/index.html","hash":"2a10a34b60aada0ce16858334322fda3f96abf67","modified":1674914191248},{"_id":"public/2012/07/13/aio_rpc/index.html","hash":"0f8cc7ff1f6541180081a1ee2ea19b2c53f1ff83","modified":1674914191248},{"_id":"public/2013/02/24/aio_rpc_mfc/index.html","hash":"7c391f4b9ef0ae69f811959155d8b86298b85f5e","modified":1674914191248},{"_id":"public/2013/10/26/threads_cpp/index.html","hash":"8448f4a79c01b67f6823599cbc36dcc54cdb7630","modified":1674914191248},{"_id":"public/img/db2.png","hash":"79103722d277c829d2b7b1e64c924e75b40e4e1f","modified":1674914191248},{"_id":"public/img/aio_rpc_mfc.png","hash":"8e28290994e32f75d3474dfb9d596cdf7620b44d","modified":1674914191248},{"_id":"public/img/db.png","hash":"9e5b58c1c10d797150f1058c2f4de25dc4fdfaa7","modified":1674914191248}],"Category":[{"name":"协程编程","_id":"cld8my2zd0000tm9k0ynd21f4"},{"name":"SSL编程","_id":"cld8my8730002tm9k4d9ag8py"},{"name":"http开发","_id":"cld8tqdn00001bx9k1m5p7c8u"},{"name":"faq","_id":"cld8vgtdu0001rt9k31wrgab3"},{"name":"进程控制","_id":"cld9no3at000729fy8o06e9vr"},{"name":"配置文件","_id":"cld9s2kmf000a29fy1ytfhp1k"},{"name":"服务编程","_id":"cld9s9840000d29fy775kfdgo"},{"name":"网络编程","_id":"cld9ui39200017x9k8v7n4frm"},{"name":"非阻塞编程","_id":"cld9vmr0e000a7x9karih8922"},{"name":"线程编程","_id":"cld9xuv8g000j7x9kgnca3dko"},{"name":"日志","_id":"cld9y3v0n000m7x9ke1pga0uz"},{"name":"redis使用","_id":"clda039u70001yr9k9kxn67rz"},{"name":"内存管理","_id":"clda1dl5o00018o9k8i7y1fdf"},{"name":"数据库编程","_id":"clda1w9vq00068o9kazdy4rdj"},{"name":"序列化","_id":"clda2hjdp00098o9k86238btw"},{"name":"对象序列化","_id":"clda2quwr000b8o9k5urx1doa"}],"Data":[],"Page":[{"title":"about Acl project","date":"2023-01-22T15:31:00.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: about Acl project\ndate: 2023-01-22 23:31:00\n---\n","updated":"2023-01-22T15:31:21.550Z","path":"about/index.html","comments":1,"layout":"page","_id":"cld7jewtf0000s99kg3b471mr","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"协程编程","date":"2023-01-23T09:53:17.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: 协程编程\ndate: 2023-01-23 17:53:17\ntype: categories\n---\n","updated":"2023-01-23T09:57:28.032Z","path":"categories/index.html","_id":"cld8msg2h0000t29kfscl7456","comments":1,"layout":"page","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Acl 网络协程框架编程指南","date":"2019-04-07T05:08:24.000Z","_content":"\n# Acl 网络协程框架编程指南\n<!-- vim-markdown-toc GFM -->\n\n* [摘要](#摘要)\n* [一、概述](#一概述)\n* [二、简单示例](#二简单示例)\n* [三、编译安装](#三编译安装)\n* [四、使用多核](#四使用多核)\n* [五、多核同步](#五多核同步)\n* [六、消息传递](#六消息传递)\n* [七、HOOK API](#七HOOKAPI)\n* [八、域名解析](#八域名解析)\n* [九、使第三方网络库协程化](#九使第三方网络库协程化)\n* [十、Windows 界面编程协程化](#十Windows界面编程协程化)\n\n<!-- vim-markdown-toc -->\n\n## 摘要\n本文主要讲述Acl网络协程框架的使用，从协程的应用场景出发，以一个简单的协程示例开始，然后逐步深入到Acl网络协程的各个使用场景及使用细节，以及需要避免的“坑”，希望能给大家带来实践上的帮助。\n## 一、概述\n讲到协程，大家必然会提到 Go 语言，毕竟是 Go 语言把协程的概念及使用实践普及的；但协程并不是一个新概念，我印象中在九十年代就出现了，当时一位同事还说微软推出了纤程（基本一个意思），可以创建成午上万个纤程，不必象线程那样只能创建较少的线程数量，但当时也没明白创建这么多纤程有啥用，只不过是一个上下文的快速切换协同而已。所以自己在写网络高并发服务时，主要还是以非阻塞方式来实现。\n其实，Go 语言的作者之一 Russ Cox 早在 2002 年左右就用 C 实现了一个简单的基于协程的网络通信模型 -- libtask，但其只是一个简单的网络协程原型，还远达不到实践的要求。自从 Go 语言兴起后，很多基于 C/C++ 开发的协程库也多了起来，其中 Acl 协程库便是其中之一。\nAcl 工程地址：https://github.com/acl-dev/acl\nAcl 协程地址：https://github.com/acl-dev/acl/tree/master/lib_fiber\n\n## 二、简单示例\n下面为一个使用 Acl 库编写的简单线程的例子：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n\nclass mythread : public acl::thread\n{\npublic:\n\tmythread(void) {}\n\t~mythread(void) {}\nprivate:\n\t// 实现基类中纯虚方法，当线程启动时该方法将被回调\n\t// @override\n\tvoid* run(void) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tprintf(\"thread-%lu: running ...\\r\\n\", acl::thread::self());\n\t\t}\n\t\treturn NULL;\n\t}\n};\n\nint main(void)\n{\n\tstd::vector<acl::thread*> threads;\n\tfor (int i = 0; i < 10; i++) {\n\t\tacl::thread* thr = new mythread;\n\t\tthreads.push_back(thr);\n\t\tthr->start();  // 启动线程\n\t}\n\t\n\tfor (std::vector<acl::thread*>::iterator it = threads.begin();\n\t\tit != threads.end(); ++it) {\n\t\t(*it)->wait();  // 等待线程退出\n\t\tdelete *it;\n\t}\n\treturn 0;\t\n}\n```\n上面线程例子非常简单，接着再给一个简单的协程的例子：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass myfiber : public acl::fiber\n{\npublic:\n\tmyfiber(void) {}\n\t~myfiber(void) {}\nprivate:\n\t// 重现基类纯虚方法，当调用 fiber::start 时，该方法将被调用\n\t// @override\n\tvoid run(void) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tprintf(\"hello world! the fiber is %d\\r\\n\", acl::fiber::self());\n\t\t\tacl::fiber::yield();  // 让出CPU运行权给其它协程\n\t\t}\n\t}\n};\n\nint main(void)\n{\n\tstd::vector<acl::fiber*> fibers;\n\tfor (int i = 0; i < 10; i++) {\n\t\tacl::fiber* fb = new myfiber;\n\t\tfibers.push_back(fb);\n\t\tfb->start();  // 启动一个协程\n\t}\n\t\n\tacl::fiber::schedule();  // 启用协程调度器\n\t\n\tfor (std::vector<acl::fiber*>::iterator it = fibers.begin();\n\t\tit != fibers.end(); ++it) {\n\t\tdelete *it;\n\t}\n}\n```\n上面示例演示了协程的创建、启动及运行的过程，与前一个线程的例子非常相似，非常简单（简单实用是 Acl 库的目标之一）。\n**协程调度其实是应用层面多个协程之间通过上下文切换形成的协作过程，如果一个协程库仅是实现了上下文切换，其实并不具备太多实用价值，当与网络事件绑定后，其价值才会显现出来**。下面一个简单的使用协程的网络服务程序：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\n// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程\nclass fiber_echo : public acl::fiber\n{\npublic:\n\tfiber_echo(acl::socket_stream* conn) : conn_(conn) {}\nprivate:\n\tacl::socket_stream* conn_;\n\t~fiber_echo(void) { delete conn_; }\n\t// @override\n\tvoid run(void) {\n\t\tchar buf[8192];\n\t\twhile (true) {\n\t\t\t// 从客户端读取数据（第三个参数为false表示不必填满整个缓冲区才返回）\n\t\t\tint ret = conn_->read(buf, sizeof(buf), false);\n\t\t\tif (ret == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 向客户端写入读到的数据\n\t\t\tif (conn_->write(buf, ret) != ret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this; // 自销毁动态创建的协程对象\n\t}\n};\n\n// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定\nclass fiber_listen : public acl::fiber\n{\npublic:\n\tfiber_listen(acl::server_socket& listener) : listener_(listener) {}\nprivate:\n\tacl::server_socket& listener_;\n\t~fiber_listen(void) {}\n\t// @override\n\tvoid run(void) {\n\t\twhile (true) {\n\t\t\tacl::socket_stream* conn = listener_.accept();  // 等待客户端连接\n\t\t\tif (conn == NULL) {\n\t\t\t\tprintf(\"accept failed: %s\\r\\n\", acl::last_serror());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 创建并启动单独的协程处理客户端连接\n\t\t\tacl::fiber* fb = new fiber_echo(conn);\n\t\t\t// 启动独立的客户端处理协程\n\t\t\tfb->start();\n\t\t}\n\t\tdelete this;\n\t}\n};\n\nint main(void)\n{\n\tconst char* addr = \"127.0.0.1:8800\";\n\tacl::server_socket listener;\n\t// 监听本地地址\n\tif (listener.open(addr) == false) {\n\t\tprintf(\"listen %s error %s\\r\\n\", addr, acl::last_serror());\n\t\treturn 1;\n\t}\n\n\t// 创建并启动独立的监听协程，接受客户端连接\n\tacl::fiber* fb = new fiber_listen(listener);\n\tfb->start();\n\n\t// 启动协程调度器\n\tacl::fiber::schedule();\n\treturn 0;\n}\n```\n这是一个简单的支持回显功能的网络协程服务器，可以很容易修改成线程模式。使用线程或线程处理网络通信都可以采用**顺序思维**模式，不必象非阻塞网络编程那样复杂，但使用协程的最大好处可以创建大量的协程来处理网络连接，而要创建大量的线程显示是不现实的（线程数非常多时，会导致操作系统的调度能力下降）。**如果你的网络服务应用不需要支持大并发，使用协程的意义就没那么大了**。\n## 三、编译安装\n在编译前，需要先从 github  https://github.com/acl-dev/acl  下载源码，国内用户可以选择从 gitee  https://gitee.com/acl-dev/acl  下载源码。\n### 3.1、Linux/Unix 平台上编译安装\n在 Linux/Unix 平台上的编译非常简单，可以选择使用 make 方式或 cmake 方式进行编译。  \n- **make 方式编译：**\n在 acl 项目根目录下运行：**make && make packinstall**，则会自动执行编译与安装过程，安装目录默认为系统目录：libacl_all.a, libfiber_cpp.a, libfiber.a 将被拷贝至 /usr/lib/ 目录，头文件将被拷贝至 /usr/include/acl-lib/ 目录。\n- **cmake 方式编译：**\n在 acl 项目根目录下创建 build 目录，然后：**cd build && cmake .. && make**\n- **将 acl 库加入至你的工程**（以 make 方式为例）\n先在代码中加入头文件包含项：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n```\n然后修改你的 Makefile 文件，示例如下：\n```c\nmytest: mytest.cpp\n\tg++ -o mytest mytest.cpp -lfiber_cpp -lacl_all -lfiber -ldl -lpthread -lz\n```\n**注意在 Makefile 中各个库的依赖顺序：** libfiber_cpp.a 依赖于 libacl_all.a 和 libfiber.a，其中 libacl_all.a 为 acl 的基础库，libfiber.a 为 C 语言协程库（其不依赖于 libacl_all.a），libfiber_cpp.a 用 C++ 语言封装了 libfiber.a，且使用了 libacl_all.a 中的一些功能。 \n### 3.2、Windows 平台上编译\n在 Windows 平台的编译也非常简单，可以用 vc2008/2010/2012/2013/2015/2017 打开相应的工程文件进行编译，如：可以用 vc2012 打开 acl_cpp_vc2012.sln 工程进行编译。\n### 3.3 Mac 平台上编译\n除可以使用 Unix 统一方式（命令行方式）编译外，还可以用 Xcode 打开工程文件进行编译。\n### 3.4 Android 平台上编译\n目前可以使用 Android Studio3.x 打开 acl\\android\\acl 目录下的工程文件进行编译。\n### 3.5 使用 MinGW 编译\n如果想要在 Windows 平台上编译 Unix 平台上的软件，可以借用 MinGW 套件进行编译，为此 Acl 库还提供了此种编译方式，但一般不建议用户使用这种编译方式，一方面是执行效率低，另一方面可能会存在某些不兼容问题。\n### 3.6 小结\n为了保证 Acl 工程无障碍使用，本人在编译 Acl 库方面下了很大功夫，支持几乎在所有平台上使用原生编译环境进行编译使用，真正达到了一键编译。甚至为了避免因依赖第三方库而导致的编译问题（如：有的模块需要 zlib 库，有的需要 polassl 库，有的需要 mysql/postgresql/sqlite 库），将这些依赖第三方库的模块都写成动态加载第三方库的方式，毕竟不是所有人都需要这些第三方库所提供的功能。\n## 四、使用多核\nAcl 协程的调度过程是基于单CPU的（虽然也可以修改成多核调度，但考虑到很多原因，最终还是采用了单核调度模式），即创建一个线程，所创建的所有协程都在这个线程空间中运行。为了使用多核，充分使用CPU资源，可以创建多个线程（也可以创建多个进程），每个线程为一个独立的协程运行容器，各个线程之间的协程相互隔离，互不影响。\n下面先修改一下上面的例子，改成多线程的协程方式：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\n// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程\nclass fiber_echo : public acl::fiber\n{\npublic:\n\tfiber_echo(acl::socket_stream* conn) : conn_(conn) {}\nprivate:\n\tacl::socket_stream* conn_;\n\t~fiber_echo(void) { delete conn_; }\n\t// @override\n\tvoid run(void) {\n\t\tchar buf[8192];\n\t\twhile (true) {\n\t\t\tint ret = conn_->read(buf, sizeof(buf), false);\n\t\t\tif (ret == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (conn_->write(buf, ret) != ret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this; // 自销毁动态创建的协程对象\n\t}\n};\n\n// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定\nclass fiber_listen : public acl::fiber\n{\npublic:\n\tfiber_listen(acl::server_socket& listener) : listener_(listener) {}\nprivate:\n\tacl::server_socket& listener_;\n\t~fiber_listen(void) {}\n\t// @override\n\tvoid run(void) {\n\t\twhile (true) {\n\t\t\tacl::socket_stream* conn = listener_.accept();  // 等待客户端连接\n\t\t\tif (conn == NULL) {\n\t\t\t\tprintf(\"accept failed: %s\\r\\n\", acl::last_serror());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 创建并启动单独的协程处理客户端连接\n\t\t\tacl::fiber* fb = new fiber_echo(conn);\n\t\t\tfb->start();\n\t\t}\n\t\tdelete this;\n\t}\n};\n\n// 独立的线程调度类\nclass thread_server : public acl::thread\n{\npublic:\n\tthread_server(acl::server_socket& listener) : listener_(listener) {}\n\t~thread_server(void) {}\nprivate:\n\tacl::server_socket& listener_;\n\t// @override\n\tvoid* run(void) {\n\t\t// 创建并启动独立的监听协程，接受客户端连接\n\t\tacl::fiber* fb = new fiber_listen(listener);\n\t\tfb->start();\n\t\t// 启动协程调度器\n\t\tacl::fiber::schedule(); // 内部处于死循环过程\n\t\treturn NULL;\n\t}\n};\n\nint main(void)\n{\n\tconst char* addr = \"127.0.0.1:8800\";\n\tacl::server_socket listener;\n\t// 监听本地地址\n\tif (listener.open(addr) == false) {\n\t\tprintf(\"listen %s error %s\\r\\n\", addr, acl::last_serror());\n\t\treturn 1;\n\t}\n\n\tstd::vector<acl::thread*> threads;\n\t// 创建多个独立的线程对象，每个线程启用独立的协程调度过程\n\tfor (int i = 0; i < 4; i++) {\n\t\tacl::thread* thr = thread_server(listener);\n\t\tthreads.push_back(thr);\n\t\tthr->start();\n\t}\n\tfor (std::vector<acl::thread*>::iterator it = threads.begin();\n\t\tit != threads.end(); ++it) {\n\t\t(*it)->wait();\n\t\tdelete *it;\n\t}\n\treturn 0;\n}\n```\n经过修改，上面的例子即可以支持大并发，又可以使用多核。\n## 五、多核同步\n上面的例子中涉及到了通过创建多线程使用多核的过程，但肯定会有人问，在多个线程中的协程之间如果想要共享某个资源怎么办？Acl 协程库提供了可以跨线程使用同步原语：线程协程事件同步及条件变量。\n首先介绍一下事件同步对象类：acl::fiber_event，该类提供了三个方法：\n```c\n\t/**\n\t * 等待事件锁\n\t * @return {bool} 返回 true 表示加锁成功，否则表示内部出错\n\t */\n\tbool wait(void);\n\n\t/**\n\t * 尝试等待事件锁\n\t * @return {bool} 返回 true 表示加锁成功，否则表示锁正在被占用\n\t */\n\tbool trywait(void);\n\n\t/**\n\t * 事件锁拥有者释放事件锁并通知等待者\n\t * @return {bool} 返回 true 表示通知成功，否则表示内部出错\n\t */\n\tbool notify(void);\n```\n下面给出一个例子，看看在多个线程中的协程之间如何进行互斥的：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass myfiber : public acl::fiber\n{\npublic:\n\tmyfiber(acl::fiber_event& lock, int& count): lock_(lock), count_(count) {}\nprivate:\n\t~myfiber(void) {}\n\t// @override\n\tvoid run(void) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tlock_.wait();\n\t\t\tcount_++;\n\t\t\tlock_.notify();\n\t\t\t//acl::fiber::delay(1);  // 本协程休息1毫秒\n\t\t}\n\t\tdelete this;\n\t}\nprivate:\n\tacl::fiber_event& lock_;\n\tint& count_;\n};\n\nclass mythread : public acl::thread\n{\npublic:\n\tmythread(acl::fiber_event& lock, int& count): lock_(lock), count_(count) {}\n\t~mythread(void) {}\nprivate:\n\t// @override\n\tvoid* run(void) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tacl::fiber* fb = new myfiber(lock_, count_);\n\t\t\tfb->start();\n\t\t}\n\t\tacl::fiber::schedule();\n\t\treturn NULL;\n\t}\nprivate:\n\tacl::fiber_event& lock_;\n\tint& count_;\n};\n\nint main(void)\n{\n\tacl::fiber_event lock;  // 可以用在多个线程之间、各个线程中的协程之间的同步过程\n\tint count = 0;\n\tstd::vector<acl::thread*> threads;\n\tfor (int i = 0; i < 4; i++) {\n\t\tacl::thread* thr = new mythread(lock, count);\n\t\tthreads.push_back(thr);\n\t\tthr->start();\n\t}\n\tfor (std::vector<acl::thread*>::iterator it = threads.begin();\n\t\tit != threads.end(); ++it) {\n\t\t(*it)->wait();\n\t\tdelete *it;\n\t}\n\n\tprintf(\"all over, count=%d\\r\\n\", count);\n\treturn 1;\n}\n```\nacl::fiber_event 常被用在多个线程中的协程之间的同步，当然也可以用在多个线程之间的同步，这在很大程度弥补了 Acl 协程框架在使用多核上的不足。\n## 六、消息传递\n通过组合 acl::fiber_event（协程事件）和 acl::fiber_cond（协程条件变量），实现了协程间进行消息传递的功能模块：acl::fiber_tbox，fiber_tbox 不仅可以用在同一线程内的协程之间传递消息，而且还可以用在不同线程中的协程之间，不同线程之间，线程与协程之间传递消息。fiber_tbox 为模板类，因而可以传递各种类型对象。以下给出一个示例：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass myobj\n{\npublic:\n\tmyobj(void) : i_(0) {}\n\t~myobj(void) {}\n\tvoid set(int i) {\n\t\ti_ = i;\n\t}\n\tvoid test(void) {\n\t\tprintf(\"hello world, i=%d\\r\\n\", i_);\n\t}\nprivate:\n\tint i_;\n};\n\n// 消费者协程，从消息管道中读取消息\nclass fiber_consumer : public acl::fiber\n{\npublic:\n\tfiber_consumer(acl::fiber_tbox<myobj>& box) : box_(box) {}\nprivate:\n\t~fiber_consumer(void) {}\nprivate:\n\tacl::fiber_tbox<myobj>& box_;\n\t// @override\n\tvoid run(void) {\n\t\twhile (true) {\n\t\t\tmyobj* o = box_.pop();\n\t\t\t// 如果读到空消息，则结束\n\t\t\tif (o == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\to->test();\n\t\t\tdelete o;\n\t\t}\n\t\tdelete this;\n\t}\n};\n\n// 生产者协程，向消息管道中放置消息\nclass fiber_producer : public acl::fiber\n{\npublic:\n\tfiber_producer(acl::fiber_tbox<myobj>& box) : box_(box) {}\nprivate:\n\t~fiber_producer(void) {}\nprivate:\n\tacl::fiber_tbox<myobj>& box_;\n\t// @override\n\tvoid run(void) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tmyobj* o = new myobj;\n\t\t\to->set(i);\n\t\t\t// 向消息管道中放置消息\n\t\t\tbox_.push(o);\n\t\t}\n\t\t// 放置空消息至消息管道中，从而通知消费者协程结束\n\t\tbox_.push(NULL);\n\t\tdelete this;\n\t}\n};\n\nint main(void)\n{\n\tacl::fiber_tbox<myobj> box;\n\t// 创建并启动消费者协程\n\tacl::fiber* consumer = new fiber_consumer(box);\n\tconsumer->start();\n\t// 创建并启动生产者协程\n\tacl::fiber* producer = new fiber_producer(box);\n\tproducer->start();\n\t// 启动协程调度器\n\tacl::fiber::schedule();\n\treturn 0; \n}\n```\n上面例子展示了同一线程中的两个协程之间的消息传递过程，因为 acl::fiber_tbox 是可以跨线程的，所以它的更大价值是用在多个线程中的不同协程之间进行消息传递。\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass myobj\n{\npublic:\n\tmyobj(void) : i_(0) {}\n\t~myobj(void) {}\n\tvoid set(int i) {\n\t\ti_ = i;\n\t}\n\tvoid test(void) {\n\t\tprintf(\"hello world, i=%d\\r\\n\", i_);\n\t}\nprivate:\n\tint i_;\n};\n\n// 消费者协程，从消息管道中读取消息\nclass fiber_consumer : public acl::fiber\n{\npublic:\n\tfiber_consumer(acl::fiber_tbox<myobj>& box) : box_(box) {}\nprivate:\n\t~fiber_consumer(void) {}\nprivate:\n\tacl::fiber_tbox<myobj>& box_;\n\t// @override\n\tvoid run(void) {\n\t\twhile (true) {\n\t\t\tmyobj* o = box_.pop();\n\t\t\t// 如果读到空消息，则结束\n\t\t\tif (o == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\to->test();\n\t\t\tdelete o;\n\t\t}\n\t\tdelete this;\n\t}\n};\n\n// 生产者线程，向消息管道中放置消息\nclass thread_producer : public acl::thread\n{\npublic:\n\tthread_producer(acl::fiber_tbox<myobj>& box) : box_(box) {}\n\t~thread_producer(void) {}\nprivate:\n\tacl::fiber_tbox<myobj>& box_;\n\tvoid* run(void) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tmyobj* o = new myobj;\n\t\t\to->set(i);\n\t\t\tbox_.push(o);\n\t\t}\n\t\tbox_.push(NULL);\n\t\treturn NULL;\n\t}\n};\n\nint main(void)\n{\n\tacl::fiber_tbox<myobj> box;\n\t// 创建并启动消费者协程\n\tacl::fiber* consumer = new fiber_consumer(box);\n\tconsumer->start();\n\t// 创建并启动生产者线程\n\tacl::thread* producer = new thread_producer(box);\n\tproducer->start();\n\t// 启动协程调度器\n\tacl::fiber::schedule();\n\t// schedule() 过程返回后，表示该协程调度器结束。\n\t// 等待生产者线程退出\n\tproducer->wait();\n\tdelete producer;\n\treturn 0; \n}\n```\n在该示例中，生产者为一个独立的线程，消费者为另一个线程中的协程，二者通过 acl::fiber_tbox 进行消息通信。但**有一点需要注意**，fiber_tbox 一般可用在“单生产者-单消费者或多生产者-单消费者”的应用场景中，不应用在多消费者的场景中，虽然用在多个消费者场景时不会造成消费丢失或内存崩溃，但当消费者数量较多时却有可能出现惊群现象，所以应避免将一个 acl::fiber_tbox 用在大量的多消费者场景中。\n下面再给一个应用场景的例子，也是我们平时经常会遇到的。\n```c\n#include <unistd.h>\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass mythread : public acl::thread\n{\npublic:\n\tmythread(acl::fiber_tbox<int>& box) :box_(box) {}\n\t~mythread(void) {}\nprivate:\n\tacl::fiber_tbox<int>& box_;\n\t// @override\n\tvoid* run(void) {\n\t\tint i;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\t/* 假设这是一个比较耗时的操作*/\n\t\t\tprintf(\"sleep one second\\r\\n\");\n\t\t\tsleep(1);\n\t\t}\n\t\tint* n = new int(i);\n\t\t// 将计算结果通过消息管道传递给等待者协程\n\t\tbox_.push(n);\n\t\treturn NULL; \n\t}\n};\n\nclass myfiber : public acl::fiber\n{\npublic:\n\tmyfiber(void) {}\n\t~myfiber(void) {}\nprivate:\n\t// @override\n\tvoid run(void) {\n\t\tacl::fiber_tbox<int> box;\n\t\tmythread thread(box);\n\t\tthread.set_detachable(true);\n\t\tthread.start();  // 启动独立的线程计算耗时运算\n\t\tint* n = box.pop();  // 等待计算线程返回运算结果，仅会阻塞当前协程\n\t\tprintf(\"n is %d\\r\\n\", *n);\n\t\tdelete n;\n\t}\n};\n\nint main(void)\n{\n\tmyfiber fb;\n\tfb.start();\n\tacl::fiber::schedule();\n\treturn 0;\n}\n```\n协程一般用在网络高并发环境中，但协程并不是万金油，协程并不适合计算密集型应用，因为线程才是操作系统的最小调度单元，而协程不是，所以当遇到一些比较耗时的运算时，为了不阻塞当前协程所在的协程调度器，应将该耗时运算过程中抛给独立的线程去处理，然后通过 acl::fiber_tbox 等待线程的运算结果。\n## 七、HOOK API\n为了使现有的很多网络应用和网络库在尽量不修改的情况下协程化，Acl 协程库 Hook 了很多与 IO 和网络通信相关的系统 API，目前已经 Hook 的系统 API 有：\n| 内容项 |API|\n|--|--|\n|网络相关|socket/listen/accept/connect  |\n|IO相关|read/readv/recv/recvfrom/recvmsg/write/writev/send/sendto/sendmsg/sendfile64|\n|域名相关|gethostbyname(_r)/getaddrinfo/freeaddrinfo|\n|事件相关|select/poll/epoll_create/ epoll_ctl/epoll_wait|\n|其它|close/sleep|\n## 八、域名解析\n使用协程方式编写网络通信程序，域名解析是不能绕过的，记得有一个协程库说为了支持域名解析，甚至看了相关实现代码，然后说通过 Hook _poll API 就可以了，实际上这并不是通用的做法，至少在我的环境里通过 Hook _poll API 是没用的，所以最稳妥的做法还是应该将 DNS 查询协议实现了，在 acl 的协程库中，域名解析模块在初期集成了第三方 DNS 库，参见：https://github.com/wahern/dns  ，但因为该第 DNS 库存在很多问题（如：不能跨平台，代码混乱，没处理IO异常等问题），所以最终 acl 协程丢弃该库，自己实现了一套更加方便灵活跨平台的 DNS 协议库。 \n\n## 九、使第三方网络库协程化\n通常网络通信库都是阻塞式的，因为非阻塞式的通信库的通用性不高（使用各自的事件引擎，很难达到应用层的使用一致性），如果把这些第三方通信库（如：mysql 客户端库，Acl 中的 Redis 库）使用协程所提供的 IO 及网络  API 重写一遍则工作量太大，不太现实，好在 Acl 协程库 Hook 了很多系统 API，从而使阻塞式的网络通信库协程化变得简单。所谓网络库协程化就是使这些网络库可以应用在协程环境中，从而可以很容易编写出支持高并发的网络程序。\n先写一个将 Acl Redis 客户端库协程化的例子：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass fiber_redis : public acl::fiber\n{\npublic:\n\tfiber_redis(acl::redis_client_cluster& cluster) : cluster_(cluster) {}\nprivate:\n\t~fiber_redis(void) {}\nprivate:\n\tacl::redis_client_cluster& cluster_;\n\t// @override\n\tvoid run(void) {\n\t\tconst char* key = \"hash-key\";\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tacl::redis cmd(&cluster_);\n\t\t\tacl::string name, val;\n\t\t\tname.format(\"hash-name-%d\", i);\n\t\t\tval.format(\"hash-val-%d\", i);\n\t\t\tif (cmd.hset(key, name, val) == -1) {\n\t\t\t\tprintf(\"hset error: %s, key=%s, name=%s\\r\\n\",\n\t\t\t\t\tcmd.result_error(), key, name.c_str());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this;\n\t}\n};\n\nint main(void)\n{\n\tconst char* redis_addr = \"127.0.0.1:6379\";\n\tacl::redis_client_cluster cluster;\n\tcluster.set(redis_addr, 0);\n\tfor (int i = 0; i < 100; i++) {\n\t\tacl::fiber* fb = new fiber_redis(cluster);\n\t\tfb->start();\n\t}\n\tacl::fiber::schedule();\n\treturn 0;\n}\n```\n读者可以尝试将上面的代码拷贝到自己机器上，编译后运行一下。另外，这个例子是只有一个线程，所以会发现 acl::redis_client_cluster 的使用方式和在线程下是一样的。如果将 acl::redis_client_cluster 在多个线程调度器上共享会怎样？还是有一点区别，如下：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\n// 每个协程共享相同的 cluster 对象，向 redis-server 中添加数据\nclass fiber_redis : public acl::fiber\n{\npublic:\n\tfiber_redis(acl::redis_client_cluster& cluster) : cluster_(cluster) {}\nprivate:\n\t~fiber_redis(void) {}\nprivate:\n\tacl::redis_client_cluster& cluster_;\n\t// @override\n\tvoid run(void) {\n\t\tconst char* key = \"hash-key\";\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tacl::redis cmd(&cluster_);\n\t\t\tacl::string name, val;\n\t\t\tname.format(\"hash-name-%d\", i);\n\t\t\tval.format(\"hash-val-%d\", i);\n\t\t\tif (cmd.hset(key, name, val) == -1) {\n\t\t\t\tprintf(\"hset error: %s, key=%s, name=%s\\r\\n\",\n\t\t\t\t\tcmd.result_error(), key, name.c_str());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this;\n\t}\n};\n\n// 每个线程运行一个独立的协程调度器\nclass mythread : public acl::thread\n{\npublic:\n\tmythread(acl::redis_client_cluster& cluster) : cluster_(cluster) {}\n\t~mythread(void) {}\nprivate:\n\tacl::redis_client_cluster& cluster_;\n\t// @override\n\tvoid* run(void) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tacl::fiber* fb = new fiber_redis(cluster_\t);\n\t\t\tfb->start();\n\t\t}\n\t\tacl::fiber::schedule();\n\t\treturn NULL;\n\t}\n};\n\nint main(void)\n{\n\tconst char* redis_addr = \"127.0.0.1:6379\";\n\tacl::redis_client_cluster cluster;\n\tcluster.set(redis_addr, 0);\n\tcluster.bind_thread(true);\n\n\t// 创建多个线程，共享 redis 集群连接池管理对象：cluster，即所有线程中的\n\t// 所有协程共享同一个 cluster 集群管理对象\n\tstd::vector<acl::thread*> threads;\n\tfor (int i = 0; i < 4; i++) {\n\t\tacl::thread* thr = new mythread(cluster);\n\t\tthreads.push_back(thr);\n\t\tthr->start();\n\t}\n\tfor (std::vector<acl::thread*>::iterator it = threads.begin();\n\t\tit != threads.end(); ++it) {\n\t\t(*it)->wait();\n\t\tdelete *it;\n\t}\n\treturn 0;\n}\n```\n在这个多线程多协程环境里使用 acl::redis_client_cluster 对象时与前面的一个例子有所不同，在这里调用了：**cluster.bind_thread(true);** \n为何要这样做？原因是 Acl Redis 的协程调度器是单线程工作模式，网络套接字句柄在协程环境里不能跨线程使用，当调用 bind_thread(true) 后，Acl 连接池管理对象会自动给每个线程分配一个连接池对象，每个线程内的所有协程共享这个绑定于本线程的连接池对象。\n## 十、Windows 界面编程协程化\n在Windows下写过界面程序的程序员都经历过使通信模块与界面结合的痛苦过程，因为 Windows 界面过程是基于 win32 消息引擎驱动的，所以在编写通信模块时一般有两个选择：要么使用 Windows 提供的异步非阻塞 API，要么把通信模块放在独立于界面的单独线程中然后通过窗口消息将结果通知窗口界面过程。\nAcl 协程库的事件引擎支持 win32 消息引擎，所以很容易将界面过程的通信过程协程化，采用这种方式，一方面程序员依然可以采用顺序编程方式，另一方面通信协程与界面过程运行于相同的线程空间，则二者在相互访问对方的成员对象时不必加锁，从而使编写通信过程变得更加简单。\n下面以一个简单的对话框为例说明界面网络通信协程化过程：    \n1. 首先使用向导程序生成一个对话框界面程序，需要指定支持 socket 通信；\n2. 然后在 OnInitDialog() 方法尾部添加如下代码：\n```c\n\t// 设置协程调度的事件引擎，同时将协程调度设为自动启动模式\n\tacl::fiber::init(acl::FIBER_EVENT_T_WMSG, true);\n\t// HOOK ACL 库中的网络 IO 过程\n\tacl::fiber::acl_io_hook();\n```\n3. 创建一个按钮，并使其绑定一个事件方法，如：OnBnClickedListen，然后在这个方法里添加一些代码：\n```c\n\t// 创建一个协程用来监听指定地址，接收客户端连接请求\n\tm_fiberListen = new CFiberListener(\"127.0.0.1:8800\");\n\t// 启动监听协程\n\tm_fiberListen->start();\n```\n4. 实现步骤 3 中指定的监听协程类\n```c\nclass CFiberListener : public acl::fiber\n{\npublic:\n\tCFiberListener(const char* addr) : m_addr(addr) {}\nprivate:\n\t~CFiberListener(void) {}\nprivate:\n\tacl::string m_addr;\n\tacl::server_socket m_listener;\n\t// @override\n\tvoid run(void) {\n\t\t// 绑定并监听指定的本地地址\n\t\tif (m_listener.open(m_addr) == false) {\n\t\t\treturn;\n\t\t}\n\t\twhile (true) {\n\t\t\t// 等待客户端连接\n\t\t\tacl::socket_stream* conn = m_listener.accept();\n\t\t\tif (conn == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 创建独立的协程处理该客户端的请求\n\t\t\tacl::fiber* fb = new CFiberClient(conn);\n\t\t\tfb->start(); // 启动客户端处理协程\n\t\t}\n\t\tdelete this;\n\t}\n};\n```\n5. 实现步骤 4 中指定的客户端响应协程类\n```c\nclass CFiberClient : public acl::fiber\n{\npublic:\n\tCFiberClient(acl::socket_stream* conn) : m_conn(conn) {}\nprivate:\n\t~CFiberClient(void) { delete m_conn; }\nprivate:\n\tacl::socket_stream* m_conn;\n\t// @override\n\tvoid run(void) {\n\t\tchar buf[8192];\n\t\twhile (true) {\n\t\t\t// 从客户端读取数据\n\t\t\tint ret = m_conn->read(buf, sizeof(buf), false);\n\t\t\tif (ret == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 将读到的数据回写给客户端\n\t\t\tif (m_conn->write(buf, ret) != ret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this;\n\t}\n};\n```\n通过以上步骤就可为 win32 界面程序添加基于协程模式的通信模块，上面的两个协程类的处理过程都是“死循环”的，而且又与界面过程同处同一线程运行空间，却为何却不会阻塞界面消息过程呢？其原因就是当通信协程类对象在遇到网络 IO 阻塞时，会自动将自己挂起，将线程的运行权交给其它协程或界面过程。原理就是这么简单，但内部实现还有点复杂度的，感兴趣的可以看看 Acl 协程库的实现源码(https://github.com/acl-dev/acl/tree/master/lib_fiber/ )。\n此外，上面示例的完整代码请参考：https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/WinEchod  。\n","source":"_posts/fiber.md","raw":"---\ntitle: Acl 网络协程框架编程指南\ndate: 2019-04-07 13:08:24\ntags: 协程编程\ncategories: 协程编程\n---\n\n# Acl 网络协程框架编程指南\n<!-- vim-markdown-toc GFM -->\n\n* [摘要](#摘要)\n* [一、概述](#一概述)\n* [二、简单示例](#二简单示例)\n* [三、编译安装](#三编译安装)\n* [四、使用多核](#四使用多核)\n* [五、多核同步](#五多核同步)\n* [六、消息传递](#六消息传递)\n* [七、HOOK API](#七HOOKAPI)\n* [八、域名解析](#八域名解析)\n* [九、使第三方网络库协程化](#九使第三方网络库协程化)\n* [十、Windows 界面编程协程化](#十Windows界面编程协程化)\n\n<!-- vim-markdown-toc -->\n\n## 摘要\n本文主要讲述Acl网络协程框架的使用，从协程的应用场景出发，以一个简单的协程示例开始，然后逐步深入到Acl网络协程的各个使用场景及使用细节，以及需要避免的“坑”，希望能给大家带来实践上的帮助。\n## 一、概述\n讲到协程，大家必然会提到 Go 语言，毕竟是 Go 语言把协程的概念及使用实践普及的；但协程并不是一个新概念，我印象中在九十年代就出现了，当时一位同事还说微软推出了纤程（基本一个意思），可以创建成午上万个纤程，不必象线程那样只能创建较少的线程数量，但当时也没明白创建这么多纤程有啥用，只不过是一个上下文的快速切换协同而已。所以自己在写网络高并发服务时，主要还是以非阻塞方式来实现。\n其实，Go 语言的作者之一 Russ Cox 早在 2002 年左右就用 C 实现了一个简单的基于协程的网络通信模型 -- libtask，但其只是一个简单的网络协程原型，还远达不到实践的要求。自从 Go 语言兴起后，很多基于 C/C++ 开发的协程库也多了起来，其中 Acl 协程库便是其中之一。\nAcl 工程地址：https://github.com/acl-dev/acl\nAcl 协程地址：https://github.com/acl-dev/acl/tree/master/lib_fiber\n\n## 二、简单示例\n下面为一个使用 Acl 库编写的简单线程的例子：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n\nclass mythread : public acl::thread\n{\npublic:\n\tmythread(void) {}\n\t~mythread(void) {}\nprivate:\n\t// 实现基类中纯虚方法，当线程启动时该方法将被回调\n\t// @override\n\tvoid* run(void) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tprintf(\"thread-%lu: running ...\\r\\n\", acl::thread::self());\n\t\t}\n\t\treturn NULL;\n\t}\n};\n\nint main(void)\n{\n\tstd::vector<acl::thread*> threads;\n\tfor (int i = 0; i < 10; i++) {\n\t\tacl::thread* thr = new mythread;\n\t\tthreads.push_back(thr);\n\t\tthr->start();  // 启动线程\n\t}\n\t\n\tfor (std::vector<acl::thread*>::iterator it = threads.begin();\n\t\tit != threads.end(); ++it) {\n\t\t(*it)->wait();  // 等待线程退出\n\t\tdelete *it;\n\t}\n\treturn 0;\t\n}\n```\n上面线程例子非常简单，接着再给一个简单的协程的例子：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass myfiber : public acl::fiber\n{\npublic:\n\tmyfiber(void) {}\n\t~myfiber(void) {}\nprivate:\n\t// 重现基类纯虚方法，当调用 fiber::start 时，该方法将被调用\n\t// @override\n\tvoid run(void) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tprintf(\"hello world! the fiber is %d\\r\\n\", acl::fiber::self());\n\t\t\tacl::fiber::yield();  // 让出CPU运行权给其它协程\n\t\t}\n\t}\n};\n\nint main(void)\n{\n\tstd::vector<acl::fiber*> fibers;\n\tfor (int i = 0; i < 10; i++) {\n\t\tacl::fiber* fb = new myfiber;\n\t\tfibers.push_back(fb);\n\t\tfb->start();  // 启动一个协程\n\t}\n\t\n\tacl::fiber::schedule();  // 启用协程调度器\n\t\n\tfor (std::vector<acl::fiber*>::iterator it = fibers.begin();\n\t\tit != fibers.end(); ++it) {\n\t\tdelete *it;\n\t}\n}\n```\n上面示例演示了协程的创建、启动及运行的过程，与前一个线程的例子非常相似，非常简单（简单实用是 Acl 库的目标之一）。\n**协程调度其实是应用层面多个协程之间通过上下文切换形成的协作过程，如果一个协程库仅是实现了上下文切换，其实并不具备太多实用价值，当与网络事件绑定后，其价值才会显现出来**。下面一个简单的使用协程的网络服务程序：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\n// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程\nclass fiber_echo : public acl::fiber\n{\npublic:\n\tfiber_echo(acl::socket_stream* conn) : conn_(conn) {}\nprivate:\n\tacl::socket_stream* conn_;\n\t~fiber_echo(void) { delete conn_; }\n\t// @override\n\tvoid run(void) {\n\t\tchar buf[8192];\n\t\twhile (true) {\n\t\t\t// 从客户端读取数据（第三个参数为false表示不必填满整个缓冲区才返回）\n\t\t\tint ret = conn_->read(buf, sizeof(buf), false);\n\t\t\tif (ret == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 向客户端写入读到的数据\n\t\t\tif (conn_->write(buf, ret) != ret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this; // 自销毁动态创建的协程对象\n\t}\n};\n\n// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定\nclass fiber_listen : public acl::fiber\n{\npublic:\n\tfiber_listen(acl::server_socket& listener) : listener_(listener) {}\nprivate:\n\tacl::server_socket& listener_;\n\t~fiber_listen(void) {}\n\t// @override\n\tvoid run(void) {\n\t\twhile (true) {\n\t\t\tacl::socket_stream* conn = listener_.accept();  // 等待客户端连接\n\t\t\tif (conn == NULL) {\n\t\t\t\tprintf(\"accept failed: %s\\r\\n\", acl::last_serror());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 创建并启动单独的协程处理客户端连接\n\t\t\tacl::fiber* fb = new fiber_echo(conn);\n\t\t\t// 启动独立的客户端处理协程\n\t\t\tfb->start();\n\t\t}\n\t\tdelete this;\n\t}\n};\n\nint main(void)\n{\n\tconst char* addr = \"127.0.0.1:8800\";\n\tacl::server_socket listener;\n\t// 监听本地地址\n\tif (listener.open(addr) == false) {\n\t\tprintf(\"listen %s error %s\\r\\n\", addr, acl::last_serror());\n\t\treturn 1;\n\t}\n\n\t// 创建并启动独立的监听协程，接受客户端连接\n\tacl::fiber* fb = new fiber_listen(listener);\n\tfb->start();\n\n\t// 启动协程调度器\n\tacl::fiber::schedule();\n\treturn 0;\n}\n```\n这是一个简单的支持回显功能的网络协程服务器，可以很容易修改成线程模式。使用线程或线程处理网络通信都可以采用**顺序思维**模式，不必象非阻塞网络编程那样复杂，但使用协程的最大好处可以创建大量的协程来处理网络连接，而要创建大量的线程显示是不现实的（线程数非常多时，会导致操作系统的调度能力下降）。**如果你的网络服务应用不需要支持大并发，使用协程的意义就没那么大了**。\n## 三、编译安装\n在编译前，需要先从 github  https://github.com/acl-dev/acl  下载源码，国内用户可以选择从 gitee  https://gitee.com/acl-dev/acl  下载源码。\n### 3.1、Linux/Unix 平台上编译安装\n在 Linux/Unix 平台上的编译非常简单，可以选择使用 make 方式或 cmake 方式进行编译。  \n- **make 方式编译：**\n在 acl 项目根目录下运行：**make && make packinstall**，则会自动执行编译与安装过程，安装目录默认为系统目录：libacl_all.a, libfiber_cpp.a, libfiber.a 将被拷贝至 /usr/lib/ 目录，头文件将被拷贝至 /usr/include/acl-lib/ 目录。\n- **cmake 方式编译：**\n在 acl 项目根目录下创建 build 目录，然后：**cd build && cmake .. && make**\n- **将 acl 库加入至你的工程**（以 make 方式为例）\n先在代码中加入头文件包含项：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n```\n然后修改你的 Makefile 文件，示例如下：\n```c\nmytest: mytest.cpp\n\tg++ -o mytest mytest.cpp -lfiber_cpp -lacl_all -lfiber -ldl -lpthread -lz\n```\n**注意在 Makefile 中各个库的依赖顺序：** libfiber_cpp.a 依赖于 libacl_all.a 和 libfiber.a，其中 libacl_all.a 为 acl 的基础库，libfiber.a 为 C 语言协程库（其不依赖于 libacl_all.a），libfiber_cpp.a 用 C++ 语言封装了 libfiber.a，且使用了 libacl_all.a 中的一些功能。 \n### 3.2、Windows 平台上编译\n在 Windows 平台的编译也非常简单，可以用 vc2008/2010/2012/2013/2015/2017 打开相应的工程文件进行编译，如：可以用 vc2012 打开 acl_cpp_vc2012.sln 工程进行编译。\n### 3.3 Mac 平台上编译\n除可以使用 Unix 统一方式（命令行方式）编译外，还可以用 Xcode 打开工程文件进行编译。\n### 3.4 Android 平台上编译\n目前可以使用 Android Studio3.x 打开 acl\\android\\acl 目录下的工程文件进行编译。\n### 3.5 使用 MinGW 编译\n如果想要在 Windows 平台上编译 Unix 平台上的软件，可以借用 MinGW 套件进行编译，为此 Acl 库还提供了此种编译方式，但一般不建议用户使用这种编译方式，一方面是执行效率低，另一方面可能会存在某些不兼容问题。\n### 3.6 小结\n为了保证 Acl 工程无障碍使用，本人在编译 Acl 库方面下了很大功夫，支持几乎在所有平台上使用原生编译环境进行编译使用，真正达到了一键编译。甚至为了避免因依赖第三方库而导致的编译问题（如：有的模块需要 zlib 库，有的需要 polassl 库，有的需要 mysql/postgresql/sqlite 库），将这些依赖第三方库的模块都写成动态加载第三方库的方式，毕竟不是所有人都需要这些第三方库所提供的功能。\n## 四、使用多核\nAcl 协程的调度过程是基于单CPU的（虽然也可以修改成多核调度，但考虑到很多原因，最终还是采用了单核调度模式），即创建一个线程，所创建的所有协程都在这个线程空间中运行。为了使用多核，充分使用CPU资源，可以创建多个线程（也可以创建多个进程），每个线程为一个独立的协程运行容器，各个线程之间的协程相互隔离，互不影响。\n下面先修改一下上面的例子，改成多线程的协程方式：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\n// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程\nclass fiber_echo : public acl::fiber\n{\npublic:\n\tfiber_echo(acl::socket_stream* conn) : conn_(conn) {}\nprivate:\n\tacl::socket_stream* conn_;\n\t~fiber_echo(void) { delete conn_; }\n\t// @override\n\tvoid run(void) {\n\t\tchar buf[8192];\n\t\twhile (true) {\n\t\t\tint ret = conn_->read(buf, sizeof(buf), false);\n\t\t\tif (ret == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tif (conn_->write(buf, ret) != ret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this; // 自销毁动态创建的协程对象\n\t}\n};\n\n// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定\nclass fiber_listen : public acl::fiber\n{\npublic:\n\tfiber_listen(acl::server_socket& listener) : listener_(listener) {}\nprivate:\n\tacl::server_socket& listener_;\n\t~fiber_listen(void) {}\n\t// @override\n\tvoid run(void) {\n\t\twhile (true) {\n\t\t\tacl::socket_stream* conn = listener_.accept();  // 等待客户端连接\n\t\t\tif (conn == NULL) {\n\t\t\t\tprintf(\"accept failed: %s\\r\\n\", acl::last_serror());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 创建并启动单独的协程处理客户端连接\n\t\t\tacl::fiber* fb = new fiber_echo(conn);\n\t\t\tfb->start();\n\t\t}\n\t\tdelete this;\n\t}\n};\n\n// 独立的线程调度类\nclass thread_server : public acl::thread\n{\npublic:\n\tthread_server(acl::server_socket& listener) : listener_(listener) {}\n\t~thread_server(void) {}\nprivate:\n\tacl::server_socket& listener_;\n\t// @override\n\tvoid* run(void) {\n\t\t// 创建并启动独立的监听协程，接受客户端连接\n\t\tacl::fiber* fb = new fiber_listen(listener);\n\t\tfb->start();\n\t\t// 启动协程调度器\n\t\tacl::fiber::schedule(); // 内部处于死循环过程\n\t\treturn NULL;\n\t}\n};\n\nint main(void)\n{\n\tconst char* addr = \"127.0.0.1:8800\";\n\tacl::server_socket listener;\n\t// 监听本地地址\n\tif (listener.open(addr) == false) {\n\t\tprintf(\"listen %s error %s\\r\\n\", addr, acl::last_serror());\n\t\treturn 1;\n\t}\n\n\tstd::vector<acl::thread*> threads;\n\t// 创建多个独立的线程对象，每个线程启用独立的协程调度过程\n\tfor (int i = 0; i < 4; i++) {\n\t\tacl::thread* thr = thread_server(listener);\n\t\tthreads.push_back(thr);\n\t\tthr->start();\n\t}\n\tfor (std::vector<acl::thread*>::iterator it = threads.begin();\n\t\tit != threads.end(); ++it) {\n\t\t(*it)->wait();\n\t\tdelete *it;\n\t}\n\treturn 0;\n}\n```\n经过修改，上面的例子即可以支持大并发，又可以使用多核。\n## 五、多核同步\n上面的例子中涉及到了通过创建多线程使用多核的过程，但肯定会有人问，在多个线程中的协程之间如果想要共享某个资源怎么办？Acl 协程库提供了可以跨线程使用同步原语：线程协程事件同步及条件变量。\n首先介绍一下事件同步对象类：acl::fiber_event，该类提供了三个方法：\n```c\n\t/**\n\t * 等待事件锁\n\t * @return {bool} 返回 true 表示加锁成功，否则表示内部出错\n\t */\n\tbool wait(void);\n\n\t/**\n\t * 尝试等待事件锁\n\t * @return {bool} 返回 true 表示加锁成功，否则表示锁正在被占用\n\t */\n\tbool trywait(void);\n\n\t/**\n\t * 事件锁拥有者释放事件锁并通知等待者\n\t * @return {bool} 返回 true 表示通知成功，否则表示内部出错\n\t */\n\tbool notify(void);\n```\n下面给出一个例子，看看在多个线程中的协程之间如何进行互斥的：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass myfiber : public acl::fiber\n{\npublic:\n\tmyfiber(acl::fiber_event& lock, int& count): lock_(lock), count_(count) {}\nprivate:\n\t~myfiber(void) {}\n\t// @override\n\tvoid run(void) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tlock_.wait();\n\t\t\tcount_++;\n\t\t\tlock_.notify();\n\t\t\t//acl::fiber::delay(1);  // 本协程休息1毫秒\n\t\t}\n\t\tdelete this;\n\t}\nprivate:\n\tacl::fiber_event& lock_;\n\tint& count_;\n};\n\nclass mythread : public acl::thread\n{\npublic:\n\tmythread(acl::fiber_event& lock, int& count): lock_(lock), count_(count) {}\n\t~mythread(void) {}\nprivate:\n\t// @override\n\tvoid* run(void) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tacl::fiber* fb = new myfiber(lock_, count_);\n\t\t\tfb->start();\n\t\t}\n\t\tacl::fiber::schedule();\n\t\treturn NULL;\n\t}\nprivate:\n\tacl::fiber_event& lock_;\n\tint& count_;\n};\n\nint main(void)\n{\n\tacl::fiber_event lock;  // 可以用在多个线程之间、各个线程中的协程之间的同步过程\n\tint count = 0;\n\tstd::vector<acl::thread*> threads;\n\tfor (int i = 0; i < 4; i++) {\n\t\tacl::thread* thr = new mythread(lock, count);\n\t\tthreads.push_back(thr);\n\t\tthr->start();\n\t}\n\tfor (std::vector<acl::thread*>::iterator it = threads.begin();\n\t\tit != threads.end(); ++it) {\n\t\t(*it)->wait();\n\t\tdelete *it;\n\t}\n\n\tprintf(\"all over, count=%d\\r\\n\", count);\n\treturn 1;\n}\n```\nacl::fiber_event 常被用在多个线程中的协程之间的同步，当然也可以用在多个线程之间的同步，这在很大程度弥补了 Acl 协程框架在使用多核上的不足。\n## 六、消息传递\n通过组合 acl::fiber_event（协程事件）和 acl::fiber_cond（协程条件变量），实现了协程间进行消息传递的功能模块：acl::fiber_tbox，fiber_tbox 不仅可以用在同一线程内的协程之间传递消息，而且还可以用在不同线程中的协程之间，不同线程之间，线程与协程之间传递消息。fiber_tbox 为模板类，因而可以传递各种类型对象。以下给出一个示例：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass myobj\n{\npublic:\n\tmyobj(void) : i_(0) {}\n\t~myobj(void) {}\n\tvoid set(int i) {\n\t\ti_ = i;\n\t}\n\tvoid test(void) {\n\t\tprintf(\"hello world, i=%d\\r\\n\", i_);\n\t}\nprivate:\n\tint i_;\n};\n\n// 消费者协程，从消息管道中读取消息\nclass fiber_consumer : public acl::fiber\n{\npublic:\n\tfiber_consumer(acl::fiber_tbox<myobj>& box) : box_(box) {}\nprivate:\n\t~fiber_consumer(void) {}\nprivate:\n\tacl::fiber_tbox<myobj>& box_;\n\t// @override\n\tvoid run(void) {\n\t\twhile (true) {\n\t\t\tmyobj* o = box_.pop();\n\t\t\t// 如果读到空消息，则结束\n\t\t\tif (o == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\to->test();\n\t\t\tdelete o;\n\t\t}\n\t\tdelete this;\n\t}\n};\n\n// 生产者协程，向消息管道中放置消息\nclass fiber_producer : public acl::fiber\n{\npublic:\n\tfiber_producer(acl::fiber_tbox<myobj>& box) : box_(box) {}\nprivate:\n\t~fiber_producer(void) {}\nprivate:\n\tacl::fiber_tbox<myobj>& box_;\n\t// @override\n\tvoid run(void) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tmyobj* o = new myobj;\n\t\t\to->set(i);\n\t\t\t// 向消息管道中放置消息\n\t\t\tbox_.push(o);\n\t\t}\n\t\t// 放置空消息至消息管道中，从而通知消费者协程结束\n\t\tbox_.push(NULL);\n\t\tdelete this;\n\t}\n};\n\nint main(void)\n{\n\tacl::fiber_tbox<myobj> box;\n\t// 创建并启动消费者协程\n\tacl::fiber* consumer = new fiber_consumer(box);\n\tconsumer->start();\n\t// 创建并启动生产者协程\n\tacl::fiber* producer = new fiber_producer(box);\n\tproducer->start();\n\t// 启动协程调度器\n\tacl::fiber::schedule();\n\treturn 0; \n}\n```\n上面例子展示了同一线程中的两个协程之间的消息传递过程，因为 acl::fiber_tbox 是可以跨线程的，所以它的更大价值是用在多个线程中的不同协程之间进行消息传递。\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass myobj\n{\npublic:\n\tmyobj(void) : i_(0) {}\n\t~myobj(void) {}\n\tvoid set(int i) {\n\t\ti_ = i;\n\t}\n\tvoid test(void) {\n\t\tprintf(\"hello world, i=%d\\r\\n\", i_);\n\t}\nprivate:\n\tint i_;\n};\n\n// 消费者协程，从消息管道中读取消息\nclass fiber_consumer : public acl::fiber\n{\npublic:\n\tfiber_consumer(acl::fiber_tbox<myobj>& box) : box_(box) {}\nprivate:\n\t~fiber_consumer(void) {}\nprivate:\n\tacl::fiber_tbox<myobj>& box_;\n\t// @override\n\tvoid run(void) {\n\t\twhile (true) {\n\t\t\tmyobj* o = box_.pop();\n\t\t\t// 如果读到空消息，则结束\n\t\t\tif (o == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\to->test();\n\t\t\tdelete o;\n\t\t}\n\t\tdelete this;\n\t}\n};\n\n// 生产者线程，向消息管道中放置消息\nclass thread_producer : public acl::thread\n{\npublic:\n\tthread_producer(acl::fiber_tbox<myobj>& box) : box_(box) {}\n\t~thread_producer(void) {}\nprivate:\n\tacl::fiber_tbox<myobj>& box_;\n\tvoid* run(void) {\n\t\tfor (int i = 0; i < 10; i++) {\n\t\t\tmyobj* o = new myobj;\n\t\t\to->set(i);\n\t\t\tbox_.push(o);\n\t\t}\n\t\tbox_.push(NULL);\n\t\treturn NULL;\n\t}\n};\n\nint main(void)\n{\n\tacl::fiber_tbox<myobj> box;\n\t// 创建并启动消费者协程\n\tacl::fiber* consumer = new fiber_consumer(box);\n\tconsumer->start();\n\t// 创建并启动生产者线程\n\tacl::thread* producer = new thread_producer(box);\n\tproducer->start();\n\t// 启动协程调度器\n\tacl::fiber::schedule();\n\t// schedule() 过程返回后，表示该协程调度器结束。\n\t// 等待生产者线程退出\n\tproducer->wait();\n\tdelete producer;\n\treturn 0; \n}\n```\n在该示例中，生产者为一个独立的线程，消费者为另一个线程中的协程，二者通过 acl::fiber_tbox 进行消息通信。但**有一点需要注意**，fiber_tbox 一般可用在“单生产者-单消费者或多生产者-单消费者”的应用场景中，不应用在多消费者的场景中，虽然用在多个消费者场景时不会造成消费丢失或内存崩溃，但当消费者数量较多时却有可能出现惊群现象，所以应避免将一个 acl::fiber_tbox 用在大量的多消费者场景中。\n下面再给一个应用场景的例子，也是我们平时经常会遇到的。\n```c\n#include <unistd.h>\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass mythread : public acl::thread\n{\npublic:\n\tmythread(acl::fiber_tbox<int>& box) :box_(box) {}\n\t~mythread(void) {}\nprivate:\n\tacl::fiber_tbox<int>& box_;\n\t// @override\n\tvoid* run(void) {\n\t\tint i;\n\t\tfor (i = 0; i < 5; i++) {\n\t\t\t/* 假设这是一个比较耗时的操作*/\n\t\t\tprintf(\"sleep one second\\r\\n\");\n\t\t\tsleep(1);\n\t\t}\n\t\tint* n = new int(i);\n\t\t// 将计算结果通过消息管道传递给等待者协程\n\t\tbox_.push(n);\n\t\treturn NULL; \n\t}\n};\n\nclass myfiber : public acl::fiber\n{\npublic:\n\tmyfiber(void) {}\n\t~myfiber(void) {}\nprivate:\n\t// @override\n\tvoid run(void) {\n\t\tacl::fiber_tbox<int> box;\n\t\tmythread thread(box);\n\t\tthread.set_detachable(true);\n\t\tthread.start();  // 启动独立的线程计算耗时运算\n\t\tint* n = box.pop();  // 等待计算线程返回运算结果，仅会阻塞当前协程\n\t\tprintf(\"n is %d\\r\\n\", *n);\n\t\tdelete n;\n\t}\n};\n\nint main(void)\n{\n\tmyfiber fb;\n\tfb.start();\n\tacl::fiber::schedule();\n\treturn 0;\n}\n```\n协程一般用在网络高并发环境中，但协程并不是万金油，协程并不适合计算密集型应用，因为线程才是操作系统的最小调度单元，而协程不是，所以当遇到一些比较耗时的运算时，为了不阻塞当前协程所在的协程调度器，应将该耗时运算过程中抛给独立的线程去处理，然后通过 acl::fiber_tbox 等待线程的运算结果。\n## 七、HOOK API\n为了使现有的很多网络应用和网络库在尽量不修改的情况下协程化，Acl 协程库 Hook 了很多与 IO 和网络通信相关的系统 API，目前已经 Hook 的系统 API 有：\n| 内容项 |API|\n|--|--|\n|网络相关|socket/listen/accept/connect  |\n|IO相关|read/readv/recv/recvfrom/recvmsg/write/writev/send/sendto/sendmsg/sendfile64|\n|域名相关|gethostbyname(_r)/getaddrinfo/freeaddrinfo|\n|事件相关|select/poll/epoll_create/ epoll_ctl/epoll_wait|\n|其它|close/sleep|\n## 八、域名解析\n使用协程方式编写网络通信程序，域名解析是不能绕过的，记得有一个协程库说为了支持域名解析，甚至看了相关实现代码，然后说通过 Hook _poll API 就可以了，实际上这并不是通用的做法，至少在我的环境里通过 Hook _poll API 是没用的，所以最稳妥的做法还是应该将 DNS 查询协议实现了，在 acl 的协程库中，域名解析模块在初期集成了第三方 DNS 库，参见：https://github.com/wahern/dns  ，但因为该第 DNS 库存在很多问题（如：不能跨平台，代码混乱，没处理IO异常等问题），所以最终 acl 协程丢弃该库，自己实现了一套更加方便灵活跨平台的 DNS 协议库。 \n\n## 九、使第三方网络库协程化\n通常网络通信库都是阻塞式的，因为非阻塞式的通信库的通用性不高（使用各自的事件引擎，很难达到应用层的使用一致性），如果把这些第三方通信库（如：mysql 客户端库，Acl 中的 Redis 库）使用协程所提供的 IO 及网络  API 重写一遍则工作量太大，不太现实，好在 Acl 协程库 Hook 了很多系统 API，从而使阻塞式的网络通信库协程化变得简单。所谓网络库协程化就是使这些网络库可以应用在协程环境中，从而可以很容易编写出支持高并发的网络程序。\n先写一个将 Acl Redis 客户端库协程化的例子：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\nclass fiber_redis : public acl::fiber\n{\npublic:\n\tfiber_redis(acl::redis_client_cluster& cluster) : cluster_(cluster) {}\nprivate:\n\t~fiber_redis(void) {}\nprivate:\n\tacl::redis_client_cluster& cluster_;\n\t// @override\n\tvoid run(void) {\n\t\tconst char* key = \"hash-key\";\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tacl::redis cmd(&cluster_);\n\t\t\tacl::string name, val;\n\t\t\tname.format(\"hash-name-%d\", i);\n\t\t\tval.format(\"hash-val-%d\", i);\n\t\t\tif (cmd.hset(key, name, val) == -1) {\n\t\t\t\tprintf(\"hset error: %s, key=%s, name=%s\\r\\n\",\n\t\t\t\t\tcmd.result_error(), key, name.c_str());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this;\n\t}\n};\n\nint main(void)\n{\n\tconst char* redis_addr = \"127.0.0.1:6379\";\n\tacl::redis_client_cluster cluster;\n\tcluster.set(redis_addr, 0);\n\tfor (int i = 0; i < 100; i++) {\n\t\tacl::fiber* fb = new fiber_redis(cluster);\n\t\tfb->start();\n\t}\n\tacl::fiber::schedule();\n\treturn 0;\n}\n```\n读者可以尝试将上面的代码拷贝到自己机器上，编译后运行一下。另外，这个例子是只有一个线程，所以会发现 acl::redis_client_cluster 的使用方式和在线程下是一样的。如果将 acl::redis_client_cluster 在多个线程调度器上共享会怎样？还是有一点区别，如下：\n```c\n#include <acl-lib/acl_cpp/lib_acl.hpp>\n#include <acl-lib/fiber/libfiber.hpp>\n\n// 每个协程共享相同的 cluster 对象，向 redis-server 中添加数据\nclass fiber_redis : public acl::fiber\n{\npublic:\n\tfiber_redis(acl::redis_client_cluster& cluster) : cluster_(cluster) {}\nprivate:\n\t~fiber_redis(void) {}\nprivate:\n\tacl::redis_client_cluster& cluster_;\n\t// @override\n\tvoid run(void) {\n\t\tconst char* key = \"hash-key\";\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tacl::redis cmd(&cluster_);\n\t\t\tacl::string name, val;\n\t\t\tname.format(\"hash-name-%d\", i);\n\t\t\tval.format(\"hash-val-%d\", i);\n\t\t\tif (cmd.hset(key, name, val) == -1) {\n\t\t\t\tprintf(\"hset error: %s, key=%s, name=%s\\r\\n\",\n\t\t\t\t\tcmd.result_error(), key, name.c_str());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this;\n\t}\n};\n\n// 每个线程运行一个独立的协程调度器\nclass mythread : public acl::thread\n{\npublic:\n\tmythread(acl::redis_client_cluster& cluster) : cluster_(cluster) {}\n\t~mythread(void) {}\nprivate:\n\tacl::redis_client_cluster& cluster_;\n\t// @override\n\tvoid* run(void) {\n\t\tfor (int i = 0; i < 100; i++) {\n\t\t\tacl::fiber* fb = new fiber_redis(cluster_\t);\n\t\t\tfb->start();\n\t\t}\n\t\tacl::fiber::schedule();\n\t\treturn NULL;\n\t}\n};\n\nint main(void)\n{\n\tconst char* redis_addr = \"127.0.0.1:6379\";\n\tacl::redis_client_cluster cluster;\n\tcluster.set(redis_addr, 0);\n\tcluster.bind_thread(true);\n\n\t// 创建多个线程，共享 redis 集群连接池管理对象：cluster，即所有线程中的\n\t// 所有协程共享同一个 cluster 集群管理对象\n\tstd::vector<acl::thread*> threads;\n\tfor (int i = 0; i < 4; i++) {\n\t\tacl::thread* thr = new mythread(cluster);\n\t\tthreads.push_back(thr);\n\t\tthr->start();\n\t}\n\tfor (std::vector<acl::thread*>::iterator it = threads.begin();\n\t\tit != threads.end(); ++it) {\n\t\t(*it)->wait();\n\t\tdelete *it;\n\t}\n\treturn 0;\n}\n```\n在这个多线程多协程环境里使用 acl::redis_client_cluster 对象时与前面的一个例子有所不同，在这里调用了：**cluster.bind_thread(true);** \n为何要这样做？原因是 Acl Redis 的协程调度器是单线程工作模式，网络套接字句柄在协程环境里不能跨线程使用，当调用 bind_thread(true) 后，Acl 连接池管理对象会自动给每个线程分配一个连接池对象，每个线程内的所有协程共享这个绑定于本线程的连接池对象。\n## 十、Windows 界面编程协程化\n在Windows下写过界面程序的程序员都经历过使通信模块与界面结合的痛苦过程，因为 Windows 界面过程是基于 win32 消息引擎驱动的，所以在编写通信模块时一般有两个选择：要么使用 Windows 提供的异步非阻塞 API，要么把通信模块放在独立于界面的单独线程中然后通过窗口消息将结果通知窗口界面过程。\nAcl 协程库的事件引擎支持 win32 消息引擎，所以很容易将界面过程的通信过程协程化，采用这种方式，一方面程序员依然可以采用顺序编程方式，另一方面通信协程与界面过程运行于相同的线程空间，则二者在相互访问对方的成员对象时不必加锁，从而使编写通信过程变得更加简单。\n下面以一个简单的对话框为例说明界面网络通信协程化过程：    \n1. 首先使用向导程序生成一个对话框界面程序，需要指定支持 socket 通信；\n2. 然后在 OnInitDialog() 方法尾部添加如下代码：\n```c\n\t// 设置协程调度的事件引擎，同时将协程调度设为自动启动模式\n\tacl::fiber::init(acl::FIBER_EVENT_T_WMSG, true);\n\t// HOOK ACL 库中的网络 IO 过程\n\tacl::fiber::acl_io_hook();\n```\n3. 创建一个按钮，并使其绑定一个事件方法，如：OnBnClickedListen，然后在这个方法里添加一些代码：\n```c\n\t// 创建一个协程用来监听指定地址，接收客户端连接请求\n\tm_fiberListen = new CFiberListener(\"127.0.0.1:8800\");\n\t// 启动监听协程\n\tm_fiberListen->start();\n```\n4. 实现步骤 3 中指定的监听协程类\n```c\nclass CFiberListener : public acl::fiber\n{\npublic:\n\tCFiberListener(const char* addr) : m_addr(addr) {}\nprivate:\n\t~CFiberListener(void) {}\nprivate:\n\tacl::string m_addr;\n\tacl::server_socket m_listener;\n\t// @override\n\tvoid run(void) {\n\t\t// 绑定并监听指定的本地地址\n\t\tif (m_listener.open(m_addr) == false) {\n\t\t\treturn;\n\t\t}\n\t\twhile (true) {\n\t\t\t// 等待客户端连接\n\t\t\tacl::socket_stream* conn = m_listener.accept();\n\t\t\tif (conn == NULL) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 创建独立的协程处理该客户端的请求\n\t\t\tacl::fiber* fb = new CFiberClient(conn);\n\t\t\tfb->start(); // 启动客户端处理协程\n\t\t}\n\t\tdelete this;\n\t}\n};\n```\n5. 实现步骤 4 中指定的客户端响应协程类\n```c\nclass CFiberClient : public acl::fiber\n{\npublic:\n\tCFiberClient(acl::socket_stream* conn) : m_conn(conn) {}\nprivate:\n\t~CFiberClient(void) { delete m_conn; }\nprivate:\n\tacl::socket_stream* m_conn;\n\t// @override\n\tvoid run(void) {\n\t\tchar buf[8192];\n\t\twhile (true) {\n\t\t\t// 从客户端读取数据\n\t\t\tint ret = m_conn->read(buf, sizeof(buf), false);\n\t\t\tif (ret == -1) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\t// 将读到的数据回写给客户端\n\t\t\tif (m_conn->write(buf, ret) != ret) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tdelete this;\n\t}\n};\n```\n通过以上步骤就可为 win32 界面程序添加基于协程模式的通信模块，上面的两个协程类的处理过程都是“死循环”的，而且又与界面过程同处同一线程运行空间，却为何却不会阻塞界面消息过程呢？其原因就是当通信协程类对象在遇到网络 IO 阻塞时，会自动将自己挂起，将线程的运行权交给其它协程或界面过程。原理就是这么简单，但内部实现还有点复杂度的，感兴趣的可以看看 Acl 协程库的实现源码(https://github.com/acl-dev/acl/tree/master/lib_fiber/ )。\n此外，上面示例的完整代码请参考：https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/WinEchod  。\n","slug":"fiber","published":1,"updated":"2023-01-23T09:58:07.112Z","_id":"cld7k62yx0000d09k1she52bt","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"Acl-网络协程框架编程指南\"><a href=\"#Acl-网络协程框架编程指南\" class=\"headerlink\" title=\"Acl 网络协程框架编程指南\"></a>Acl 网络协程框架编程指南</h1><!-- vim-markdown-toc GFM -->\n\n<ul>\n<li><a href=\"#%E6%91%98%E8%A6%81\">摘要</a></li>\n<li><a href=\"#%E4%B8%80%E6%A6%82%E8%BF%B0\">一、概述</a></li>\n<li><a href=\"#%E4%BA%8C%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B\">二、简单示例</a></li>\n<li><a href=\"#%E4%B8%89%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85\">三、编译安装</a></li>\n<li><a href=\"#%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%A0%B8\">四、使用多核</a></li>\n<li><a href=\"#%E4%BA%94%E5%A4%9A%E6%A0%B8%E5%90%8C%E6%AD%A5\">五、多核同步</a></li>\n<li><a href=\"#%E5%85%AD%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92\">六、消息传递</a></li>\n<li><a href=\"#%E4%B8%83HOOKAPI\">七、HOOK API</a></li>\n<li><a href=\"#%E5%85%AB%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90\">八、域名解析</a></li>\n<li><a href=\"#%E4%B9%9D%E4%BD%BF%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%BB%9C%E5%BA%93%E5%8D%8F%E7%A8%8B%E5%8C%96\">九、使第三方网络库协程化</a></li>\n<li><a href=\"#%E5%8D%81Windows%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8C%96\">十、Windows 界面编程协程化</a></li>\n</ul>\n<!-- vim-markdown-toc -->\n\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>本文主要讲述Acl网络协程框架的使用，从协程的应用场景出发，以一个简单的协程示例开始，然后逐步深入到Acl网络协程的各个使用场景及使用细节，以及需要避免的“坑”，希望能给大家带来实践上的帮助。</p>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>讲到协程，大家必然会提到 Go 语言，毕竟是 Go 语言把协程的概念及使用实践普及的；但协程并不是一个新概念，我印象中在九十年代就出现了，当时一位同事还说微软推出了纤程（基本一个意思），可以创建成午上万个纤程，不必象线程那样只能创建较少的线程数量，但当时也没明白创建这么多纤程有啥用，只不过是一个上下文的快速切换协同而已。所以自己在写网络高并发服务时，主要还是以非阻塞方式来实现。<br>其实，Go 语言的作者之一 Russ Cox 早在 2002 年左右就用 C 实现了一个简单的基于协程的网络通信模型 – libtask，但其只是一个简单的网络协程原型，还远达不到实践的要求。自从 Go 语言兴起后，很多基于 C&#x2F;C++ 开发的协程库也多了起来，其中 Acl 协程库便是其中之一。<br>Acl 工程地址：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>Acl 协程地址：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_fiber\">https://github.com/acl-dev/acl/tree/master/lib_fiber</a></p>\n<h2 id=\"二、简单示例\"><a href=\"#二、简单示例\" class=\"headerlink\" title=\"二、简单示例\"></a>二、简单示例</h2><p>下面为一个使用 Acl 库编写的简单线程的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mythread</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tmythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t~mythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\t<span class=\"hljs-comment\">// 实现基类中纯虚方法，当线程启动时该方法将被回调</span><br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;thread-%lu: running ...\\r\\n&quot;</span>, acl::thread::self());<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\tacl::thread* thr = new mythread;<br>\t\tthreads.push_back(thr);<br>\t\tthr-&gt;start();  <span class=\"hljs-comment\">// 启动线程</span><br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>\t\tit != threads.end(); ++it) &#123;<br>\t\t(*it)-&gt;wait();  <span class=\"hljs-comment\">// 等待线程退出</span><br>\t\tdelete *it;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\t<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面线程例子非常简单，接着再给一个简单的协程的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myfiber</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tmyfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t~myfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\t<span class=\"hljs-comment\">// 重现基类纯虚方法，当调用 fiber::start 时，该方法将被调用</span><br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world! the fiber is %d\\r\\n&quot;</span>, acl::fiber::self());<br>\t\t\tacl::fiber::yield();  <span class=\"hljs-comment\">// 让出CPU运行权给其它协程</span><br>\t\t&#125;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::fiber*&gt; fibers;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\tacl::fiber* fb = new myfiber;<br>\t\tfibers.push_back(fb);<br>\t\tfb-&gt;start();  <span class=\"hljs-comment\">// 启动一个协程</span><br>\t&#125;<br>\t<br>\tacl::fiber::schedule();  <span class=\"hljs-comment\">// 启用协程调度器</span><br>\t<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::fiber*&gt;::iterator it = fibers.begin();<br>\t\tit != fibers.end(); ++it) &#123;<br>\t\tdelete *it;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面示例演示了协程的创建、启动及运行的过程，与前一个线程的例子非常相似，非常简单（简单实用是 Acl 库的目标之一）。<br><strong>协程调度其实是应用层面多个协程之间通过上下文切换形成的协作过程，如果一个协程库仅是实现了上下文切换，其实并不具备太多实用价值，当与网络事件绑定后，其价值才会显现出来</strong>。下面一个简单的使用协程的网络服务程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-comment\">// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_echo</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_echo(acl::socket_stream* conn) : conn_(conn) &#123;&#125;<br>private:<br>\tacl::socket_stream* conn_;<br>\t~fiber_echo(<span class=\"hljs-type\">void</span>) &#123; delete conn_; &#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 从客户端读取数据（第三个参数为false表示不必填满整个缓冲区才返回）</span><br>\t\t\t<span class=\"hljs-type\">int</span> ret = conn_-&gt;read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 向客户端写入读到的数据</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn_-&gt;write(buf, ret) != ret) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this; <span class=\"hljs-comment\">// 自销毁动态创建的协程对象</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_listen</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_listen(acl::server_socket&amp; listener) : listener_(listener) &#123;&#125;<br>private:<br>\tacl::server_socket&amp; listener_;<br>\t~fiber_listen(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\tacl::socket_stream* conn = listener_.accept();  <span class=\"hljs-comment\">// 等待客户端连接</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept failed: %s\\r\\n&quot;</span>, acl::last_serror());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 创建并启动单独的协程处理客户端连接</span><br>\t\t\tacl::fiber* fb = new fiber_echo(conn);<br>\t\t\t<span class=\"hljs-comment\">// 启动独立的客户端处理协程</span><br>\t\t\tfb-&gt;start();<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:8800&quot;</span>;<br>\tacl::server_socket listener;<br>\t<span class=\"hljs-comment\">// 监听本地地址</span><br>\t<span class=\"hljs-keyword\">if</span> (listener.open(addr) == <span class=\"hljs-literal\">false</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen %s error %s\\r\\n&quot;</span>, addr, acl::last_serror());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 创建并启动独立的监听协程，接受客户端连接</span><br>\tacl::fiber* fb = new fiber_listen(listener);<br>\tfb-&gt;start();<br><br>\t<span class=\"hljs-comment\">// 启动协程调度器</span><br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这是一个简单的支持回显功能的网络协程服务器，可以很容易修改成线程模式。使用线程或线程处理网络通信都可以采用<strong>顺序思维</strong>模式，不必象非阻塞网络编程那样复杂，但使用协程的最大好处可以创建大量的协程来处理网络连接，而要创建大量的线程显示是不现实的（线程数非常多时，会导致操作系统的调度能力下降）。<strong>如果你的网络服务应用不需要支持大并发，使用协程的意义就没那么大了</strong>。</p>\n<h2 id=\"三、编译安装\"><a href=\"#三、编译安装\" class=\"headerlink\" title=\"三、编译安装\"></a>三、编译安装</h2><p>在编译前，需要先从 github  <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a>  下载源码，国内用户可以选择从 gitee  <a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a>  下载源码。</p>\n<h3 id=\"3-1、Linux-x2F-Unix-平台上编译安装\"><a href=\"#3-1、Linux-x2F-Unix-平台上编译安装\" class=\"headerlink\" title=\"3.1、Linux&#x2F;Unix 平台上编译安装\"></a>3.1、Linux&#x2F;Unix 平台上编译安装</h3><p>在 Linux&#x2F;Unix 平台上的编译非常简单，可以选择使用 make 方式或 cmake 方式进行编译。  </p>\n<ul>\n<li><strong>make 方式编译：</strong><br>在 acl 项目根目录下运行：<strong>make &amp;&amp; make packinstall</strong>，则会自动执行编译与安装过程，安装目录默认为系统目录：libacl_all.a, libfiber_cpp.a, libfiber.a 将被拷贝至 &#x2F;usr&#x2F;lib&#x2F; 目录，头文件将被拷贝至 &#x2F;usr&#x2F;include&#x2F;acl-lib&#x2F; 目录。</li>\n<li><strong>cmake 方式编译：</strong><br>在 acl 项目根目录下创建 build 目录，然后：<strong>cd build &amp;&amp; cmake .. &amp;&amp; make</strong></li>\n<li><strong>将 acl 库加入至你的工程</strong>（以 make 方式为例）<br>先在代码中加入头文件包含项：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br></code></pre></td></tr></table></figure>\n然后修改你的 Makefile 文件，示例如下：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">mytest: mytest.cpp<br>\tg++ -o mytest mytest.cpp -lfiber_cpp -lacl_all -lfiber -ldl -lpthread -lz<br></code></pre></td></tr></table></figure>\n<strong>注意在 Makefile 中各个库的依赖顺序：</strong> libfiber_cpp.a 依赖于 libacl_all.a 和 libfiber.a，其中 libacl_all.a 为 acl 的基础库，libfiber.a 为 C 语言协程库（其不依赖于 libacl_all.a），libfiber_cpp.a 用 C++ 语言封装了 libfiber.a，且使用了 libacl_all.a 中的一些功能。</li>\n</ul>\n<h3 id=\"3-2、Windows-平台上编译\"><a href=\"#3-2、Windows-平台上编译\" class=\"headerlink\" title=\"3.2、Windows 平台上编译\"></a>3.2、Windows 平台上编译</h3><p>在 Windows 平台的编译也非常简单，可以用 vc2008&#x2F;2010&#x2F;2012&#x2F;2013&#x2F;2015&#x2F;2017 打开相应的工程文件进行编译，如：可以用 vc2012 打开 acl_cpp_vc2012.sln 工程进行编译。</p>\n<h3 id=\"3-3-Mac-平台上编译\"><a href=\"#3-3-Mac-平台上编译\" class=\"headerlink\" title=\"3.3 Mac 平台上编译\"></a>3.3 Mac 平台上编译</h3><p>除可以使用 Unix 统一方式（命令行方式）编译外，还可以用 Xcode 打开工程文件进行编译。</p>\n<h3 id=\"3-4-Android-平台上编译\"><a href=\"#3-4-Android-平台上编译\" class=\"headerlink\" title=\"3.4 Android 平台上编译\"></a>3.4 Android 平台上编译</h3><p>目前可以使用 Android Studio3.x 打开 acl\\android\\acl 目录下的工程文件进行编译。</p>\n<h3 id=\"3-5-使用-MinGW-编译\"><a href=\"#3-5-使用-MinGW-编译\" class=\"headerlink\" title=\"3.5 使用 MinGW 编译\"></a>3.5 使用 MinGW 编译</h3><p>如果想要在 Windows 平台上编译 Unix 平台上的软件，可以借用 MinGW 套件进行编译，为此 Acl 库还提供了此种编译方式，但一般不建议用户使用这种编译方式，一方面是执行效率低，另一方面可能会存在某些不兼容问题。</p>\n<h3 id=\"3-6-小结\"><a href=\"#3-6-小结\" class=\"headerlink\" title=\"3.6 小结\"></a>3.6 小结</h3><p>为了保证 Acl 工程无障碍使用，本人在编译 Acl 库方面下了很大功夫，支持几乎在所有平台上使用原生编译环境进行编译使用，真正达到了一键编译。甚至为了避免因依赖第三方库而导致的编译问题（如：有的模块需要 zlib 库，有的需要 polassl 库，有的需要 mysql&#x2F;postgresql&#x2F;sqlite 库），将这些依赖第三方库的模块都写成动态加载第三方库的方式，毕竟不是所有人都需要这些第三方库所提供的功能。</p>\n<h2 id=\"四、使用多核\"><a href=\"#四、使用多核\" class=\"headerlink\" title=\"四、使用多核\"></a>四、使用多核</h2><p>Acl 协程的调度过程是基于单CPU的（虽然也可以修改成多核调度，但考虑到很多原因，最终还是采用了单核调度模式），即创建一个线程，所创建的所有协程都在这个线程空间中运行。为了使用多核，充分使用CPU资源，可以创建多个线程（也可以创建多个进程），每个线程为一个独立的协程运行容器，各个线程之间的协程相互隔离，互不影响。<br>下面先修改一下上面的例子，改成多线程的协程方式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-comment\">// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_echo</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_echo(acl::socket_stream* conn) : conn_(conn) &#123;&#125;<br>private:<br>\tacl::socket_stream* conn_;<br>\t~fiber_echo(<span class=\"hljs-type\">void</span>) &#123; delete conn_; &#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\t<span class=\"hljs-type\">int</span> ret = conn_-&gt;read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn_-&gt;write(buf, ret) != ret) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this; <span class=\"hljs-comment\">// 自销毁动态创建的协程对象</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_listen</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_listen(acl::server_socket&amp; listener) : listener_(listener) &#123;&#125;<br>private:<br>\tacl::server_socket&amp; listener_;<br>\t~fiber_listen(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\tacl::socket_stream* conn = listener_.accept();  <span class=\"hljs-comment\">// 等待客户端连接</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept failed: %s\\r\\n&quot;</span>, acl::last_serror());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 创建并启动单独的协程处理客户端连接</span><br>\t\t\tacl::fiber* fb = new fiber_echo(conn);<br>\t\t\tfb-&gt;start();<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 独立的线程调度类</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">thread_server</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tthread_server(acl::server_socket&amp; listener) : listener_(listener) &#123;&#125;<br>\t~thread_server(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::server_socket&amp; listener_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-comment\">// 创建并启动独立的监听协程，接受客户端连接</span><br>\t\tacl::fiber* fb = new fiber_listen(listener);<br>\t\tfb-&gt;start();<br>\t\t<span class=\"hljs-comment\">// 启动协程调度器</span><br>\t\tacl::fiber::schedule(); <span class=\"hljs-comment\">// 内部处于死循环过程</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:8800&quot;</span>;<br>\tacl::server_socket listener;<br>\t<span class=\"hljs-comment\">// 监听本地地址</span><br>\t<span class=\"hljs-keyword\">if</span> (listener.open(addr) == <span class=\"hljs-literal\">false</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen %s error %s\\r\\n&quot;</span>, addr, acl::last_serror());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>\t<span class=\"hljs-comment\">// 创建多个独立的线程对象，每个线程启用独立的协程调度过程</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\tacl::thread* thr = thread_server(listener);<br>\t\tthreads.push_back(thr);<br>\t\tthr-&gt;start();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>\t\tit != threads.end(); ++it) &#123;<br>\t\t(*it)-&gt;wait();<br>\t\tdelete *it;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>经过修改，上面的例子即可以支持大并发，又可以使用多核。</p>\n<h2 id=\"五、多核同步\"><a href=\"#五、多核同步\" class=\"headerlink\" title=\"五、多核同步\"></a>五、多核同步</h2><p>上面的例子中涉及到了通过创建多线程使用多核的过程，但肯定会有人问，在多个线程中的协程之间如果想要共享某个资源怎么办？Acl 协程库提供了可以跨线程使用同步原语：线程协程事件同步及条件变量。<br>首先介绍一下事件同步对象类：acl::fiber_event，该类提供了三个方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 等待事件锁</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示加锁成功，否则表示内部出错</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 尝试等待事件锁</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示加锁成功，否则表示锁正在被占用</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">trywait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 事件锁拥有者释放事件锁并通知等待者</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示通知成功，否则表示内部出错</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">notify</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n<p>下面给出一个例子，看看在多个线程中的协程之间如何进行互斥的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myfiber</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tmyfiber(acl::fiber_event&amp; lock, <span class=\"hljs-type\">int</span>&amp; count): lock_(lock), count_(count) &#123;&#125;<br>private:<br>\t~myfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tlock_.wait();<br>\t\t\tcount_++;<br>\t\t\tlock_.notify();<br>\t\t\t<span class=\"hljs-comment\">//acl::fiber::delay(1);  // 本协程休息1毫秒</span><br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>private:<br>\tacl::fiber_event&amp; lock_;<br>\t<span class=\"hljs-type\">int</span>&amp; count_;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mythread</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tmythread(acl::fiber_event&amp; lock, <span class=\"hljs-type\">int</span>&amp; count): lock_(lock), count_(count) &#123;&#125;<br>\t~mythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tacl::fiber* fb = new myfiber(lock_, count_);<br>\t\t\tfb-&gt;start();<br>\t\t&#125;<br>\t\tacl::fiber::schedule();<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>private:<br>\tacl::fiber_event&amp; lock_;<br>\t<span class=\"hljs-type\">int</span>&amp; count_;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tacl::fiber_event lock;  <span class=\"hljs-comment\">// 可以用在多个线程之间、各个线程中的协程之间的同步过程</span><br>\t<span class=\"hljs-type\">int</span> count = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\tacl::thread* thr = new mythread(lock, count);<br>\t\tthreads.push_back(thr);<br>\t\tthr-&gt;start();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>\t\tit != threads.end(); ++it) &#123;<br>\t\t(*it)-&gt;wait();<br>\t\tdelete *it;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;all over, count=%d\\r\\n&quot;</span>, count);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>acl::fiber_event 常被用在多个线程中的协程之间的同步，当然也可以用在多个线程之间的同步，这在很大程度弥补了 Acl 协程框架在使用多核上的不足。</p>\n<h2 id=\"六、消息传递\"><a href=\"#六、消息传递\" class=\"headerlink\" title=\"六、消息传递\"></a>六、消息传递</h2><p>通过组合 acl::fiber_event（协程事件）和 acl::fiber_cond（协程条件变量），实现了协程间进行消息传递的功能模块：acl::fiber_tbox，fiber_tbox 不仅可以用在同一线程内的协程之间传递消息，而且还可以用在不同线程中的协程之间，不同线程之间，线程与协程之间传递消息。fiber_tbox 为模板类，因而可以传递各种类型对象。以下给出一个示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myobj</span></span><br><span class=\"hljs-class\">&#123;</span><br>public:<br>\tmyobj(<span class=\"hljs-type\">void</span>) : i_(<span class=\"hljs-number\">0</span>) &#123;&#125;<br>\t~myobj(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">set</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> &#123;<br>\t\ti_ = i;<br>\t&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world, i=%d\\r\\n&quot;</span>, i_);<br>\t&#125;<br>private:<br>\t<span class=\"hljs-type\">int</span> i_;<br>&#125;;<br><br><span class=\"hljs-comment\">// 消费者协程，从消息管道中读取消息</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_consumer</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_consumer(acl::fiber_tbox&lt;myobj&gt;&amp; box) : box_(box) &#123;&#125;<br>private:<br>\t~fiber_consumer(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;myobj&gt;&amp; box_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\tmyobj* o = box_.pop();<br>\t\t\t<span class=\"hljs-comment\">// 如果读到空消息，则结束</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (o == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\to-&gt;test();<br>\t\t\tdelete o;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 生产者协程，向消息管道中放置消息</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_producer</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_producer(acl::fiber_tbox&lt;myobj&gt;&amp; box) : box_(box) &#123;&#125;<br>private:<br>\t~fiber_producer(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;myobj&gt;&amp; box_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\t\tmyobj* o = new myobj;<br>\t\t\to-&gt;<span class=\"hljs-built_in\">set</span>(i);<br>\t\t\t<span class=\"hljs-comment\">// 向消息管道中放置消息</span><br>\t\t\tbox_.push(o);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 放置空消息至消息管道中，从而通知消费者协程结束</span><br>\t\tbox_.push(<span class=\"hljs-literal\">NULL</span>);<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tacl::fiber_tbox&lt;myobj&gt; box;<br>\t<span class=\"hljs-comment\">// 创建并启动消费者协程</span><br>\tacl::fiber* consumer = new fiber_consumer(box);<br>\tconsumer-&gt;start();<br>\t<span class=\"hljs-comment\">// 创建并启动生产者协程</span><br>\tacl::fiber* producer = new fiber_producer(box);<br>\tproducer-&gt;start();<br>\t<span class=\"hljs-comment\">// 启动协程调度器</span><br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面例子展示了同一线程中的两个协程之间的消息传递过程，因为 acl::fiber_tbox 是可以跨线程的，所以它的更大价值是用在多个线程中的不同协程之间进行消息传递。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myobj</span></span><br><span class=\"hljs-class\">&#123;</span><br>public:<br>\tmyobj(<span class=\"hljs-type\">void</span>) : i_(<span class=\"hljs-number\">0</span>) &#123;&#125;<br>\t~myobj(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">set</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> &#123;<br>\t\ti_ = i;<br>\t&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world, i=%d\\r\\n&quot;</span>, i_);<br>\t&#125;<br>private:<br>\t<span class=\"hljs-type\">int</span> i_;<br>&#125;;<br><br><span class=\"hljs-comment\">// 消费者协程，从消息管道中读取消息</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_consumer</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_consumer(acl::fiber_tbox&lt;myobj&gt;&amp; box) : box_(box) &#123;&#125;<br>private:<br>\t~fiber_consumer(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;myobj&gt;&amp; box_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\tmyobj* o = box_.pop();<br>\t\t\t<span class=\"hljs-comment\">// 如果读到空消息，则结束</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (o == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\to-&gt;test();<br>\t\t\tdelete o;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 生产者线程，向消息管道中放置消息</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">thread_producer</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tthread_producer(acl::fiber_tbox&lt;myobj&gt;&amp; box) : box_(box) &#123;&#125;<br>\t~thread_producer(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;myobj&gt;&amp; box_;<br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\t\tmyobj* o = new myobj;<br>\t\t\to-&gt;<span class=\"hljs-built_in\">set</span>(i);<br>\t\t\tbox_.push(o);<br>\t\t&#125;<br>\t\tbox_.push(<span class=\"hljs-literal\">NULL</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tacl::fiber_tbox&lt;myobj&gt; box;<br>\t<span class=\"hljs-comment\">// 创建并启动消费者协程</span><br>\tacl::fiber* consumer = new fiber_consumer(box);<br>\tconsumer-&gt;start();<br>\t<span class=\"hljs-comment\">// 创建并启动生产者线程</span><br>\tacl::thread* producer = new thread_producer(box);<br>\tproducer-&gt;start();<br>\t<span class=\"hljs-comment\">// 启动协程调度器</span><br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-comment\">// schedule() 过程返回后，表示该协程调度器结束。</span><br>\t<span class=\"hljs-comment\">// 等待生产者线程退出</span><br>\tproducer-&gt;wait();<br>\tdelete producer;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在该示例中，生产者为一个独立的线程，消费者为另一个线程中的协程，二者通过 acl::fiber_tbox 进行消息通信。但<strong>有一点需要注意</strong>，fiber_tbox 一般可用在“单生产者-单消费者或多生产者-单消费者”的应用场景中，不应用在多消费者的场景中，虽然用在多个消费者场景时不会造成消费丢失或内存崩溃，但当消费者数量较多时却有可能出现惊群现象，所以应避免将一个 acl::fiber_tbox 用在大量的多消费者场景中。<br>下面再给一个应用场景的例子，也是我们平时经常会遇到的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mythread</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tmythread(acl::fiber_tbox&lt;<span class=\"hljs-type\">int</span>&gt;&amp; box) :box_(box) &#123;&#125;<br>\t~mythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;<span class=\"hljs-type\">int</span>&gt;&amp; box_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">int</span> i;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++) &#123;<br>\t\t\t<span class=\"hljs-comment\">/* 假设这是一个比较耗时的操作*/</span><br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;sleep one second\\r\\n&quot;</span>);<br>\t\t\tsleep(<span class=\"hljs-number\">1</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-type\">int</span>* n = new <span class=\"hljs-type\">int</span>(i);<br>\t\t<span class=\"hljs-comment\">// 将计算结果通过消息管道传递给等待者协程</span><br>\t\tbox_.push(n);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>; <br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myfiber</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tmyfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t~myfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\tacl::fiber_tbox&lt;<span class=\"hljs-type\">int</span>&gt; box;<br>\t\tmythread <span class=\"hljs-title function_\">thread</span><span class=\"hljs-params\">(box)</span>;<br>\t\tthread.set_detachable(<span class=\"hljs-literal\">true</span>);<br>\t\tthread.start();  <span class=\"hljs-comment\">// 启动独立的线程计算耗时运算</span><br>\t\t<span class=\"hljs-type\">int</span>* n = box.pop();  <span class=\"hljs-comment\">// 等待计算线程返回运算结果，仅会阻塞当前协程</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;n is %d\\r\\n&quot;</span>, *n);<br>\t\tdelete n;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tmyfiber fb;<br>\tfb.start();<br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>协程一般用在网络高并发环境中，但协程并不是万金油，协程并不适合计算密集型应用，因为线程才是操作系统的最小调度单元，而协程不是，所以当遇到一些比较耗时的运算时，为了不阻塞当前协程所在的协程调度器，应将该耗时运算过程中抛给独立的线程去处理，然后通过 acl::fiber_tbox 等待线程的运算结果。</p>\n<h2 id=\"七、HOOK-API\"><a href=\"#七、HOOK-API\" class=\"headerlink\" title=\"七、HOOK API\"></a>七、HOOK API</h2><p>为了使现有的很多网络应用和网络库在尽量不修改的情况下协程化，Acl 协程库 Hook 了很多与 IO 和网络通信相关的系统 API，目前已经 Hook 的系统 API 有：</p>\n<table>\n<thead>\n<tr>\n<th>内容项</th>\n<th>API</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>网络相关</td>\n<td>socket&#x2F;listen&#x2F;accept&#x2F;connect</td>\n</tr>\n<tr>\n<td>IO相关</td>\n<td>read&#x2F;readv&#x2F;recv&#x2F;recvfrom&#x2F;recvmsg&#x2F;write&#x2F;writev&#x2F;send&#x2F;sendto&#x2F;sendmsg&#x2F;sendfile64</td>\n</tr>\n<tr>\n<td>域名相关</td>\n<td>gethostbyname(_r)&#x2F;getaddrinfo&#x2F;freeaddrinfo</td>\n</tr>\n<tr>\n<td>事件相关</td>\n<td>select&#x2F;poll&#x2F;epoll_create&#x2F; epoll_ctl&#x2F;epoll_wait</td>\n</tr>\n<tr>\n<td>其它</td>\n<td>close&#x2F;sleep</td>\n</tr>\n</tbody></table>\n<h2 id=\"八、域名解析\"><a href=\"#八、域名解析\" class=\"headerlink\" title=\"八、域名解析\"></a>八、域名解析</h2><p>使用协程方式编写网络通信程序，域名解析是不能绕过的，记得有一个协程库说为了支持域名解析，甚至看了相关实现代码，然后说通过 Hook _poll API 就可以了，实际上这并不是通用的做法，至少在我的环境里通过 Hook _poll API 是没用的，所以最稳妥的做法还是应该将 DNS 查询协议实现了，在 acl 的协程库中，域名解析模块在初期集成了第三方 DNS 库，参见：<a href=\"https://github.com/wahern/dns\">https://github.com/wahern/dns</a>  ，但因为该第 DNS 库存在很多问题（如：不能跨平台，代码混乱，没处理IO异常等问题），所以最终 acl 协程丢弃该库，自己实现了一套更加方便灵活跨平台的 DNS 协议库。 </p>\n<h2 id=\"九、使第三方网络库协程化\"><a href=\"#九、使第三方网络库协程化\" class=\"headerlink\" title=\"九、使第三方网络库协程化\"></a>九、使第三方网络库协程化</h2><p>通常网络通信库都是阻塞式的，因为非阻塞式的通信库的通用性不高（使用各自的事件引擎，很难达到应用层的使用一致性），如果把这些第三方通信库（如：mysql 客户端库，Acl 中的 Redis 库）使用协程所提供的 IO 及网络  API 重写一遍则工作量太大，不太现实，好在 Acl 协程库 Hook 了很多系统 API，从而使阻塞式的网络通信库协程化变得简单。所谓网络库协程化就是使这些网络库可以应用在协程环境中，从而可以很容易编写出支持高并发的网络程序。<br>先写一个将 Acl Redis 客户端库协程化的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_redis</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_redis(acl::redis_client_cluster&amp; cluster) : cluster_(cluster) &#123;&#125;<br>private:<br>\t~fiber_redis(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::redis_client_cluster&amp; cluster_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key = <span class=\"hljs-string\">&quot;hash-key&quot;</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tacl::redis <span class=\"hljs-title function_\">cmd</span><span class=\"hljs-params\">(&amp;cluster_)</span>;<br>\t\t\tacl::<span class=\"hljs-built_in\">string</span> name, val;<br>\t\t\tname.format(<span class=\"hljs-string\">&quot;hash-name-%d&quot;</span>, i);<br>\t\t\tval.format(<span class=\"hljs-string\">&quot;hash-val-%d&quot;</span>, i);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (cmd.hset(key, name, val) == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hset error: %s, key=%s, name=%s\\r\\n&quot;</span>,<br>\t\t\t\t\tcmd.result_error(), key, name.c_str());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr = <span class=\"hljs-string\">&quot;127.0.0.1:6379&quot;</span>;<br>\tacl::redis_client_cluster cluster;<br>\tcluster.<span class=\"hljs-built_in\">set</span>(redis_addr, <span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\tacl::fiber* fb = new fiber_redis(cluster);<br>\t\tfb-&gt;start();<br>\t&#125;<br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>读者可以尝试将上面的代码拷贝到自己机器上，编译后运行一下。另外，这个例子是只有一个线程，所以会发现 acl::redis_client_cluster 的使用方式和在线程下是一样的。如果将 acl::redis_client_cluster 在多个线程调度器上共享会怎样？还是有一点区别，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-comment\">// 每个协程共享相同的 cluster 对象，向 redis-server 中添加数据</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_redis</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_redis(acl::redis_client_cluster&amp; cluster) : cluster_(cluster) &#123;&#125;<br>private:<br>\t~fiber_redis(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::redis_client_cluster&amp; cluster_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key = <span class=\"hljs-string\">&quot;hash-key&quot;</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tacl::redis <span class=\"hljs-title function_\">cmd</span><span class=\"hljs-params\">(&amp;cluster_)</span>;<br>\t\t\tacl::<span class=\"hljs-built_in\">string</span> name, val;<br>\t\t\tname.format(<span class=\"hljs-string\">&quot;hash-name-%d&quot;</span>, i);<br>\t\t\tval.format(<span class=\"hljs-string\">&quot;hash-val-%d&quot;</span>, i);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (cmd.hset(key, name, val) == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hset error: %s, key=%s, name=%s\\r\\n&quot;</span>,<br>\t\t\t\t\tcmd.result_error(), key, name.c_str());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 每个线程运行一个独立的协程调度器</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mythread</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tmythread(acl::redis_client_cluster&amp; cluster) : cluster_(cluster) &#123;&#125;<br>\t~mythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::redis_client_cluster&amp; cluster_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tacl::fiber* fb = new fiber_redis(cluster_\t);<br>\t\t\tfb-&gt;start();<br>\t\t&#125;<br>\t\tacl::fiber::schedule();<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr = <span class=\"hljs-string\">&quot;127.0.0.1:6379&quot;</span>;<br>\tacl::redis_client_cluster cluster;<br>\tcluster.<span class=\"hljs-built_in\">set</span>(redis_addr, <span class=\"hljs-number\">0</span>);<br>\tcluster.bind_thread(<span class=\"hljs-literal\">true</span>);<br><br>\t<span class=\"hljs-comment\">// 创建多个线程，共享 redis 集群连接池管理对象：cluster，即所有线程中的</span><br>\t<span class=\"hljs-comment\">// 所有协程共享同一个 cluster 集群管理对象</span><br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\tacl::thread* thr = new mythread(cluster);<br>\t\tthreads.push_back(thr);<br>\t\tthr-&gt;start();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>\t\tit != threads.end(); ++it) &#123;<br>\t\t(*it)-&gt;wait();<br>\t\tdelete *it;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在这个多线程多协程环境里使用 acl::redis_client_cluster 对象时与前面的一个例子有所不同，在这里调用了：<strong>cluster.bind_thread(true);</strong><br>为何要这样做？原因是 Acl Redis 的协程调度器是单线程工作模式，网络套接字句柄在协程环境里不能跨线程使用，当调用 bind_thread(true) 后，Acl 连接池管理对象会自动给每个线程分配一个连接池对象，每个线程内的所有协程共享这个绑定于本线程的连接池对象。</p>\n<h2 id=\"十、Windows-界面编程协程化\"><a href=\"#十、Windows-界面编程协程化\" class=\"headerlink\" title=\"十、Windows 界面编程协程化\"></a>十、Windows 界面编程协程化</h2><p>在Windows下写过界面程序的程序员都经历过使通信模块与界面结合的痛苦过程，因为 Windows 界面过程是基于 win32 消息引擎驱动的，所以在编写通信模块时一般有两个选择：要么使用 Windows 提供的异步非阻塞 API，要么把通信模块放在独立于界面的单独线程中然后通过窗口消息将结果通知窗口界面过程。<br>Acl 协程库的事件引擎支持 win32 消息引擎，所以很容易将界面过程的通信过程协程化，采用这种方式，一方面程序员依然可以采用顺序编程方式，另一方面通信协程与界面过程运行于相同的线程空间，则二者在相互访问对方的成员对象时不必加锁，从而使编写通信过程变得更加简单。<br>下面以一个简单的对话框为例说明界面网络通信协程化过程：    </p>\n<ol>\n<li>首先使用向导程序生成一个对话框界面程序，需要指定支持 socket 通信；</li>\n<li>然后在 OnInitDialog() 方法尾部添加如下代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 设置协程调度的事件引擎，同时将协程调度设为自动启动模式</span><br>acl::fiber::init(acl::FIBER_EVENT_T_WMSG, <span class=\"hljs-literal\">true</span>);<br><span class=\"hljs-comment\">// HOOK ACL 库中的网络 IO 过程</span><br>acl::fiber::acl_io_hook();<br></code></pre></td></tr></table></figure></li>\n<li>创建一个按钮，并使其绑定一个事件方法，如：OnBnClickedListen，然后在这个方法里添加一些代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 创建一个协程用来监听指定地址，接收客户端连接请求</span><br>m_fiberListen = new CFiberListener(<span class=\"hljs-string\">&quot;127.0.0.1:8800&quot;</span>);<br><span class=\"hljs-comment\">// 启动监听协程</span><br>m_fiberListen-&gt;start();<br></code></pre></td></tr></table></figure></li>\n<li>实现步骤 3 中指定的监听协程类<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CFiberListener</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tCFiberListener(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr) : m_addr(addr) &#123;&#125;<br>private:<br>\t~CFiberListener(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::<span class=\"hljs-built_in\">string</span> m_addr;<br>\tacl::server_socket m_listener;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-comment\">// 绑定并监听指定的本地地址</span><br>\t\t<span class=\"hljs-keyword\">if</span> (m_listener.open(m_addr) == <span class=\"hljs-literal\">false</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 等待客户端连接</span><br>\t\t\tacl::socket_stream* conn = m_listener.accept();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 创建独立的协程处理该客户端的请求</span><br>\t\t\tacl::fiber* fb = new CFiberClient(conn);<br>\t\t\tfb-&gt;start(); <span class=\"hljs-comment\">// 启动客户端处理协程</span><br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>\n<li>实现步骤 4 中指定的客户端响应协程类<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CFiberClient</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tCFiberClient(acl::socket_stream* conn) : m_conn(conn) &#123;&#125;<br>private:<br>\t~CFiberClient(<span class=\"hljs-type\">void</span>) &#123; delete m_conn; &#125;<br>private:<br>\tacl::socket_stream* m_conn;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 从客户端读取数据</span><br>\t\t\t<span class=\"hljs-type\">int</span> ret = m_conn-&gt;read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 将读到的数据回写给客户端</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (m_conn-&gt;write(buf, ret) != ret) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n通过以上步骤就可为 win32 界面程序添加基于协程模式的通信模块，上面的两个协程类的处理过程都是“死循环”的，而且又与界面过程同处同一线程运行空间，却为何却不会阻塞界面消息过程呢？其原因就是当通信协程类对象在遇到网络 IO 阻塞时，会自动将自己挂起，将线程的运行权交给其它协程或界面过程。原理就是这么简单，但内部实现还有点复杂度的，感兴趣的可以看看 Acl 协程库的实现源码(<a href=\"https://github.com/acl-dev/acl/tree/master/lib_fiber/\">https://github.com/acl-dev/acl/tree/master/lib_fiber/</a> )。<br>此外，上面示例的完整代码请参考：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/WinEchod\">https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/WinEchod</a>  。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Acl-网络协程框架编程指南\"><a href=\"#Acl-网络协程框架编程指南\" class=\"headerlink\" title=\"Acl 网络协程框架编程指南\"></a>Acl 网络协程框架编程指南</h1><!-- vim-markdown-toc GFM -->\n\n<ul>\n<li><a href=\"#%E6%91%98%E8%A6%81\">摘要</a></li>\n<li><a href=\"#%E4%B8%80%E6%A6%82%E8%BF%B0\">一、概述</a></li>\n<li><a href=\"#%E4%BA%8C%E7%AE%80%E5%8D%95%E7%A4%BA%E4%BE%8B\">二、简单示例</a></li>\n<li><a href=\"#%E4%B8%89%E7%BC%96%E8%AF%91%E5%AE%89%E8%A3%85\">三、编译安装</a></li>\n<li><a href=\"#%E5%9B%9B%E4%BD%BF%E7%94%A8%E5%A4%9A%E6%A0%B8\">四、使用多核</a></li>\n<li><a href=\"#%E4%BA%94%E5%A4%9A%E6%A0%B8%E5%90%8C%E6%AD%A5\">五、多核同步</a></li>\n<li><a href=\"#%E5%85%AD%E6%B6%88%E6%81%AF%E4%BC%A0%E9%80%92\">六、消息传递</a></li>\n<li><a href=\"#%E4%B8%83HOOKAPI\">七、HOOK API</a></li>\n<li><a href=\"#%E5%85%AB%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90\">八、域名解析</a></li>\n<li><a href=\"#%E4%B9%9D%E4%BD%BF%E7%AC%AC%E4%B8%89%E6%96%B9%E7%BD%91%E7%BB%9C%E5%BA%93%E5%8D%8F%E7%A8%8B%E5%8C%96\">九、使第三方网络库协程化</a></li>\n<li><a href=\"#%E5%8D%81Windows%E7%95%8C%E9%9D%A2%E7%BC%96%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%8C%96\">十、Windows 界面编程协程化</a></li>\n</ul>\n<!-- vim-markdown-toc -->\n\n<h2 id=\"摘要\"><a href=\"#摘要\" class=\"headerlink\" title=\"摘要\"></a>摘要</h2><p>本文主要讲述Acl网络协程框架的使用，从协程的应用场景出发，以一个简单的协程示例开始，然后逐步深入到Acl网络协程的各个使用场景及使用细节，以及需要避免的“坑”，希望能给大家带来实践上的帮助。</p>\n<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>讲到协程，大家必然会提到 Go 语言，毕竟是 Go 语言把协程的概念及使用实践普及的；但协程并不是一个新概念，我印象中在九十年代就出现了，当时一位同事还说微软推出了纤程（基本一个意思），可以创建成午上万个纤程，不必象线程那样只能创建较少的线程数量，但当时也没明白创建这么多纤程有啥用，只不过是一个上下文的快速切换协同而已。所以自己在写网络高并发服务时，主要还是以非阻塞方式来实现。<br>其实，Go 语言的作者之一 Russ Cox 早在 2002 年左右就用 C 实现了一个简单的基于协程的网络通信模型 – libtask，但其只是一个简单的网络协程原型，还远达不到实践的要求。自从 Go 语言兴起后，很多基于 C&#x2F;C++ 开发的协程库也多了起来，其中 Acl 协程库便是其中之一。<br>Acl 工程地址：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>Acl 协程地址：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_fiber\">https://github.com/acl-dev/acl/tree/master/lib_fiber</a></p>\n<h2 id=\"二、简单示例\"><a href=\"#二、简单示例\" class=\"headerlink\" title=\"二、简单示例\"></a>二、简单示例</h2><p>下面为一个使用 Acl 库编写的简单线程的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mythread</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tmythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t~mythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\t<span class=\"hljs-comment\">// 实现基类中纯虚方法，当线程启动时该方法将被回调</span><br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;thread-%lu: running ...\\r\\n&quot;</span>, acl::thread::self());<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\tacl::thread* thr = new mythread;<br>\t\tthreads.push_back(thr);<br>\t\tthr-&gt;start();  <span class=\"hljs-comment\">// 启动线程</span><br>\t&#125;<br>\t<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>\t\tit != threads.end(); ++it) &#123;<br>\t\t(*it)-&gt;wait();  <span class=\"hljs-comment\">// 等待线程退出</span><br>\t\tdelete *it;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;\t<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面线程例子非常简单，接着再给一个简单的协程的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myfiber</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tmyfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t~myfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\t<span class=\"hljs-comment\">// 重现基类纯虚方法，当调用 fiber::start 时，该方法将被调用</span><br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world! the fiber is %d\\r\\n&quot;</span>, acl::fiber::self());<br>\t\t\tacl::fiber::yield();  <span class=\"hljs-comment\">// 让出CPU运行权给其它协程</span><br>\t\t&#125;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::fiber*&gt; fibers;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\tacl::fiber* fb = new myfiber;<br>\t\tfibers.push_back(fb);<br>\t\tfb-&gt;start();  <span class=\"hljs-comment\">// 启动一个协程</span><br>\t&#125;<br>\t<br>\tacl::fiber::schedule();  <span class=\"hljs-comment\">// 启用协程调度器</span><br>\t<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::fiber*&gt;::iterator it = fibers.begin();<br>\t\tit != fibers.end(); ++it) &#123;<br>\t\tdelete *it;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面示例演示了协程的创建、启动及运行的过程，与前一个线程的例子非常相似，非常简单（简单实用是 Acl 库的目标之一）。<br><strong>协程调度其实是应用层面多个协程之间通过上下文切换形成的协作过程，如果一个协程库仅是实现了上下文切换，其实并不具备太多实用价值，当与网络事件绑定后，其价值才会显现出来</strong>。下面一个简单的使用协程的网络服务程序：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-comment\">// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_echo</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_echo(acl::socket_stream* conn) : conn_(conn) &#123;&#125;<br>private:<br>\tacl::socket_stream* conn_;<br>\t~fiber_echo(<span class=\"hljs-type\">void</span>) &#123; delete conn_; &#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 从客户端读取数据（第三个参数为false表示不必填满整个缓冲区才返回）</span><br>\t\t\t<span class=\"hljs-type\">int</span> ret = conn_-&gt;read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 向客户端写入读到的数据</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn_-&gt;write(buf, ret) != ret) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this; <span class=\"hljs-comment\">// 自销毁动态创建的协程对象</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_listen</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_listen(acl::server_socket&amp; listener) : listener_(listener) &#123;&#125;<br>private:<br>\tacl::server_socket&amp; listener_;<br>\t~fiber_listen(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\tacl::socket_stream* conn = listener_.accept();  <span class=\"hljs-comment\">// 等待客户端连接</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept failed: %s\\r\\n&quot;</span>, acl::last_serror());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 创建并启动单独的协程处理客户端连接</span><br>\t\t\tacl::fiber* fb = new fiber_echo(conn);<br>\t\t\t<span class=\"hljs-comment\">// 启动独立的客户端处理协程</span><br>\t\t\tfb-&gt;start();<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:8800&quot;</span>;<br>\tacl::server_socket listener;<br>\t<span class=\"hljs-comment\">// 监听本地地址</span><br>\t<span class=\"hljs-keyword\">if</span> (listener.open(addr) == <span class=\"hljs-literal\">false</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen %s error %s\\r\\n&quot;</span>, addr, acl::last_serror());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 创建并启动独立的监听协程，接受客户端连接</span><br>\tacl::fiber* fb = new fiber_listen(listener);<br>\tfb-&gt;start();<br><br>\t<span class=\"hljs-comment\">// 启动协程调度器</span><br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>这是一个简单的支持回显功能的网络协程服务器，可以很容易修改成线程模式。使用线程或线程处理网络通信都可以采用<strong>顺序思维</strong>模式，不必象非阻塞网络编程那样复杂，但使用协程的最大好处可以创建大量的协程来处理网络连接，而要创建大量的线程显示是不现实的（线程数非常多时，会导致操作系统的调度能力下降）。<strong>如果你的网络服务应用不需要支持大并发，使用协程的意义就没那么大了</strong>。</p>\n<h2 id=\"三、编译安装\"><a href=\"#三、编译安装\" class=\"headerlink\" title=\"三、编译安装\"></a>三、编译安装</h2><p>在编译前，需要先从 github  <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a>  下载源码，国内用户可以选择从 gitee  <a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a>  下载源码。</p>\n<h3 id=\"3-1、Linux-x2F-Unix-平台上编译安装\"><a href=\"#3-1、Linux-x2F-Unix-平台上编译安装\" class=\"headerlink\" title=\"3.1、Linux&#x2F;Unix 平台上编译安装\"></a>3.1、Linux&#x2F;Unix 平台上编译安装</h3><p>在 Linux&#x2F;Unix 平台上的编译非常简单，可以选择使用 make 方式或 cmake 方式进行编译。  </p>\n<ul>\n<li><strong>make 方式编译：</strong><br>在 acl 项目根目录下运行：<strong>make &amp;&amp; make packinstall</strong>，则会自动执行编译与安装过程，安装目录默认为系统目录：libacl_all.a, libfiber_cpp.a, libfiber.a 将被拷贝至 &#x2F;usr&#x2F;lib&#x2F; 目录，头文件将被拷贝至 &#x2F;usr&#x2F;include&#x2F;acl-lib&#x2F; 目录。</li>\n<li><strong>cmake 方式编译：</strong><br>在 acl 项目根目录下创建 build 目录，然后：<strong>cd build &amp;&amp; cmake .. &amp;&amp; make</strong></li>\n<li><strong>将 acl 库加入至你的工程</strong>（以 make 方式为例）<br>先在代码中加入头文件包含项：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br></code></pre></td></tr></table></figure>\n然后修改你的 Makefile 文件，示例如下：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\">mytest: mytest.cpp<br>\tg++ -o mytest mytest.cpp -lfiber_cpp -lacl_all -lfiber -ldl -lpthread -lz<br></code></pre></td></tr></table></figure>\n<strong>注意在 Makefile 中各个库的依赖顺序：</strong> libfiber_cpp.a 依赖于 libacl_all.a 和 libfiber.a，其中 libacl_all.a 为 acl 的基础库，libfiber.a 为 C 语言协程库（其不依赖于 libacl_all.a），libfiber_cpp.a 用 C++ 语言封装了 libfiber.a，且使用了 libacl_all.a 中的一些功能。</li>\n</ul>\n<h3 id=\"3-2、Windows-平台上编译\"><a href=\"#3-2、Windows-平台上编译\" class=\"headerlink\" title=\"3.2、Windows 平台上编译\"></a>3.2、Windows 平台上编译</h3><p>在 Windows 平台的编译也非常简单，可以用 vc2008&#x2F;2010&#x2F;2012&#x2F;2013&#x2F;2015&#x2F;2017 打开相应的工程文件进行编译，如：可以用 vc2012 打开 acl_cpp_vc2012.sln 工程进行编译。</p>\n<h3 id=\"3-3-Mac-平台上编译\"><a href=\"#3-3-Mac-平台上编译\" class=\"headerlink\" title=\"3.3 Mac 平台上编译\"></a>3.3 Mac 平台上编译</h3><p>除可以使用 Unix 统一方式（命令行方式）编译外，还可以用 Xcode 打开工程文件进行编译。</p>\n<h3 id=\"3-4-Android-平台上编译\"><a href=\"#3-4-Android-平台上编译\" class=\"headerlink\" title=\"3.4 Android 平台上编译\"></a>3.4 Android 平台上编译</h3><p>目前可以使用 Android Studio3.x 打开 acl\\android\\acl 目录下的工程文件进行编译。</p>\n<h3 id=\"3-5-使用-MinGW-编译\"><a href=\"#3-5-使用-MinGW-编译\" class=\"headerlink\" title=\"3.5 使用 MinGW 编译\"></a>3.5 使用 MinGW 编译</h3><p>如果想要在 Windows 平台上编译 Unix 平台上的软件，可以借用 MinGW 套件进行编译，为此 Acl 库还提供了此种编译方式，但一般不建议用户使用这种编译方式，一方面是执行效率低，另一方面可能会存在某些不兼容问题。</p>\n<h3 id=\"3-6-小结\"><a href=\"#3-6-小结\" class=\"headerlink\" title=\"3.6 小结\"></a>3.6 小结</h3><p>为了保证 Acl 工程无障碍使用，本人在编译 Acl 库方面下了很大功夫，支持几乎在所有平台上使用原生编译环境进行编译使用，真正达到了一键编译。甚至为了避免因依赖第三方库而导致的编译问题（如：有的模块需要 zlib 库，有的需要 polassl 库，有的需要 mysql&#x2F;postgresql&#x2F;sqlite 库），将这些依赖第三方库的模块都写成动态加载第三方库的方式，毕竟不是所有人都需要这些第三方库所提供的功能。</p>\n<h2 id=\"四、使用多核\"><a href=\"#四、使用多核\" class=\"headerlink\" title=\"四、使用多核\"></a>四、使用多核</h2><p>Acl 协程的调度过程是基于单CPU的（虽然也可以修改成多核调度，但考虑到很多原因，最终还是采用了单核调度模式），即创建一个线程，所创建的所有协程都在这个线程空间中运行。为了使用多核，充分使用CPU资源，可以创建多个线程（也可以创建多个进程），每个线程为一个独立的协程运行容器，各个线程之间的协程相互隔离，互不影响。<br>下面先修改一下上面的例子，改成多线程的协程方式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-comment\">// 客户端协程处理类，用来回显客户发送的内容，每一个客户端连接绑定一个独立的协程</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_echo</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_echo(acl::socket_stream* conn) : conn_(conn) &#123;&#125;<br>private:<br>\tacl::socket_stream* conn_;<br>\t~fiber_echo(<span class=\"hljs-type\">void</span>) &#123; delete conn_; &#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\t<span class=\"hljs-type\">int</span> ret = conn_-&gt;read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn_-&gt;write(buf, ret) != ret) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this; <span class=\"hljs-comment\">// 自销毁动态创建的协程对象</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 独立的协程过程，接收客户端连接，并将接收的连接与新创建的协程进行绑定</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_listen</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_listen(acl::server_socket&amp; listener) : listener_(listener) &#123;&#125;<br>private:<br>\tacl::server_socket&amp; listener_;<br>\t~fiber_listen(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\tacl::socket_stream* conn = listener_.accept();  <span class=\"hljs-comment\">// 等待客户端连接</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept failed: %s\\r\\n&quot;</span>, acl::last_serror());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 创建并启动单独的协程处理客户端连接</span><br>\t\t\tacl::fiber* fb = new fiber_echo(conn);<br>\t\t\tfb-&gt;start();<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 独立的线程调度类</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">thread_server</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tthread_server(acl::server_socket&amp; listener) : listener_(listener) &#123;&#125;<br>\t~thread_server(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::server_socket&amp; listener_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-comment\">// 创建并启动独立的监听协程，接受客户端连接</span><br>\t\tacl::fiber* fb = new fiber_listen(listener);<br>\t\tfb-&gt;start();<br>\t\t<span class=\"hljs-comment\">// 启动协程调度器</span><br>\t\tacl::fiber::schedule(); <span class=\"hljs-comment\">// 内部处于死循环过程</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:8800&quot;</span>;<br>\tacl::server_socket listener;<br>\t<span class=\"hljs-comment\">// 监听本地地址</span><br>\t<span class=\"hljs-keyword\">if</span> (listener.open(addr) == <span class=\"hljs-literal\">false</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen %s error %s\\r\\n&quot;</span>, addr, acl::last_serror());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>\t<span class=\"hljs-comment\">// 创建多个独立的线程对象，每个线程启用独立的协程调度过程</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\tacl::thread* thr = thread_server(listener);<br>\t\tthreads.push_back(thr);<br>\t\tthr-&gt;start();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>\t\tit != threads.end(); ++it) &#123;<br>\t\t(*it)-&gt;wait();<br>\t\tdelete *it;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>经过修改，上面的例子即可以支持大并发，又可以使用多核。</p>\n<h2 id=\"五、多核同步\"><a href=\"#五、多核同步\" class=\"headerlink\" title=\"五、多核同步\"></a>五、多核同步</h2><p>上面的例子中涉及到了通过创建多线程使用多核的过程，但肯定会有人问，在多个线程中的协程之间如果想要共享某个资源怎么办？Acl 协程库提供了可以跨线程使用同步原语：线程协程事件同步及条件变量。<br>首先介绍一下事件同步对象类：acl::fiber_event，该类提供了三个方法：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 等待事件锁</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示加锁成功，否则表示内部出错</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 尝试等待事件锁</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示加锁成功，否则表示锁正在被占用</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">trywait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 事件锁拥有者释放事件锁并通知等待者</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示通知成功，否则表示内部出错</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">notify</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n<p>下面给出一个例子，看看在多个线程中的协程之间如何进行互斥的：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myfiber</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tmyfiber(acl::fiber_event&amp; lock, <span class=\"hljs-type\">int</span>&amp; count): lock_(lock), count_(count) &#123;&#125;<br>private:<br>\t~myfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tlock_.wait();<br>\t\t\tcount_++;<br>\t\t\tlock_.notify();<br>\t\t\t<span class=\"hljs-comment\">//acl::fiber::delay(1);  // 本协程休息1毫秒</span><br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>private:<br>\tacl::fiber_event&amp; lock_;<br>\t<span class=\"hljs-type\">int</span>&amp; count_;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mythread</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tmythread(acl::fiber_event&amp; lock, <span class=\"hljs-type\">int</span>&amp; count): lock_(lock), count_(count) &#123;&#125;<br>\t~mythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tacl::fiber* fb = new myfiber(lock_, count_);<br>\t\t\tfb-&gt;start();<br>\t\t&#125;<br>\t\tacl::fiber::schedule();<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>private:<br>\tacl::fiber_event&amp; lock_;<br>\t<span class=\"hljs-type\">int</span>&amp; count_;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tacl::fiber_event lock;  <span class=\"hljs-comment\">// 可以用在多个线程之间、各个线程中的协程之间的同步过程</span><br>\t<span class=\"hljs-type\">int</span> count = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\tacl::thread* thr = new mythread(lock, count);<br>\t\tthreads.push_back(thr);<br>\t\tthr-&gt;start();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>\t\tit != threads.end(); ++it) &#123;<br>\t\t(*it)-&gt;wait();<br>\t\tdelete *it;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;all over, count=%d\\r\\n&quot;</span>, count);<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>acl::fiber_event 常被用在多个线程中的协程之间的同步，当然也可以用在多个线程之间的同步，这在很大程度弥补了 Acl 协程框架在使用多核上的不足。</p>\n<h2 id=\"六、消息传递\"><a href=\"#六、消息传递\" class=\"headerlink\" title=\"六、消息传递\"></a>六、消息传递</h2><p>通过组合 acl::fiber_event（协程事件）和 acl::fiber_cond（协程条件变量），实现了协程间进行消息传递的功能模块：acl::fiber_tbox，fiber_tbox 不仅可以用在同一线程内的协程之间传递消息，而且还可以用在不同线程中的协程之间，不同线程之间，线程与协程之间传递消息。fiber_tbox 为模板类，因而可以传递各种类型对象。以下给出一个示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myobj</span></span><br><span class=\"hljs-class\">&#123;</span><br>public:<br>\tmyobj(<span class=\"hljs-type\">void</span>) : i_(<span class=\"hljs-number\">0</span>) &#123;&#125;<br>\t~myobj(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">set</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> &#123;<br>\t\ti_ = i;<br>\t&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world, i=%d\\r\\n&quot;</span>, i_);<br>\t&#125;<br>private:<br>\t<span class=\"hljs-type\">int</span> i_;<br>&#125;;<br><br><span class=\"hljs-comment\">// 消费者协程，从消息管道中读取消息</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_consumer</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_consumer(acl::fiber_tbox&lt;myobj&gt;&amp; box) : box_(box) &#123;&#125;<br>private:<br>\t~fiber_consumer(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;myobj&gt;&amp; box_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\tmyobj* o = box_.pop();<br>\t\t\t<span class=\"hljs-comment\">// 如果读到空消息，则结束</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (o == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\to-&gt;test();<br>\t\t\tdelete o;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 生产者协程，向消息管道中放置消息</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_producer</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_producer(acl::fiber_tbox&lt;myobj&gt;&amp; box) : box_(box) &#123;&#125;<br>private:<br>\t~fiber_producer(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;myobj&gt;&amp; box_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\t\tmyobj* o = new myobj;<br>\t\t\to-&gt;<span class=\"hljs-built_in\">set</span>(i);<br>\t\t\t<span class=\"hljs-comment\">// 向消息管道中放置消息</span><br>\t\t\tbox_.push(o);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 放置空消息至消息管道中，从而通知消费者协程结束</span><br>\t\tbox_.push(<span class=\"hljs-literal\">NULL</span>);<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tacl::fiber_tbox&lt;myobj&gt; box;<br>\t<span class=\"hljs-comment\">// 创建并启动消费者协程</span><br>\tacl::fiber* consumer = new fiber_consumer(box);<br>\tconsumer-&gt;start();<br>\t<span class=\"hljs-comment\">// 创建并启动生产者协程</span><br>\tacl::fiber* producer = new fiber_producer(box);<br>\tproducer-&gt;start();<br>\t<span class=\"hljs-comment\">// 启动协程调度器</span><br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>\n<p>上面例子展示了同一线程中的两个协程之间的消息传递过程，因为 acl::fiber_tbox 是可以跨线程的，所以它的更大价值是用在多个线程中的不同协程之间进行消息传递。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myobj</span></span><br><span class=\"hljs-class\">&#123;</span><br>public:<br>\tmyobj(<span class=\"hljs-type\">void</span>) : i_(<span class=\"hljs-number\">0</span>) &#123;&#125;<br>\t~myobj(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">set</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> i)</span> &#123;<br>\t\ti_ = i;<br>\t&#125;<br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world, i=%d\\r\\n&quot;</span>, i_);<br>\t&#125;<br>private:<br>\t<span class=\"hljs-type\">int</span> i_;<br>&#125;;<br><br><span class=\"hljs-comment\">// 消费者协程，从消息管道中读取消息</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_consumer</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_consumer(acl::fiber_tbox&lt;myobj&gt;&amp; box) : box_(box) &#123;&#125;<br>private:<br>\t~fiber_consumer(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;myobj&gt;&amp; box_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\tmyobj* o = box_.pop();<br>\t\t\t<span class=\"hljs-comment\">// 如果读到空消息，则结束</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (o == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\to-&gt;test();<br>\t\t\tdelete o;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 生产者线程，向消息管道中放置消息</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">thread_producer</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tthread_producer(acl::fiber_tbox&lt;myobj&gt;&amp; box) : box_(box) &#123;&#125;<br>\t~thread_producer(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;myobj&gt;&amp; box_;<br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++) &#123;<br>\t\t\tmyobj* o = new myobj;<br>\t\t\to-&gt;<span class=\"hljs-built_in\">set</span>(i);<br>\t\t\tbox_.push(o);<br>\t\t&#125;<br>\t\tbox_.push(<span class=\"hljs-literal\">NULL</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tacl::fiber_tbox&lt;myobj&gt; box;<br>\t<span class=\"hljs-comment\">// 创建并启动消费者协程</span><br>\tacl::fiber* consumer = new fiber_consumer(box);<br>\tconsumer-&gt;start();<br>\t<span class=\"hljs-comment\">// 创建并启动生产者线程</span><br>\tacl::thread* producer = new thread_producer(box);<br>\tproducer-&gt;start();<br>\t<span class=\"hljs-comment\">// 启动协程调度器</span><br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-comment\">// schedule() 过程返回后，表示该协程调度器结束。</span><br>\t<span class=\"hljs-comment\">// 等待生产者线程退出</span><br>\tproducer-&gt;wait();<br>\tdelete producer;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>; <br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在该示例中，生产者为一个独立的线程，消费者为另一个线程中的协程，二者通过 acl::fiber_tbox 进行消息通信。但<strong>有一点需要注意</strong>，fiber_tbox 一般可用在“单生产者-单消费者或多生产者-单消费者”的应用场景中，不应用在多消费者的场景中，虽然用在多个消费者场景时不会造成消费丢失或内存崩溃，但当消费者数量较多时却有可能出现惊群现象，所以应避免将一个 acl::fiber_tbox 用在大量的多消费者场景中。<br>下面再给一个应用场景的例子，也是我们平时经常会遇到的。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;unistd.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mythread</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tmythread(acl::fiber_tbox&lt;<span class=\"hljs-type\">int</span>&gt;&amp; box) :box_(box) &#123;&#125;<br>\t~mythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::fiber_tbox&lt;<span class=\"hljs-type\">int</span>&gt;&amp; box_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">int</span> i;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">5</span>; i++) &#123;<br>\t\t\t<span class=\"hljs-comment\">/* 假设这是一个比较耗时的操作*/</span><br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;sleep one second\\r\\n&quot;</span>);<br>\t\t\tsleep(<span class=\"hljs-number\">1</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-type\">int</span>* n = new <span class=\"hljs-type\">int</span>(i);<br>\t\t<span class=\"hljs-comment\">// 将计算结果通过消息管道传递给等待者协程</span><br>\t\tbox_.push(n);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>; <br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">myfiber</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tmyfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>\t~myfiber(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\tacl::fiber_tbox&lt;<span class=\"hljs-type\">int</span>&gt; box;<br>\t\tmythread <span class=\"hljs-title function_\">thread</span><span class=\"hljs-params\">(box)</span>;<br>\t\tthread.set_detachable(<span class=\"hljs-literal\">true</span>);<br>\t\tthread.start();  <span class=\"hljs-comment\">// 启动独立的线程计算耗时运算</span><br>\t\t<span class=\"hljs-type\">int</span>* n = box.pop();  <span class=\"hljs-comment\">// 等待计算线程返回运算结果，仅会阻塞当前协程</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;n is %d\\r\\n&quot;</span>, *n);<br>\t\tdelete n;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tmyfiber fb;<br>\tfb.start();<br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>协程一般用在网络高并发环境中，但协程并不是万金油，协程并不适合计算密集型应用，因为线程才是操作系统的最小调度单元，而协程不是，所以当遇到一些比较耗时的运算时，为了不阻塞当前协程所在的协程调度器，应将该耗时运算过程中抛给独立的线程去处理，然后通过 acl::fiber_tbox 等待线程的运算结果。</p>\n<h2 id=\"七、HOOK-API\"><a href=\"#七、HOOK-API\" class=\"headerlink\" title=\"七、HOOK API\"></a>七、HOOK API</h2><p>为了使现有的很多网络应用和网络库在尽量不修改的情况下协程化，Acl 协程库 Hook 了很多与 IO 和网络通信相关的系统 API，目前已经 Hook 的系统 API 有：</p>\n<table>\n<thead>\n<tr>\n<th>内容项</th>\n<th>API</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>网络相关</td>\n<td>socket&#x2F;listen&#x2F;accept&#x2F;connect</td>\n</tr>\n<tr>\n<td>IO相关</td>\n<td>read&#x2F;readv&#x2F;recv&#x2F;recvfrom&#x2F;recvmsg&#x2F;write&#x2F;writev&#x2F;send&#x2F;sendto&#x2F;sendmsg&#x2F;sendfile64</td>\n</tr>\n<tr>\n<td>域名相关</td>\n<td>gethostbyname(_r)&#x2F;getaddrinfo&#x2F;freeaddrinfo</td>\n</tr>\n<tr>\n<td>事件相关</td>\n<td>select&#x2F;poll&#x2F;epoll_create&#x2F; epoll_ctl&#x2F;epoll_wait</td>\n</tr>\n<tr>\n<td>其它</td>\n<td>close&#x2F;sleep</td>\n</tr>\n</tbody></table>\n<h2 id=\"八、域名解析\"><a href=\"#八、域名解析\" class=\"headerlink\" title=\"八、域名解析\"></a>八、域名解析</h2><p>使用协程方式编写网络通信程序，域名解析是不能绕过的，记得有一个协程库说为了支持域名解析，甚至看了相关实现代码，然后说通过 Hook _poll API 就可以了，实际上这并不是通用的做法，至少在我的环境里通过 Hook _poll API 是没用的，所以最稳妥的做法还是应该将 DNS 查询协议实现了，在 acl 的协程库中，域名解析模块在初期集成了第三方 DNS 库，参见：<a href=\"https://github.com/wahern/dns\">https://github.com/wahern/dns</a>  ，但因为该第 DNS 库存在很多问题（如：不能跨平台，代码混乱，没处理IO异常等问题），所以最终 acl 协程丢弃该库，自己实现了一套更加方便灵活跨平台的 DNS 协议库。 </p>\n<h2 id=\"九、使第三方网络库协程化\"><a href=\"#九、使第三方网络库协程化\" class=\"headerlink\" title=\"九、使第三方网络库协程化\"></a>九、使第三方网络库协程化</h2><p>通常网络通信库都是阻塞式的，因为非阻塞式的通信库的通用性不高（使用各自的事件引擎，很难达到应用层的使用一致性），如果把这些第三方通信库（如：mysql 客户端库，Acl 中的 Redis 库）使用协程所提供的 IO 及网络  API 重写一遍则工作量太大，不太现实，好在 Acl 协程库 Hook 了很多系统 API，从而使阻塞式的网络通信库协程化变得简单。所谓网络库协程化就是使这些网络库可以应用在协程环境中，从而可以很容易编写出支持高并发的网络程序。<br>先写一个将 Acl Redis 客户端库协程化的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_redis</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_redis(acl::redis_client_cluster&amp; cluster) : cluster_(cluster) &#123;&#125;<br>private:<br>\t~fiber_redis(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::redis_client_cluster&amp; cluster_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key = <span class=\"hljs-string\">&quot;hash-key&quot;</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tacl::redis <span class=\"hljs-title function_\">cmd</span><span class=\"hljs-params\">(&amp;cluster_)</span>;<br>\t\t\tacl::<span class=\"hljs-built_in\">string</span> name, val;<br>\t\t\tname.format(<span class=\"hljs-string\">&quot;hash-name-%d&quot;</span>, i);<br>\t\t\tval.format(<span class=\"hljs-string\">&quot;hash-val-%d&quot;</span>, i);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (cmd.hset(key, name, val) == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hset error: %s, key=%s, name=%s\\r\\n&quot;</span>,<br>\t\t\t\t\tcmd.result_error(), key, name.c_str());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr = <span class=\"hljs-string\">&quot;127.0.0.1:6379&quot;</span>;<br>\tacl::redis_client_cluster cluster;<br>\tcluster.<span class=\"hljs-built_in\">set</span>(redis_addr, <span class=\"hljs-number\">0</span>);<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\tacl::fiber* fb = new fiber_redis(cluster);<br>\t\tfb-&gt;start();<br>\t&#125;<br>\tacl::fiber::schedule();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>读者可以尝试将上面的代码拷贝到自己机器上，编译后运行一下。另外，这个例子是只有一个线程，所以会发现 acl::redis_client_cluster 的使用方式和在线程下是一样的。如果将 acl::redis_client_cluster 在多个线程调度器上共享会怎样？还是有一点区别，如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/acl_cpp/lib_acl.hpp&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;acl-lib/fiber/libfiber.hpp&gt;</span></span><br><br><span class=\"hljs-comment\">// 每个协程共享相同的 cluster 对象，向 redis-server 中添加数据</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">fiber_redis</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tfiber_redis(acl::redis_client_cluster&amp; cluster) : cluster_(cluster) &#123;&#125;<br>private:<br>\t~fiber_redis(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::redis_client_cluster&amp; cluster_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key = <span class=\"hljs-string\">&quot;hash-key&quot;</span>;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tacl::redis <span class=\"hljs-title function_\">cmd</span><span class=\"hljs-params\">(&amp;cluster_)</span>;<br>\t\t\tacl::<span class=\"hljs-built_in\">string</span> name, val;<br>\t\t\tname.format(<span class=\"hljs-string\">&quot;hash-name-%d&quot;</span>, i);<br>\t\t\tval.format(<span class=\"hljs-string\">&quot;hash-val-%d&quot;</span>, i);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (cmd.hset(key, name, val) == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hset error: %s, key=%s, name=%s\\r\\n&quot;</span>,<br>\t\t\t\t\tcmd.result_error(), key, name.c_str());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 每个线程运行一个独立的协程调度器</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">mythread</span> :</span> public acl::thread<br>&#123;<br>public:<br>\tmythread(acl::redis_client_cluster&amp; cluster) : cluster_(cluster) &#123;&#125;<br>\t~mythread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::redis_client_cluster&amp; cluster_;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">100</span>; i++) &#123;<br>\t\t\tacl::fiber* fb = new fiber_redis(cluster_\t);<br>\t\t\tfb-&gt;start();<br>\t\t&#125;<br>\t\tacl::fiber::schedule();<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr = <span class=\"hljs-string\">&quot;127.0.0.1:6379&quot;</span>;<br>\tacl::redis_client_cluster cluster;<br>\tcluster.<span class=\"hljs-built_in\">set</span>(redis_addr, <span class=\"hljs-number\">0</span>);<br>\tcluster.bind_thread(<span class=\"hljs-literal\">true</span>);<br><br>\t<span class=\"hljs-comment\">// 创建多个线程，共享 redis 集群连接池管理对象：cluster，即所有线程中的</span><br>\t<span class=\"hljs-comment\">// 所有协程共享同一个 cluster 集群管理对象</span><br>\t<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">4</span>; i++) &#123;<br>\t\tacl::thread* thr = new mythread(cluster);<br>\t\tthreads.push_back(thr);<br>\t\tthr-&gt;start();<br>\t&#125;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>\t\tit != threads.end(); ++it) &#123;<br>\t\t(*it)-&gt;wait();<br>\t\tdelete *it;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在这个多线程多协程环境里使用 acl::redis_client_cluster 对象时与前面的一个例子有所不同，在这里调用了：<strong>cluster.bind_thread(true);</strong><br>为何要这样做？原因是 Acl Redis 的协程调度器是单线程工作模式，网络套接字句柄在协程环境里不能跨线程使用，当调用 bind_thread(true) 后，Acl 连接池管理对象会自动给每个线程分配一个连接池对象，每个线程内的所有协程共享这个绑定于本线程的连接池对象。</p>\n<h2 id=\"十、Windows-界面编程协程化\"><a href=\"#十、Windows-界面编程协程化\" class=\"headerlink\" title=\"十、Windows 界面编程协程化\"></a>十、Windows 界面编程协程化</h2><p>在Windows下写过界面程序的程序员都经历过使通信模块与界面结合的痛苦过程，因为 Windows 界面过程是基于 win32 消息引擎驱动的，所以在编写通信模块时一般有两个选择：要么使用 Windows 提供的异步非阻塞 API，要么把通信模块放在独立于界面的单独线程中然后通过窗口消息将结果通知窗口界面过程。<br>Acl 协程库的事件引擎支持 win32 消息引擎，所以很容易将界面过程的通信过程协程化，采用这种方式，一方面程序员依然可以采用顺序编程方式，另一方面通信协程与界面过程运行于相同的线程空间，则二者在相互访问对方的成员对象时不必加锁，从而使编写通信过程变得更加简单。<br>下面以一个简单的对话框为例说明界面网络通信协程化过程：    </p>\n<ol>\n<li>首先使用向导程序生成一个对话框界面程序，需要指定支持 socket 通信；</li>\n<li>然后在 OnInitDialog() 方法尾部添加如下代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 设置协程调度的事件引擎，同时将协程调度设为自动启动模式</span><br>acl::fiber::init(acl::FIBER_EVENT_T_WMSG, <span class=\"hljs-literal\">true</span>);<br><span class=\"hljs-comment\">// HOOK ACL 库中的网络 IO 过程</span><br>acl::fiber::acl_io_hook();<br></code></pre></td></tr></table></figure></li>\n<li>创建一个按钮，并使其绑定一个事件方法，如：OnBnClickedListen，然后在这个方法里添加一些代码：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 创建一个协程用来监听指定地址，接收客户端连接请求</span><br>m_fiberListen = new CFiberListener(<span class=\"hljs-string\">&quot;127.0.0.1:8800&quot;</span>);<br><span class=\"hljs-comment\">// 启动监听协程</span><br>m_fiberListen-&gt;start();<br></code></pre></td></tr></table></figure></li>\n<li>实现步骤 3 中指定的监听协程类<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CFiberListener</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tCFiberListener(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr) : m_addr(addr) &#123;&#125;<br>private:<br>\t~CFiberListener(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>private:<br>\tacl::<span class=\"hljs-built_in\">string</span> m_addr;<br>\tacl::server_socket m_listener;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-comment\">// 绑定并监听指定的本地地址</span><br>\t\t<span class=\"hljs-keyword\">if</span> (m_listener.open(m_addr) == <span class=\"hljs-literal\">false</span>) &#123;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 等待客户端连接</span><br>\t\t\tacl::socket_stream* conn = m_listener.accept();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 创建独立的协程处理该客户端的请求</span><br>\t\t\tacl::fiber* fb = new CFiberClient(conn);<br>\t\t\tfb-&gt;start(); <span class=\"hljs-comment\">// 启动客户端处理协程</span><br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure></li>\n<li>实现步骤 4 中指定的客户端响应协程类<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CFiberClient</span> :</span> public acl::fiber<br>&#123;<br>public:<br>\tCFiberClient(acl::socket_stream* conn) : m_conn(conn) &#123;&#125;<br>private:<br>\t~CFiberClient(<span class=\"hljs-type\">void</span>) &#123; delete m_conn; &#125;<br>private:<br>\tacl::socket_stream* m_conn;<br>\t<span class=\"hljs-comment\">// @override</span><br>\t<span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>\t\t<span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 从客户端读取数据</span><br>\t\t\t<span class=\"hljs-type\">int</span> ret = m_conn-&gt;read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 将读到的数据回写给客户端</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (m_conn-&gt;write(buf, ret) != ret) &#123;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tdelete this;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n通过以上步骤就可为 win32 界面程序添加基于协程模式的通信模块，上面的两个协程类的处理过程都是“死循环”的，而且又与界面过程同处同一线程运行空间，却为何却不会阻塞界面消息过程呢？其原因就是当通信协程类对象在遇到网络 IO 阻塞时，会自动将自己挂起，将线程的运行权交给其它协程或界面过程。原理就是这么简单，但内部实现还有点复杂度的，感兴趣的可以看看 Acl 协程库的实现源码(<a href=\"https://github.com/acl-dev/acl/tree/master/lib_fiber/\">https://github.com/acl-dev/acl/tree/master/lib_fiber/</a> )。<br>此外，上面示例的完整代码请参考：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/WinEchod\">https://github.com/acl-dev/acl/tree/master/lib_fiber/samples/WinEchod</a>  。</li>\n</ol>\n"},{"title":"使用SSL中对数据进行加密传输","date":"2020-01-15T05:08:24.000Z","_content":"\n# 使用SSL中对数据进行加密传输\n\n## 一、概述  \n\n在 Acl 的网络通信模块中，为了支持安全网络传输，引入了第三方 SSL 库，当前支持 Polarssl 及其升级版 MbedTLS，Acl 库中通过抽象与封装，大大简化了 SSL 的使用过程（现在开源的 SSL 库使用确实太复杂了），以下是在 Acl 库中使用 SSL 的特点：  \n- 为了不给不使用 SSL 功能的用户造成编译上的障碍，Acl 库采用动态加载 SSL 动态库方式，这样在连接时就不必提供 SSL 库（当然，通过设置编译开关，也允许用户采用静态连接 SSL 库的方式）；  \n- 在 Acl 的工程中，仅包含了指定版本的 Polarssl/Mbedtls 头文件（在 acl/include/ 目录下），这些头文件在编译 Acl 的 SSL 模块时会使用到，且不对外暴露，因此使用者需要自行提供对应版本的 SSL 动态二进制库（SSL库的源代码可以去官方 https://tls.mbed.org/ 下载，或者去 https://github.com/acl-dev/third_party 处下载）；\n- 在 Acl SSL 模块中，分为全局配置类和 IO 通信类，配置类对象只需在程序启动时进行创建与初始化，且整个进程中按单例方式使用；IO 通信类对象与每一个 TCP 连接所对应的 socket 进行绑定，TCP 连接建立时进行初始化，进行 SSL 握手并接管 IO 过程；\n- Acl SSL 模块支持服务端及客户端方式，在服务端模块时需要加载数字证书及证书私钥；\n- Acl SSL 模块支持阻塞与非阻塞两种通信方式，阻塞方式还可以用在 Acl 协程通信中；\n- Acl SSL 模块已经应用在 Acl HTTP 通信中，从而方便用户编写支持 HTTPS/Websocket 的客户端或服务端程序；同时，Acl SSL 模块也给 Acl Redis 模块提供了安全通信功能；\n- Acl SSL 模块是线程安全的，虽然官方提供的 Mbedtls 库中增加支持线程安全的编译选项，但其默认情况下却是将此功能关闭的（这真是一个坑人的地方），当你需要打开线程支持功能时还必须得要提供线程锁功能（通过函数回调注册自己的线程锁，好在 Acl 库中有跨平台的线程模块），这应该是 Mbedtls 默认情况下不打开线程支持的原因；\n- 当你使用 Mbedtls 时，建议从 https://github.com/acl-dev/third_party/tree/master/mbedtls-2.7.12 下载 Mbedtls 源码编译，此处的 Mbedtls 与官方的主要区别是：\n  1. 在 config.h 中打开了线程安全的编译选项，同时添加了用于线程安全的互斥锁头文件：threading_alt.h；\n  2. Mbedtls 库编译后生成了三个库文件：libmbedcrypto/libmbedx509/libmbedtls，而原来 Polarssl 只生成一个库文件，所以为了用户使用方便，修改了 libray/CMakeLists.txt 文件，可以将这三个库文件合并成一个；\n  3. 增加了 visualc/VC2012（而官方仅提供了 VS2010），这样在 Windows 平台下可以使用 VS 2012 来编译生成 mbedtls 库。\n \n## 二、API 接口说明\n为了支持更加通用的 SSL 接口，在 Acl SSL 模块中定义了两个基础类：`sslbase_conf` 和 `sslbase_io`，其中 `ssbase_conf` 类对象可以用做全局单一实例，`ssbase_io` 类对象用来给每一个 TCP socket 对象提供安全 IO 通信功能。\n\n### 2.1、sslbase_conf 类\n在 ssbase_conf 类中定义了纯虚方法：`open`，用来创建 SSL IO 通信类对象，在当前所支持 Polarssl 和 MbedTSL 中的配置类中（分别为：`acl::polarssl_conf` 和 `acl::mbedtls_conf`）均实现了该方法。下面是 `open` 方法的具体说明：\n```c\n/**\n * 纯虚方法，创建 SSL IO 对象\n * @param nblock {bool} 是否为非阻塞模式\n * @return {sslbase_io*}\n */\nvirtual sslbase_io* open(bool nblock) = 0;\n```\n在客户端或服务端创建 SSL IO 对象（即：sslbase_io 对象）时调用，被用来与 TCP socket 进行绑定。下面是绑定过程：\n```c\nbool bind_ssl_io(acl::socket_stream& conn, acl::sslbase_conf& ssl_conf)\n{\n\t// 创建一个阻塞式 SSL IO 对象\n\tbool non_block = false;\n\tacl::sslbase_io* ssl = ssl_conf.open(non_block); \n\t\n\t// 将 SSL IO 对象与 TCP 连接流对象进行绑定，在绑定过程中会进行 SSL 握手，\n\t// 如果 SSL 握手失败，则返回该 SSL IO 对象，返回 NULL 表示绑定成功。\n\tif (conn.setup_hook(ssl) == ssl) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n```\n其中 `acl::sslbase_io` 的父类为 `acl::stream_hook`，在`acl::stream` 流基础类中提供了方法`setup_hook`用来注册外部 IO 过程，其中的参数类型为`stream_hook` ，通过绑定外部 IO 过程，将 SSL IO 过程与 acl 中的流处理 IO 过程进行绑定，从而使 acl 的 IO 流过程具备了 SSL 安全传输能力。 \n \n下面的几个接口用在服务端进行证书及私钥加载过程：\n```c\n/**                                                                    \n * 添加一个服务端/客户端自己的证书，可以多次调用本方法加载多个证书 \n * @param crt_file {const char*} 证书文件全路径，非空 \n * @return {bool} 添加证书是否成功 \n */                                                                    \n virtual bool add_cert(const char* crt_file);\n/**                                                                    \n * 添加服务端/客户端的密钥(每个配置实例只需调用一次本方法) \n * @param key_file {const char*} 密钥文件全路径，非空\n * @param key_pass {const char*} 密钥文件的密码，没有密钥密码可写 NULL\n * @return {bool} 设置是否成功\n */\nvirtual bool set_key(const char* key_file, const char* key_pass = NULL)；\n\n/**\n * 当为服务端模式时是否启用会话缓存功能，有助于提高 SSL 握手效率\n * @param on {bool} 是否在服务端启用会话缓存方式\n * 注：该函数仅对服务端模式有效\n */\nvirtual void enable_cache(bool on)；\n```\n\n### 2.2、sslbase_io 类\n`acl::sslbase_io` 类对象与每一个 TCP 连接对象 `acl::socket_stream` 进行绑定，使 `acl::socket_stream` 具备了进行 SSL 安全传输的能力，在 `acl::sslbase_io`类中声明了纯虚方法`handshake`，这使之成为纯虚类；另外，`acl::sslbase_io` 虽然继承于`acl::stream_hook`类，但并没有实现 `acl::stream_hook` 中规定的四个纯虚方法：`open`，`on_close`，`read`，`send`，这几个虚方法也需要 `acl::sslbase_io`的子类来实现，目前`acl::sslbase_io`有两个子类`acl::polarssl_io`及`acl::mbedtls_io` 分别用来支持 Polarssl 及 MbedTLS。\n下面是这几个纯虚方法的声明：\n```c\n/**\n * ssl 握手纯虚方法（属于 sslbase_io 类）\n * @return {bool} 返回 true 表示 SSL 握手成功，否则表示失败\n */\nvirtual bool handshake(void) = 0;\n```\n下面几个虚方法声明于 `acl::stream_hook` 类中：\n```c\n/**\n * 读数据接口\n * @param buf {void*} 读缓冲区地址，读到的数据将存放在该缓冲区中\n * @param len {size_t} buf 缓冲区大小\n * @return {int} 读到字节数，当返回值 < 0 时表示出错\n */\nvirtual int read(void* buf, size_t len) = 0;\n\n/**\n * 发送数据接口\n * @param buf {const void*} 发送缓冲区地址\n * @param len {size_t} buf 缓冲区中数据的长度(必须 > 0) \n * @return {int} 写入的数据长度，返回值 <０　时表示出错\n */\nvirtual int send(const void* buf, size_t len) = 0;\n\n/**\n * 在 stream/aio_stream 的 setup_hook 内部将会调用 stream_hook::open\n * 过程，以便于子类对象用来初始化一些数据及会话\n * @param s {ACL_VSTREAM*} 在 setup_hook 内部调用该方法将创建的流对象\n *  作为参数传入\n * @return {bool} 如果子类实例返回 false，则 setup_hook 调用失败且会恢复原样\n */\nvirtual bool open(ACL_VSTREAM* s) = 0; \n\n/**\n * 当 stream/aio_stream 流对象关闭前将会回调该函数以便于子类实例做一些善后工作\n * @param alive {bool} 该连接是否依然正常\n * @return {bool}\n */\nvirtual bool on_close(bool alive) { (void) alive; return true; } \n\n/**\n * 当 stream/aio_stream 对象需要释放 stream_hook 子类对象时调用此方法\n */\nvirtual void destroy(void) {}\n```\n以上几个虚方法均可以在 `acl::polarssl_io` 及 `acl::mbedtls_io` 中看到被实现。\n\n## 三、编程示例\n### 2.1、服务器模式（使用 MbedTLS）\n首先给出一个完整的支持 SSL 的服务端例子，该例子使用了 MbedTLS 做为 SSL 库，如果想切换成 Polarssl 也非常简单，方法类似（该示例位置：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server）：\n```c\n#include <assert.h>\n#include \"lib_acl.h\"\n#include \"acl_cpp/lib_acl.hpp\"\n\nclass echo_thread : public acl::thread {\npublic:\n        echo_thread(acl::sslbase_conf& ssl_conf, acl::socket_stream* conn)\n        : ssl_conf_(ssl_conf), conn_(conn) {}\n\nprivate:\n        acl::sslbase_conf&  ssl_conf_;\n        acl::socket_stream* conn_;\n\n        ~echo_thread(void) { delete conn_; }\n\n        // @override\n        void* run(void) {\n                conn_->set_rw_timeout(60);\n\n                // 给 socket 安装 SSL IO 过程\n                if (!setup_ssl()) {\n                        return NULL;\n                }\n\n                do_echo();\n\n                delete this;\n                return NULL;\n        }\n\n        bool setup_ssl(void) {\n                bool non_block = false;\n                acl::sslbase_io* ssl = ssl_conf_.open(non_block);\n\n                // 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络\n                // 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程\n                if (conn_->setup_hook(ssl) == ssl) {\n                        printf(\"setup ssl IO hook error!\\r\\n\");\n                        ssl->destroy();\n                        return false;\n                }\n                return true;\n        }\n\n        void do_echo(void) {\n                char buf[4096];\n\n                while (true) {\n                        int ret = conn_->read(buf, sizeof(buf), false);\n                        if (ret == -1) {\n                                break;\n                        }\n                        if (conn_->write(buf, ret) == -1) {\n                                break;\n                        }\n                }\n        }\n};\n\nstatic void start_server(const acl::string addr, acl::sslbase_conf& ssl_conf) {\n        acl::server_socket ss;\n        if (!ss.open(addr)) {\n                printf(\"listen %s error %s\\r\\n\", addr.c_str(), acl::last_serror());\n                return;\n        }\n\n        while (true) {\n                acl::socket_stream* conn = ss.accept();\n                if (conn == NULL) {\n                        printf(\"accept error %s\\r\\n\", acl::last_serror());\n                        break;\n                }\n                acl::thread* thr = new echo_thread(ssl_conf, conn);\n                thr->set_detachable(true);\n                thr->start();\n        }\n}\n\nstatic bool ssl_init(const acl::string& ssl_crt, const acl::string& ssl_key,\n        acl::mbedtls_conf& ssl_conf) {\n\n        ssl_conf.enable_cache(true);\n\n        // 加载 SSL 证书\n        if (!ssl_conf.add_cert(ssl_crt)) {\n                printf(\"add ssl crt=%s error\\r\\n\", ssl_crt.c_str());\n                return false;\n        }\n\n        // 设置 SSL 证书私钥\n        if (!ssl_conf.set_key(ssl_key)) {\n                printf(\"set ssl key=%s error\\r\\n\", ssl_key.c_str());\n                return false;\n        }\n\n        return true;\n}\n\nstatic void usage(const char* procname) {\n        printf(\"usage: %s -h [help]\\r\\n\"\n                \" -s listen_addr\\r\\n\"\n                \" -L ssl_libs_path\\r\\n\"\n                \" -c ssl_crt\\r\\n\"\n                \" -k ssl_key\\r\\n\", procname);\n}\n\nint main(int argc, char* argv[]) {\n        acl::string addr = \"0.0.0.0|2443\";\n#if defined(__APPLE__)\n        acl::string ssl_lib = \"../libmbedtls_all.dylib\";\n#elif defined(__linux__)\n        acl::string ssl_lib = \"../libmbedtls_all.so\";\n#elif defined(_WIN32) || defined(_WIN64)\n        acl::string ssl_path = \"../mbedtls.dll\";\n\n        acl::acl_cpp_init();\n#else\n# error \"unknown OS type\"\n#endif\n        acl::string ssl_crt = \"../ssl_crt.pem\", ssl_key = \"../ssl_key.pem\";\n\n        int ch;\n        while ((ch = getopt(argc, argv, \"hs:L:c:k:\")) > 0) {\n                switch (ch) {\n                case 'h':\n                        usage(argv[0]);\n                        return 0;\n                case 's':\n                        addr = optarg;\n                        break;\n                case 'L':\n                        ssl_lib = optarg;\n                        break;\n                case 'c':\n                        ssl_crt = optarg;\n                        break;\n                case 'k':\n                        ssl_key = optarg;\n                        break;\n                default:\n                        break;\n                }\n        }\n\n        acl::log::stdout_open(true);\n        \n        // 设置 MbedTLS 动态库路径\n        const std::vector<acl::string>& libs = ssl_lib.split2(\",; \\t\");\n        if (libs.size() == 1) {\n                acl::mbedtls_conf::set_libpath(libs[0]);\n        } else if (libs.size() == 3) {\n                // libcrypto, libx509, libssl);\n                acl::mbedtls_conf::set_libpath(libs[0], libs[1], libs[2]);\n        } else {\n                printf(\"invalid ssl_lib=%s\\r\\n\", ssl_lib.c_str());\n                return 1;\n        }\n\n        // 加载 MbedTLS 动态库\n        if (!acl::mbedtls_conf::load()) {\n                printf(\"load %s error\\r\\n\", ssl_lib.c_str());\n                return 1;\n        }\n\n        // 初始化服务端模式下的全局 SSL 配置对象\n        bool server_side = true;\n\n        // SSL 证书校验级别\n        acl::mbedtls_verify_t verify_mode = acl::MBEDTLS_VERIFY_NONE;\n\n        acl::mbedtls_conf ssl_conf(server_side, verify_mode);\n\n        if (!ssl_init(ssl_crt, ssl_key, ssl_conf)) {\n                printf(\"ssl_init failed\\r\\n\");\n                return 1;\n        }\n        \n        start_server(addr, ssl_conf);\n        return 0;\n}\n```\n关于该示例有以下几点说明：\n- 该服务端例子使用了 MbedTLS 库；\n- 采用了动态加载 MbedTLS 动态库的方式；\n- 动态加载时需要设置 MbedTLS 动态库的路径，然后再加载，但在设置动态库的路径时却有两种方式，之所以有两种设置 MbedTLS 动态库路径的方法，主要是因为原来的 Polarssl 只生成一个库，而到 MbedTLS 后却生成了三个库：libmbedcrypto，libmbedx509 和 libmbedtls，其中的依赖关系是 libmbedx509 依赖于 libmbedcrypto，libmbedtls 依赖于 libmbedx509 和 libmbedcrypto；但在 Windows 平台上，官方却只提供了生成一个库（将这三个库合并）的工程；因此，在 acl::mbedtls_conf 中在加载动态库时，提供两种方式，一个接口是用来设置三个库的位置并加载，另一个接口用来设置一个统一库的位置度加载；\n- 该例子大体处理流程：\n  - 通过 `acl::mbedtls_conf::set_libpath` 方法设置 MbedTLS 的三个动态库或一个统一的动态库，然后调用 `acl::mbedtls_conf::load` 加载动态库；\n  - 在 `ssl_init` 函数中，调用基类 `acl::sslbase_conf` 中的虚方法 `add_cert` 及 `set_key` 分别用来加载 SSL 数字证书及证书私钥；\n  - 在 `start_server` 函数中，监听本地服务地址，每接收一个 TCP 连接（对应一个 `acl::socket_stream` 对象）便启动一个线程进行 echo 过程；\n  - 在客户端处理线程中，调用 `echo_thread::setup_ssl` 方法给该 `acl::socket_stream` TCP 流对象绑定一个 SSL IO 对象，即：先通过调用 `acl::mbedtls_conf::open` 方法创建一个 `acl::mbedtls_io` SSL IO 对象，然后通过 `acl::socket_stream` 的基类中的方法 `set_hook` 将该 SSL IO 对象与 TCP 流对象进行绑定并完成 SSL 握手过程；\n  - SSL 握手成功后进入到 `echo_thread::do_echo` 函数中进行简单的 SSL 安全 echo 过程。\n \n### 2.2、客户端模式（使用 MbedTLS）\n在熟悉了上面的 SSL 服务端编程后，下面给出使用 SSL 进行客户端编程的示例（该示例位置：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client）：\n```c\n#include <assert.h>\n#include \"lib_acl.h\"\n#include \"acl_cpp/lib_acl.hpp\"\n\nclass echo_thread : public acl::thread {\npublic:\n        echo_thread(acl::sslbase_conf& ssl_conf, const char* addr, int count)\n        : ssl_conf_(ssl_conf), addr_(addr), count_(count) {}\n\n        ~echo_thread(void) {}\n\nprivate:\n        acl::sslbase_conf&  ssl_conf_;\n        acl::string addr_;\n        int count_;\n\nprivate:\n        // @override\n        void* run(void) {\n                acl::socket_stream conn;\n                conn.set_rw_timeout(60);\n                if (!conn.open(addr_, 10, 10)) {\n                        printf(\"connect %s error %s\\r\\n\",\n                                addr_.c_str(), acl::last_serror());\n                        return NULL;\n                }\n\n                // 给 socket 安装 SSL IO 过程\n                if (!setup_ssl(conn)) {\n                        return NULL;\n                }\n\n                do_echo(conn);\n\n                return NULL;\n        }\n        bool setup_ssl(acl::socket_stream& conn) {\n                bool non_block = false;\n                acl::sslbase_io* ssl = ssl_conf_.open(non_block);\n\n                // 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络\n                // 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程\n                if (conn.setup_hook(ssl) == ssl) {\n                        printf(\"setup ssl IO hook error!\\r\\n\");\n                        ssl->destroy();\n                        return false;\n                }\n                printf(\"ssl setup ok!\\r\\n\");\n\n                return true;\n        }\n\n        void do_echo(acl::socket_stream& conn) {\n                const char* data = \"hello world!\\r\\n\";\n                int i;\n                for (i = 0; i < count_; i++) {\n                        if (conn.write(data, strlen(data)) == -1) {\n                                break;\n                        }\n\n                        char buf[4096];\n                        int ret = conn.read(buf, sizeof(buf) - 1, false);\n                        if (ret == -1) {\n                                printf(\"read over, count=%d\\r\\n\", i + 1);\n                                break;\n                        }\n                        buf[ret] = 0;\n                        if (i == 0) {\n                                printf(\"read: %s\", buf);\n                        }\n                }\n                printf(\"thread-%lu: count=%d\\n\", acl::thread::self(), i);\n        }\n};\n\nstatic void start_clients(acl::sslbase_conf& ssl_conf, const acl::string addr,\n        int cocurrent, int count) {\n\n        std::vector<acl::thread*> threads;\n        for (int i = 0; i < cocurrent; i++) {\n                acl::thread* thr = new echo_thread(ssl_conf, addr, count);\n                threads.push_back(thr);\n                thr->start();\n        }\n\n        for (std::vector<acl::thread*>::iterator it = threads.begin();\n                it != threads.end(); ++it) {\n                (*it)->wait(NULL);\n                delete *it;\n        }\n}\n\nstatic void usage(const char* procname) {\n        printf(\"usage: %s -h [help]\\r\\n\"\n                \" -s listen_addr\\r\\n\"\n                \" -L ssl_libs_path\\r\\n\"\n                \" -c cocurrent\\r\\n\"\n                \" -n count\\r\\n\", procname);\n}\n\nint main(int argc, char* argv[]) {\n        acl::string addr = \"0.0.0.0|2443\";\n#if defined(__APPLE__)\n        acl::string ssl_lib = \"../libmbedtls_all.dylib\";\n#elif defined(__linux__)\n        acl::string ssl_lib = \"../libmbedtls_all.so\";\n#elif defined(_WIN32) || defined(_WIN64)\n        acl::string ssl_path = \"../mbedtls.dll\";\n\n        acl::acl_cpp_init();\n#else\n# error \"unknown OS type\"\n#endif\n\n        int ch, cocurrent = 10, count = 10;\n        while ((ch = getopt(argc, argv, \"hs:L:c:n:\")) > 0) {\n                switch (ch) {\n                case 'h':\n                        usage(argv[0]);\n                        return 0;\n                case 's':\n                        addr = optarg;\n                        break;\n                case 'L':\n                        ssl_lib = optarg;\n                        break;\n                case 'c':\n                        cocurrent = atoi(optarg);\n                        break;\n                case 'n':\n                        count = atoi(optarg);\n                        break;\n                default:\n                        break;\n                }\n        }\n\n        acl::log::stdout_open(true);\n\n        // 设置 MbedTLS 动态库路径\n        const std::vector<acl::string>& libs = ssl_lib.split2(\",; \\t\");\n        if (libs.size() == 1) {\n                acl::mbedtls_conf::set_libpath(libs[0]);\n        } else if (libs.size() == 3) {\n                // libcrypto, libx509, libssl);\n                acl::mbedtls_conf::set_libpath(libs[0], libs[1], libs[2]);\n        } else {\n                printf(\"invalid ssl_lib=%s\\r\\n\", ssl_lib.c_str());\n                return 1;\n        }\n\n        // 加载 MbedTLS 动态库\n        if (!acl::mbedtls_conf::load()) {\n                printf(\"load %s error\\r\\n\", ssl_lib.c_str());\n                return 1;\n        }\n\n        // 初始化客户端模式下的全局 SSL 配置对象\n        bool server_side = false;\n\n        // SSL 证书校验级别\n        acl::mbedtls_verify_t verify_mode = acl::MBEDTLS_VERIFY_NONE;\n        acl::mbedtls_conf ssl_conf(server_side, verify_mode);\n        start_clients(ssl_conf, addr, cocurrent, count);\n        return 0;\n}\n```\n在客户方式下使用 SSL 时的方法与服务端时相似，不同之处是在客户端下使用 SSL 时不必加载证书和设置私钥。\n\n### 2.3、非阻塞模式\n在使用 SSL 进行非阻塞编程时，动态库的加载、证书的加载及设置私钥过程与阻塞式 SSL 编程方法相同，不同之处在于创建 SSL IO 对象时需要设置为非阻塞方式，另外在 SSL 握手阶段需要不断检测 SSL 握手是否成功，下面只给出相关不同之处，完整示例可以参考：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_server，https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_client）：\n\n- 调用 `acl::sslbase_conf` 中的虚方法 `open` 时传入的参数为 `true` 表明所创建的 SSL IO 对象为非阻塞方式；\n- 在创建非阻塞 IO 对象后，需要调用 `acl::aio_socket_stream` 中的 `read_wait` 方法，以便可以触发 `acl::aio_istream::read_wakeup` 回调，从而在该回调里完成 SSL 握手过程；\n- 在非阻塞IO的读回调里需要调用 `acl::sslbase_io` 中的虚方法 `handshake` 尝试进行 SSL 握手并通过 `handshake_ok` 检测握手是否成功。\n下面给出在 `read_wakeup` 回调里进行 SSL 握手的过程：\n```c\nbool read_wakeup()\n{\n        acl::sslbase_io* hook = (acl::sslbase_io*) client_->get_hook();\n        if (hook == NULL) { \n                // 非 SSL 模式，异步读取数据\n                //client_->read(__timeout);\n                client_->gets(__timeout, false); \n                return true;\n        }       \n\n        // 尝试进行 SSL 握手\n        if (!hook->handshake()) {\n                printf(\"ssl handshake failed\\r\\n\");\n                return false;\n        }       \n\n        // 如果 SSL 握手已经成功，则开始按行读数据\n        if (hook->handshake_ok()) {\n                // 由 reactor 模式转为 proactor 模式，从而取消\n                // read_wakeup 回调过程\n                client_->disable_read();\n\n                // 异步读取数据，将会回调 read_callback\n                //client_->read(__timeout);\n                client_->gets(__timeout, false); \n                return true;\n        }       \n\n        // SSL 握手还未完成，等待本函数再次被触发\n        return true;\n}\n```\n在该代码片断中，如果 SSL 握手一直处于进行中，则 `read_wakeup` 可能会被调用多次，这就意味着 `handshake` 握手过程也会被调用多次，然后再通过 `handshake_ok` 判断握手是否已经成功，如果成果，则通过调用 `gets` 方法切换到 IO 过程（该 IO 过程对应的回调为 `read_callback`），否则进行 SSL 握手过程（继续等待 `read_wakeup` 被回调）。\n","source":"_posts/ssl.md","raw":"---\ntitle: 使用SSL中对数据进行加密传输\ndate: 2020-01-15 13:08:24\ntags: SSL编程\ncategories: SSL编程\n---\n\n# 使用SSL中对数据进行加密传输\n\n## 一、概述  \n\n在 Acl 的网络通信模块中，为了支持安全网络传输，引入了第三方 SSL 库，当前支持 Polarssl 及其升级版 MbedTLS，Acl 库中通过抽象与封装，大大简化了 SSL 的使用过程（现在开源的 SSL 库使用确实太复杂了），以下是在 Acl 库中使用 SSL 的特点：  \n- 为了不给不使用 SSL 功能的用户造成编译上的障碍，Acl 库采用动态加载 SSL 动态库方式，这样在连接时就不必提供 SSL 库（当然，通过设置编译开关，也允许用户采用静态连接 SSL 库的方式）；  \n- 在 Acl 的工程中，仅包含了指定版本的 Polarssl/Mbedtls 头文件（在 acl/include/ 目录下），这些头文件在编译 Acl 的 SSL 模块时会使用到，且不对外暴露，因此使用者需要自行提供对应版本的 SSL 动态二进制库（SSL库的源代码可以去官方 https://tls.mbed.org/ 下载，或者去 https://github.com/acl-dev/third_party 处下载）；\n- 在 Acl SSL 模块中，分为全局配置类和 IO 通信类，配置类对象只需在程序启动时进行创建与初始化，且整个进程中按单例方式使用；IO 通信类对象与每一个 TCP 连接所对应的 socket 进行绑定，TCP 连接建立时进行初始化，进行 SSL 握手并接管 IO 过程；\n- Acl SSL 模块支持服务端及客户端方式，在服务端模块时需要加载数字证书及证书私钥；\n- Acl SSL 模块支持阻塞与非阻塞两种通信方式，阻塞方式还可以用在 Acl 协程通信中；\n- Acl SSL 模块已经应用在 Acl HTTP 通信中，从而方便用户编写支持 HTTPS/Websocket 的客户端或服务端程序；同时，Acl SSL 模块也给 Acl Redis 模块提供了安全通信功能；\n- Acl SSL 模块是线程安全的，虽然官方提供的 Mbedtls 库中增加支持线程安全的编译选项，但其默认情况下却是将此功能关闭的（这真是一个坑人的地方），当你需要打开线程支持功能时还必须得要提供线程锁功能（通过函数回调注册自己的线程锁，好在 Acl 库中有跨平台的线程模块），这应该是 Mbedtls 默认情况下不打开线程支持的原因；\n- 当你使用 Mbedtls 时，建议从 https://github.com/acl-dev/third_party/tree/master/mbedtls-2.7.12 下载 Mbedtls 源码编译，此处的 Mbedtls 与官方的主要区别是：\n  1. 在 config.h 中打开了线程安全的编译选项，同时添加了用于线程安全的互斥锁头文件：threading_alt.h；\n  2. Mbedtls 库编译后生成了三个库文件：libmbedcrypto/libmbedx509/libmbedtls，而原来 Polarssl 只生成一个库文件，所以为了用户使用方便，修改了 libray/CMakeLists.txt 文件，可以将这三个库文件合并成一个；\n  3. 增加了 visualc/VC2012（而官方仅提供了 VS2010），这样在 Windows 平台下可以使用 VS 2012 来编译生成 mbedtls 库。\n \n## 二、API 接口说明\n为了支持更加通用的 SSL 接口，在 Acl SSL 模块中定义了两个基础类：`sslbase_conf` 和 `sslbase_io`，其中 `ssbase_conf` 类对象可以用做全局单一实例，`ssbase_io` 类对象用来给每一个 TCP socket 对象提供安全 IO 通信功能。\n\n### 2.1、sslbase_conf 类\n在 ssbase_conf 类中定义了纯虚方法：`open`，用来创建 SSL IO 通信类对象，在当前所支持 Polarssl 和 MbedTSL 中的配置类中（分别为：`acl::polarssl_conf` 和 `acl::mbedtls_conf`）均实现了该方法。下面是 `open` 方法的具体说明：\n```c\n/**\n * 纯虚方法，创建 SSL IO 对象\n * @param nblock {bool} 是否为非阻塞模式\n * @return {sslbase_io*}\n */\nvirtual sslbase_io* open(bool nblock) = 0;\n```\n在客户端或服务端创建 SSL IO 对象（即：sslbase_io 对象）时调用，被用来与 TCP socket 进行绑定。下面是绑定过程：\n```c\nbool bind_ssl_io(acl::socket_stream& conn, acl::sslbase_conf& ssl_conf)\n{\n\t// 创建一个阻塞式 SSL IO 对象\n\tbool non_block = false;\n\tacl::sslbase_io* ssl = ssl_conf.open(non_block); \n\t\n\t// 将 SSL IO 对象与 TCP 连接流对象进行绑定，在绑定过程中会进行 SSL 握手，\n\t// 如果 SSL 握手失败，则返回该 SSL IO 对象，返回 NULL 表示绑定成功。\n\tif (conn.setup_hook(ssl) == ssl) {\n\t\treturn false;\n\t} else {\n\t\treturn true;\n\t}\n}\n```\n其中 `acl::sslbase_io` 的父类为 `acl::stream_hook`，在`acl::stream` 流基础类中提供了方法`setup_hook`用来注册外部 IO 过程，其中的参数类型为`stream_hook` ，通过绑定外部 IO 过程，将 SSL IO 过程与 acl 中的流处理 IO 过程进行绑定，从而使 acl 的 IO 流过程具备了 SSL 安全传输能力。 \n \n下面的几个接口用在服务端进行证书及私钥加载过程：\n```c\n/**                                                                    \n * 添加一个服务端/客户端自己的证书，可以多次调用本方法加载多个证书 \n * @param crt_file {const char*} 证书文件全路径，非空 \n * @return {bool} 添加证书是否成功 \n */                                                                    \n virtual bool add_cert(const char* crt_file);\n/**                                                                    \n * 添加服务端/客户端的密钥(每个配置实例只需调用一次本方法) \n * @param key_file {const char*} 密钥文件全路径，非空\n * @param key_pass {const char*} 密钥文件的密码，没有密钥密码可写 NULL\n * @return {bool} 设置是否成功\n */\nvirtual bool set_key(const char* key_file, const char* key_pass = NULL)；\n\n/**\n * 当为服务端模式时是否启用会话缓存功能，有助于提高 SSL 握手效率\n * @param on {bool} 是否在服务端启用会话缓存方式\n * 注：该函数仅对服务端模式有效\n */\nvirtual void enable_cache(bool on)；\n```\n\n### 2.2、sslbase_io 类\n`acl::sslbase_io` 类对象与每一个 TCP 连接对象 `acl::socket_stream` 进行绑定，使 `acl::socket_stream` 具备了进行 SSL 安全传输的能力，在 `acl::sslbase_io`类中声明了纯虚方法`handshake`，这使之成为纯虚类；另外，`acl::sslbase_io` 虽然继承于`acl::stream_hook`类，但并没有实现 `acl::stream_hook` 中规定的四个纯虚方法：`open`，`on_close`，`read`，`send`，这几个虚方法也需要 `acl::sslbase_io`的子类来实现，目前`acl::sslbase_io`有两个子类`acl::polarssl_io`及`acl::mbedtls_io` 分别用来支持 Polarssl 及 MbedTLS。\n下面是这几个纯虚方法的声明：\n```c\n/**\n * ssl 握手纯虚方法（属于 sslbase_io 类）\n * @return {bool} 返回 true 表示 SSL 握手成功，否则表示失败\n */\nvirtual bool handshake(void) = 0;\n```\n下面几个虚方法声明于 `acl::stream_hook` 类中：\n```c\n/**\n * 读数据接口\n * @param buf {void*} 读缓冲区地址，读到的数据将存放在该缓冲区中\n * @param len {size_t} buf 缓冲区大小\n * @return {int} 读到字节数，当返回值 < 0 时表示出错\n */\nvirtual int read(void* buf, size_t len) = 0;\n\n/**\n * 发送数据接口\n * @param buf {const void*} 发送缓冲区地址\n * @param len {size_t} buf 缓冲区中数据的长度(必须 > 0) \n * @return {int} 写入的数据长度，返回值 <０　时表示出错\n */\nvirtual int send(const void* buf, size_t len) = 0;\n\n/**\n * 在 stream/aio_stream 的 setup_hook 内部将会调用 stream_hook::open\n * 过程，以便于子类对象用来初始化一些数据及会话\n * @param s {ACL_VSTREAM*} 在 setup_hook 内部调用该方法将创建的流对象\n *  作为参数传入\n * @return {bool} 如果子类实例返回 false，则 setup_hook 调用失败且会恢复原样\n */\nvirtual bool open(ACL_VSTREAM* s) = 0; \n\n/**\n * 当 stream/aio_stream 流对象关闭前将会回调该函数以便于子类实例做一些善后工作\n * @param alive {bool} 该连接是否依然正常\n * @return {bool}\n */\nvirtual bool on_close(bool alive) { (void) alive; return true; } \n\n/**\n * 当 stream/aio_stream 对象需要释放 stream_hook 子类对象时调用此方法\n */\nvirtual void destroy(void) {}\n```\n以上几个虚方法均可以在 `acl::polarssl_io` 及 `acl::mbedtls_io` 中看到被实现。\n\n## 三、编程示例\n### 2.1、服务器模式（使用 MbedTLS）\n首先给出一个完整的支持 SSL 的服务端例子，该例子使用了 MbedTLS 做为 SSL 库，如果想切换成 Polarssl 也非常简单，方法类似（该示例位置：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server）：\n```c\n#include <assert.h>\n#include \"lib_acl.h\"\n#include \"acl_cpp/lib_acl.hpp\"\n\nclass echo_thread : public acl::thread {\npublic:\n        echo_thread(acl::sslbase_conf& ssl_conf, acl::socket_stream* conn)\n        : ssl_conf_(ssl_conf), conn_(conn) {}\n\nprivate:\n        acl::sslbase_conf&  ssl_conf_;\n        acl::socket_stream* conn_;\n\n        ~echo_thread(void) { delete conn_; }\n\n        // @override\n        void* run(void) {\n                conn_->set_rw_timeout(60);\n\n                // 给 socket 安装 SSL IO 过程\n                if (!setup_ssl()) {\n                        return NULL;\n                }\n\n                do_echo();\n\n                delete this;\n                return NULL;\n        }\n\n        bool setup_ssl(void) {\n                bool non_block = false;\n                acl::sslbase_io* ssl = ssl_conf_.open(non_block);\n\n                // 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络\n                // 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程\n                if (conn_->setup_hook(ssl) == ssl) {\n                        printf(\"setup ssl IO hook error!\\r\\n\");\n                        ssl->destroy();\n                        return false;\n                }\n                return true;\n        }\n\n        void do_echo(void) {\n                char buf[4096];\n\n                while (true) {\n                        int ret = conn_->read(buf, sizeof(buf), false);\n                        if (ret == -1) {\n                                break;\n                        }\n                        if (conn_->write(buf, ret) == -1) {\n                                break;\n                        }\n                }\n        }\n};\n\nstatic void start_server(const acl::string addr, acl::sslbase_conf& ssl_conf) {\n        acl::server_socket ss;\n        if (!ss.open(addr)) {\n                printf(\"listen %s error %s\\r\\n\", addr.c_str(), acl::last_serror());\n                return;\n        }\n\n        while (true) {\n                acl::socket_stream* conn = ss.accept();\n                if (conn == NULL) {\n                        printf(\"accept error %s\\r\\n\", acl::last_serror());\n                        break;\n                }\n                acl::thread* thr = new echo_thread(ssl_conf, conn);\n                thr->set_detachable(true);\n                thr->start();\n        }\n}\n\nstatic bool ssl_init(const acl::string& ssl_crt, const acl::string& ssl_key,\n        acl::mbedtls_conf& ssl_conf) {\n\n        ssl_conf.enable_cache(true);\n\n        // 加载 SSL 证书\n        if (!ssl_conf.add_cert(ssl_crt)) {\n                printf(\"add ssl crt=%s error\\r\\n\", ssl_crt.c_str());\n                return false;\n        }\n\n        // 设置 SSL 证书私钥\n        if (!ssl_conf.set_key(ssl_key)) {\n                printf(\"set ssl key=%s error\\r\\n\", ssl_key.c_str());\n                return false;\n        }\n\n        return true;\n}\n\nstatic void usage(const char* procname) {\n        printf(\"usage: %s -h [help]\\r\\n\"\n                \" -s listen_addr\\r\\n\"\n                \" -L ssl_libs_path\\r\\n\"\n                \" -c ssl_crt\\r\\n\"\n                \" -k ssl_key\\r\\n\", procname);\n}\n\nint main(int argc, char* argv[]) {\n        acl::string addr = \"0.0.0.0|2443\";\n#if defined(__APPLE__)\n        acl::string ssl_lib = \"../libmbedtls_all.dylib\";\n#elif defined(__linux__)\n        acl::string ssl_lib = \"../libmbedtls_all.so\";\n#elif defined(_WIN32) || defined(_WIN64)\n        acl::string ssl_path = \"../mbedtls.dll\";\n\n        acl::acl_cpp_init();\n#else\n# error \"unknown OS type\"\n#endif\n        acl::string ssl_crt = \"../ssl_crt.pem\", ssl_key = \"../ssl_key.pem\";\n\n        int ch;\n        while ((ch = getopt(argc, argv, \"hs:L:c:k:\")) > 0) {\n                switch (ch) {\n                case 'h':\n                        usage(argv[0]);\n                        return 0;\n                case 's':\n                        addr = optarg;\n                        break;\n                case 'L':\n                        ssl_lib = optarg;\n                        break;\n                case 'c':\n                        ssl_crt = optarg;\n                        break;\n                case 'k':\n                        ssl_key = optarg;\n                        break;\n                default:\n                        break;\n                }\n        }\n\n        acl::log::stdout_open(true);\n        \n        // 设置 MbedTLS 动态库路径\n        const std::vector<acl::string>& libs = ssl_lib.split2(\",; \\t\");\n        if (libs.size() == 1) {\n                acl::mbedtls_conf::set_libpath(libs[0]);\n        } else if (libs.size() == 3) {\n                // libcrypto, libx509, libssl);\n                acl::mbedtls_conf::set_libpath(libs[0], libs[1], libs[2]);\n        } else {\n                printf(\"invalid ssl_lib=%s\\r\\n\", ssl_lib.c_str());\n                return 1;\n        }\n\n        // 加载 MbedTLS 动态库\n        if (!acl::mbedtls_conf::load()) {\n                printf(\"load %s error\\r\\n\", ssl_lib.c_str());\n                return 1;\n        }\n\n        // 初始化服务端模式下的全局 SSL 配置对象\n        bool server_side = true;\n\n        // SSL 证书校验级别\n        acl::mbedtls_verify_t verify_mode = acl::MBEDTLS_VERIFY_NONE;\n\n        acl::mbedtls_conf ssl_conf(server_side, verify_mode);\n\n        if (!ssl_init(ssl_crt, ssl_key, ssl_conf)) {\n                printf(\"ssl_init failed\\r\\n\");\n                return 1;\n        }\n        \n        start_server(addr, ssl_conf);\n        return 0;\n}\n```\n关于该示例有以下几点说明：\n- 该服务端例子使用了 MbedTLS 库；\n- 采用了动态加载 MbedTLS 动态库的方式；\n- 动态加载时需要设置 MbedTLS 动态库的路径，然后再加载，但在设置动态库的路径时却有两种方式，之所以有两种设置 MbedTLS 动态库路径的方法，主要是因为原来的 Polarssl 只生成一个库，而到 MbedTLS 后却生成了三个库：libmbedcrypto，libmbedx509 和 libmbedtls，其中的依赖关系是 libmbedx509 依赖于 libmbedcrypto，libmbedtls 依赖于 libmbedx509 和 libmbedcrypto；但在 Windows 平台上，官方却只提供了生成一个库（将这三个库合并）的工程；因此，在 acl::mbedtls_conf 中在加载动态库时，提供两种方式，一个接口是用来设置三个库的位置并加载，另一个接口用来设置一个统一库的位置度加载；\n- 该例子大体处理流程：\n  - 通过 `acl::mbedtls_conf::set_libpath` 方法设置 MbedTLS 的三个动态库或一个统一的动态库，然后调用 `acl::mbedtls_conf::load` 加载动态库；\n  - 在 `ssl_init` 函数中，调用基类 `acl::sslbase_conf` 中的虚方法 `add_cert` 及 `set_key` 分别用来加载 SSL 数字证书及证书私钥；\n  - 在 `start_server` 函数中，监听本地服务地址，每接收一个 TCP 连接（对应一个 `acl::socket_stream` 对象）便启动一个线程进行 echo 过程；\n  - 在客户端处理线程中，调用 `echo_thread::setup_ssl` 方法给该 `acl::socket_stream` TCP 流对象绑定一个 SSL IO 对象，即：先通过调用 `acl::mbedtls_conf::open` 方法创建一个 `acl::mbedtls_io` SSL IO 对象，然后通过 `acl::socket_stream` 的基类中的方法 `set_hook` 将该 SSL IO 对象与 TCP 流对象进行绑定并完成 SSL 握手过程；\n  - SSL 握手成功后进入到 `echo_thread::do_echo` 函数中进行简单的 SSL 安全 echo 过程。\n \n### 2.2、客户端模式（使用 MbedTLS）\n在熟悉了上面的 SSL 服务端编程后，下面给出使用 SSL 进行客户端编程的示例（该示例位置：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client）：\n```c\n#include <assert.h>\n#include \"lib_acl.h\"\n#include \"acl_cpp/lib_acl.hpp\"\n\nclass echo_thread : public acl::thread {\npublic:\n        echo_thread(acl::sslbase_conf& ssl_conf, const char* addr, int count)\n        : ssl_conf_(ssl_conf), addr_(addr), count_(count) {}\n\n        ~echo_thread(void) {}\n\nprivate:\n        acl::sslbase_conf&  ssl_conf_;\n        acl::string addr_;\n        int count_;\n\nprivate:\n        // @override\n        void* run(void) {\n                acl::socket_stream conn;\n                conn.set_rw_timeout(60);\n                if (!conn.open(addr_, 10, 10)) {\n                        printf(\"connect %s error %s\\r\\n\",\n                                addr_.c_str(), acl::last_serror());\n                        return NULL;\n                }\n\n                // 给 socket 安装 SSL IO 过程\n                if (!setup_ssl(conn)) {\n                        return NULL;\n                }\n\n                do_echo(conn);\n\n                return NULL;\n        }\n        bool setup_ssl(acl::socket_stream& conn) {\n                bool non_block = false;\n                acl::sslbase_io* ssl = ssl_conf_.open(non_block);\n\n                // 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络\n                // 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程\n                if (conn.setup_hook(ssl) == ssl) {\n                        printf(\"setup ssl IO hook error!\\r\\n\");\n                        ssl->destroy();\n                        return false;\n                }\n                printf(\"ssl setup ok!\\r\\n\");\n\n                return true;\n        }\n\n        void do_echo(acl::socket_stream& conn) {\n                const char* data = \"hello world!\\r\\n\";\n                int i;\n                for (i = 0; i < count_; i++) {\n                        if (conn.write(data, strlen(data)) == -1) {\n                                break;\n                        }\n\n                        char buf[4096];\n                        int ret = conn.read(buf, sizeof(buf) - 1, false);\n                        if (ret == -1) {\n                                printf(\"read over, count=%d\\r\\n\", i + 1);\n                                break;\n                        }\n                        buf[ret] = 0;\n                        if (i == 0) {\n                                printf(\"read: %s\", buf);\n                        }\n                }\n                printf(\"thread-%lu: count=%d\\n\", acl::thread::self(), i);\n        }\n};\n\nstatic void start_clients(acl::sslbase_conf& ssl_conf, const acl::string addr,\n        int cocurrent, int count) {\n\n        std::vector<acl::thread*> threads;\n        for (int i = 0; i < cocurrent; i++) {\n                acl::thread* thr = new echo_thread(ssl_conf, addr, count);\n                threads.push_back(thr);\n                thr->start();\n        }\n\n        for (std::vector<acl::thread*>::iterator it = threads.begin();\n                it != threads.end(); ++it) {\n                (*it)->wait(NULL);\n                delete *it;\n        }\n}\n\nstatic void usage(const char* procname) {\n        printf(\"usage: %s -h [help]\\r\\n\"\n                \" -s listen_addr\\r\\n\"\n                \" -L ssl_libs_path\\r\\n\"\n                \" -c cocurrent\\r\\n\"\n                \" -n count\\r\\n\", procname);\n}\n\nint main(int argc, char* argv[]) {\n        acl::string addr = \"0.0.0.0|2443\";\n#if defined(__APPLE__)\n        acl::string ssl_lib = \"../libmbedtls_all.dylib\";\n#elif defined(__linux__)\n        acl::string ssl_lib = \"../libmbedtls_all.so\";\n#elif defined(_WIN32) || defined(_WIN64)\n        acl::string ssl_path = \"../mbedtls.dll\";\n\n        acl::acl_cpp_init();\n#else\n# error \"unknown OS type\"\n#endif\n\n        int ch, cocurrent = 10, count = 10;\n        while ((ch = getopt(argc, argv, \"hs:L:c:n:\")) > 0) {\n                switch (ch) {\n                case 'h':\n                        usage(argv[0]);\n                        return 0;\n                case 's':\n                        addr = optarg;\n                        break;\n                case 'L':\n                        ssl_lib = optarg;\n                        break;\n                case 'c':\n                        cocurrent = atoi(optarg);\n                        break;\n                case 'n':\n                        count = atoi(optarg);\n                        break;\n                default:\n                        break;\n                }\n        }\n\n        acl::log::stdout_open(true);\n\n        // 设置 MbedTLS 动态库路径\n        const std::vector<acl::string>& libs = ssl_lib.split2(\",; \\t\");\n        if (libs.size() == 1) {\n                acl::mbedtls_conf::set_libpath(libs[0]);\n        } else if (libs.size() == 3) {\n                // libcrypto, libx509, libssl);\n                acl::mbedtls_conf::set_libpath(libs[0], libs[1], libs[2]);\n        } else {\n                printf(\"invalid ssl_lib=%s\\r\\n\", ssl_lib.c_str());\n                return 1;\n        }\n\n        // 加载 MbedTLS 动态库\n        if (!acl::mbedtls_conf::load()) {\n                printf(\"load %s error\\r\\n\", ssl_lib.c_str());\n                return 1;\n        }\n\n        // 初始化客户端模式下的全局 SSL 配置对象\n        bool server_side = false;\n\n        // SSL 证书校验级别\n        acl::mbedtls_verify_t verify_mode = acl::MBEDTLS_VERIFY_NONE;\n        acl::mbedtls_conf ssl_conf(server_side, verify_mode);\n        start_clients(ssl_conf, addr, cocurrent, count);\n        return 0;\n}\n```\n在客户方式下使用 SSL 时的方法与服务端时相似，不同之处是在客户端下使用 SSL 时不必加载证书和设置私钥。\n\n### 2.3、非阻塞模式\n在使用 SSL 进行非阻塞编程时，动态库的加载、证书的加载及设置私钥过程与阻塞式 SSL 编程方法相同，不同之处在于创建 SSL IO 对象时需要设置为非阻塞方式，另外在 SSL 握手阶段需要不断检测 SSL 握手是否成功，下面只给出相关不同之处，完整示例可以参考：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_server，https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_client）：\n\n- 调用 `acl::sslbase_conf` 中的虚方法 `open` 时传入的参数为 `true` 表明所创建的 SSL IO 对象为非阻塞方式；\n- 在创建非阻塞 IO 对象后，需要调用 `acl::aio_socket_stream` 中的 `read_wait` 方法，以便可以触发 `acl::aio_istream::read_wakeup` 回调，从而在该回调里完成 SSL 握手过程；\n- 在非阻塞IO的读回调里需要调用 `acl::sslbase_io` 中的虚方法 `handshake` 尝试进行 SSL 握手并通过 `handshake_ok` 检测握手是否成功。\n下面给出在 `read_wakeup` 回调里进行 SSL 握手的过程：\n```c\nbool read_wakeup()\n{\n        acl::sslbase_io* hook = (acl::sslbase_io*) client_->get_hook();\n        if (hook == NULL) { \n                // 非 SSL 模式，异步读取数据\n                //client_->read(__timeout);\n                client_->gets(__timeout, false); \n                return true;\n        }       \n\n        // 尝试进行 SSL 握手\n        if (!hook->handshake()) {\n                printf(\"ssl handshake failed\\r\\n\");\n                return false;\n        }       \n\n        // 如果 SSL 握手已经成功，则开始按行读数据\n        if (hook->handshake_ok()) {\n                // 由 reactor 模式转为 proactor 模式，从而取消\n                // read_wakeup 回调过程\n                client_->disable_read();\n\n                // 异步读取数据，将会回调 read_callback\n                //client_->read(__timeout);\n                client_->gets(__timeout, false); \n                return true;\n        }       \n\n        // SSL 握手还未完成，等待本函数再次被触发\n        return true;\n}\n```\n在该代码片断中，如果 SSL 握手一直处于进行中，则 `read_wakeup` 可能会被调用多次，这就意味着 `handshake` 握手过程也会被调用多次，然后再通过 `handshake_ok` 判断握手是否已经成功，如果成果，则通过调用 `gets` 方法切换到 IO 过程（该 IO 过程对应的回调为 `read_callback`），否则进行 SSL 握手过程（继续等待 `read_wakeup` 被回调）。\n","slug":"ssl","published":1,"updated":"2023-01-23T09:58:13.986Z","_id":"cld8cwq7a0003m7fy4vic72n0","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"使用SSL中对数据进行加密传输\"><a href=\"#使用SSL中对数据进行加密传输\" class=\"headerlink\" title=\"使用SSL中对数据进行加密传输\"></a>使用SSL中对数据进行加密传输</h1><h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>在 Acl 的网络通信模块中，为了支持安全网络传输，引入了第三方 SSL 库，当前支持 Polarssl 及其升级版 MbedTLS，Acl 库中通过抽象与封装，大大简化了 SSL 的使用过程（现在开源的 SSL 库使用确实太复杂了），以下是在 Acl 库中使用 SSL 的特点：  </p>\n<ul>\n<li>为了不给不使用 SSL 功能的用户造成编译上的障碍，Acl 库采用动态加载 SSL 动态库方式，这样在连接时就不必提供 SSL 库（当然，通过设置编译开关，也允许用户采用静态连接 SSL 库的方式）；  </li>\n<li>在 Acl 的工程中，仅包含了指定版本的 Polarssl&#x2F;Mbedtls 头文件（在 acl&#x2F;include&#x2F; 目录下），这些头文件在编译 Acl 的 SSL 模块时会使用到，且不对外暴露，因此使用者需要自行提供对应版本的 SSL 动态二进制库（SSL库的源代码可以去官方 <a href=\"https://tls.mbed.org/\">https://tls.mbed.org/</a> 下载，或者去 <a href=\"https://github.com/acl-dev/third_party\">https://github.com/acl-dev/third_party</a> 处下载）；</li>\n<li>在 Acl SSL 模块中，分为全局配置类和 IO 通信类，配置类对象只需在程序启动时进行创建与初始化，且整个进程中按单例方式使用；IO 通信类对象与每一个 TCP 连接所对应的 socket 进行绑定，TCP 连接建立时进行初始化，进行 SSL 握手并接管 IO 过程；</li>\n<li>Acl SSL 模块支持服务端及客户端方式，在服务端模块时需要加载数字证书及证书私钥；</li>\n<li>Acl SSL 模块支持阻塞与非阻塞两种通信方式，阻塞方式还可以用在 Acl 协程通信中；</li>\n<li>Acl SSL 模块已经应用在 Acl HTTP 通信中，从而方便用户编写支持 HTTPS&#x2F;Websocket 的客户端或服务端程序；同时，Acl SSL 模块也给 Acl Redis 模块提供了安全通信功能；</li>\n<li>Acl SSL 模块是线程安全的，虽然官方提供的 Mbedtls 库中增加支持线程安全的编译选项，但其默认情况下却是将此功能关闭的（这真是一个坑人的地方），当你需要打开线程支持功能时还必须得要提供线程锁功能（通过函数回调注册自己的线程锁，好在 Acl 库中有跨平台的线程模块），这应该是 Mbedtls 默认情况下不打开线程支持的原因；</li>\n<li>当你使用 Mbedtls 时，建议从 <a href=\"https://github.com/acl-dev/third_party/tree/master/mbedtls-2.7.12\">https://github.com/acl-dev/third_party/tree/master/mbedtls-2.7.12</a> 下载 Mbedtls 源码编译，此处的 Mbedtls 与官方的主要区别是：<ol>\n<li>在 config.h 中打开了线程安全的编译选项，同时添加了用于线程安全的互斥锁头文件：threading_alt.h；</li>\n<li>Mbedtls 库编译后生成了三个库文件：libmbedcrypto&#x2F;libmbedx509&#x2F;libmbedtls，而原来 Polarssl 只生成一个库文件，所以为了用户使用方便，修改了 libray&#x2F;CMakeLists.txt 文件，可以将这三个库文件合并成一个；</li>\n<li>增加了 visualc&#x2F;VC2012（而官方仅提供了 VS2010），这样在 Windows 平台下可以使用 VS 2012 来编译生成 mbedtls 库。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"二、API-接口说明\"><a href=\"#二、API-接口说明\" class=\"headerlink\" title=\"二、API 接口说明\"></a>二、API 接口说明</h2><p>为了支持更加通用的 SSL 接口，在 Acl SSL 模块中定义了两个基础类：<code>sslbase_conf</code> 和 <code>sslbase_io</code>，其中 <code>ssbase_conf</code> 类对象可以用做全局单一实例，<code>ssbase_io</code> 类对象用来给每一个 TCP socket 对象提供安全 IO 通信功能。</p>\n<h3 id=\"2-1、sslbase-conf-类\"><a href=\"#2-1、sslbase-conf-类\" class=\"headerlink\" title=\"2.1、sslbase_conf 类\"></a>2.1、sslbase_conf 类</h3><p>在 ssbase_conf 类中定义了纯虚方法：<code>open</code>，用来创建 SSL IO 通信类对象，在当前所支持 Polarssl 和 MbedTSL 中的配置类中（分别为：<code>acl::polarssl_conf</code> 和 <code>acl::mbedtls_conf</code>）均实现了该方法。下面是 <code>open</code> 方法的具体说明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 纯虚方法，创建 SSL IO 对象</span><br><span class=\"hljs-comment\"> * @param nblock &#123;bool&#125; 是否为非阻塞模式</span><br><span class=\"hljs-comment\"> * @return &#123;sslbase_io*&#125;</span><br><span class=\"hljs-comment\"> */</span><br>virtual sslbase_io* <span class=\"hljs-title function_\">open</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> nblock)</span> = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n<p>在客户端或服务端创建 SSL IO 对象（即：sslbase_io 对象）时调用，被用来与 TCP socket 进行绑定。下面是绑定过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">bind_ssl_io</span><span class=\"hljs-params\">(acl::socket_stream&amp; conn, acl::sslbase_conf&amp; ssl_conf)</span><br>&#123;<br>\t<span class=\"hljs-comment\">// 创建一个阻塞式 SSL IO 对象</span><br>\t<span class=\"hljs-type\">bool</span> non_block = <span class=\"hljs-literal\">false</span>;<br>\tacl::sslbase_io* ssl = ssl_conf.open(non_block); <br>\t<br>\t<span class=\"hljs-comment\">// 将 SSL IO 对象与 TCP 连接流对象进行绑定，在绑定过程中会进行 SSL 握手，</span><br>\t<span class=\"hljs-comment\">// 如果 SSL 握手失败，则返回该 SSL IO 对象，返回 NULL 表示绑定成功。</span><br>\t<span class=\"hljs-keyword\">if</span> (conn.setup_hook(ssl) == ssl) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其中 <code>acl::sslbase_io</code> 的父类为 <code>acl::stream_hook</code>，在<code>acl::stream</code> 流基础类中提供了方法<code>setup_hook</code>用来注册外部 IO 过程，其中的参数类型为<code>stream_hook</code> ，通过绑定外部 IO 过程，将 SSL IO 过程与 acl 中的流处理 IO 过程进行绑定，从而使 acl 的 IO 流过程具备了 SSL 安全传输能力。 </p>\n<p>下面的几个接口用在服务端进行证书及私钥加载过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**                                                                    </span><br><span class=\"hljs-comment\"> * 添加一个服务端/客户端自己的证书，可以多次调用本方法加载多个证书 </span><br><span class=\"hljs-comment\"> * @param crt_file &#123;const char*&#125; 证书文件全路径，非空 </span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 添加证书是否成功 </span><br><span class=\"hljs-comment\"> */</span>                                                                    <br> virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">add_cert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* crt_file)</span>;<br><span class=\"hljs-comment\">/**                                                                    </span><br><span class=\"hljs-comment\"> * 添加服务端/客户端的密钥(每个配置实例只需调用一次本方法) </span><br><span class=\"hljs-comment\"> * @param key_file &#123;const char*&#125; 密钥文件全路径，非空</span><br><span class=\"hljs-comment\"> * @param key_pass &#123;const char*&#125; 密钥文件的密码，没有密钥密码可写 NULL</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 设置是否成功</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">set_key</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key_file, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key_pass = <span class=\"hljs-literal\">NULL</span>)</span>；<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当为服务端模式时是否启用会话缓存功能，有助于提高 SSL 握手效率</span><br><span class=\"hljs-comment\"> * @param on &#123;bool&#125; 是否在服务端启用会话缓存方式</span><br><span class=\"hljs-comment\"> * 注：该函数仅对服务端模式有效</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">enable_cache</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> on)</span>；<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2、sslbase-io-类\"><a href=\"#2-2、sslbase-io-类\" class=\"headerlink\" title=\"2.2、sslbase_io 类\"></a>2.2、sslbase_io 类</h3><p><code>acl::sslbase_io</code> 类对象与每一个 TCP 连接对象 <code>acl::socket_stream</code> 进行绑定，使 <code>acl::socket_stream</code> 具备了进行 SSL 安全传输的能力，在 <code>acl::sslbase_io</code>类中声明了纯虚方法<code>handshake</code>，这使之成为纯虚类；另外，<code>acl::sslbase_io</code> 虽然继承于<code>acl::stream_hook</code>类，但并没有实现 <code>acl::stream_hook</code> 中规定的四个纯虚方法：<code>open</code>，<code>on_close</code>，<code>read</code>，<code>send</code>，这几个虚方法也需要 <code>acl::sslbase_io</code>的子类来实现，目前<code>acl::sslbase_io</code>有两个子类<code>acl::polarssl_io</code>及<code>acl::mbedtls_io</code> 分别用来支持 Polarssl 及 MbedTLS。<br>下面是这几个纯虚方法的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * ssl 握手纯虚方法（属于 sslbase_io 类）</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示 SSL 握手成功，否则表示失败</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">handshake</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n<p>下面几个虚方法声明于 <code>acl::stream_hook</code> 类中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 读数据接口</span><br><span class=\"hljs-comment\"> * @param buf &#123;void*&#125; 读缓冲区地址，读到的数据将存放在该缓冲区中</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125; buf 缓冲区大小</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 读到字节数，当返回值 &lt; 0 时表示出错</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">read</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* buf, <span class=\"hljs-type\">size_t</span> len)</span> = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 发送数据接口</span><br><span class=\"hljs-comment\"> * @param buf &#123;const void*&#125; 发送缓冲区地址</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125; buf 缓冲区中数据的长度(必须 &gt; 0) </span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 写入的数据长度，返回值 &lt;０　时表示出错</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">send</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* buf, <span class=\"hljs-type\">size_t</span> len)</span> = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在 stream/aio_stream 的 setup_hook 内部将会调用 stream_hook::open</span><br><span class=\"hljs-comment\"> * 过程，以便于子类对象用来初始化一些数据及会话</span><br><span class=\"hljs-comment\"> * @param s &#123;ACL_VSTREAM*&#125; 在 setup_hook 内部调用该方法将创建的流对象</span><br><span class=\"hljs-comment\"> *  作为参数传入</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 如果子类实例返回 false，则 setup_hook 调用失败且会恢复原样</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">open</span><span class=\"hljs-params\">(ACL_VSTREAM* s)</span> = <span class=\"hljs-number\">0</span>; <br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 stream/aio_stream 流对象关闭前将会回调该函数以便于子类实例做一些善后工作</span><br><span class=\"hljs-comment\"> * @param alive &#123;bool&#125; 该连接是否依然正常</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">on_close</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> alive)</span> &#123; (<span class=\"hljs-type\">void</span>) alive; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; &#125; <br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 stream/aio_stream 对象需要释放 stream_hook 子类对象时调用此方法</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">destroy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>以上几个虚方法均可以在 <code>acl::polarssl_io</code> 及 <code>acl::mbedtls_io</code> 中看到被实现。</p>\n<h2 id=\"三、编程示例\"><a href=\"#三、编程示例\" class=\"headerlink\" title=\"三、编程示例\"></a>三、编程示例</h2><h3 id=\"2-1、服务器模式（使用-MbedTLS）\"><a href=\"#2-1、服务器模式（使用-MbedTLS）\" class=\"headerlink\" title=\"2.1、服务器模式（使用 MbedTLS）\"></a>2.1、服务器模式（使用 MbedTLS）</h3><p>首先给出一个完整的支持 SSL 的服务端例子，该例子使用了 MbedTLS 做为 SSL 库，如果想切换成 Polarssl 也非常简单，方法类似（该示例位置：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server%EF%BC%89%EF%BC%9A\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server）：</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">echo_thread</span> :</span> public acl::thread &#123;<br>public:<br>        echo_thread(acl::sslbase_conf&amp; ssl_conf, acl::socket_stream* conn)<br>        : ssl_conf_(ssl_conf), conn_(conn) &#123;&#125;<br><br>private:<br>        acl::sslbase_conf&amp;  ssl_conf_;<br>        acl::socket_stream* conn_;<br><br>        ~echo_thread(<span class=\"hljs-type\">void</span>) &#123; delete conn_; &#125;<br><br>        <span class=\"hljs-comment\">// @override</span><br>        <span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>                conn_-&gt;set_rw_timeout(<span class=\"hljs-number\">60</span>);<br><br>                <span class=\"hljs-comment\">// 给 socket 安装 SSL IO 过程</span><br>                <span class=\"hljs-keyword\">if</span> (!setup_ssl()) &#123;<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>                &#125;<br><br>                do_echo();<br><br>                delete this;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>        &#125;<br><br>        <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">setup_ssl</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>                <span class=\"hljs-type\">bool</span> non_block = <span class=\"hljs-literal\">false</span>;<br>                acl::sslbase_io* ssl = ssl_conf_.open(non_block);<br><br>                <span class=\"hljs-comment\">// 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络</span><br>                <span class=\"hljs-comment\">// 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程</span><br>                <span class=\"hljs-keyword\">if</span> (conn_-&gt;setup_hook(ssl) == ssl) &#123;<br>                        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;setup ssl IO hook error!\\r\\n&quot;</span>);<br>                        ssl-&gt;destroy();<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>                &#125;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        &#125;<br><br>        <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">do_echo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>                <span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">4096</span>];<br><br>                <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>                        <span class=\"hljs-type\">int</span> ret = conn_-&gt;read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>                        <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>                                <span class=\"hljs-keyword\">break</span>;<br>                        &#125;<br>                        <span class=\"hljs-keyword\">if</span> (conn_-&gt;write(buf, ret) == <span class=\"hljs-number\">-1</span>) &#123;<br>                                <span class=\"hljs-keyword\">break</span>;<br>                        &#125;<br>                &#125;<br>        &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">start_server</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> acl::<span class=\"hljs-built_in\">string</span> addr, acl::sslbase_conf&amp; ssl_conf)</span> &#123;<br>        acl::server_socket ss;<br>        <span class=\"hljs-keyword\">if</span> (!ss.open(addr)) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen %s error %s\\r\\n&quot;</span>, addr.c_str(), acl::last_serror());<br>                <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>                acl::socket_stream* conn = ss.accept();<br>                <span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>                        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept error %s\\r\\n&quot;</span>, acl::last_serror());<br>                        <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>                acl::thread* thr = new echo_thread(ssl_conf, conn);<br>                thr-&gt;set_detachable(<span class=\"hljs-literal\">true</span>);<br>                thr-&gt;start();<br>        &#125;<br>&#125;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">ssl_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> acl::<span class=\"hljs-built_in\">string</span>&amp; ssl_crt, <span class=\"hljs-type\">const</span> acl::<span class=\"hljs-built_in\">string</span>&amp; ssl_key,</span><br><span class=\"hljs-params\">        acl::mbedtls_conf&amp; ssl_conf)</span> &#123;<br><br>        ssl_conf.enable_cache(<span class=\"hljs-literal\">true</span>);<br><br>        <span class=\"hljs-comment\">// 加载 SSL 证书</span><br>        <span class=\"hljs-keyword\">if</span> (!ssl_conf.add_cert(ssl_crt)) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;add ssl crt=%s error\\r\\n&quot;</span>, ssl_crt.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 设置 SSL 证书私钥</span><br>        <span class=\"hljs-keyword\">if</span> (!ssl_conf.set_key(ssl_key)) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;set ssl key=%s error\\r\\n&quot;</span>, ssl_key.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* procname)</span> &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h [help]\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -s listen_addr\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -L ssl_libs_path\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -c ssl_crt\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -k ssl_key\\r\\n&quot;</span>, procname);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span> &#123;<br>        acl::<span class=\"hljs-built_in\">string</span> addr = <span class=\"hljs-string\">&quot;0.0.0.0|2443&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(__APPLE__)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_lib = <span class=\"hljs-string\">&quot;../libmbedtls_all.dylib&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined(__linux__)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_lib = <span class=\"hljs-string\">&quot;../libmbedtls_all.so&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined(_WIN32) || defined(_WIN64)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_path = <span class=\"hljs-string\">&quot;../mbedtls.dll&quot;</span>;<br><br>        acl::acl_cpp_init();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">error</span> <span class=\"hljs-string\">&quot;unknown OS type&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_crt = <span class=\"hljs-string\">&quot;../ssl_crt.pem&quot;</span>, ssl_key = <span class=\"hljs-string\">&quot;../ssl_key.pem&quot;</span>;<br><br>        <span class=\"hljs-type\">int</span> ch;<br>        <span class=\"hljs-keyword\">while</span> ((ch = getopt(argc, argv, <span class=\"hljs-string\">&quot;hs:L:c:k:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>                <span class=\"hljs-keyword\">switch</span> (ch) &#123;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>                        usage(argv[<span class=\"hljs-number\">0</span>]);<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;s&#x27;</span>:<br>                        addr = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;L&#x27;</span>:<br>                        ssl_lib = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;c&#x27;</span>:<br>                        ssl_crt = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;k&#x27;</span>:<br>                        ssl_key = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">default</span>:<br>                        <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>        &#125;<br><br>        acl::<span class=\"hljs-built_in\">log</span>::stdout_open(<span class=\"hljs-literal\">true</span>);<br>        <br>        <span class=\"hljs-comment\">// 设置 MbedTLS 动态库路径</span><br>        <span class=\"hljs-type\">const</span> <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::<span class=\"hljs-built_in\">string</span>&gt;&amp; libs = ssl_lib.split2(<span class=\"hljs-string\">&quot;,; \\t&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span> (libs.size() == <span class=\"hljs-number\">1</span>) &#123;<br>                acl::mbedtls_conf::set_libpath(libs[<span class=\"hljs-number\">0</span>]);<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (libs.size() == <span class=\"hljs-number\">3</span>) &#123;<br>                <span class=\"hljs-comment\">// libcrypto, libx509, libssl);</span><br>                acl::mbedtls_conf::set_libpath(libs[<span class=\"hljs-number\">0</span>], libs[<span class=\"hljs-number\">1</span>], libs[<span class=\"hljs-number\">2</span>]);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;invalid ssl_lib=%s\\r\\n&quot;</span>, ssl_lib.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 加载 MbedTLS 动态库</span><br>        <span class=\"hljs-keyword\">if</span> (!acl::mbedtls_conf::load()) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;load %s error\\r\\n&quot;</span>, ssl_lib.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 初始化服务端模式下的全局 SSL 配置对象</span><br>        <span class=\"hljs-type\">bool</span> server_side = <span class=\"hljs-literal\">true</span>;<br><br>        <span class=\"hljs-comment\">// SSL 证书校验级别</span><br>        acl::<span class=\"hljs-type\">mbedtls_verify_t</span> verify_mode = acl::MBEDTLS_VERIFY_NONE;<br><br>        acl::mbedtls_conf <span class=\"hljs-title function_\">ssl_conf</span><span class=\"hljs-params\">(server_side, verify_mode)</span>;<br><br>        <span class=\"hljs-keyword\">if</span> (!ssl_init(ssl_crt, ssl_key, ssl_conf)) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ssl_init failed\\r\\n&quot;</span>);<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br>        <br>        start_server(addr, ssl_conf);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>关于该示例有以下几点说明：</p>\n<ul>\n<li>该服务端例子使用了 MbedTLS 库；</li>\n<li>采用了动态加载 MbedTLS 动态库的方式；</li>\n<li>动态加载时需要设置 MbedTLS 动态库的路径，然后再加载，但在设置动态库的路径时却有两种方式，之所以有两种设置 MbedTLS 动态库路径的方法，主要是因为原来的 Polarssl 只生成一个库，而到 MbedTLS 后却生成了三个库：libmbedcrypto，libmbedx509 和 libmbedtls，其中的依赖关系是 libmbedx509 依赖于 libmbedcrypto，libmbedtls 依赖于 libmbedx509 和 libmbedcrypto；但在 Windows 平台上，官方却只提供了生成一个库（将这三个库合并）的工程；因此，在 acl::mbedtls_conf 中在加载动态库时，提供两种方式，一个接口是用来设置三个库的位置并加载，另一个接口用来设置一个统一库的位置度加载；</li>\n<li>该例子大体处理流程：<ul>\n<li>通过 <code>acl::mbedtls_conf::set_libpath</code> 方法设置 MbedTLS 的三个动态库或一个统一的动态库，然后调用 <code>acl::mbedtls_conf::load</code> 加载动态库；</li>\n<li>在 <code>ssl_init</code> 函数中，调用基类 <code>acl::sslbase_conf</code> 中的虚方法 <code>add_cert</code> 及 <code>set_key</code> 分别用来加载 SSL 数字证书及证书私钥；</li>\n<li>在 <code>start_server</code> 函数中，监听本地服务地址，每接收一个 TCP 连接（对应一个 <code>acl::socket_stream</code> 对象）便启动一个线程进行 echo 过程；</li>\n<li>在客户端处理线程中，调用 <code>echo_thread::setup_ssl</code> 方法给该 <code>acl::socket_stream</code> TCP 流对象绑定一个 SSL IO 对象，即：先通过调用 <code>acl::mbedtls_conf::open</code> 方法创建一个 <code>acl::mbedtls_io</code> SSL IO 对象，然后通过 <code>acl::socket_stream</code> 的基类中的方法 <code>set_hook</code> 将该 SSL IO 对象与 TCP 流对象进行绑定并完成 SSL 握手过程；</li>\n<li>SSL 握手成功后进入到 <code>echo_thread::do_echo</code> 函数中进行简单的 SSL 安全 echo 过程。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2、客户端模式（使用-MbedTLS）\"><a href=\"#2-2、客户端模式（使用-MbedTLS）\" class=\"headerlink\" title=\"2.2、客户端模式（使用 MbedTLS）\"></a>2.2、客户端模式（使用 MbedTLS）</h3><p>在熟悉了上面的 SSL 服务端编程后，下面给出使用 SSL 进行客户端编程的示例（该示例位置：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client%EF%BC%89%EF%BC%9A\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client）：</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">echo_thread</span> :</span> public acl::thread &#123;<br>public:<br>        echo_thread(acl::sslbase_conf&amp; ssl_conf, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">int</span> count)<br>        : ssl_conf_(ssl_conf), addr_(addr), count_(count) &#123;&#125;<br><br>        ~echo_thread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br><br>private:<br>        acl::sslbase_conf&amp;  ssl_conf_;<br>        acl::<span class=\"hljs-built_in\">string</span> addr_;<br>        <span class=\"hljs-type\">int</span> count_;<br><br>private:<br>        <span class=\"hljs-comment\">// @override</span><br>        <span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>                acl::socket_stream conn;<br>                conn.set_rw_timeout(<span class=\"hljs-number\">60</span>);<br>                <span class=\"hljs-keyword\">if</span> (!conn.open(addr_, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>)) &#123;<br>                        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;connect %s error %s\\r\\n&quot;</span>,<br>                                addr_.c_str(), acl::last_serror());<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>                &#125;<br><br>                <span class=\"hljs-comment\">// 给 socket 安装 SSL IO 过程</span><br>                <span class=\"hljs-keyword\">if</span> (!setup_ssl(conn)) &#123;<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>                &#125;<br><br>                do_echo(conn);<br><br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>        &#125;<br>        <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">setup_ssl</span><span class=\"hljs-params\">(acl::socket_stream&amp; conn)</span> &#123;<br>                <span class=\"hljs-type\">bool</span> non_block = <span class=\"hljs-literal\">false</span>;<br>                acl::sslbase_io* ssl = ssl_conf_.open(non_block);<br><br>                <span class=\"hljs-comment\">// 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络</span><br>                <span class=\"hljs-comment\">// 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程</span><br>                <span class=\"hljs-keyword\">if</span> (conn.setup_hook(ssl) == ssl) &#123;<br>                        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;setup ssl IO hook error!\\r\\n&quot;</span>);<br>                        ssl-&gt;destroy();<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>                &#125;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ssl setup ok!\\r\\n&quot;</span>);<br><br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        &#125;<br><br>        <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">do_echo</span><span class=\"hljs-params\">(acl::socket_stream&amp; conn)</span> &#123;<br>                <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* data = <span class=\"hljs-string\">&quot;hello world!\\r\\n&quot;</span>;<br>                <span class=\"hljs-type\">int</span> i;<br>                <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; count_; i++) &#123;<br>                        <span class=\"hljs-keyword\">if</span> (conn.write(data, <span class=\"hljs-built_in\">strlen</span>(data)) == <span class=\"hljs-number\">-1</span>) &#123;<br>                                <span class=\"hljs-keyword\">break</span>;<br>                        &#125;<br><br>                        <span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">4096</span>];<br>                        <span class=\"hljs-type\">int</span> ret = conn.read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf) - <span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">false</span>);<br>                        <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>                                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;read over, count=%d\\r\\n&quot;</span>, i + <span class=\"hljs-number\">1</span>);<br>                                <span class=\"hljs-keyword\">break</span>;<br>                        &#125;<br>                        buf[ret] = <span class=\"hljs-number\">0</span>;<br>                        <span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">0</span>) &#123;<br>                                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;read: %s&quot;</span>, buf);<br>                        &#125;<br>                &#125;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;thread-%lu: count=%d\\n&quot;</span>, acl::thread::self(), i);<br>        &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">start_clients</span><span class=\"hljs-params\">(acl::sslbase_conf&amp; ssl_conf, <span class=\"hljs-type\">const</span> acl::<span class=\"hljs-built_in\">string</span> addr,</span><br><span class=\"hljs-params\">        <span class=\"hljs-type\">int</span> cocurrent, <span class=\"hljs-type\">int</span> count)</span> &#123;<br><br>        <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; cocurrent; i++) &#123;<br>                acl::thread* thr = new echo_thread(ssl_conf, addr, count);<br>                threads.push_back(thr);<br>                thr-&gt;start();<br>        &#125;<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>                it != threads.end(); ++it) &#123;<br>                (*it)-&gt;wait(<span class=\"hljs-literal\">NULL</span>);<br>                delete *it;<br>        &#125;<br>&#125;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* procname)</span> &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h [help]\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -s listen_addr\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -L ssl_libs_path\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -c cocurrent\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -n count\\r\\n&quot;</span>, procname);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span> &#123;<br>        acl::<span class=\"hljs-built_in\">string</span> addr = <span class=\"hljs-string\">&quot;0.0.0.0|2443&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(__APPLE__)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_lib = <span class=\"hljs-string\">&quot;../libmbedtls_all.dylib&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined(__linux__)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_lib = <span class=\"hljs-string\">&quot;../libmbedtls_all.so&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined(_WIN32) || defined(_WIN64)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_path = <span class=\"hljs-string\">&quot;../mbedtls.dll&quot;</span>;<br><br>        acl::acl_cpp_init();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">error</span> <span class=\"hljs-string\">&quot;unknown OS type&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>        <span class=\"hljs-type\">int</span> ch, cocurrent = <span class=\"hljs-number\">10</span>, count = <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-keyword\">while</span> ((ch = getopt(argc, argv, <span class=\"hljs-string\">&quot;hs:L:c:n:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>                <span class=\"hljs-keyword\">switch</span> (ch) &#123;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>                        usage(argv[<span class=\"hljs-number\">0</span>]);<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;s&#x27;</span>:<br>                        addr = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;L&#x27;</span>:<br>                        ssl_lib = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;c&#x27;</span>:<br>                        cocurrent = atoi(optarg);<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;n&#x27;</span>:<br>                        count = atoi(optarg);<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">default</span>:<br>                        <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>        &#125;<br><br>        acl::<span class=\"hljs-built_in\">log</span>::stdout_open(<span class=\"hljs-literal\">true</span>);<br><br>        <span class=\"hljs-comment\">// 设置 MbedTLS 动态库路径</span><br>        <span class=\"hljs-type\">const</span> <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::<span class=\"hljs-built_in\">string</span>&gt;&amp; libs = ssl_lib.split2(<span class=\"hljs-string\">&quot;,; \\t&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span> (libs.size() == <span class=\"hljs-number\">1</span>) &#123;<br>                acl::mbedtls_conf::set_libpath(libs[<span class=\"hljs-number\">0</span>]);<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (libs.size() == <span class=\"hljs-number\">3</span>) &#123;<br>                <span class=\"hljs-comment\">// libcrypto, libx509, libssl);</span><br>                acl::mbedtls_conf::set_libpath(libs[<span class=\"hljs-number\">0</span>], libs[<span class=\"hljs-number\">1</span>], libs[<span class=\"hljs-number\">2</span>]);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;invalid ssl_lib=%s\\r\\n&quot;</span>, ssl_lib.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 加载 MbedTLS 动态库</span><br>        <span class=\"hljs-keyword\">if</span> (!acl::mbedtls_conf::load()) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;load %s error\\r\\n&quot;</span>, ssl_lib.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 初始化客户端模式下的全局 SSL 配置对象</span><br>        <span class=\"hljs-type\">bool</span> server_side = <span class=\"hljs-literal\">false</span>;<br><br>        <span class=\"hljs-comment\">// SSL 证书校验级别</span><br>        acl::<span class=\"hljs-type\">mbedtls_verify_t</span> verify_mode = acl::MBEDTLS_VERIFY_NONE;<br>        acl::mbedtls_conf <span class=\"hljs-title function_\">ssl_conf</span><span class=\"hljs-params\">(server_side, verify_mode)</span>;<br>        start_clients(ssl_conf, addr, cocurrent, count);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在客户方式下使用 SSL 时的方法与服务端时相似，不同之处是在客户端下使用 SSL 时不必加载证书和设置私钥。</p>\n<h3 id=\"2-3、非阻塞模式\"><a href=\"#2-3、非阻塞模式\" class=\"headerlink\" title=\"2.3、非阻塞模式\"></a>2.3、非阻塞模式</h3><p>在使用 SSL 进行非阻塞编程时，动态库的加载、证书的加载及设置私钥过程与阻塞式 SSL 编程方法相同，不同之处在于创建 SSL IO 对象时需要设置为非阻塞方式，另外在 SSL 握手阶段需要不断检测 SSL 握手是否成功，下面只给出相关不同之处，完整示例可以参考：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_server%EF%BC%8Chttps://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_client%EF%BC%89%EF%BC%9A\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_server，https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_client）：</a></p>\n<ul>\n<li>调用 <code>acl::sslbase_conf</code> 中的虚方法 <code>open</code> 时传入的参数为 <code>true</code> 表明所创建的 SSL IO 对象为非阻塞方式；</li>\n<li>在创建非阻塞 IO 对象后，需要调用 <code>acl::aio_socket_stream</code> 中的 <code>read_wait</code> 方法，以便可以触发 <code>acl::aio_istream::read_wakeup</code> 回调，从而在该回调里完成 SSL 握手过程；</li>\n<li>在非阻塞IO的读回调里需要调用 <code>acl::sslbase_io</code> 中的虚方法 <code>handshake</code> 尝试进行 SSL 握手并通过 <code>handshake_ok</code> 检测握手是否成功。<br>下面给出在 <code>read_wakeup</code> 回调里进行 SSL 握手的过程：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">read_wakeup</span><span class=\"hljs-params\">()</span><br>&#123;<br>        acl::sslbase_io* hook = (acl::sslbase_io*) client_-&gt;get_hook();<br>        <span class=\"hljs-keyword\">if</span> (hook == <span class=\"hljs-literal\">NULL</span>) &#123; <br>                <span class=\"hljs-comment\">// 非 SSL 模式，异步读取数据</span><br>                <span class=\"hljs-comment\">//client_-&gt;read(__timeout);</span><br>                client_-&gt;gets(__timeout, <span class=\"hljs-literal\">false</span>); <br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        &#125;       <br><br>        <span class=\"hljs-comment\">// 尝试进行 SSL 握手</span><br>        <span class=\"hljs-keyword\">if</span> (!hook-&gt;handshake()) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ssl handshake failed\\r\\n&quot;</span>);<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;       <br><br>        <span class=\"hljs-comment\">// 如果 SSL 握手已经成功，则开始按行读数据</span><br>        <span class=\"hljs-keyword\">if</span> (hook-&gt;handshake_ok()) &#123;<br>                <span class=\"hljs-comment\">// 由 reactor 模式转为 proactor 模式，从而取消</span><br>                <span class=\"hljs-comment\">// read_wakeup 回调过程</span><br>                client_-&gt;disable_read();<br><br>                <span class=\"hljs-comment\">// 异步读取数据，将会回调 read_callback</span><br>                <span class=\"hljs-comment\">//client_-&gt;read(__timeout);</span><br>                client_-&gt;gets(__timeout, <span class=\"hljs-literal\">false</span>); <br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        &#125;       <br><br>        <span class=\"hljs-comment\">// SSL 握手还未完成，等待本函数再次被触发</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n在该代码片断中，如果 SSL 握手一直处于进行中，则 <code>read_wakeup</code> 可能会被调用多次，这就意味着 <code>handshake</code> 握手过程也会被调用多次，然后再通过 <code>handshake_ok</code> 判断握手是否已经成功，如果成果，则通过调用 <code>gets</code> 方法切换到 IO 过程（该 IO 过程对应的回调为 <code>read_callback</code>），否则进行 SSL 握手过程（继续等待 <code>read_wakeup</code> 被回调）。</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"使用SSL中对数据进行加密传输\"><a href=\"#使用SSL中对数据进行加密传输\" class=\"headerlink\" title=\"使用SSL中对数据进行加密传输\"></a>使用SSL中对数据进行加密传输</h1><h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>在 Acl 的网络通信模块中，为了支持安全网络传输，引入了第三方 SSL 库，当前支持 Polarssl 及其升级版 MbedTLS，Acl 库中通过抽象与封装，大大简化了 SSL 的使用过程（现在开源的 SSL 库使用确实太复杂了），以下是在 Acl 库中使用 SSL 的特点：  </p>\n<ul>\n<li>为了不给不使用 SSL 功能的用户造成编译上的障碍，Acl 库采用动态加载 SSL 动态库方式，这样在连接时就不必提供 SSL 库（当然，通过设置编译开关，也允许用户采用静态连接 SSL 库的方式）；  </li>\n<li>在 Acl 的工程中，仅包含了指定版本的 Polarssl&#x2F;Mbedtls 头文件（在 acl&#x2F;include&#x2F; 目录下），这些头文件在编译 Acl 的 SSL 模块时会使用到，且不对外暴露，因此使用者需要自行提供对应版本的 SSL 动态二进制库（SSL库的源代码可以去官方 <a href=\"https://tls.mbed.org/\">https://tls.mbed.org/</a> 下载，或者去 <a href=\"https://github.com/acl-dev/third_party\">https://github.com/acl-dev/third_party</a> 处下载）；</li>\n<li>在 Acl SSL 模块中，分为全局配置类和 IO 通信类，配置类对象只需在程序启动时进行创建与初始化，且整个进程中按单例方式使用；IO 通信类对象与每一个 TCP 连接所对应的 socket 进行绑定，TCP 连接建立时进行初始化，进行 SSL 握手并接管 IO 过程；</li>\n<li>Acl SSL 模块支持服务端及客户端方式，在服务端模块时需要加载数字证书及证书私钥；</li>\n<li>Acl SSL 模块支持阻塞与非阻塞两种通信方式，阻塞方式还可以用在 Acl 协程通信中；</li>\n<li>Acl SSL 模块已经应用在 Acl HTTP 通信中，从而方便用户编写支持 HTTPS&#x2F;Websocket 的客户端或服务端程序；同时，Acl SSL 模块也给 Acl Redis 模块提供了安全通信功能；</li>\n<li>Acl SSL 模块是线程安全的，虽然官方提供的 Mbedtls 库中增加支持线程安全的编译选项，但其默认情况下却是将此功能关闭的（这真是一个坑人的地方），当你需要打开线程支持功能时还必须得要提供线程锁功能（通过函数回调注册自己的线程锁，好在 Acl 库中有跨平台的线程模块），这应该是 Mbedtls 默认情况下不打开线程支持的原因；</li>\n<li>当你使用 Mbedtls 时，建议从 <a href=\"https://github.com/acl-dev/third_party/tree/master/mbedtls-2.7.12\">https://github.com/acl-dev/third_party/tree/master/mbedtls-2.7.12</a> 下载 Mbedtls 源码编译，此处的 Mbedtls 与官方的主要区别是：<ol>\n<li>在 config.h 中打开了线程安全的编译选项，同时添加了用于线程安全的互斥锁头文件：threading_alt.h；</li>\n<li>Mbedtls 库编译后生成了三个库文件：libmbedcrypto&#x2F;libmbedx509&#x2F;libmbedtls，而原来 Polarssl 只生成一个库文件，所以为了用户使用方便，修改了 libray&#x2F;CMakeLists.txt 文件，可以将这三个库文件合并成一个；</li>\n<li>增加了 visualc&#x2F;VC2012（而官方仅提供了 VS2010），这样在 Windows 平台下可以使用 VS 2012 来编译生成 mbedtls 库。</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"二、API-接口说明\"><a href=\"#二、API-接口说明\" class=\"headerlink\" title=\"二、API 接口说明\"></a>二、API 接口说明</h2><p>为了支持更加通用的 SSL 接口，在 Acl SSL 模块中定义了两个基础类：<code>sslbase_conf</code> 和 <code>sslbase_io</code>，其中 <code>ssbase_conf</code> 类对象可以用做全局单一实例，<code>ssbase_io</code> 类对象用来给每一个 TCP socket 对象提供安全 IO 通信功能。</p>\n<h3 id=\"2-1、sslbase-conf-类\"><a href=\"#2-1、sslbase-conf-类\" class=\"headerlink\" title=\"2.1、sslbase_conf 类\"></a>2.1、sslbase_conf 类</h3><p>在 ssbase_conf 类中定义了纯虚方法：<code>open</code>，用来创建 SSL IO 通信类对象，在当前所支持 Polarssl 和 MbedTSL 中的配置类中（分别为：<code>acl::polarssl_conf</code> 和 <code>acl::mbedtls_conf</code>）均实现了该方法。下面是 <code>open</code> 方法的具体说明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 纯虚方法，创建 SSL IO 对象</span><br><span class=\"hljs-comment\"> * @param nblock &#123;bool&#125; 是否为非阻塞模式</span><br><span class=\"hljs-comment\"> * @return &#123;sslbase_io*&#125;</span><br><span class=\"hljs-comment\"> */</span><br>virtual sslbase_io* <span class=\"hljs-title function_\">open</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> nblock)</span> = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n<p>在客户端或服务端创建 SSL IO 对象（即：sslbase_io 对象）时调用，被用来与 TCP socket 进行绑定。下面是绑定过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">bind_ssl_io</span><span class=\"hljs-params\">(acl::socket_stream&amp; conn, acl::sslbase_conf&amp; ssl_conf)</span><br>&#123;<br>\t<span class=\"hljs-comment\">// 创建一个阻塞式 SSL IO 对象</span><br>\t<span class=\"hljs-type\">bool</span> non_block = <span class=\"hljs-literal\">false</span>;<br>\tacl::sslbase_io* ssl = ssl_conf.open(non_block); <br>\t<br>\t<span class=\"hljs-comment\">// 将 SSL IO 对象与 TCP 连接流对象进行绑定，在绑定过程中会进行 SSL 握手，</span><br>\t<span class=\"hljs-comment\">// 如果 SSL 握手失败，则返回该 SSL IO 对象，返回 NULL 表示绑定成功。</span><br>\t<span class=\"hljs-keyword\">if</span> (conn.setup_hook(ssl) == ssl) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其中 <code>acl::sslbase_io</code> 的父类为 <code>acl::stream_hook</code>，在<code>acl::stream</code> 流基础类中提供了方法<code>setup_hook</code>用来注册外部 IO 过程，其中的参数类型为<code>stream_hook</code> ，通过绑定外部 IO 过程，将 SSL IO 过程与 acl 中的流处理 IO 过程进行绑定，从而使 acl 的 IO 流过程具备了 SSL 安全传输能力。 </p>\n<p>下面的几个接口用在服务端进行证书及私钥加载过程：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**                                                                    </span><br><span class=\"hljs-comment\"> * 添加一个服务端/客户端自己的证书，可以多次调用本方法加载多个证书 </span><br><span class=\"hljs-comment\"> * @param crt_file &#123;const char*&#125; 证书文件全路径，非空 </span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 添加证书是否成功 </span><br><span class=\"hljs-comment\"> */</span>                                                                    <br> virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">add_cert</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* crt_file)</span>;<br><span class=\"hljs-comment\">/**                                                                    </span><br><span class=\"hljs-comment\"> * 添加服务端/客户端的密钥(每个配置实例只需调用一次本方法) </span><br><span class=\"hljs-comment\"> * @param key_file &#123;const char*&#125; 密钥文件全路径，非空</span><br><span class=\"hljs-comment\"> * @param key_pass &#123;const char*&#125; 密钥文件的密码，没有密钥密码可写 NULL</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 设置是否成功</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">set_key</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key_file, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key_pass = <span class=\"hljs-literal\">NULL</span>)</span>；<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当为服务端模式时是否启用会话缓存功能，有助于提高 SSL 握手效率</span><br><span class=\"hljs-comment\"> * @param on &#123;bool&#125; 是否在服务端启用会话缓存方式</span><br><span class=\"hljs-comment\"> * 注：该函数仅对服务端模式有效</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">enable_cache</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> on)</span>；<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2、sslbase-io-类\"><a href=\"#2-2、sslbase-io-类\" class=\"headerlink\" title=\"2.2、sslbase_io 类\"></a>2.2、sslbase_io 类</h3><p><code>acl::sslbase_io</code> 类对象与每一个 TCP 连接对象 <code>acl::socket_stream</code> 进行绑定，使 <code>acl::socket_stream</code> 具备了进行 SSL 安全传输的能力，在 <code>acl::sslbase_io</code>类中声明了纯虚方法<code>handshake</code>，这使之成为纯虚类；另外，<code>acl::sslbase_io</code> 虽然继承于<code>acl::stream_hook</code>类，但并没有实现 <code>acl::stream_hook</code> 中规定的四个纯虚方法：<code>open</code>，<code>on_close</code>，<code>read</code>，<code>send</code>，这几个虚方法也需要 <code>acl::sslbase_io</code>的子类来实现，目前<code>acl::sslbase_io</code>有两个子类<code>acl::polarssl_io</code>及<code>acl::mbedtls_io</code> 分别用来支持 Polarssl 及 MbedTLS。<br>下面是这几个纯虚方法的声明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * ssl 握手纯虚方法（属于 sslbase_io 类）</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示 SSL 握手成功，否则表示失败</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">handshake</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n<p>下面几个虚方法声明于 <code>acl::stream_hook</code> 类中：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 读数据接口</span><br><span class=\"hljs-comment\"> * @param buf &#123;void*&#125; 读缓冲区地址，读到的数据将存放在该缓冲区中</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125; buf 缓冲区大小</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 读到字节数，当返回值 &lt; 0 时表示出错</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">read</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* buf, <span class=\"hljs-type\">size_t</span> len)</span> = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 发送数据接口</span><br><span class=\"hljs-comment\"> * @param buf &#123;const void*&#125; 发送缓冲区地址</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125; buf 缓冲区中数据的长度(必须 &gt; 0) </span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 写入的数据长度，返回值 &lt;０　时表示出错</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">send</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* buf, <span class=\"hljs-type\">size_t</span> len)</span> = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在 stream/aio_stream 的 setup_hook 内部将会调用 stream_hook::open</span><br><span class=\"hljs-comment\"> * 过程，以便于子类对象用来初始化一些数据及会话</span><br><span class=\"hljs-comment\"> * @param s &#123;ACL_VSTREAM*&#125; 在 setup_hook 内部调用该方法将创建的流对象</span><br><span class=\"hljs-comment\"> *  作为参数传入</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 如果子类实例返回 false，则 setup_hook 调用失败且会恢复原样</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">open</span><span class=\"hljs-params\">(ACL_VSTREAM* s)</span> = <span class=\"hljs-number\">0</span>; <br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 stream/aio_stream 流对象关闭前将会回调该函数以便于子类实例做一些善后工作</span><br><span class=\"hljs-comment\"> * @param alive &#123;bool&#125; 该连接是否依然正常</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">on_close</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> alive)</span> &#123; (<span class=\"hljs-type\">void</span>) alive; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; &#125; <br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 stream/aio_stream 对象需要释放 stream_hook 子类对象时调用此方法</span><br><span class=\"hljs-comment\"> */</span><br>virtual <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">destroy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;&#125;<br></code></pre></td></tr></table></figure>\n<p>以上几个虚方法均可以在 <code>acl::polarssl_io</code> 及 <code>acl::mbedtls_io</code> 中看到被实现。</p>\n<h2 id=\"三、编程示例\"><a href=\"#三、编程示例\" class=\"headerlink\" title=\"三、编程示例\"></a>三、编程示例</h2><h3 id=\"2-1、服务器模式（使用-MbedTLS）\"><a href=\"#2-1、服务器模式（使用-MbedTLS）\" class=\"headerlink\" title=\"2.1、服务器模式（使用 MbedTLS）\"></a>2.1、服务器模式（使用 MbedTLS）</h3><p>首先给出一个完整的支持 SSL 的服务端例子，该例子使用了 MbedTLS 做为 SSL 库，如果想切换成 Polarssl 也非常简单，方法类似（该示例位置：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server%EF%BC%89%EF%BC%9A\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/server）：</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">echo_thread</span> :</span> public acl::thread &#123;<br>public:<br>        echo_thread(acl::sslbase_conf&amp; ssl_conf, acl::socket_stream* conn)<br>        : ssl_conf_(ssl_conf), conn_(conn) &#123;&#125;<br><br>private:<br>        acl::sslbase_conf&amp;  ssl_conf_;<br>        acl::socket_stream* conn_;<br><br>        ~echo_thread(<span class=\"hljs-type\">void</span>) &#123; delete conn_; &#125;<br><br>        <span class=\"hljs-comment\">// @override</span><br>        <span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>                conn_-&gt;set_rw_timeout(<span class=\"hljs-number\">60</span>);<br><br>                <span class=\"hljs-comment\">// 给 socket 安装 SSL IO 过程</span><br>                <span class=\"hljs-keyword\">if</span> (!setup_ssl()) &#123;<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>                &#125;<br><br>                do_echo();<br><br>                delete this;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>        &#125;<br><br>        <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">setup_ssl</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>                <span class=\"hljs-type\">bool</span> non_block = <span class=\"hljs-literal\">false</span>;<br>                acl::sslbase_io* ssl = ssl_conf_.open(non_block);<br><br>                <span class=\"hljs-comment\">// 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络</span><br>                <span class=\"hljs-comment\">// 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程</span><br>                <span class=\"hljs-keyword\">if</span> (conn_-&gt;setup_hook(ssl) == ssl) &#123;<br>                        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;setup ssl IO hook error!\\r\\n&quot;</span>);<br>                        ssl-&gt;destroy();<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>                &#125;<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        &#125;<br><br>        <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">do_echo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>                <span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">4096</span>];<br><br>                <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>                        <span class=\"hljs-type\">int</span> ret = conn_-&gt;read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>                        <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>                                <span class=\"hljs-keyword\">break</span>;<br>                        &#125;<br>                        <span class=\"hljs-keyword\">if</span> (conn_-&gt;write(buf, ret) == <span class=\"hljs-number\">-1</span>) &#123;<br>                                <span class=\"hljs-keyword\">break</span>;<br>                        &#125;<br>                &#125;<br>        &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">start_server</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> acl::<span class=\"hljs-built_in\">string</span> addr, acl::sslbase_conf&amp; ssl_conf)</span> &#123;<br>        acl::server_socket ss;<br>        <span class=\"hljs-keyword\">if</span> (!ss.open(addr)) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen %s error %s\\r\\n&quot;</span>, addr.c_str(), acl::last_serror());<br>                <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>                acl::socket_stream* conn = ss.accept();<br>                <span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>                        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept error %s\\r\\n&quot;</span>, acl::last_serror());<br>                        <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>                acl::thread* thr = new echo_thread(ssl_conf, conn);<br>                thr-&gt;set_detachable(<span class=\"hljs-literal\">true</span>);<br>                thr-&gt;start();<br>        &#125;<br>&#125;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">ssl_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> acl::<span class=\"hljs-built_in\">string</span>&amp; ssl_crt, <span class=\"hljs-type\">const</span> acl::<span class=\"hljs-built_in\">string</span>&amp; ssl_key,</span><br><span class=\"hljs-params\">        acl::mbedtls_conf&amp; ssl_conf)</span> &#123;<br><br>        ssl_conf.enable_cache(<span class=\"hljs-literal\">true</span>);<br><br>        <span class=\"hljs-comment\">// 加载 SSL 证书</span><br>        <span class=\"hljs-keyword\">if</span> (!ssl_conf.add_cert(ssl_crt)) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;add ssl crt=%s error\\r\\n&quot;</span>, ssl_crt.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 设置 SSL 证书私钥</span><br>        <span class=\"hljs-keyword\">if</span> (!ssl_conf.set_key(ssl_key)) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;set ssl key=%s error\\r\\n&quot;</span>, ssl_key.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* procname)</span> &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h [help]\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -s listen_addr\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -L ssl_libs_path\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -c ssl_crt\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -k ssl_key\\r\\n&quot;</span>, procname);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span> &#123;<br>        acl::<span class=\"hljs-built_in\">string</span> addr = <span class=\"hljs-string\">&quot;0.0.0.0|2443&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(__APPLE__)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_lib = <span class=\"hljs-string\">&quot;../libmbedtls_all.dylib&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined(__linux__)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_lib = <span class=\"hljs-string\">&quot;../libmbedtls_all.so&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined(_WIN32) || defined(_WIN64)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_path = <span class=\"hljs-string\">&quot;../mbedtls.dll&quot;</span>;<br><br>        acl::acl_cpp_init();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">error</span> <span class=\"hljs-string\">&quot;unknown OS type&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_crt = <span class=\"hljs-string\">&quot;../ssl_crt.pem&quot;</span>, ssl_key = <span class=\"hljs-string\">&quot;../ssl_key.pem&quot;</span>;<br><br>        <span class=\"hljs-type\">int</span> ch;<br>        <span class=\"hljs-keyword\">while</span> ((ch = getopt(argc, argv, <span class=\"hljs-string\">&quot;hs:L:c:k:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>                <span class=\"hljs-keyword\">switch</span> (ch) &#123;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>                        usage(argv[<span class=\"hljs-number\">0</span>]);<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;s&#x27;</span>:<br>                        addr = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;L&#x27;</span>:<br>                        ssl_lib = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;c&#x27;</span>:<br>                        ssl_crt = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;k&#x27;</span>:<br>                        ssl_key = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">default</span>:<br>                        <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>        &#125;<br><br>        acl::<span class=\"hljs-built_in\">log</span>::stdout_open(<span class=\"hljs-literal\">true</span>);<br>        <br>        <span class=\"hljs-comment\">// 设置 MbedTLS 动态库路径</span><br>        <span class=\"hljs-type\">const</span> <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::<span class=\"hljs-built_in\">string</span>&gt;&amp; libs = ssl_lib.split2(<span class=\"hljs-string\">&quot;,; \\t&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span> (libs.size() == <span class=\"hljs-number\">1</span>) &#123;<br>                acl::mbedtls_conf::set_libpath(libs[<span class=\"hljs-number\">0</span>]);<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (libs.size() == <span class=\"hljs-number\">3</span>) &#123;<br>                <span class=\"hljs-comment\">// libcrypto, libx509, libssl);</span><br>                acl::mbedtls_conf::set_libpath(libs[<span class=\"hljs-number\">0</span>], libs[<span class=\"hljs-number\">1</span>], libs[<span class=\"hljs-number\">2</span>]);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;invalid ssl_lib=%s\\r\\n&quot;</span>, ssl_lib.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 加载 MbedTLS 动态库</span><br>        <span class=\"hljs-keyword\">if</span> (!acl::mbedtls_conf::load()) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;load %s error\\r\\n&quot;</span>, ssl_lib.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 初始化服务端模式下的全局 SSL 配置对象</span><br>        <span class=\"hljs-type\">bool</span> server_side = <span class=\"hljs-literal\">true</span>;<br><br>        <span class=\"hljs-comment\">// SSL 证书校验级别</span><br>        acl::<span class=\"hljs-type\">mbedtls_verify_t</span> verify_mode = acl::MBEDTLS_VERIFY_NONE;<br><br>        acl::mbedtls_conf <span class=\"hljs-title function_\">ssl_conf</span><span class=\"hljs-params\">(server_side, verify_mode)</span>;<br><br>        <span class=\"hljs-keyword\">if</span> (!ssl_init(ssl_crt, ssl_key, ssl_conf)) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ssl_init failed\\r\\n&quot;</span>);<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br>        <br>        start_server(addr, ssl_conf);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>关于该示例有以下几点说明：</p>\n<ul>\n<li>该服务端例子使用了 MbedTLS 库；</li>\n<li>采用了动态加载 MbedTLS 动态库的方式；</li>\n<li>动态加载时需要设置 MbedTLS 动态库的路径，然后再加载，但在设置动态库的路径时却有两种方式，之所以有两种设置 MbedTLS 动态库路径的方法，主要是因为原来的 Polarssl 只生成一个库，而到 MbedTLS 后却生成了三个库：libmbedcrypto，libmbedx509 和 libmbedtls，其中的依赖关系是 libmbedx509 依赖于 libmbedcrypto，libmbedtls 依赖于 libmbedx509 和 libmbedcrypto；但在 Windows 平台上，官方却只提供了生成一个库（将这三个库合并）的工程；因此，在 acl::mbedtls_conf 中在加载动态库时，提供两种方式，一个接口是用来设置三个库的位置并加载，另一个接口用来设置一个统一库的位置度加载；</li>\n<li>该例子大体处理流程：<ul>\n<li>通过 <code>acl::mbedtls_conf::set_libpath</code> 方法设置 MbedTLS 的三个动态库或一个统一的动态库，然后调用 <code>acl::mbedtls_conf::load</code> 加载动态库；</li>\n<li>在 <code>ssl_init</code> 函数中，调用基类 <code>acl::sslbase_conf</code> 中的虚方法 <code>add_cert</code> 及 <code>set_key</code> 分别用来加载 SSL 数字证书及证书私钥；</li>\n<li>在 <code>start_server</code> 函数中，监听本地服务地址，每接收一个 TCP 连接（对应一个 <code>acl::socket_stream</code> 对象）便启动一个线程进行 echo 过程；</li>\n<li>在客户端处理线程中，调用 <code>echo_thread::setup_ssl</code> 方法给该 <code>acl::socket_stream</code> TCP 流对象绑定一个 SSL IO 对象，即：先通过调用 <code>acl::mbedtls_conf::open</code> 方法创建一个 <code>acl::mbedtls_io</code> SSL IO 对象，然后通过 <code>acl::socket_stream</code> 的基类中的方法 <code>set_hook</code> 将该 SSL IO 对象与 TCP 流对象进行绑定并完成 SSL 握手过程；</li>\n<li>SSL 握手成功后进入到 <code>echo_thread::do_echo</code> 函数中进行简单的 SSL 安全 echo 过程。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"2-2、客户端模式（使用-MbedTLS）\"><a href=\"#2-2、客户端模式（使用-MbedTLS）\" class=\"headerlink\" title=\"2.2、客户端模式（使用 MbedTLS）\"></a>2.2、客户端模式（使用 MbedTLS）</h3><p>在熟悉了上面的 SSL 服务端编程后，下面给出使用 SSL 进行客户端编程的示例（该示例位置：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client%EF%BC%89%EF%BC%9A\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/client）：</a></p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">echo_thread</span> :</span> public acl::thread &#123;<br>public:<br>        echo_thread(acl::sslbase_conf&amp; ssl_conf, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">int</span> count)<br>        : ssl_conf_(ssl_conf), addr_(addr), count_(count) &#123;&#125;<br><br>        ~echo_thread(<span class=\"hljs-type\">void</span>) &#123;&#125;<br><br>private:<br>        acl::sslbase_conf&amp;  ssl_conf_;<br>        acl::<span class=\"hljs-built_in\">string</span> addr_;<br>        <span class=\"hljs-type\">int</span> count_;<br><br>private:<br>        <span class=\"hljs-comment\">// @override</span><br>        <span class=\"hljs-type\">void</span>* <span class=\"hljs-title function_\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>                acl::socket_stream conn;<br>                conn.set_rw_timeout(<span class=\"hljs-number\">60</span>);<br>                <span class=\"hljs-keyword\">if</span> (!conn.open(addr_, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">10</span>)) &#123;<br>                        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;connect %s error %s\\r\\n&quot;</span>,<br>                                addr_.c_str(), acl::last_serror());<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>                &#125;<br><br>                <span class=\"hljs-comment\">// 给 socket 安装 SSL IO 过程</span><br>                <span class=\"hljs-keyword\">if</span> (!setup_ssl(conn)) &#123;<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>                &#125;<br><br>                do_echo(conn);<br><br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>        &#125;<br>        <span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">setup_ssl</span><span class=\"hljs-params\">(acl::socket_stream&amp; conn)</span> &#123;<br>                <span class=\"hljs-type\">bool</span> non_block = <span class=\"hljs-literal\">false</span>;<br>                acl::sslbase_io* ssl = ssl_conf_.open(non_block);<br><br>                <span class=\"hljs-comment\">// 对于使用 SSL 方式的流对象，需要将 SSL IO 流对象注册至网络</span><br>                <span class=\"hljs-comment\">// 连接流对象中，即用 ssl io 替换 stream 中默认的底层 IO 过程</span><br>                <span class=\"hljs-keyword\">if</span> (conn.setup_hook(ssl) == ssl) &#123;<br>                        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;setup ssl IO hook error!\\r\\n&quot;</span>);<br>                        ssl-&gt;destroy();<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>                &#125;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ssl setup ok!\\r\\n&quot;</span>);<br><br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        &#125;<br><br>        <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">do_echo</span><span class=\"hljs-params\">(acl::socket_stream&amp; conn)</span> &#123;<br>                <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* data = <span class=\"hljs-string\">&quot;hello world!\\r\\n&quot;</span>;<br>                <span class=\"hljs-type\">int</span> i;<br>                <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; count_; i++) &#123;<br>                        <span class=\"hljs-keyword\">if</span> (conn.write(data, <span class=\"hljs-built_in\">strlen</span>(data)) == <span class=\"hljs-number\">-1</span>) &#123;<br>                                <span class=\"hljs-keyword\">break</span>;<br>                        &#125;<br><br>                        <span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">4096</span>];<br>                        <span class=\"hljs-type\">int</span> ret = conn.read(buf, <span class=\"hljs-keyword\">sizeof</span>(buf) - <span class=\"hljs-number\">1</span>, <span class=\"hljs-literal\">false</span>);<br>                        <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>                                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;read over, count=%d\\r\\n&quot;</span>, i + <span class=\"hljs-number\">1</span>);<br>                                <span class=\"hljs-keyword\">break</span>;<br>                        &#125;<br>                        buf[ret] = <span class=\"hljs-number\">0</span>;<br>                        <span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">0</span>) &#123;<br>                                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;read: %s&quot;</span>, buf);<br>                        &#125;<br>                &#125;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;thread-%lu: count=%d\\n&quot;</span>, acl::thread::self(), i);<br>        &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">start_clients</span><span class=\"hljs-params\">(acl::sslbase_conf&amp; ssl_conf, <span class=\"hljs-type\">const</span> acl::<span class=\"hljs-built_in\">string</span> addr,</span><br><span class=\"hljs-params\">        <span class=\"hljs-type\">int</span> cocurrent, <span class=\"hljs-type\">int</span> count)</span> &#123;<br><br>        <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt; threads;<br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; cocurrent; i++) &#123;<br>                acl::thread* thr = new echo_thread(ssl_conf, addr, count);<br>                threads.push_back(thr);<br>                thr-&gt;start();<br>        &#125;<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::thread*&gt;::iterator it = threads.begin();<br>                it != threads.end(); ++it) &#123;<br>                (*it)-&gt;wait(<span class=\"hljs-literal\">NULL</span>);<br>                delete *it;<br>        &#125;<br>&#125;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* procname)</span> &#123;<br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h [help]\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -s listen_addr\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -L ssl_libs_path\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -c cocurrent\\r\\n&quot;</span><br>                <span class=\"hljs-string\">&quot; -n count\\r\\n&quot;</span>, procname);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span> &#123;<br>        acl::<span class=\"hljs-built_in\">string</span> addr = <span class=\"hljs-string\">&quot;0.0.0.0|2443&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">if</span> defined(__APPLE__)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_lib = <span class=\"hljs-string\">&quot;../libmbedtls_all.dylib&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined(__linux__)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_lib = <span class=\"hljs-string\">&quot;../libmbedtls_all.so&quot;</span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">elif</span> defined(_WIN32) || defined(_WIN64)</span><br>        acl::<span class=\"hljs-built_in\">string</span> ssl_path = <span class=\"hljs-string\">&quot;../mbedtls.dll&quot;</span>;<br><br>        acl::acl_cpp_init();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">error</span> <span class=\"hljs-string\">&quot;unknown OS type&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>        <span class=\"hljs-type\">int</span> ch, cocurrent = <span class=\"hljs-number\">10</span>, count = <span class=\"hljs-number\">10</span>;<br>        <span class=\"hljs-keyword\">while</span> ((ch = getopt(argc, argv, <span class=\"hljs-string\">&quot;hs:L:c:n:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>                <span class=\"hljs-keyword\">switch</span> (ch) &#123;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>                        usage(argv[<span class=\"hljs-number\">0</span>]);<br>                        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;s&#x27;</span>:<br>                        addr = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;L&#x27;</span>:<br>                        ssl_lib = optarg;<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;c&#x27;</span>:<br>                        cocurrent = atoi(optarg);<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;n&#x27;</span>:<br>                        count = atoi(optarg);<br>                        <span class=\"hljs-keyword\">break</span>;<br>                <span class=\"hljs-keyword\">default</span>:<br>                        <span class=\"hljs-keyword\">break</span>;<br>                &#125;<br>        &#125;<br><br>        acl::<span class=\"hljs-built_in\">log</span>::stdout_open(<span class=\"hljs-literal\">true</span>);<br><br>        <span class=\"hljs-comment\">// 设置 MbedTLS 动态库路径</span><br>        <span class=\"hljs-type\">const</span> <span class=\"hljs-built_in\">std</span>::<span class=\"hljs-built_in\">vector</span>&lt;acl::<span class=\"hljs-built_in\">string</span>&gt;&amp; libs = ssl_lib.split2(<span class=\"hljs-string\">&quot;,; \\t&quot;</span>);<br>        <span class=\"hljs-keyword\">if</span> (libs.size() == <span class=\"hljs-number\">1</span>) &#123;<br>                acl::mbedtls_conf::set_libpath(libs[<span class=\"hljs-number\">0</span>]);<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (libs.size() == <span class=\"hljs-number\">3</span>) &#123;<br>                <span class=\"hljs-comment\">// libcrypto, libx509, libssl);</span><br>                acl::mbedtls_conf::set_libpath(libs[<span class=\"hljs-number\">0</span>], libs[<span class=\"hljs-number\">1</span>], libs[<span class=\"hljs-number\">2</span>]);<br>        &#125; <span class=\"hljs-keyword\">else</span> &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;invalid ssl_lib=%s\\r\\n&quot;</span>, ssl_lib.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 加载 MbedTLS 动态库</span><br>        <span class=\"hljs-keyword\">if</span> (!acl::mbedtls_conf::load()) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;load %s error\\r\\n&quot;</span>, ssl_lib.c_str());<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">1</span>;<br>        &#125;<br><br>        <span class=\"hljs-comment\">// 初始化客户端模式下的全局 SSL 配置对象</span><br>        <span class=\"hljs-type\">bool</span> server_side = <span class=\"hljs-literal\">false</span>;<br><br>        <span class=\"hljs-comment\">// SSL 证书校验级别</span><br>        acl::<span class=\"hljs-type\">mbedtls_verify_t</span> verify_mode = acl::MBEDTLS_VERIFY_NONE;<br>        acl::mbedtls_conf <span class=\"hljs-title function_\">ssl_conf</span><span class=\"hljs-params\">(server_side, verify_mode)</span>;<br>        start_clients(ssl_conf, addr, cocurrent, count);<br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在客户方式下使用 SSL 时的方法与服务端时相似，不同之处是在客户端下使用 SSL 时不必加载证书和设置私钥。</p>\n<h3 id=\"2-3、非阻塞模式\"><a href=\"#2-3、非阻塞模式\" class=\"headerlink\" title=\"2.3、非阻塞模式\"></a>2.3、非阻塞模式</h3><p>在使用 SSL 进行非阻塞编程时，动态库的加载、证书的加载及设置私钥过程与阻塞式 SSL 编程方法相同，不同之处在于创建 SSL IO 对象时需要设置为非阻塞方式，另外在 SSL 握手阶段需要不断检测 SSL 握手是否成功，下面只给出相关不同之处，完整示例可以参考：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_server%EF%BC%8Chttps://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_client%EF%BC%89%EF%BC%9A\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_server，https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/ssl/aio_client）：</a></p>\n<ul>\n<li>调用 <code>acl::sslbase_conf</code> 中的虚方法 <code>open</code> 时传入的参数为 <code>true</code> 表明所创建的 SSL IO 对象为非阻塞方式；</li>\n<li>在创建非阻塞 IO 对象后，需要调用 <code>acl::aio_socket_stream</code> 中的 <code>read_wait</code> 方法，以便可以触发 <code>acl::aio_istream::read_wakeup</code> 回调，从而在该回调里完成 SSL 握手过程；</li>\n<li>在非阻塞IO的读回调里需要调用 <code>acl::sslbase_io</code> 中的虚方法 <code>handshake</code> 尝试进行 SSL 握手并通过 <code>handshake_ok</code> 检测握手是否成功。<br>下面给出在 <code>read_wakeup</code> 回调里进行 SSL 握手的过程：<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title function_\">read_wakeup</span><span class=\"hljs-params\">()</span><br>&#123;<br>        acl::sslbase_io* hook = (acl::sslbase_io*) client_-&gt;get_hook();<br>        <span class=\"hljs-keyword\">if</span> (hook == <span class=\"hljs-literal\">NULL</span>) &#123; <br>                <span class=\"hljs-comment\">// 非 SSL 模式，异步读取数据</span><br>                <span class=\"hljs-comment\">//client_-&gt;read(__timeout);</span><br>                client_-&gt;gets(__timeout, <span class=\"hljs-literal\">false</span>); <br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        &#125;       <br><br>        <span class=\"hljs-comment\">// 尝试进行 SSL 握手</span><br>        <span class=\"hljs-keyword\">if</span> (!hook-&gt;handshake()) &#123;<br>                <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;ssl handshake failed\\r\\n&quot;</span>);<br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>        &#125;       <br><br>        <span class=\"hljs-comment\">// 如果 SSL 握手已经成功，则开始按行读数据</span><br>        <span class=\"hljs-keyword\">if</span> (hook-&gt;handshake_ok()) &#123;<br>                <span class=\"hljs-comment\">// 由 reactor 模式转为 proactor 模式，从而取消</span><br>                <span class=\"hljs-comment\">// read_wakeup 回调过程</span><br>                client_-&gt;disable_read();<br><br>                <span class=\"hljs-comment\">// 异步读取数据，将会回调 read_callback</span><br>                <span class=\"hljs-comment\">//client_-&gt;read(__timeout);</span><br>                client_-&gt;gets(__timeout, <span class=\"hljs-literal\">false</span>); <br>                <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>        &#125;       <br><br>        <span class=\"hljs-comment\">// SSL 握手还未完成，等待本函数再次被触发</span><br>        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n在该代码片断中，如果 SSL 握手一直处于进行中，则 <code>read_wakeup</code> 可能会被调用多次，这就意味着 <code>handshake</code> 握手过程也会被调用多次，然后再通过 <code>handshake_ok</code> 判断握手是否已经成功，如果成果，则通过调用 <code>gets</code> 方法切换到 IO 过程（该 IO 过程对应的回调为 <code>read_callback</code>），否则进行 SSL 握手过程（继续等待 <code>read_wakeup</code> 被回调）。</li>\n</ul>\n"},{"title":"编译使用Acl协程库","date":"2019-03-23T05:08:24.000Z","_content":"\n## 一、概述\n在《使用 acl 协程编写高并发网络服务》和《使用协程方式编写高并发的 WEB 服务》两篇文章中介绍了如何使用 acl 的协程功能编写高并发服务器程序，本文主要介绍如何编译使用 acl 的网络协程库。\n\n## 二、 acl 协程库的依赖关系\n目前 acl 协程主要分为 C 库（lib_fiber.a，在 acl/lib_fiber/c 目录下）和 C++库（libfiber_cpp.a，在 acl/lib_fiber/cpp 目录下），其中 lib_fiber_cpp.a 依赖 libfiber.a，具体的依赖关系如下：\n![协程库依赖](/img/fiber_depedence.png)\n\nlibfiber.a 目前是独立的库，libfiber_cpp.a 依赖 libfiber.a 和 lib_acl_cpp.a，lib_acl_cpp.a 依赖 lib_protocol.a 和 lib_acl.a，lib_protocol.a 依赖 lib_acl.a。\n\n其中，lib_acl.a 为 acl 中的核心基础 C 库，lib_protocol.a 为 acl 中的网络协议（http/icmp/smtp）基础 C 库，lib_acl_cpp 为 C++库，依赖上述两个 C 库；libfiber.a 为独立的网络协程库，仅依赖于系统库，libfiber_cpp.a 为封装了 libfiber.a 的 C++ 库，如果用户所用的 GCC 支持 C++11，则该库还支持更为简洁的创建协程的方式（借助于 C++11中的 lambda 表达式方式）。\n\n## 三、一个简单的例子\n下面是一个简单的使用 acl 协程的例子：\n\n```c\n#include \"lib_acl.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"fiber/lib_fiber.h\"\n\nstatic int __max_loop = 100;\nstatic int __max_fiber = 10;\nstatic int __stack_size = 64000;\n\n/* 协程处理入口函数 */\nstatic void fiber_main(ACL_FIBER *fiber, void *ctx acl_unused)\n{\n    int  i;\n\n    /* 两种方式均可以获得当前的协程号 */\n    assert(acl_fiber_self() == acl_fiber_id(fiber));\n\n    for (i = 0; i < __max_loop; i++) {\n        acl_fiber_yield();  /* 主动让出 CPU 给其它协程 */\n        printf(\"fiber-%d\\r\\n\", acl_fiber_self());\n    }\n}\n\nint main(void)\n{\n    int   ch, i;\n\n    /* 创建协程 */\n    for (i = 0; i < __max_fiber; i++) {\n        acl_fiber_create(fiber_main, NULL, __stack_size);\n    }\n\n    printf(\"---- begin schedule fibers now ----\\r\\n\");\n    acl_fiber_schedule(); /* 循环调度所有协程，直至所有协程退出 */\n    printf(\"---- all fibers exit ----\\r\\n\");\n    return 0;\n}\n```\n\n上述例子非常简单，说明了 acl 协程创建、启动和运行过程，如果仅此而已，当然使用协程并没有什么卵用，协程的关键价值在于与网络通信的结合，可以达到高并发、高性能的目的。因此，现实中协程的应用范围主要还是网络服务方面，更为准确的叫法应该是“网络协程”，脱离了“网络”协程基本没啥价值。本文的开头给出了两个链接，指明了网络协程的应用场景及实例。\n\n## 四、编译例子\n下面的 Makefile 文件说明了最简单的编译方式：\n\n```\nfiber: main.o\n        gcc -o fiber main.o -L./lib_fiber/lib -L./lib_acl/lib -l_acl  -lfiber -lpthread -ldl\nmain.o: main.c\n        gcc -c main.c -O3 -DLINUX2 -I./lib_fiber/c/include -I./lib_acl/include\n```\n该 Makefile 也非常简单，也仅是说明了使用 acl 网络协程库时的编译条件。其中，l_fiber 指定了 acl 的网络协程库，l_acl 指定了 acl 基础库，-lpthread 及 -ldl 指定所依赖的系统库；-DLINUX2 指定 LINUX 平台的编译条件，-I 指定头文件所在位置。\n\n## 五、C++ 示例\n上面的例子展示了使用 acl C 协程库的使用方法，同时 acl 也提供了 C++ 类封装，方便 C++ 程序员编写协程应用，下面的例子为使用标准 C++ 编写的协程示例：\n\n```c++\n#include <assert.h>\n#include <iostream>\n#include \"acl_cpp/lib_acl.hpp\"\n#include \"fiber/lib_fiber.hpp\"\n\nclass myfiber : public acl::fiber\n{\npublic:\n    myfiber(int max_loop) : max_loop_(max_loop) {}\n\nprotected:\n    // @override 实现基类纯虚函数\n    void run(void)\n    {\n        // 两种方式均可以获得当前的协程号\n        assert(get_id() == acl::fiber::self());\n\n        for (int i = 0; i < max_loop_; i++) {\n            acl::fiber::yield(); // 主动让出 CPU 给其它协程\n            std::cout << \"fiber-\" << acl::fiber::self() << std::endl;\n        }\n\n        delete this; // 因为是动态创建的，所以需自动销毁\n    }\n\nprivate:\n    int max_loop_;\n\n    ~myfiber(void) {}\n};\n\nint main(void)\n{\n    int i, max_fiber = 10, max_loop = 10;\n\n    for (i = 0; i < max_fiber; i++) {\n        acl::fiber* fb = new myfiber(max_loop); // 创建协程\n        fb->start(); // 启动协程\n    }\n\n    std::cout << \"---- begin schedule fibers now ----\" << std::endl;\n    acl::fiber::schedule(); // 循环调度所有协程，直至所有协程退出\n    std::cout << \"---- all fibers exit ----\" << std::endl;\n\n    return 0;\n}\n```\n\n该例子也非常简单，实现了与上面 C 示例相同的功能，只是采用 C++ 而已。用户首先需要定义自己的类，其继承于 acl::fiber 协程类，然后实现协程类中的纯虚方法：run()，当调用协程的启动方法 start() 时，acl::fiber 基类会自动回调纯虚方法  run()。\n\n该 C++ 示例的 Makefile 与 C 的有所不同，内容如下：\n\n```\nfiber: main.o\n        g++ -o fiber main.o -L./lib_fiber/lib -lfiber_cpp \\\n                -L./lib_acl_cpp/lib -l_acl_cpp \\\n                -L./lib_acl/lib -l_acl -lfiber \\\n                -lpthread -ldl\nmain.o: main.cpp\n        g++ -O3 -Wall -c main.cpp -DLINUX2 -I./lib_fiber/cpp/include \\\n                -I./lib_acl_cpp/include\n```\n\n## 六、C++11 示例\nacl 的协程库同时提供了支持 C++11 方式的调用方法，使创建协程更加方便，代码如下：\n\n```c++\n#include <iostream>\n#include \"acl_cpp/lib_acl.hpp\"\n#include \"fiber/lib_fiber.hpp\"\n\nstatic void fiber_main(int max_loop)\n{\n    for (int i = 0; i < max_loop; i++) {\n        acl::fiber::yield(); // 主动让出 CPU 给其它协程\n        std::cout << \"fiber-\" << acl::fiber::self() << std::endl;\n    }\n}\n\nint main(void)\n{\n    int i, max_fiber = 10, max_loop = 10;\n\n    for (i = 0; i < max_fiber; i++) {\n        go[=] { // 采用 c++11 的 lambad 表达式方式创建协程\n            fiber_main(max_loop); // 进入协程处理函数\n        };\n    }\n\n    std::cout << \"---- begin schedule fibers now ----\" << std::endl;\n    // 循环调度所有协程，直至所有协程退出\n    acl::fiber::schedule();\n    std::cout << \"---- all fibers exit ----\" << std::endl;\n\n    return 0;\n}\n```\n\n使用 C++11 方式创建协程是不是感觉更加简洁？\n\n同样下面给出 makefile 内容：\n\n```\nfiber: main.o\n        g++ -o fiber main.o -L../../../lib -lfiber_cpp \\\n                -L../../../../lib_acl_cpp/lib -l_acl_cpp \\\n                -L../../../../lib_acl/lib -l_acl  -lfiber \\\n                -lpthread -ldl\nmain.o: main.cpp\n        g++ -std=c++11 -O3 -Wall -c main.cpp -DLINUX2 -I.. -I../../../cpp/include \\\n                -I../../../../lib_acl_cpp/include\n```\n\n## 七、基于协程的网络服务\n前面提到了“如果协程不与网络应用结合，则不会发挥其价值“，因此，下面就给出一个具体的基于协程的网络服务器程序：\n\n```c++\n#include <iostream>\n#include \"acl_cpp/lib_acl.hpp\"\n#include \"fiber/lib_fiber.hpp\"\n\nclass fiber_client : public acl::fiber\n{\npublic:\n    fiber_client(acl::socket_stream* conn) : conn_(conn) {}\n\nprotected:\n    // @override 实现基类纯虚函数\n    void run(void)\n    {\n        std::cout << \"fiber-\" << acl::fiber::self()\n            << \": fd=\" << conn_->sock_handle()\n            << \", addr=\" << conn_->get_peer() << std::endl;\n        echo();\n        delete this; // 因为是动态创建的，所以需自动销毁\n    }\n\nprivate:\n    acl::socket_stream* conn_;\n\n    ~fiber_client(void)\n    {\n        delete conn_;\n    }\n\n    void echo(void)\n    {\n        char buf[8192];\n\n        // 从客户端读取数据并回显\n        while (!conn_->eof()) {\n            int ret = conn_->read(buf, sizeof(buf), false);\n            if (ret == -1) {\n                std::cout << \"read \" << acl::last_serror() << std::endl;\n                break;\n            }\n            if (conn_->write(buf, ret) == -1) {\n                std::cout << \"write \" << acl::last_serror() << std::endl;\n                break;\n            }\n        }\n    }\n};\n\nclass fiber_server : public acl::fiber\n{\npublic:\n    fiber_server(const char* addr) : addr_(addr) {}\n\nprotected:\n    // @override\n    void run(void)\n    {\n        // 监听服务地址\n        acl::server_socket ss;\n        if (ss.open(addr_) == false) {\n            std::cout << \"listen \" << addr_.c_str() << \" error\" << std::endl;\n            delete this;\n            return;\n        }\n\n        std::cout << \"listen \" << addr_.c_str() << \" ok\" << std::endl;\n\n        while (true) {\n            // 等待接收客户端连接\n            acl::socket_stream* conn = ss.accept();\n            if (conn == NULL) {\n                std::cout << \"accept error\" << std::endl;\n                break;\n            }\n\n            // 创建客户端处理协程\n            acl::fiber* fb = new fiber_client(conn);\n            fb->start();\n        }\n\n        delete this;\n    }\n\nprivate:\n    acl::string addr_;\n\n    ~fiber_server(void) {}\n};\n\nint main(void)\n{\n    const char* addr = \"127.0.0.1:8089\";\n\n    acl::fiber* fb = new fiber_server(addr); // 创建监听服务协程\n    fb->start(); // 启动监听协程\n\n    // 循环调度所有协程，直至所有协程退出\n    acl::fiber::schedule();\n\n    return 0;\n}\n```\n\n麻雀虽小，五脏俱全，该示例简明扼要地说明了如何使用 acl 的网络协程库编写支持高并发的网络服务应用。\n\n## 八、参考\n在 acl/lib_fiber/samples/ 目录下，还有大量的使用 acl 协程的例子，包括：定时器、简单聊天服务、mysql 访问协程化、redis 访问协程化、域名解析协程化等。\n\ngithub：https://github.com/acl-dev/acl\ngitee: http://git.oschina.net/acl-dev/acl\n","source":"_posts/build_use_fiber.md","raw":"---\ntitle: 编译使用Acl协程库\ndate: 2019-03-23 13:08:24\ntags: 协程编程\ncategories: 协程编程\n---\n\n## 一、概述\n在《使用 acl 协程编写高并发网络服务》和《使用协程方式编写高并发的 WEB 服务》两篇文章中介绍了如何使用 acl 的协程功能编写高并发服务器程序，本文主要介绍如何编译使用 acl 的网络协程库。\n\n## 二、 acl 协程库的依赖关系\n目前 acl 协程主要分为 C 库（lib_fiber.a，在 acl/lib_fiber/c 目录下）和 C++库（libfiber_cpp.a，在 acl/lib_fiber/cpp 目录下），其中 lib_fiber_cpp.a 依赖 libfiber.a，具体的依赖关系如下：\n![协程库依赖](/img/fiber_depedence.png)\n\nlibfiber.a 目前是独立的库，libfiber_cpp.a 依赖 libfiber.a 和 lib_acl_cpp.a，lib_acl_cpp.a 依赖 lib_protocol.a 和 lib_acl.a，lib_protocol.a 依赖 lib_acl.a。\n\n其中，lib_acl.a 为 acl 中的核心基础 C 库，lib_protocol.a 为 acl 中的网络协议（http/icmp/smtp）基础 C 库，lib_acl_cpp 为 C++库，依赖上述两个 C 库；libfiber.a 为独立的网络协程库，仅依赖于系统库，libfiber_cpp.a 为封装了 libfiber.a 的 C++ 库，如果用户所用的 GCC 支持 C++11，则该库还支持更为简洁的创建协程的方式（借助于 C++11中的 lambda 表达式方式）。\n\n## 三、一个简单的例子\n下面是一个简单的使用 acl 协程的例子：\n\n```c\n#include \"lib_acl.h\"\n#include <stdio.h>\n#include <stdlib.h>\n#include \"fiber/lib_fiber.h\"\n\nstatic int __max_loop = 100;\nstatic int __max_fiber = 10;\nstatic int __stack_size = 64000;\n\n/* 协程处理入口函数 */\nstatic void fiber_main(ACL_FIBER *fiber, void *ctx acl_unused)\n{\n    int  i;\n\n    /* 两种方式均可以获得当前的协程号 */\n    assert(acl_fiber_self() == acl_fiber_id(fiber));\n\n    for (i = 0; i < __max_loop; i++) {\n        acl_fiber_yield();  /* 主动让出 CPU 给其它协程 */\n        printf(\"fiber-%d\\r\\n\", acl_fiber_self());\n    }\n}\n\nint main(void)\n{\n    int   ch, i;\n\n    /* 创建协程 */\n    for (i = 0; i < __max_fiber; i++) {\n        acl_fiber_create(fiber_main, NULL, __stack_size);\n    }\n\n    printf(\"---- begin schedule fibers now ----\\r\\n\");\n    acl_fiber_schedule(); /* 循环调度所有协程，直至所有协程退出 */\n    printf(\"---- all fibers exit ----\\r\\n\");\n    return 0;\n}\n```\n\n上述例子非常简单，说明了 acl 协程创建、启动和运行过程，如果仅此而已，当然使用协程并没有什么卵用，协程的关键价值在于与网络通信的结合，可以达到高并发、高性能的目的。因此，现实中协程的应用范围主要还是网络服务方面，更为准确的叫法应该是“网络协程”，脱离了“网络”协程基本没啥价值。本文的开头给出了两个链接，指明了网络协程的应用场景及实例。\n\n## 四、编译例子\n下面的 Makefile 文件说明了最简单的编译方式：\n\n```\nfiber: main.o\n        gcc -o fiber main.o -L./lib_fiber/lib -L./lib_acl/lib -l_acl  -lfiber -lpthread -ldl\nmain.o: main.c\n        gcc -c main.c -O3 -DLINUX2 -I./lib_fiber/c/include -I./lib_acl/include\n```\n该 Makefile 也非常简单，也仅是说明了使用 acl 网络协程库时的编译条件。其中，l_fiber 指定了 acl 的网络协程库，l_acl 指定了 acl 基础库，-lpthread 及 -ldl 指定所依赖的系统库；-DLINUX2 指定 LINUX 平台的编译条件，-I 指定头文件所在位置。\n\n## 五、C++ 示例\n上面的例子展示了使用 acl C 协程库的使用方法，同时 acl 也提供了 C++ 类封装，方便 C++ 程序员编写协程应用，下面的例子为使用标准 C++ 编写的协程示例：\n\n```c++\n#include <assert.h>\n#include <iostream>\n#include \"acl_cpp/lib_acl.hpp\"\n#include \"fiber/lib_fiber.hpp\"\n\nclass myfiber : public acl::fiber\n{\npublic:\n    myfiber(int max_loop) : max_loop_(max_loop) {}\n\nprotected:\n    // @override 实现基类纯虚函数\n    void run(void)\n    {\n        // 两种方式均可以获得当前的协程号\n        assert(get_id() == acl::fiber::self());\n\n        for (int i = 0; i < max_loop_; i++) {\n            acl::fiber::yield(); // 主动让出 CPU 给其它协程\n            std::cout << \"fiber-\" << acl::fiber::self() << std::endl;\n        }\n\n        delete this; // 因为是动态创建的，所以需自动销毁\n    }\n\nprivate:\n    int max_loop_;\n\n    ~myfiber(void) {}\n};\n\nint main(void)\n{\n    int i, max_fiber = 10, max_loop = 10;\n\n    for (i = 0; i < max_fiber; i++) {\n        acl::fiber* fb = new myfiber(max_loop); // 创建协程\n        fb->start(); // 启动协程\n    }\n\n    std::cout << \"---- begin schedule fibers now ----\" << std::endl;\n    acl::fiber::schedule(); // 循环调度所有协程，直至所有协程退出\n    std::cout << \"---- all fibers exit ----\" << std::endl;\n\n    return 0;\n}\n```\n\n该例子也非常简单，实现了与上面 C 示例相同的功能，只是采用 C++ 而已。用户首先需要定义自己的类，其继承于 acl::fiber 协程类，然后实现协程类中的纯虚方法：run()，当调用协程的启动方法 start() 时，acl::fiber 基类会自动回调纯虚方法  run()。\n\n该 C++ 示例的 Makefile 与 C 的有所不同，内容如下：\n\n```\nfiber: main.o\n        g++ -o fiber main.o -L./lib_fiber/lib -lfiber_cpp \\\n                -L./lib_acl_cpp/lib -l_acl_cpp \\\n                -L./lib_acl/lib -l_acl -lfiber \\\n                -lpthread -ldl\nmain.o: main.cpp\n        g++ -O3 -Wall -c main.cpp -DLINUX2 -I./lib_fiber/cpp/include \\\n                -I./lib_acl_cpp/include\n```\n\n## 六、C++11 示例\nacl 的协程库同时提供了支持 C++11 方式的调用方法，使创建协程更加方便，代码如下：\n\n```c++\n#include <iostream>\n#include \"acl_cpp/lib_acl.hpp\"\n#include \"fiber/lib_fiber.hpp\"\n\nstatic void fiber_main(int max_loop)\n{\n    for (int i = 0; i < max_loop; i++) {\n        acl::fiber::yield(); // 主动让出 CPU 给其它协程\n        std::cout << \"fiber-\" << acl::fiber::self() << std::endl;\n    }\n}\n\nint main(void)\n{\n    int i, max_fiber = 10, max_loop = 10;\n\n    for (i = 0; i < max_fiber; i++) {\n        go[=] { // 采用 c++11 的 lambad 表达式方式创建协程\n            fiber_main(max_loop); // 进入协程处理函数\n        };\n    }\n\n    std::cout << \"---- begin schedule fibers now ----\" << std::endl;\n    // 循环调度所有协程，直至所有协程退出\n    acl::fiber::schedule();\n    std::cout << \"---- all fibers exit ----\" << std::endl;\n\n    return 0;\n}\n```\n\n使用 C++11 方式创建协程是不是感觉更加简洁？\n\n同样下面给出 makefile 内容：\n\n```\nfiber: main.o\n        g++ -o fiber main.o -L../../../lib -lfiber_cpp \\\n                -L../../../../lib_acl_cpp/lib -l_acl_cpp \\\n                -L../../../../lib_acl/lib -l_acl  -lfiber \\\n                -lpthread -ldl\nmain.o: main.cpp\n        g++ -std=c++11 -O3 -Wall -c main.cpp -DLINUX2 -I.. -I../../../cpp/include \\\n                -I../../../../lib_acl_cpp/include\n```\n\n## 七、基于协程的网络服务\n前面提到了“如果协程不与网络应用结合，则不会发挥其价值“，因此，下面就给出一个具体的基于协程的网络服务器程序：\n\n```c++\n#include <iostream>\n#include \"acl_cpp/lib_acl.hpp\"\n#include \"fiber/lib_fiber.hpp\"\n\nclass fiber_client : public acl::fiber\n{\npublic:\n    fiber_client(acl::socket_stream* conn) : conn_(conn) {}\n\nprotected:\n    // @override 实现基类纯虚函数\n    void run(void)\n    {\n        std::cout << \"fiber-\" << acl::fiber::self()\n            << \": fd=\" << conn_->sock_handle()\n            << \", addr=\" << conn_->get_peer() << std::endl;\n        echo();\n        delete this; // 因为是动态创建的，所以需自动销毁\n    }\n\nprivate:\n    acl::socket_stream* conn_;\n\n    ~fiber_client(void)\n    {\n        delete conn_;\n    }\n\n    void echo(void)\n    {\n        char buf[8192];\n\n        // 从客户端读取数据并回显\n        while (!conn_->eof()) {\n            int ret = conn_->read(buf, sizeof(buf), false);\n            if (ret == -1) {\n                std::cout << \"read \" << acl::last_serror() << std::endl;\n                break;\n            }\n            if (conn_->write(buf, ret) == -1) {\n                std::cout << \"write \" << acl::last_serror() << std::endl;\n                break;\n            }\n        }\n    }\n};\n\nclass fiber_server : public acl::fiber\n{\npublic:\n    fiber_server(const char* addr) : addr_(addr) {}\n\nprotected:\n    // @override\n    void run(void)\n    {\n        // 监听服务地址\n        acl::server_socket ss;\n        if (ss.open(addr_) == false) {\n            std::cout << \"listen \" << addr_.c_str() << \" error\" << std::endl;\n            delete this;\n            return;\n        }\n\n        std::cout << \"listen \" << addr_.c_str() << \" ok\" << std::endl;\n\n        while (true) {\n            // 等待接收客户端连接\n            acl::socket_stream* conn = ss.accept();\n            if (conn == NULL) {\n                std::cout << \"accept error\" << std::endl;\n                break;\n            }\n\n            // 创建客户端处理协程\n            acl::fiber* fb = new fiber_client(conn);\n            fb->start();\n        }\n\n        delete this;\n    }\n\nprivate:\n    acl::string addr_;\n\n    ~fiber_server(void) {}\n};\n\nint main(void)\n{\n    const char* addr = \"127.0.0.1:8089\";\n\n    acl::fiber* fb = new fiber_server(addr); // 创建监听服务协程\n    fb->start(); // 启动监听协程\n\n    // 循环调度所有协程，直至所有协程退出\n    acl::fiber::schedule();\n\n    return 0;\n}\n```\n\n麻雀虽小，五脏俱全，该示例简明扼要地说明了如何使用 acl 的网络协程库编写支持高并发的网络服务应用。\n\n## 八、参考\n在 acl/lib_fiber/samples/ 目录下，还有大量的使用 acl 协程的例子，包括：定时器、简单聊天服务、mysql 访问协程化、redis 访问协程化、域名解析协程化等。\n\ngithub：https://github.com/acl-dev/acl\ngitee: http://git.oschina.net/acl-dev/acl\n","slug":"build_use_fiber","published":1,"updated":"2023-01-23T12:37:46.942Z","_id":"cld8rbzr200005i9k9l4v0par","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>在《使用 acl 协程编写高并发网络服务》和《使用协程方式编写高并发的 WEB 服务》两篇文章中介绍了如何使用 acl 的协程功能编写高并发服务器程序，本文主要介绍如何编译使用 acl 的网络协程库。</p>\n<h2 id=\"二、-acl-协程库的依赖关系\"><a href=\"#二、-acl-协程库的依赖关系\" class=\"headerlink\" title=\"二、 acl 协程库的依赖关系\"></a>二、 acl 协程库的依赖关系</h2><p>目前 acl 协程主要分为 C 库（lib_fiber.a，在 acl&#x2F;lib_fiber&#x2F;c 目录下）和 C++库（libfiber_cpp.a，在 acl&#x2F;lib_fiber&#x2F;cpp 目录下），其中 lib_fiber_cpp.a 依赖 libfiber.a，具体的依赖关系如下：<br><img src=\"/img/fiber_depedence.png\" alt=\"协程库依赖\"></p>\n<p>libfiber.a 目前是独立的库，libfiber_cpp.a 依赖 libfiber.a 和 lib_acl_cpp.a，lib_acl_cpp.a 依赖 lib_protocol.a 和 lib_acl.a，lib_protocol.a 依赖 lib_acl.a。</p>\n<p>其中，lib_acl.a 为 acl 中的核心基础 C 库，lib_protocol.a 为 acl 中的网络协议（http&#x2F;icmp&#x2F;smtp）基础 C 库，lib_acl_cpp 为 C++库，依赖上述两个 C 库；libfiber.a 为独立的网络协程库，仅依赖于系统库，libfiber_cpp.a 为封装了 libfiber.a 的 C++ 库，如果用户所用的 GCC 支持 C++11，则该库还支持更为简洁的创建协程的方式（借助于 C++11中的 lambda 表达式方式）。</p>\n<h2 id=\"三、一个简单的例子\"><a href=\"#三、一个简单的例子\" class=\"headerlink\" title=\"三、一个简单的例子\"></a>三、一个简单的例子</h2><p>下面是一个简单的使用 acl 协程的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.h&quot;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __max_loop = <span class=\"hljs-number\">100</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __max_fiber = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __stack_size = <span class=\"hljs-number\">64000</span>;<br><br><span class=\"hljs-comment\">/* 协程处理入口函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">fiber_main</span><span class=\"hljs-params\">(ACL_FIBER *fiber, <span class=\"hljs-type\">void</span> *ctx acl_unused)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span>  i;<br><br>    <span class=\"hljs-comment\">/* 两种方式均可以获得当前的协程号 */</span><br>    assert(acl_fiber_self() == acl_fiber_id(fiber));<br><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; __max_loop; i++) &#123;<br>        acl_fiber_yield();  <span class=\"hljs-comment\">/* 主动让出 CPU 给其它协程 */</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;fiber-%d\\r\\n&quot;</span>, acl_fiber_self());<br>    &#125;<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span>   ch, i;<br><br>    <span class=\"hljs-comment\">/* 创建协程 */</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; __max_fiber; i++) &#123;<br>        acl_fiber_create(fiber_main, <span class=\"hljs-literal\">NULL</span>, __stack_size);<br>    &#125;<br><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;---- begin schedule fibers now ----\\r\\n&quot;</span>);<br>    acl_fiber_schedule(); <span class=\"hljs-comment\">/* 循环调度所有协程，直至所有协程退出 */</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;---- all fibers exit ----\\r\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述例子非常简单，说明了 acl 协程创建、启动和运行过程，如果仅此而已，当然使用协程并没有什么卵用，协程的关键价值在于与网络通信的结合，可以达到高并发、高性能的目的。因此，现实中协程的应用范围主要还是网络服务方面，更为准确的叫法应该是“网络协程”，脱离了“网络”协程基本没啥价值。本文的开头给出了两个链接，指明了网络协程的应用场景及实例。</p>\n<h2 id=\"四、编译例子\"><a href=\"#四、编译例子\" class=\"headerlink\" title=\"四、编译例子\"></a>四、编译例子</h2><p>下面的 Makefile 文件说明了最简单的编译方式：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">fiber: <span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.o</span><br>        gcc -o fiber <span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.o</span> -L./lib_fiber/lib -L./lib_acl/lib -l_acl  -lfiber -lpthread -ldl<br><span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.o</span>: <span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.c</span><br>        gcc -c <span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.c</span> -O3 -DLINUX2 -I./lib_fiber/c/include -I./lib_acl/include<br></code></pre></td></tr></table></figure>\n<p>该 Makefile 也非常简单，也仅是说明了使用 acl 网络协程库时的编译条件。其中，l_fiber 指定了 acl 的网络协程库，l_acl 指定了 acl 基础库，-lpthread 及 -ldl 指定所依赖的系统库；-DLINUX2 指定 LINUX 平台的编译条件，-I 指定头文件所在位置。</p>\n<h2 id=\"五、C-示例\"><a href=\"#五、C-示例\" class=\"headerlink\" title=\"五、C++ 示例\"></a>五、C++ 示例</h2><p>上面的例子展示了使用 acl C 协程库的使用方法，同时 acl 也提供了 C++ 类封装，方便 C++ 程序员编写协程应用，下面的例子为使用标准 C++ 编写的协程示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myfiber</span> : <span class=\"hljs-keyword\">public</span> acl::fiber<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">myfiber</span>(<span class=\"hljs-type\">int</span> max_loop) : <span class=\"hljs-built_in\">max_loop_</span>(max_loop) &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-comment\">// @override 实现基类纯虚函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-comment\">// 两种方式均可以获得当前的协程号</span><br>        <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">get_id</span>() == acl::fiber::<span class=\"hljs-built_in\">self</span>());<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_loop_; i++) &#123;<br>            acl::fiber::<span class=\"hljs-built_in\">yield</span>(); <span class=\"hljs-comment\">// 主动让出 CPU 给其它协程</span><br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;fiber-&quot;</span> &lt;&lt; acl::fiber::<span class=\"hljs-built_in\">self</span>() &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>; <span class=\"hljs-comment\">// 因为是动态创建的，所以需自动销毁</span><br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> max_loop_;<br><br>    ~<span class=\"hljs-built_in\">myfiber</span>(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> i, max_fiber = <span class=\"hljs-number\">10</span>, max_loop = <span class=\"hljs-number\">10</span>;<br><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; max_fiber; i++) &#123;<br>        acl::fiber* fb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">myfiber</span>(max_loop); <span class=\"hljs-comment\">// 创建协程</span><br>        fb-&gt;<span class=\"hljs-built_in\">start</span>(); <span class=\"hljs-comment\">// 启动协程</span><br>    &#125;<br><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;---- begin schedule fibers now ----&quot;</span> &lt;&lt; std::endl;<br>    acl::fiber::<span class=\"hljs-built_in\">schedule</span>(); <span class=\"hljs-comment\">// 循环调度所有协程，直至所有协程退出</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;---- all fibers exit ----&quot;</span> &lt;&lt; std::endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该例子也非常简单，实现了与上面 C 示例相同的功能，只是采用 C++ 而已。用户首先需要定义自己的类，其继承于 acl::fiber 协程类，然后实现协程类中的纯虚方法：run()，当调用协程的启动方法 start() 时，acl::fiber 基类会自动回调纯虚方法  run()。</p>\n<p>该 C++ 示例的 Makefile 与 C 的有所不同，内容如下：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">fiber: main.o<br>        g++ -o fiber main.o -L.<span class=\"hljs-regexp\">/lib_fiber/</span>lib -lfiber_cpp \\<br>                -L.<span class=\"hljs-regexp\">/lib_acl_cpp/</span>lib -l_acl_cpp \\<br>                -L.<span class=\"hljs-regexp\">/lib_acl/</span>lib -l_acl -lfiber \\<br>                -lpthread -ldl<br>main.o: main.cpp<br>        g++ -O3 -Wall -c main.cpp -DLINUX2 -I.<span class=\"hljs-regexp\">/lib_fiber/</span>cpp/<span class=\"hljs-keyword\">include</span> \\<br>                -I.<span class=\"hljs-regexp\">/lib_acl_cpp/i</span>nclude<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、C-11-示例\"><a href=\"#六、C-11-示例\" class=\"headerlink\" title=\"六、C++11 示例\"></a>六、C++11 示例</h2><p>acl 的协程库同时提供了支持 C++11 方式的调用方法，使创建协程更加方便，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.hpp&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fiber_main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> max_loop)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_loop; i++) &#123;<br>        acl::fiber::<span class=\"hljs-built_in\">yield</span>(); <span class=\"hljs-comment\">// 主动让出 CPU 给其它协程</span><br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;fiber-&quot;</span> &lt;&lt; acl::fiber::<span class=\"hljs-built_in\">self</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> i, max_fiber = <span class=\"hljs-number\">10</span>, max_loop = <span class=\"hljs-number\">10</span>;<br><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; max_fiber; i++) &#123;<br>        go[=] &#123; <span class=\"hljs-comment\">// 采用 c++11 的 lambad 表达式方式创建协程</span><br>            <span class=\"hljs-built_in\">fiber_main</span>(max_loop); <span class=\"hljs-comment\">// 进入协程处理函数</span><br>        &#125;;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;---- begin schedule fibers now ----&quot;</span> &lt;&lt; std::endl;<br>    <span class=\"hljs-comment\">// 循环调度所有协程，直至所有协程退出</span><br>    acl::fiber::<span class=\"hljs-built_in\">schedule</span>();<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;---- all fibers exit ----&quot;</span> &lt;&lt; std::endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用 C++11 方式创建协程是不是感觉更加简洁？</p>\n<p>同样下面给出 makefile 内容：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">fiber: main.o<br>        g++ -o fiber main.o -L..<span class=\"hljs-regexp\">/../</span>../lib -lfiber_cpp \\<br>                -L..<span class=\"hljs-regexp\">/../</span>..<span class=\"hljs-regexp\">/../</span>lib_acl_cpp/lib -l_acl_cpp \\<br>                -L..<span class=\"hljs-regexp\">/../</span>..<span class=\"hljs-regexp\">/../</span>lib_acl/lib -l_acl  -lfiber \\<br>                -lpthread -ldl<br>main.o: main.cpp<br>        g++ -std=c++<span class=\"hljs-number\">11</span> -O3 -Wall -c main.cpp -DLINUX2 -I.. -I..<span class=\"hljs-regexp\">/../</span>..<span class=\"hljs-regexp\">/cpp/i</span>nclude \\<br>                -I..<span class=\"hljs-regexp\">/../</span>..<span class=\"hljs-regexp\">/../</span>lib_acl_cpp/<span class=\"hljs-keyword\">include</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、基于协程的网络服务\"><a href=\"#七、基于协程的网络服务\" class=\"headerlink\" title=\"七、基于协程的网络服务\"></a>七、基于协程的网络服务</h2><p>前面提到了“如果协程不与网络应用结合，则不会发挥其价值“，因此，下面就给出一个具体的基于协程的网络服务器程序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">fiber_client</span> : <span class=\"hljs-keyword\">public</span> acl::fiber<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">fiber_client</span>(acl::socket_stream* conn) : <span class=\"hljs-built_in\">conn_</span>(conn) &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-comment\">// @override 实现基类纯虚函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;fiber-&quot;</span> &lt;&lt; acl::fiber::<span class=\"hljs-built_in\">self</span>()<br>            &lt;&lt; <span class=\"hljs-string\">&quot;: fd=&quot;</span> &lt;&lt; conn_-&gt;<span class=\"hljs-built_in\">sock_handle</span>()<br>            &lt;&lt; <span class=\"hljs-string\">&quot;, addr=&quot;</span> &lt;&lt; conn_-&gt;<span class=\"hljs-built_in\">get_peer</span>() &lt;&lt; std::endl;<br>        <span class=\"hljs-built_in\">echo</span>();<br>        <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>; <span class=\"hljs-comment\">// 因为是动态创建的，所以需自动销毁</span><br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    acl::socket_stream* conn_;<br><br>    ~<span class=\"hljs-built_in\">fiber_client</span>(<span class=\"hljs-type\">void</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span> conn_;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">echo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br><br>        <span class=\"hljs-comment\">// 从客户端读取数据并回显</span><br>        <span class=\"hljs-keyword\">while</span> (!conn_-&gt;<span class=\"hljs-built_in\">eof</span>()) &#123;<br>            <span class=\"hljs-type\">int</span> ret = conn_-&gt;<span class=\"hljs-built_in\">read</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>            <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;read &quot;</span> &lt;&lt; acl::<span class=\"hljs-built_in\">last_serror</span>() &lt;&lt; std::endl;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (conn_-&gt;<span class=\"hljs-built_in\">write</span>(buf, ret) == <span class=\"hljs-number\">-1</span>) &#123;<br>                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;write &quot;</span> &lt;&lt; acl::<span class=\"hljs-built_in\">last_serror</span>() &lt;&lt; std::endl;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">fiber_server</span> : <span class=\"hljs-keyword\">public</span> acl::fiber<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">fiber_server</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr) : <span class=\"hljs-built_in\">addr_</span>(addr) &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-comment\">// @override</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-comment\">// 监听服务地址</span><br>        acl::server_socket ss;<br>        <span class=\"hljs-keyword\">if</span> (ss.<span class=\"hljs-built_in\">open</span>(addr_) == <span class=\"hljs-literal\">false</span>) &#123;<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;listen &quot;</span> &lt;&lt; addr_.<span class=\"hljs-built_in\">c_str</span>() &lt;&lt; <span class=\"hljs-string\">&quot; error&quot;</span> &lt;&lt; std::endl;<br>            <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;listen &quot;</span> &lt;&lt; addr_.<span class=\"hljs-built_in\">c_str</span>() &lt;&lt; <span class=\"hljs-string\">&quot; ok&quot;</span> &lt;&lt; std::endl;<br><br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>            <span class=\"hljs-comment\">// 等待接收客户端连接</span><br>            acl::socket_stream* conn = ss.<span class=\"hljs-built_in\">accept</span>();<br>            <span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;accept error&quot;</span> &lt;&lt; std::endl;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br><br>            <span class=\"hljs-comment\">// 创建客户端处理协程</span><br>            acl::fiber* fb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">fiber_client</span>(conn);<br>            fb-&gt;<span class=\"hljs-built_in\">start</span>();<br>        &#125;<br><br>        <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    acl::string addr_;<br><br>    ~<span class=\"hljs-built_in\">fiber_server</span>(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:8089&quot;</span>;<br><br>    acl::fiber* fb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">fiber_server</span>(addr); <span class=\"hljs-comment\">// 创建监听服务协程</span><br>    fb-&gt;<span class=\"hljs-built_in\">start</span>(); <span class=\"hljs-comment\">// 启动监听协程</span><br><br>    <span class=\"hljs-comment\">// 循环调度所有协程，直至所有协程退出</span><br>    acl::fiber::<span class=\"hljs-built_in\">schedule</span>();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>麻雀虽小，五脏俱全，该示例简明扼要地说明了如何使用 acl 的网络协程库编写支持高并发的网络服务应用。</p>\n<h2 id=\"八、参考\"><a href=\"#八、参考\" class=\"headerlink\" title=\"八、参考\"></a>八、参考</h2><p>在 acl&#x2F;lib_fiber&#x2F;samples&#x2F; 目录下，还有大量的使用 acl 协程的例子，包括：定时器、简单聊天服务、mysql 访问协程化、redis 访问协程化、域名解析协程化等。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee: <a href=\"http://git.oschina.net/acl-dev/acl\">http://git.oschina.net/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>在《使用 acl 协程编写高并发网络服务》和《使用协程方式编写高并发的 WEB 服务》两篇文章中介绍了如何使用 acl 的协程功能编写高并发服务器程序，本文主要介绍如何编译使用 acl 的网络协程库。</p>\n<h2 id=\"二、-acl-协程库的依赖关系\"><a href=\"#二、-acl-协程库的依赖关系\" class=\"headerlink\" title=\"二、 acl 协程库的依赖关系\"></a>二、 acl 协程库的依赖关系</h2><p>目前 acl 协程主要分为 C 库（lib_fiber.a，在 acl&#x2F;lib_fiber&#x2F;c 目录下）和 C++库（libfiber_cpp.a，在 acl&#x2F;lib_fiber&#x2F;cpp 目录下），其中 lib_fiber_cpp.a 依赖 libfiber.a，具体的依赖关系如下：<br><img src=\"/img/fiber_depedence.png\" alt=\"协程库依赖\"></p>\n<p>libfiber.a 目前是独立的库，libfiber_cpp.a 依赖 libfiber.a 和 lib_acl_cpp.a，lib_acl_cpp.a 依赖 lib_protocol.a 和 lib_acl.a，lib_protocol.a 依赖 lib_acl.a。</p>\n<p>其中，lib_acl.a 为 acl 中的核心基础 C 库，lib_protocol.a 为 acl 中的网络协议（http&#x2F;icmp&#x2F;smtp）基础 C 库，lib_acl_cpp 为 C++库，依赖上述两个 C 库；libfiber.a 为独立的网络协程库，仅依赖于系统库，libfiber_cpp.a 为封装了 libfiber.a 的 C++ 库，如果用户所用的 GCC 支持 C++11，则该库还支持更为简洁的创建协程的方式（借助于 C++11中的 lambda 表达式方式）。</p>\n<h2 id=\"三、一个简单的例子\"><a href=\"#三、一个简单的例子\" class=\"headerlink\" title=\"三、一个简单的例子\"></a>三、一个简单的例子</h2><p>下面是一个简单的使用 acl 协程的例子：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.h&quot;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __max_loop = <span class=\"hljs-number\">100</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __max_fiber = <span class=\"hljs-number\">10</span>;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __stack_size = <span class=\"hljs-number\">64000</span>;<br><br><span class=\"hljs-comment\">/* 协程处理入口函数 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">fiber_main</span><span class=\"hljs-params\">(ACL_FIBER *fiber, <span class=\"hljs-type\">void</span> *ctx acl_unused)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span>  i;<br><br>    <span class=\"hljs-comment\">/* 两种方式均可以获得当前的协程号 */</span><br>    assert(acl_fiber_self() == acl_fiber_id(fiber));<br><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; __max_loop; i++) &#123;<br>        acl_fiber_yield();  <span class=\"hljs-comment\">/* 主动让出 CPU 给其它协程 */</span><br>        <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;fiber-%d\\r\\n&quot;</span>, acl_fiber_self());<br>    &#125;<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>    <span class=\"hljs-type\">int</span>   ch, i;<br><br>    <span class=\"hljs-comment\">/* 创建协程 */</span><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; __max_fiber; i++) &#123;<br>        acl_fiber_create(fiber_main, <span class=\"hljs-literal\">NULL</span>, __stack_size);<br>    &#125;<br><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;---- begin schedule fibers now ----\\r\\n&quot;</span>);<br>    acl_fiber_schedule(); <span class=\"hljs-comment\">/* 循环调度所有协程，直至所有协程退出 */</span><br>    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;---- all fibers exit ----\\r\\n&quot;</span>);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上述例子非常简单，说明了 acl 协程创建、启动和运行过程，如果仅此而已，当然使用协程并没有什么卵用，协程的关键价值在于与网络通信的结合，可以达到高并发、高性能的目的。因此，现实中协程的应用范围主要还是网络服务方面，更为准确的叫法应该是“网络协程”，脱离了“网络”协程基本没啥价值。本文的开头给出了两个链接，指明了网络协程的应用场景及实例。</p>\n<h2 id=\"四、编译例子\"><a href=\"#四、编译例子\" class=\"headerlink\" title=\"四、编译例子\"></a>四、编译例子</h2><p>下面的 Makefile 文件说明了最简单的编译方式：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">fiber: <span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.o</span><br>        gcc -o fiber <span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.o</span> -L./lib_fiber/lib -L./lib_acl/lib -l_acl  -lfiber -lpthread -ldl<br><span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.o</span>: <span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.c</span><br>        gcc -c <span class=\"hljs-selector-tag\">main</span><span class=\"hljs-selector-class\">.c</span> -O3 -DLINUX2 -I./lib_fiber/c/include -I./lib_acl/include<br></code></pre></td></tr></table></figure>\n<p>该 Makefile 也非常简单，也仅是说明了使用 acl 网络协程库时的编译条件。其中，l_fiber 指定了 acl 的网络协程库，l_acl 指定了 acl 基础库，-lpthread 及 -ldl 指定所依赖的系统库；-DLINUX2 指定 LINUX 平台的编译条件，-I 指定头文件所在位置。</p>\n<h2 id=\"五、C-示例\"><a href=\"#五、C-示例\" class=\"headerlink\" title=\"五、C++ 示例\"></a>五、C++ 示例</h2><p>上面的例子展示了使用 acl C 协程库的使用方法，同时 acl 也提供了 C++ 类封装，方便 C++ 程序员编写协程应用，下面的例子为使用标准 C++ 编写的协程示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myfiber</span> : <span class=\"hljs-keyword\">public</span> acl::fiber<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">myfiber</span>(<span class=\"hljs-type\">int</span> max_loop) : <span class=\"hljs-built_in\">max_loop_</span>(max_loop) &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-comment\">// @override 实现基类纯虚函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-comment\">// 两种方式均可以获得当前的协程号</span><br>        <span class=\"hljs-built_in\">assert</span>(<span class=\"hljs-built_in\">get_id</span>() == acl::fiber::<span class=\"hljs-built_in\">self</span>());<br><br>        <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_loop_; i++) &#123;<br>            acl::fiber::<span class=\"hljs-built_in\">yield</span>(); <span class=\"hljs-comment\">// 主动让出 CPU 给其它协程</span><br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;fiber-&quot;</span> &lt;&lt; acl::fiber::<span class=\"hljs-built_in\">self</span>() &lt;&lt; std::endl;<br>        &#125;<br><br>        <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>; <span class=\"hljs-comment\">// 因为是动态创建的，所以需自动销毁</span><br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-type\">int</span> max_loop_;<br><br>    ~<span class=\"hljs-built_in\">myfiber</span>(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> i, max_fiber = <span class=\"hljs-number\">10</span>, max_loop = <span class=\"hljs-number\">10</span>;<br><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; max_fiber; i++) &#123;<br>        acl::fiber* fb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">myfiber</span>(max_loop); <span class=\"hljs-comment\">// 创建协程</span><br>        fb-&gt;<span class=\"hljs-built_in\">start</span>(); <span class=\"hljs-comment\">// 启动协程</span><br>    &#125;<br><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;---- begin schedule fibers now ----&quot;</span> &lt;&lt; std::endl;<br>    acl::fiber::<span class=\"hljs-built_in\">schedule</span>(); <span class=\"hljs-comment\">// 循环调度所有协程，直至所有协程退出</span><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;---- all fibers exit ----&quot;</span> &lt;&lt; std::endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该例子也非常简单，实现了与上面 C 示例相同的功能，只是采用 C++ 而已。用户首先需要定义自己的类，其继承于 acl::fiber 协程类，然后实现协程类中的纯虚方法：run()，当调用协程的启动方法 start() 时，acl::fiber 基类会自动回调纯虚方法  run()。</p>\n<p>该 C++ 示例的 Makefile 与 C 的有所不同，内容如下：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">fiber: main.o<br>        g++ -o fiber main.o -L.<span class=\"hljs-regexp\">/lib_fiber/</span>lib -lfiber_cpp \\<br>                -L.<span class=\"hljs-regexp\">/lib_acl_cpp/</span>lib -l_acl_cpp \\<br>                -L.<span class=\"hljs-regexp\">/lib_acl/</span>lib -l_acl -lfiber \\<br>                -lpthread -ldl<br>main.o: main.cpp<br>        g++ -O3 -Wall -c main.cpp -DLINUX2 -I.<span class=\"hljs-regexp\">/lib_fiber/</span>cpp/<span class=\"hljs-keyword\">include</span> \\<br>                -I.<span class=\"hljs-regexp\">/lib_acl_cpp/i</span>nclude<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、C-11-示例\"><a href=\"#六、C-11-示例\" class=\"headerlink\" title=\"六、C++11 示例\"></a>六、C++11 示例</h2><p>acl 的协程库同时提供了支持 C++11 方式的调用方法，使创建协程更加方便，代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.hpp&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fiber_main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> max_loop)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_loop; i++) &#123;<br>        acl::fiber::<span class=\"hljs-built_in\">yield</span>(); <span class=\"hljs-comment\">// 主动让出 CPU 给其它协程</span><br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;fiber-&quot;</span> &lt;&lt; acl::fiber::<span class=\"hljs-built_in\">self</span>() &lt;&lt; std::endl;<br>    &#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">int</span> i, max_fiber = <span class=\"hljs-number\">10</span>, max_loop = <span class=\"hljs-number\">10</span>;<br><br>    <span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; max_fiber; i++) &#123;<br>        go[=] &#123; <span class=\"hljs-comment\">// 采用 c++11 的 lambad 表达式方式创建协程</span><br>            <span class=\"hljs-built_in\">fiber_main</span>(max_loop); <span class=\"hljs-comment\">// 进入协程处理函数</span><br>        &#125;;<br>    &#125;<br><br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;---- begin schedule fibers now ----&quot;</span> &lt;&lt; std::endl;<br>    <span class=\"hljs-comment\">// 循环调度所有协程，直至所有协程退出</span><br>    acl::fiber::<span class=\"hljs-built_in\">schedule</span>();<br>    std::cout &lt;&lt; <span class=\"hljs-string\">&quot;---- all fibers exit ----&quot;</span> &lt;&lt; std::endl;<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用 C++11 方式创建协程是不是感觉更加简洁？</p>\n<p>同样下面给出 makefile 内容：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">fiber: main.o<br>        g++ -o fiber main.o -L..<span class=\"hljs-regexp\">/../</span>../lib -lfiber_cpp \\<br>                -L..<span class=\"hljs-regexp\">/../</span>..<span class=\"hljs-regexp\">/../</span>lib_acl_cpp/lib -l_acl_cpp \\<br>                -L..<span class=\"hljs-regexp\">/../</span>..<span class=\"hljs-regexp\">/../</span>lib_acl/lib -l_acl  -lfiber \\<br>                -lpthread -ldl<br>main.o: main.cpp<br>        g++ -std=c++<span class=\"hljs-number\">11</span> -O3 -Wall -c main.cpp -DLINUX2 -I.. -I..<span class=\"hljs-regexp\">/../</span>..<span class=\"hljs-regexp\">/cpp/i</span>nclude \\<br>                -I..<span class=\"hljs-regexp\">/../</span>..<span class=\"hljs-regexp\">/../</span>lib_acl_cpp/<span class=\"hljs-keyword\">include</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"七、基于协程的网络服务\"><a href=\"#七、基于协程的网络服务\" class=\"headerlink\" title=\"七、基于协程的网络服务\"></a>七、基于协程的网络服务</h2><p>前面提到了“如果协程不与网络应用结合，则不会发挥其价值“，因此，下面就给出一个具体的基于协程的网络服务器程序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">fiber_client</span> : <span class=\"hljs-keyword\">public</span> acl::fiber<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">fiber_client</span>(acl::socket_stream* conn) : <span class=\"hljs-built_in\">conn_</span>(conn) &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-comment\">// @override 实现基类纯虚函数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;fiber-&quot;</span> &lt;&lt; acl::fiber::<span class=\"hljs-built_in\">self</span>()<br>            &lt;&lt; <span class=\"hljs-string\">&quot;: fd=&quot;</span> &lt;&lt; conn_-&gt;<span class=\"hljs-built_in\">sock_handle</span>()<br>            &lt;&lt; <span class=\"hljs-string\">&quot;, addr=&quot;</span> &lt;&lt; conn_-&gt;<span class=\"hljs-built_in\">get_peer</span>() &lt;&lt; std::endl;<br>        <span class=\"hljs-built_in\">echo</span>();<br>        <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>; <span class=\"hljs-comment\">// 因为是动态创建的，所以需自动销毁</span><br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    acl::socket_stream* conn_;<br><br>    ~<span class=\"hljs-built_in\">fiber_client</span>(<span class=\"hljs-type\">void</span>)<br>    &#123;<br>        <span class=\"hljs-keyword\">delete</span> conn_;<br>    &#125;<br><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">echo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br><br>        <span class=\"hljs-comment\">// 从客户端读取数据并回显</span><br>        <span class=\"hljs-keyword\">while</span> (!conn_-&gt;<span class=\"hljs-built_in\">eof</span>()) &#123;<br>            <span class=\"hljs-type\">int</span> ret = conn_-&gt;<span class=\"hljs-built_in\">read</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>            <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>) &#123;<br>                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;read &quot;</span> &lt;&lt; acl::<span class=\"hljs-built_in\">last_serror</span>() &lt;&lt; std::endl;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">if</span> (conn_-&gt;<span class=\"hljs-built_in\">write</span>(buf, ret) == <span class=\"hljs-number\">-1</span>) &#123;<br>                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;write &quot;</span> &lt;&lt; acl::<span class=\"hljs-built_in\">last_serror</span>() &lt;&lt; std::endl;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">fiber_server</span> : <span class=\"hljs-keyword\">public</span> acl::fiber<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-built_in\">fiber_server</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr) : <span class=\"hljs-built_in\">addr_</span>(addr) &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>    <span class=\"hljs-comment\">// @override</span><br>    <span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">    </span>&#123;<br>        <span class=\"hljs-comment\">// 监听服务地址</span><br>        acl::server_socket ss;<br>        <span class=\"hljs-keyword\">if</span> (ss.<span class=\"hljs-built_in\">open</span>(addr_) == <span class=\"hljs-literal\">false</span>) &#123;<br>            std::cout &lt;&lt; <span class=\"hljs-string\">&quot;listen &quot;</span> &lt;&lt; addr_.<span class=\"hljs-built_in\">c_str</span>() &lt;&lt; <span class=\"hljs-string\">&quot; error&quot;</span> &lt;&lt; std::endl;<br>            <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>            <span class=\"hljs-keyword\">return</span>;<br>        &#125;<br><br>        std::cout &lt;&lt; <span class=\"hljs-string\">&quot;listen &quot;</span> &lt;&lt; addr_.<span class=\"hljs-built_in\">c_str</span>() &lt;&lt; <span class=\"hljs-string\">&quot; ok&quot;</span> &lt;&lt; std::endl;<br><br>        <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>) &#123;<br>            <span class=\"hljs-comment\">// 等待接收客户端连接</span><br>            acl::socket_stream* conn = ss.<span class=\"hljs-built_in\">accept</span>();<br>            <span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>) &#123;<br>                std::cout &lt;&lt; <span class=\"hljs-string\">&quot;accept error&quot;</span> &lt;&lt; std::endl;<br>                <span class=\"hljs-keyword\">break</span>;<br>            &#125;<br><br>            <span class=\"hljs-comment\">// 创建客户端处理协程</span><br>            acl::fiber* fb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">fiber_client</span>(conn);<br>            fb-&gt;<span class=\"hljs-built_in\">start</span>();<br>        &#125;<br><br>        <span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>    &#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>    acl::string addr_;<br><br>    ~<span class=\"hljs-built_in\">fiber_server</span>(<span class=\"hljs-type\">void</span>) &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:8089&quot;</span>;<br><br>    acl::fiber* fb = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">fiber_server</span>(addr); <span class=\"hljs-comment\">// 创建监听服务协程</span><br>    fb-&gt;<span class=\"hljs-built_in\">start</span>(); <span class=\"hljs-comment\">// 启动监听协程</span><br><br>    <span class=\"hljs-comment\">// 循环调度所有协程，直至所有协程退出</span><br>    acl::fiber::<span class=\"hljs-built_in\">schedule</span>();<br><br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>麻雀虽小，五脏俱全，该示例简明扼要地说明了如何使用 acl 的网络协程库编写支持高并发的网络服务应用。</p>\n<h2 id=\"八、参考\"><a href=\"#八、参考\" class=\"headerlink\" title=\"八、参考\"></a>八、参考</h2><p>在 acl&#x2F;lib_fiber&#x2F;samples&#x2F; 目录下，还有大量的使用 acl 协程的例子，包括：定时器、简单聊天服务、mysql 访问协程化、redis 访问协程化、域名解析协程化等。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee: <a href=\"http://git.oschina.net/acl-dev/acl\">http://git.oschina.net/acl-dev/acl</a></p>\n"},{"title":"用C++实现类似于JAVA HttpServlet 的编程接口","date":"2012-05-20T05:08:24.000Z","_content":"\n## 一、概述\n互联网刚兴起时，很多项目都是用 C /Perl 语言写的一大堆 CGI，一些老程序员可谓是偿尽了编程的苦，因为那时国内的技术水平普遍比较低，如果你会 CGI 编程，就已经算是行业中人了，如果你对 CGI 编程比较熟练，则就可以称得是“专家”了，后来技术不断进步，各种国外的新技术都进入中国并不断得到普及，CGI 就逐渐沦为一种落后的技术，后来的 PHP, JSP/Servlet, ASP 逐渐占领了 WEB 编程的技术市场，这个时候如果你说再用 C 写 CGI，别人会感觉是在和古人对话。现在主流的 WEB 开发语言一个很大的优势就是有各种相对成熟的基础库和框架，开发效率很高，而 CGI 则就逊色很多。当然，这些语言也得有执行效率相对较低的问题，毕竟它们都是脚本语言或半编译语言，需要虚拟机解释执行，象 facebook 的 WEB 前端基本都是用 PHP 写的，他们为了解决执行效率问题，在一位华人的领导下开发了可以将 PHP 代码转成 C++ 代码的工具（hiphop)，从而使执行效率大大提高，这也从另一个侧面反映出技术人员还是希望他们的程序能够运行的更快些。\n\n本文主要描述了 acl_cpp 库中有关 WEB 编程的方法类，为了使大家容易上手，其中的接口设计及命名尽量模仿 JAVA HttpServlet 等相关的类（希望 Oracle 不会告我侵权，呵呵）。如果您会用C/C++编程，同时又有使用 Java Servlet 进行 WEB 编程的经验，则该文您读起来一点不会费力，当然如果您多年从事 WEB 开发，我想理解这些类的设计及用法也不应该有什么难度。好了，下面就开始讲如何使用 acl_cpp 库中的 http/ 模块下的类进行 web 编程。\n\n在 acl_cpp/src/http 模块下，有几个类与 WEB 编程相关：HttpServlet，HttpServletRequest, HttpServletResponse, HttpSession, http_header, http_mime, http_client。如果您掌握了这几个类的用法，则进行 WEB 编程就不会有什么问题了，下面一一介绍这几个类：\n\n## 二、HttpServlet 类\n构造函数及析构函数：\n```c++\n\t/**\n\t * 构造函数\n\t */\n\tHttpServlet(void);\n\n\t/**\n\t * 纯虚析构函数，即该类必须由子类进行实例化\n\t */\n\tvirtual ~HttpServlet(void) = 0;\n```\n\n在构建函数中，为了支持 HttpSession 数据的存储，需要用户给出 memcached 的服务器地址（目前仅支持采用 memcached 来存储 session 数据，将来应该会扩展至可以支持 redis 等），同时用户还需要给出 session 的 cookie ID 标识符以发给浏览器。\n\n四个虚接口，需要子类实现以应对不同的浏览器的 HTTP 请求：\n```c++\n\t/**\n\t * 当 HTTP 请求为 GET 方式时的虚函数\n\t */\n\tvirtual bool doGet(HttpServletRequest&, HttpServletResponse&);\n\n\t/**\n\t * 当 HTTP 请求为 POST 方式时的虚函数\n\t */\n\tvirtual bool doPost(HttpServletRequest&, HttpServletResponse&);\n\n\t/**\n\t * 当 HTTP 请求为 PUT 方式时的虚函数\n\t */\n\tvirtual bool doPut(HttpServletRequest&, HttpServletResponse&);\n\n\t/**\n\t * 当 HTTP 请求为 CONNECT 方式时的虚函数\n\t */\n\tvirtual bool doConnect(HttpServletRequest&, HttpServletResponse&);\n\n\t/**\n\t * 当 HTTP 请求为 PURGE 方式时的虚函数，该方法在清除 SQUID 的缓存\n\t * 时会用到\n\t */\n\tvirtual bool doPurge(HttpServletRequest&, HttpServletResponse&);\n```\n\n用户实现的 HttpServlet 子类中可以实现以上几个虚接口的一个或者几个，以满足不同的 HTTP 请求。\n \n下面的函数为 HttpServlet 类开始运行的函数：\n```c++\n\t/**\n\t * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数\n\t * @param session {session&} 存储 session 数据的对象\n\t * @param stream {socket_stream*} 当在 acl_master 服务器框架控制下\n\t *  运行时，该参数必须非空；当在 apache 下以 CGI 方式运行时，该参数\n\t *  设为 NULL；另外，该函数内部不会关闭流连接，应用应自行处理流对象\n\t *  的关闭情况，这样可以方便与 acl_master 架构结合\n\t * @param body_parse {bool} 针对 POST 方法，该参数指定是否需要\n\t *  读取 HTTP 请求数据体并按 n/v 方式进行分析；当为 true 则内\n\t *  部会读取 HTTP 请求体数据，并进行分析，当用户调用 getParameter\n\t *  时，不仅可以获得 URL 中的参数，同时可以获得 POST 数据体中\n\t *  的参数；当该参数为 false 时则不读取数据体\n\t * @param body_limit {int} 针对 POST 方法，当数据体为文本参数\n\t *  类型时，此参数限制数据体的长度；当数据体为数据流或 MIME\n\t *  格式或 body_read 为 false，此参数无效\n\t * @return {bool} 返回处理结果\n\t */\n\tbool doRun(session& session, socket_stream* stream = NULL,\n\t\tbool body_parse = true, int body_limit = 102400);\n\n\t/**\n\t * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数，\n\t * 调用本函数意味着采用 memcached 来存储 session 数据\n\t * @param memcached_addr {const char*} memcached 服务器地址，格式：IP:PORT\n\t * @param stream {socket_stream*} 含义同上\n\t * @param body_parse {bool} 含义同上\n\t * @param body_limit {int} 含义同上\n\t * @return {bool} 返回处理结果\n\t */\n\tbool doRun(const char* memcached_addr = \"127.0.0.1:11211\",\n\t\tsocket_stream* stream = NULL,\n\t\tbool body_parse = true, int body_limit = 102400);\n\n```\n\n从上面五个虚方法中，可以看到两个重要的类：HttpServletRequest 和 HttpServletResponse。这两个类分别表示 http 请求类及 http 响应类，这两个类都是由 HttpServlet 类对象创建并释放的，所以用户不必创建和销毁这两个类对象实例。下面分别介绍这两个类：\n\n## 三、HttpServletRequest 类\n该类主要是与浏览器的请求过程相关，您可以通过该类的方法获得浏览器的请求数据。该类的方法比较多（基本上是参照了 java HttpServlet 的功能方法及名称），所以下面仅介绍几个主要的方法：\n\n```c++\n\t/**\n\t * 获得 HTTP 请求中的参数值，该值已经被 URL 解码且\n\t * 转换成本地要求的字符集；针对 GET 方法，则是获得\n\t * URL 中 ? 后面的参数值；针对 POST 方法，则可以获得\n\t * URL 中 ? 后面的参数值或请求体中的参数值\n\t */\n\tconst char* getParameter(const char* name) const;\n\n\t/**\n\t * 获得 HTTP 客户端请求的某个 cookie 值\n\t * @param name {const char*} cookie 名称，必须非空\n\t * @return {const char*} cookie 值，当返回 NULL 时表示\n\t *  cookie 值不存在\n\t */\n\tconst char* getCookieValue(const char* name) const;\n\n\t/**\n\t * 获得与该 HTTP 会话相关的 HttpSession 对象引用\n\t * @return {HttpSession&}\n\t */\n\tHttpSession& getSession(void);\n\n\t/**\n\t * 获得与 HTTP 客户端连接关联的输入流对象引用\n\t * @return {istream&}\n\t */\n\tistream& getInputStream(void) const;\n\n\t/**\n\t * 获得 HTTP 请求数据的数据长度\n\t * @return {acl_int64} 返回 -1 表示可能为 GET 方法，\n\t *  或 HTTP 请求头中没有 Content-Length 字段\n\t */\n#ifdef WIN32\n\t__int64 getContentLength(void) const;\n#else\n\tlong long int getContentLength(void) const;\n#endif\n\n\t/**\n\t * 当 HTTP 请求头中的 Content-Type 为\n\t * multipart/form-data; boundary=xxx 格式时，说明为文件上传\n\t * 数据类型，则可以通过此函数获得 http_mime 对象\n\t * @return {const http_mime*} 返回 NULL 则说明没有 MIME 对象，\n\t *  返回的值用户不能手工释放，因为在 HttpServletRequest 的析\n\t *  构中会自动释放\n\t */\n\thttp_mime* getHttpMime(void) const;\n\n\t/**\n\t * 获得 HTTP 请求数据的类型\n\t * @return {http_request_t}，一般对 POST 方法中的上传\n\t *  文件应用而言，需要调用该函数获得是否是上传数据类型\n\t */\n\thttp_request_t getRequestType(void) const;\n```\n\n以上方法一般都是我们在实际对 HttpServletRequest 类方法使用过程中用得较多的。如：\n\n```\n    getParmeter： 用来获得 http 请求参数\n    getCookieValue：获得浏览器的 cookie 值\n    getSession：获得该 HttpServlet 类对象的 session 会话\n    getInputStream：获得 http 连接的输入流\n    getContentLength：针对 HTTP POST 请求，此函数获得 HTTP 请求数据体的长度\n    getRequestType：针对 HTTP POST 请求，此函数返回 HTTP 请求数据体的传输方式（普通的 name=value 方式，multipart 上传文件格式以及数据流格式）\n```\n \n## 四、HttpServletResponse 类\n该类主要与将您写的程序将处理数据结果返回给浏览器的过程相关，下面也仅介绍该类的一些常用的函数，如果您需要更多的功能，请参数 HttpServletResponse.hpp 头文件。\n\n```c++\n\t/**\n\t * 设置 HTTP 响应数据体的 Content-Type 字段值，可字段值可以为：\n\t * text/html 或 text/html; charset=utf8 格式\n\t * @param value {const char*} 字段值\n\t */\n\tvoid setContentType(const char* value);\n\n\t/**\n\t * 设置 HTTP 响应数据体中字符集，当已经在 setContentType 设置\n\t * 了字符集，则就不必再调用本函数设置字符集\n\t * @param charset {const char*} 响应体数据的字符集\n\t */\n\tvoid setCharacterEncoding(const char* charset);\n\n\t/**\n\t * 设置 HTTP 响应头中的状态码：1xx, 2xx, 3xx, 4xx, 5xx\n\t * @param status {int} HTTP 响应状态码, 如：200\n\t */\n\tvoid setStatus(int status);\n\n\t/**\n\t * 添加 cookie\n\t * @param name {const char*} cookie 名\n\t * @param value {const char*} cookie 值\n\t * @param domain {const char*} cookie 存储域\n\t * @param path {const char*} cookie 存储路径\n\t * @param expires {time_t} cookie 过期时间间隔，当当前时间加\n\t *  该值为 cookie 的过期时间截(秒)\n\t */\n\tvoid addCookie(const char* name, const char* value,\n\t\tconst char* domain = NULL, const char* path = NULL, time_t expires = 0);\n\n\t/**\n\t * 发送 HTTP 响应头，用户应该发送数据体前调用此函数将 HTTP\n\t * 响应头发送给客户端\n\t */\n\tbool sendHeader(void);\n\n\t/**\n\t * 获得 HTTP 响应对象的输出流对象，用户在调用 sendHeader 发送\n\t * 完 HTTP 响应头后，通过该输出流来发送 HTTP 数据体\n\t * @return {ostream&}\n\t */\n\tostream& getOutputStream(void) const;\n```\n\n- setCharacterEncoding：该方法设置 HTTP 响应头的 HTTP 数据体的字符集，如果通过该函数设置了字符集，即使您在返回的 html 数据中重新设置了其它的字符集，浏览器也会优先使用 HTTP 响应头中设置的字符集，所以用户一定得注意这点；\n- setContentType：该方法用来设置 HTTP 响应头中的 Content-Type 字段，对于 xml 数据则设置 text/xml，对 html 数据则设置 text/html，当然您也可以设置 image/jpeg 等数据类型；当然，您也可以直接通过该方法在设置数据类型的同时指定数据的字符集，如可以直接写：setContentType(\"text/html; charset=utf8\")，这个用法等同于：setContentType(\"text/html\"); setCharacterEncoding(\"utf8\")。\n- setStatus：设置 HTTP 响应头的状态码（一般不用设置状态码，除非是您确实需要单独设置）；\n- addCookie：在 HTTP 响应头中添加 cookie 内容；\n- sendHeader：发送 HTTP 响应头；\n- getOutputStream：该函数返回输出流对象，您可以向输出流中直接写 HTTP 响应的数据体（关于 ostream 类的使用请参数头文件：include/ostream.hpp）。\n\n除了以上三个类外，还有一个类比较重要：HttpSession 类，该类主要实现与 session 会话相关的功能：\n\n## 五、HttpSession 类\n该类对象实例用户也不必创建与释放，在 HttpServet 类对象内容自动管理该类对象实例。主要用的方法有：\n```c++\n\t/**\n\t * 获得客户端在服务端存储的对应 session 变量名，子类可以重载该方法\n\t * @param name {const char*} session 名，非空\n\t * @return {const char*} session 值，为空说明不存在或内部\n\t *  查询失败\n\t */\n\tvirtual const char* getAttribute(const char* name) const;\n\n\t/**\n\t * 设置服务端对应 session 名的 session 值，子类可以重载该方法\n\t * @param name {const char*} session 名，非空\n\t * @param name {const char*} session 值，非空\n\t * @return {bool} 返回 false 说明设置失败\n\t */\n\tvirtual bool setAttribute(const char* name, const char* value);\n```\n\n只所以将这两个方法声明为虚方法，是因为 HttpSession 的 session 数据存储目前仅支持 memcached，您如果有精力的话可以实现一个子类用来支持其它的数据存储方式。当然您也可以在您实现的子类中实现自己的产生唯一 session id 的方法，即实现如下虚方法：\n\n```c++\nprotected:\n\t/**\n\t * 创建某个 session 会话的唯一 ID 号，子类可以重载该方法\n\t * @param buf {char*} 存储结果缓冲区\n\t * @param len {size_t} buf 缓冲区大小，buf 缓冲区大小建议\n\t *  64 字节左右\n\t */\n\tvirtual void createSid(char* buf, size_t len);\n```\n\n好了，上面说了一大堆类及类函数，下面还是以一个具体的示例来说明这些类的用法：\n\n## 六、示例\n下面的例子是一个 CGI 例子，编译后可执行程序可以直接放在 apache 的 cgi-bin/ 目录，用户可以用浏览器访问。\n\n```c++\n// http_servlet.cpp : 定义控制台应用程序的入口点。\n//\n\n#include \"lib_acl.hpp\"\nusing namespace acl;\n\n//////////////////////////////////////////////////////////////////////////\n\nclass http_servlet : public HttpServlet\n{\npublic:\n\thttp_servlet(void)\n\t{\n\t}\n\n\t~http_servlet(void)\n\t{\n\t}\n\n\t// 实现处理 HTTP GET 请求的功能函数\n\tbool doGet(HttpServletRequest& req, HttpServletResponse& res)\n\t{\n\t\treturn doPost(req, res);\n\t}\n\n\t// 实现处理 HTTP POST 请求的功能函数\n\tbool doPost(HttpServletRequest& req, HttpServletResponse& res)\n\t{\n\t\t// 获得某浏览器用户的 session 的某个变量值，如果不存在则设置一个\n\t\tconst char* sid = req.getSession().getAttribute(\"sid\");\n\t\tif (sid == NULL || *sid == 0)\n\t\t\treq.getSession().setAttribute(\"sid\", \"xxxxxx\");\n\n\t\t// 再取一次该浏览器用户的 session 的某个属性值\n\t\tsid = req.getSession().getAttribute(\"sid\");\n\n\t\t// 取得浏览器发来的两个 cookie 值\n\t\tconst char* cookie1 = req.getCookieValue(\"name1\");\n\t\tconst char* cookie2 = req.getCookieValue(\"name2\");\n\n\t\t// 开始创建 HTTP 响应头\n\n\t\t// 设置 cookie\n  \t\tres.addCookie(\"name1\", \"value1\");\n\n\t\t// 设置具有作用域和过期时间的 cookie\n\t\tres.addCookie(\"name2\", \"value2\", \".test.com\", \"/\", 3600 * 24);\n\t\t// res.setStatus(200);  // 可以设置返回的状态码\n\n\t\t// 两种方式都可以设置字符集\n\t\tif (0)\n\t\t\tres.setContentType(\"text/xml; charset=gb2312\");\n\t\telse {\n\t\t\t// 先设置数据类型\n\t\t\tres.setContentType(\"text/xml\");\n\n\t\t\t// 再设置数据字符集\n\t\t\tres.setCharacterEncoding(\"gb2312\");\n\t\t}\n\n\t\t// 获得浏览器请求的两个参数值\n\t\tconst char* param1 = req.getParameter(\"name1\");\n\t\tconst char* param2 = req.getParameter(\"name2\");\n\n\t\t// 创建 xml 格式的数据体\n\t\txml body;\n\t\tbody.get_root().add_child(\"root\", true)\n\t\t\t.add_child(\"sessions\", true)\n\t\t\t\t.add_child(\"session\", true)\n\t\t\t\t\t.add_attr(\"sid\", sid ? sid : \"null\")\n\t\t\t\t\t.get_parent()\n\t\t\t\t.get_parent()\n\t\t\t.add_child(\"cookies\", true)\n\t\t\t\t.add_child(\"cookie\", true)\n\t\t\t\t\t.add_attr(\"name1\", cookie1 ? cookie1 : \"null\")\n\t\t\t\t\t.get_parent()\n\t\t\t\t.add_child(\"cookie\", true)\n\t\t\t\t\t.add_attr(\"name2\", cookie2 ? cookie2 : \"null\")\n\t\t\t\t\t.get_parent()\n\t\t\t\t.get_parent()\n\t\t\t.add_child(\"params\", true)\n\t\t\t\t.add_child(\"param\", true)\n\t\t\t\t\t.add_attr(\"name1\", param1 ? param1 : \"null\")\n\t\t\t\t\t.get_parent()\n\t\t\t\t.add_child(\"param\", true)\n\t\t\t\t\t.add_attr(\"name2\", param2 ? param2 : \"null\");\n\t\tstring buf;\n\t\tbody.build_xml(buf);\n\t\t// 在http 响应头中设置数据体长度\n\t\tres.setContentLength(buf.length());\n\t\t// 发送 http 响应头\n\t\tif (res.sendHeader() == false)\n\t\t\treturn false;\n\t\t// 发送 http 响应体\n\t\tif (res.write(buf) == false)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nint main(void)\n{\n#ifdef WIN32\n\tacl::acl_cpp_init();  // win32 环境下需要初始化库\n#endif\n\n\thttp_servlet servle;\n\n\t// cgi 开始运行\n\tservlet.doRun(\"127.0.0.1:11211\");  // 开始运行，并设定 memcached 的服务地址为：127.0.0.1:11211\n\n\t// 运行完毕，程序退出\n\treturn 0;\n}\n```\n\n经常使用 Java HttpServlet 等类进行 web 编程的用户对上面的代码一定不会感到陌生，但它的的确确是一个 CGI 程序，可以放在 Apache 及支持 CGI 的 Webserver 下运行。当然，大家应该都清楚 CGI 在运行时因进程切换而导致了效率较为低下，在另一篇文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中展示了用上面的 http_servlet 类并结合 acl_cpp 的服务器模型实现的一个WEB服务器的例子，效率比 CGI 要高的多(效率也应比 FCGI高，因为其少了 Webserver 层的过滤)；文章《acl_cpp web 编程之文件上传 》中举例讲述了在服务端如何使用 acl_cpp 库处理浏览器上传文件的功能。\n\nacl 下载\ngithub: https://github.com/acl-dev/acl\ngitee: https://github.com/acl-dev/acl\n","source":"_posts/http_servlet.md","raw":"---\ntitle: 用C++实现类似于JAVA HttpServlet 的编程接口\ndate: 2012-05-20 13:08:24\ntags: http\ncategories: http开发\n---\n\n## 一、概述\n互联网刚兴起时，很多项目都是用 C /Perl 语言写的一大堆 CGI，一些老程序员可谓是偿尽了编程的苦，因为那时国内的技术水平普遍比较低，如果你会 CGI 编程，就已经算是行业中人了，如果你对 CGI 编程比较熟练，则就可以称得是“专家”了，后来技术不断进步，各种国外的新技术都进入中国并不断得到普及，CGI 就逐渐沦为一种落后的技术，后来的 PHP, JSP/Servlet, ASP 逐渐占领了 WEB 编程的技术市场，这个时候如果你说再用 C 写 CGI，别人会感觉是在和古人对话。现在主流的 WEB 开发语言一个很大的优势就是有各种相对成熟的基础库和框架，开发效率很高，而 CGI 则就逊色很多。当然，这些语言也得有执行效率相对较低的问题，毕竟它们都是脚本语言或半编译语言，需要虚拟机解释执行，象 facebook 的 WEB 前端基本都是用 PHP 写的，他们为了解决执行效率问题，在一位华人的领导下开发了可以将 PHP 代码转成 C++ 代码的工具（hiphop)，从而使执行效率大大提高，这也从另一个侧面反映出技术人员还是希望他们的程序能够运行的更快些。\n\n本文主要描述了 acl_cpp 库中有关 WEB 编程的方法类，为了使大家容易上手，其中的接口设计及命名尽量模仿 JAVA HttpServlet 等相关的类（希望 Oracle 不会告我侵权，呵呵）。如果您会用C/C++编程，同时又有使用 Java Servlet 进行 WEB 编程的经验，则该文您读起来一点不会费力，当然如果您多年从事 WEB 开发，我想理解这些类的设计及用法也不应该有什么难度。好了，下面就开始讲如何使用 acl_cpp 库中的 http/ 模块下的类进行 web 编程。\n\n在 acl_cpp/src/http 模块下，有几个类与 WEB 编程相关：HttpServlet，HttpServletRequest, HttpServletResponse, HttpSession, http_header, http_mime, http_client。如果您掌握了这几个类的用法，则进行 WEB 编程就不会有什么问题了，下面一一介绍这几个类：\n\n## 二、HttpServlet 类\n构造函数及析构函数：\n```c++\n\t/**\n\t * 构造函数\n\t */\n\tHttpServlet(void);\n\n\t/**\n\t * 纯虚析构函数，即该类必须由子类进行实例化\n\t */\n\tvirtual ~HttpServlet(void) = 0;\n```\n\n在构建函数中，为了支持 HttpSession 数据的存储，需要用户给出 memcached 的服务器地址（目前仅支持采用 memcached 来存储 session 数据，将来应该会扩展至可以支持 redis 等），同时用户还需要给出 session 的 cookie ID 标识符以发给浏览器。\n\n四个虚接口，需要子类实现以应对不同的浏览器的 HTTP 请求：\n```c++\n\t/**\n\t * 当 HTTP 请求为 GET 方式时的虚函数\n\t */\n\tvirtual bool doGet(HttpServletRequest&, HttpServletResponse&);\n\n\t/**\n\t * 当 HTTP 请求为 POST 方式时的虚函数\n\t */\n\tvirtual bool doPost(HttpServletRequest&, HttpServletResponse&);\n\n\t/**\n\t * 当 HTTP 请求为 PUT 方式时的虚函数\n\t */\n\tvirtual bool doPut(HttpServletRequest&, HttpServletResponse&);\n\n\t/**\n\t * 当 HTTP 请求为 CONNECT 方式时的虚函数\n\t */\n\tvirtual bool doConnect(HttpServletRequest&, HttpServletResponse&);\n\n\t/**\n\t * 当 HTTP 请求为 PURGE 方式时的虚函数，该方法在清除 SQUID 的缓存\n\t * 时会用到\n\t */\n\tvirtual bool doPurge(HttpServletRequest&, HttpServletResponse&);\n```\n\n用户实现的 HttpServlet 子类中可以实现以上几个虚接口的一个或者几个，以满足不同的 HTTP 请求。\n \n下面的函数为 HttpServlet 类开始运行的函数：\n```c++\n\t/**\n\t * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数\n\t * @param session {session&} 存储 session 数据的对象\n\t * @param stream {socket_stream*} 当在 acl_master 服务器框架控制下\n\t *  运行时，该参数必须非空；当在 apache 下以 CGI 方式运行时，该参数\n\t *  设为 NULL；另外，该函数内部不会关闭流连接，应用应自行处理流对象\n\t *  的关闭情况，这样可以方便与 acl_master 架构结合\n\t * @param body_parse {bool} 针对 POST 方法，该参数指定是否需要\n\t *  读取 HTTP 请求数据体并按 n/v 方式进行分析；当为 true 则内\n\t *  部会读取 HTTP 请求体数据，并进行分析，当用户调用 getParameter\n\t *  时，不仅可以获得 URL 中的参数，同时可以获得 POST 数据体中\n\t *  的参数；当该参数为 false 时则不读取数据体\n\t * @param body_limit {int} 针对 POST 方法，当数据体为文本参数\n\t *  类型时，此参数限制数据体的长度；当数据体为数据流或 MIME\n\t *  格式或 body_read 为 false，此参数无效\n\t * @return {bool} 返回处理结果\n\t */\n\tbool doRun(session& session, socket_stream* stream = NULL,\n\t\tbool body_parse = true, int body_limit = 102400);\n\n\t/**\n\t * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数，\n\t * 调用本函数意味着采用 memcached 来存储 session 数据\n\t * @param memcached_addr {const char*} memcached 服务器地址，格式：IP:PORT\n\t * @param stream {socket_stream*} 含义同上\n\t * @param body_parse {bool} 含义同上\n\t * @param body_limit {int} 含义同上\n\t * @return {bool} 返回处理结果\n\t */\n\tbool doRun(const char* memcached_addr = \"127.0.0.1:11211\",\n\t\tsocket_stream* stream = NULL,\n\t\tbool body_parse = true, int body_limit = 102400);\n\n```\n\n从上面五个虚方法中，可以看到两个重要的类：HttpServletRequest 和 HttpServletResponse。这两个类分别表示 http 请求类及 http 响应类，这两个类都是由 HttpServlet 类对象创建并释放的，所以用户不必创建和销毁这两个类对象实例。下面分别介绍这两个类：\n\n## 三、HttpServletRequest 类\n该类主要是与浏览器的请求过程相关，您可以通过该类的方法获得浏览器的请求数据。该类的方法比较多（基本上是参照了 java HttpServlet 的功能方法及名称），所以下面仅介绍几个主要的方法：\n\n```c++\n\t/**\n\t * 获得 HTTP 请求中的参数值，该值已经被 URL 解码且\n\t * 转换成本地要求的字符集；针对 GET 方法，则是获得\n\t * URL 中 ? 后面的参数值；针对 POST 方法，则可以获得\n\t * URL 中 ? 后面的参数值或请求体中的参数值\n\t */\n\tconst char* getParameter(const char* name) const;\n\n\t/**\n\t * 获得 HTTP 客户端请求的某个 cookie 值\n\t * @param name {const char*} cookie 名称，必须非空\n\t * @return {const char*} cookie 值，当返回 NULL 时表示\n\t *  cookie 值不存在\n\t */\n\tconst char* getCookieValue(const char* name) const;\n\n\t/**\n\t * 获得与该 HTTP 会话相关的 HttpSession 对象引用\n\t * @return {HttpSession&}\n\t */\n\tHttpSession& getSession(void);\n\n\t/**\n\t * 获得与 HTTP 客户端连接关联的输入流对象引用\n\t * @return {istream&}\n\t */\n\tistream& getInputStream(void) const;\n\n\t/**\n\t * 获得 HTTP 请求数据的数据长度\n\t * @return {acl_int64} 返回 -1 表示可能为 GET 方法，\n\t *  或 HTTP 请求头中没有 Content-Length 字段\n\t */\n#ifdef WIN32\n\t__int64 getContentLength(void) const;\n#else\n\tlong long int getContentLength(void) const;\n#endif\n\n\t/**\n\t * 当 HTTP 请求头中的 Content-Type 为\n\t * multipart/form-data; boundary=xxx 格式时，说明为文件上传\n\t * 数据类型，则可以通过此函数获得 http_mime 对象\n\t * @return {const http_mime*} 返回 NULL 则说明没有 MIME 对象，\n\t *  返回的值用户不能手工释放，因为在 HttpServletRequest 的析\n\t *  构中会自动释放\n\t */\n\thttp_mime* getHttpMime(void) const;\n\n\t/**\n\t * 获得 HTTP 请求数据的类型\n\t * @return {http_request_t}，一般对 POST 方法中的上传\n\t *  文件应用而言，需要调用该函数获得是否是上传数据类型\n\t */\n\thttp_request_t getRequestType(void) const;\n```\n\n以上方法一般都是我们在实际对 HttpServletRequest 类方法使用过程中用得较多的。如：\n\n```\n    getParmeter： 用来获得 http 请求参数\n    getCookieValue：获得浏览器的 cookie 值\n    getSession：获得该 HttpServlet 类对象的 session 会话\n    getInputStream：获得 http 连接的输入流\n    getContentLength：针对 HTTP POST 请求，此函数获得 HTTP 请求数据体的长度\n    getRequestType：针对 HTTP POST 请求，此函数返回 HTTP 请求数据体的传输方式（普通的 name=value 方式，multipart 上传文件格式以及数据流格式）\n```\n \n## 四、HttpServletResponse 类\n该类主要与将您写的程序将处理数据结果返回给浏览器的过程相关，下面也仅介绍该类的一些常用的函数，如果您需要更多的功能，请参数 HttpServletResponse.hpp 头文件。\n\n```c++\n\t/**\n\t * 设置 HTTP 响应数据体的 Content-Type 字段值，可字段值可以为：\n\t * text/html 或 text/html; charset=utf8 格式\n\t * @param value {const char*} 字段值\n\t */\n\tvoid setContentType(const char* value);\n\n\t/**\n\t * 设置 HTTP 响应数据体中字符集，当已经在 setContentType 设置\n\t * 了字符集，则就不必再调用本函数设置字符集\n\t * @param charset {const char*} 响应体数据的字符集\n\t */\n\tvoid setCharacterEncoding(const char* charset);\n\n\t/**\n\t * 设置 HTTP 响应头中的状态码：1xx, 2xx, 3xx, 4xx, 5xx\n\t * @param status {int} HTTP 响应状态码, 如：200\n\t */\n\tvoid setStatus(int status);\n\n\t/**\n\t * 添加 cookie\n\t * @param name {const char*} cookie 名\n\t * @param value {const char*} cookie 值\n\t * @param domain {const char*} cookie 存储域\n\t * @param path {const char*} cookie 存储路径\n\t * @param expires {time_t} cookie 过期时间间隔，当当前时间加\n\t *  该值为 cookie 的过期时间截(秒)\n\t */\n\tvoid addCookie(const char* name, const char* value,\n\t\tconst char* domain = NULL, const char* path = NULL, time_t expires = 0);\n\n\t/**\n\t * 发送 HTTP 响应头，用户应该发送数据体前调用此函数将 HTTP\n\t * 响应头发送给客户端\n\t */\n\tbool sendHeader(void);\n\n\t/**\n\t * 获得 HTTP 响应对象的输出流对象，用户在调用 sendHeader 发送\n\t * 完 HTTP 响应头后，通过该输出流来发送 HTTP 数据体\n\t * @return {ostream&}\n\t */\n\tostream& getOutputStream(void) const;\n```\n\n- setCharacterEncoding：该方法设置 HTTP 响应头的 HTTP 数据体的字符集，如果通过该函数设置了字符集，即使您在返回的 html 数据中重新设置了其它的字符集，浏览器也会优先使用 HTTP 响应头中设置的字符集，所以用户一定得注意这点；\n- setContentType：该方法用来设置 HTTP 响应头中的 Content-Type 字段，对于 xml 数据则设置 text/xml，对 html 数据则设置 text/html，当然您也可以设置 image/jpeg 等数据类型；当然，您也可以直接通过该方法在设置数据类型的同时指定数据的字符集，如可以直接写：setContentType(\"text/html; charset=utf8\")，这个用法等同于：setContentType(\"text/html\"); setCharacterEncoding(\"utf8\")。\n- setStatus：设置 HTTP 响应头的状态码（一般不用设置状态码，除非是您确实需要单独设置）；\n- addCookie：在 HTTP 响应头中添加 cookie 内容；\n- sendHeader：发送 HTTP 响应头；\n- getOutputStream：该函数返回输出流对象，您可以向输出流中直接写 HTTP 响应的数据体（关于 ostream 类的使用请参数头文件：include/ostream.hpp）。\n\n除了以上三个类外，还有一个类比较重要：HttpSession 类，该类主要实现与 session 会话相关的功能：\n\n## 五、HttpSession 类\n该类对象实例用户也不必创建与释放，在 HttpServet 类对象内容自动管理该类对象实例。主要用的方法有：\n```c++\n\t/**\n\t * 获得客户端在服务端存储的对应 session 变量名，子类可以重载该方法\n\t * @param name {const char*} session 名，非空\n\t * @return {const char*} session 值，为空说明不存在或内部\n\t *  查询失败\n\t */\n\tvirtual const char* getAttribute(const char* name) const;\n\n\t/**\n\t * 设置服务端对应 session 名的 session 值，子类可以重载该方法\n\t * @param name {const char*} session 名，非空\n\t * @param name {const char*} session 值，非空\n\t * @return {bool} 返回 false 说明设置失败\n\t */\n\tvirtual bool setAttribute(const char* name, const char* value);\n```\n\n只所以将这两个方法声明为虚方法，是因为 HttpSession 的 session 数据存储目前仅支持 memcached，您如果有精力的话可以实现一个子类用来支持其它的数据存储方式。当然您也可以在您实现的子类中实现自己的产生唯一 session id 的方法，即实现如下虚方法：\n\n```c++\nprotected:\n\t/**\n\t * 创建某个 session 会话的唯一 ID 号，子类可以重载该方法\n\t * @param buf {char*} 存储结果缓冲区\n\t * @param len {size_t} buf 缓冲区大小，buf 缓冲区大小建议\n\t *  64 字节左右\n\t */\n\tvirtual void createSid(char* buf, size_t len);\n```\n\n好了，上面说了一大堆类及类函数，下面还是以一个具体的示例来说明这些类的用法：\n\n## 六、示例\n下面的例子是一个 CGI 例子，编译后可执行程序可以直接放在 apache 的 cgi-bin/ 目录，用户可以用浏览器访问。\n\n```c++\n// http_servlet.cpp : 定义控制台应用程序的入口点。\n//\n\n#include \"lib_acl.hpp\"\nusing namespace acl;\n\n//////////////////////////////////////////////////////////////////////////\n\nclass http_servlet : public HttpServlet\n{\npublic:\n\thttp_servlet(void)\n\t{\n\t}\n\n\t~http_servlet(void)\n\t{\n\t}\n\n\t// 实现处理 HTTP GET 请求的功能函数\n\tbool doGet(HttpServletRequest& req, HttpServletResponse& res)\n\t{\n\t\treturn doPost(req, res);\n\t}\n\n\t// 实现处理 HTTP POST 请求的功能函数\n\tbool doPost(HttpServletRequest& req, HttpServletResponse& res)\n\t{\n\t\t// 获得某浏览器用户的 session 的某个变量值，如果不存在则设置一个\n\t\tconst char* sid = req.getSession().getAttribute(\"sid\");\n\t\tif (sid == NULL || *sid == 0)\n\t\t\treq.getSession().setAttribute(\"sid\", \"xxxxxx\");\n\n\t\t// 再取一次该浏览器用户的 session 的某个属性值\n\t\tsid = req.getSession().getAttribute(\"sid\");\n\n\t\t// 取得浏览器发来的两个 cookie 值\n\t\tconst char* cookie1 = req.getCookieValue(\"name1\");\n\t\tconst char* cookie2 = req.getCookieValue(\"name2\");\n\n\t\t// 开始创建 HTTP 响应头\n\n\t\t// 设置 cookie\n  \t\tres.addCookie(\"name1\", \"value1\");\n\n\t\t// 设置具有作用域和过期时间的 cookie\n\t\tres.addCookie(\"name2\", \"value2\", \".test.com\", \"/\", 3600 * 24);\n\t\t// res.setStatus(200);  // 可以设置返回的状态码\n\n\t\t// 两种方式都可以设置字符集\n\t\tif (0)\n\t\t\tres.setContentType(\"text/xml; charset=gb2312\");\n\t\telse {\n\t\t\t// 先设置数据类型\n\t\t\tres.setContentType(\"text/xml\");\n\n\t\t\t// 再设置数据字符集\n\t\t\tres.setCharacterEncoding(\"gb2312\");\n\t\t}\n\n\t\t// 获得浏览器请求的两个参数值\n\t\tconst char* param1 = req.getParameter(\"name1\");\n\t\tconst char* param2 = req.getParameter(\"name2\");\n\n\t\t// 创建 xml 格式的数据体\n\t\txml body;\n\t\tbody.get_root().add_child(\"root\", true)\n\t\t\t.add_child(\"sessions\", true)\n\t\t\t\t.add_child(\"session\", true)\n\t\t\t\t\t.add_attr(\"sid\", sid ? sid : \"null\")\n\t\t\t\t\t.get_parent()\n\t\t\t\t.get_parent()\n\t\t\t.add_child(\"cookies\", true)\n\t\t\t\t.add_child(\"cookie\", true)\n\t\t\t\t\t.add_attr(\"name1\", cookie1 ? cookie1 : \"null\")\n\t\t\t\t\t.get_parent()\n\t\t\t\t.add_child(\"cookie\", true)\n\t\t\t\t\t.add_attr(\"name2\", cookie2 ? cookie2 : \"null\")\n\t\t\t\t\t.get_parent()\n\t\t\t\t.get_parent()\n\t\t\t.add_child(\"params\", true)\n\t\t\t\t.add_child(\"param\", true)\n\t\t\t\t\t.add_attr(\"name1\", param1 ? param1 : \"null\")\n\t\t\t\t\t.get_parent()\n\t\t\t\t.add_child(\"param\", true)\n\t\t\t\t\t.add_attr(\"name2\", param2 ? param2 : \"null\");\n\t\tstring buf;\n\t\tbody.build_xml(buf);\n\t\t// 在http 响应头中设置数据体长度\n\t\tres.setContentLength(buf.length());\n\t\t// 发送 http 响应头\n\t\tif (res.sendHeader() == false)\n\t\t\treturn false;\n\t\t// 发送 http 响应体\n\t\tif (res.write(buf) == false)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nint main(void)\n{\n#ifdef WIN32\n\tacl::acl_cpp_init();  // win32 环境下需要初始化库\n#endif\n\n\thttp_servlet servle;\n\n\t// cgi 开始运行\n\tservlet.doRun(\"127.0.0.1:11211\");  // 开始运行，并设定 memcached 的服务地址为：127.0.0.1:11211\n\n\t// 运行完毕，程序退出\n\treturn 0;\n}\n```\n\n经常使用 Java HttpServlet 等类进行 web 编程的用户对上面的代码一定不会感到陌生，但它的的确确是一个 CGI 程序，可以放在 Apache 及支持 CGI 的 Webserver 下运行。当然，大家应该都清楚 CGI 在运行时因进程切换而导致了效率较为低下，在另一篇文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中展示了用上面的 http_servlet 类并结合 acl_cpp 的服务器模型实现的一个WEB服务器的例子，效率比 CGI 要高的多(效率也应比 FCGI高，因为其少了 Webserver 层的过滤)；文章《acl_cpp web 编程之文件上传 》中举例讲述了在服务端如何使用 acl_cpp 库处理浏览器上传文件的功能。\n\nacl 下载\ngithub: https://github.com/acl-dev/acl\ngitee: https://github.com/acl-dev/acl\n","slug":"http_servlet","published":1,"updated":"2023-01-23T14:03:08.806Z","_id":"cld8tqdmt0000bx9k8pa70tko","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>互联网刚兴起时，很多项目都是用 C &#x2F;Perl 语言写的一大堆 CGI，一些老程序员可谓是偿尽了编程的苦，因为那时国内的技术水平普遍比较低，如果你会 CGI 编程，就已经算是行业中人了，如果你对 CGI 编程比较熟练，则就可以称得是“专家”了，后来技术不断进步，各种国外的新技术都进入中国并不断得到普及，CGI 就逐渐沦为一种落后的技术，后来的 PHP, JSP&#x2F;Servlet, ASP 逐渐占领了 WEB 编程的技术市场，这个时候如果你说再用 C 写 CGI，别人会感觉是在和古人对话。现在主流的 WEB 开发语言一个很大的优势就是有各种相对成熟的基础库和框架，开发效率很高，而 CGI 则就逊色很多。当然，这些语言也得有执行效率相对较低的问题，毕竟它们都是脚本语言或半编译语言，需要虚拟机解释执行，象 facebook 的 WEB 前端基本都是用 PHP 写的，他们为了解决执行效率问题，在一位华人的领导下开发了可以将 PHP 代码转成 C++ 代码的工具（hiphop)，从而使执行效率大大提高，这也从另一个侧面反映出技术人员还是希望他们的程序能够运行的更快些。</p>\n<p>本文主要描述了 acl_cpp 库中有关 WEB 编程的方法类，为了使大家容易上手，其中的接口设计及命名尽量模仿 JAVA HttpServlet 等相关的类（希望 Oracle 不会告我侵权，呵呵）。如果您会用C&#x2F;C++编程，同时又有使用 Java Servlet 进行 WEB 编程的经验，则该文您读起来一点不会费力，当然如果您多年从事 WEB 开发，我想理解这些类的设计及用法也不应该有什么难度。好了，下面就开始讲如何使用 acl_cpp 库中的 http&#x2F; 模块下的类进行 web 编程。</p>\n<p>在 acl_cpp&#x2F;src&#x2F;http 模块下，有几个类与 WEB 编程相关：HttpServlet，HttpServletRequest, HttpServletResponse, HttpSession, http_header, http_mime, http_client。如果您掌握了这几个类的用法，则进行 WEB 编程就不会有什么问题了，下面一一介绍这几个类：</p>\n<h2 id=\"二、HttpServlet-类\"><a href=\"#二、HttpServlet-类\" class=\"headerlink\" title=\"二、HttpServlet 类\"></a>二、HttpServlet 类</h2><p>构造函数及析构函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构造函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">HttpServlet</span>(<span class=\"hljs-type\">void</span>);<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 纯虚析构函数，即该类必须由子类进行实例化</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">HttpServlet</span>(<span class=\"hljs-type\">void</span>) = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n\n<p>在构建函数中，为了支持 HttpSession 数据的存储，需要用户给出 memcached 的服务器地址（目前仅支持采用 memcached 来存储 session 数据，将来应该会扩展至可以支持 redis 等），同时用户还需要给出 session 的 cookie ID 标识符以发给浏览器。</p>\n<p>四个虚接口，需要子类实现以应对不同的浏览器的 HTTP 请求：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 GET 方式时的虚函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doGet</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 POST 方式时的虚函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 PUT 方式时的虚函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPut</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 CONNECT 方式时的虚函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doConnect</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 PURGE 方式时的虚函数，该方法在清除 SQUID 的缓存</span><br><span class=\"hljs-comment\"> * 时会用到</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPurge</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>用户实现的 HttpServlet 子类中可以实现以上几个虚接口的一个或者几个，以满足不同的 HTTP 请求。</p>\n<p>下面的函数为 HttpServlet 类开始运行的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数</span><br><span class=\"hljs-comment\"> * @param session &#123;session&amp;&#125; 存储 session 数据的对象</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125; 当在 acl_master 服务器框架控制下</span><br><span class=\"hljs-comment\"> *  运行时，该参数必须非空；当在 apache 下以 CGI 方式运行时，该参数</span><br><span class=\"hljs-comment\"> *  设为 NULL；另外，该函数内部不会关闭流连接，应用应自行处理流对象</span><br><span class=\"hljs-comment\"> *  的关闭情况，这样可以方便与 acl_master 架构结合</span><br><span class=\"hljs-comment\"> * @param body_parse &#123;bool&#125; 针对 POST 方法，该参数指定是否需要</span><br><span class=\"hljs-comment\"> *  读取 HTTP 请求数据体并按 n/v 方式进行分析；当为 true 则内</span><br><span class=\"hljs-comment\"> *  部会读取 HTTP 请求体数据，并进行分析，当用户调用 getParameter</span><br><span class=\"hljs-comment\"> *  时，不仅可以获得 URL 中的参数，同时可以获得 POST 数据体中</span><br><span class=\"hljs-comment\"> *  的参数；当该参数为 false 时则不读取数据体</span><br><span class=\"hljs-comment\"> * @param body_limit &#123;int&#125; 针对 POST 方法，当数据体为文本参数</span><br><span class=\"hljs-comment\"> *  类型时，此参数限制数据体的长度；当数据体为数据流或 MIME</span><br><span class=\"hljs-comment\"> *  格式或 body_read 为 false，此参数无效</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回处理结果</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doRun</span><span class=\"hljs-params\">(session&amp; session, socket_stream* stream = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">bool</span> body_parse = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">int</span> body_limit = <span class=\"hljs-number\">102400</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数，</span><br><span class=\"hljs-comment\"> * 调用本函数意味着采用 memcached 来存储 session 数据</span><br><span class=\"hljs-comment\"> * @param memcached_addr &#123;const char*&#125; memcached 服务器地址，格式：IP:PORT</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125; 含义同上</span><br><span class=\"hljs-comment\"> * @param body_parse &#123;bool&#125; 含义同上</span><br><span class=\"hljs-comment\"> * @param body_limit &#123;int&#125; 含义同上</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回处理结果</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doRun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* memcached_addr = <span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\tsocket_stream* stream = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">bool</span> body_parse = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">int</span> body_limit = <span class=\"hljs-number\">102400</span>)</span></span>;<br><br></code></pre></td></tr></table></figure>\n\n<p>从上面五个虚方法中，可以看到两个重要的类：HttpServletRequest 和 HttpServletResponse。这两个类分别表示 http 请求类及 http 响应类，这两个类都是由 HttpServlet 类对象创建并释放的，所以用户不必创建和销毁这两个类对象实例。下面分别介绍这两个类：</p>\n<h2 id=\"三、HttpServletRequest-类\"><a href=\"#三、HttpServletRequest-类\" class=\"headerlink\" title=\"三、HttpServletRequest 类\"></a>三、HttpServletRequest 类</h2><p>该类主要是与浏览器的请求过程相关，您可以通过该类的方法获得浏览器的请求数据。该类的方法比较多（基本上是参照了 java HttpServlet 的功能方法及名称），所以下面仅介绍几个主要的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 请求中的参数值，该值已经被 URL 解码且</span><br><span class=\"hljs-comment\">\t * 转换成本地要求的字符集；针对 GET 方法，则是获得</span><br><span class=\"hljs-comment\">\t * URL 中 ? 后面的参数值；针对 POST 方法，则可以获得</span><br><span class=\"hljs-comment\">\t * URL 中 ? 后面的参数值或请求体中的参数值</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">getParameter</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 客户端请求的某个 cookie 值</span><br><span class=\"hljs-comment\">\t * @param name &#123;const char*&#125; cookie 名称，必须非空</span><br><span class=\"hljs-comment\">\t * @return &#123;const char*&#125; cookie 值，当返回 NULL 时表示</span><br><span class=\"hljs-comment\">\t *  cookie 值不存在</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">getCookieValue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得与该 HTTP 会话相关的 HttpSession 对象引用</span><br><span class=\"hljs-comment\">\t * @return &#123;HttpSession&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">HttpSession&amp; <span class=\"hljs-title\">getSession</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得与 HTTP 客户端连接关联的输入流对象引用</span><br><span class=\"hljs-comment\">\t * @return &#123;istream&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">istream&amp; <span class=\"hljs-title\">getInputStream</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 请求数据的数据长度</span><br><span class=\"hljs-comment\">\t * @return &#123;acl_int64&#125; 返回 -1 表示可能为 GET 方法，</span><br><span class=\"hljs-comment\">\t *  或 HTTP 请求头中没有 Content-Length 字段</span><br><span class=\"hljs-comment\">\t */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t<span class=\"hljs-function\">__int64 <span class=\"hljs-title\">getContentLength</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getContentLength</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 当 HTTP 请求头中的 Content-Type 为</span><br><span class=\"hljs-comment\">\t * multipart/form-data; boundary=xxx 格式时，说明为文件上传</span><br><span class=\"hljs-comment\">\t * 数据类型，则可以通过此函数获得 http_mime 对象</span><br><span class=\"hljs-comment\">\t * @return &#123;const http_mime*&#125; 返回 NULL 则说明没有 MIME 对象，</span><br><span class=\"hljs-comment\">\t *  返回的值用户不能手工释放，因为在 HttpServletRequest 的析</span><br><span class=\"hljs-comment\">\t *  构中会自动释放</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">http_mime* <span class=\"hljs-title\">getHttpMime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 请求数据的类型</span><br><span class=\"hljs-comment\">\t * @return &#123;http_request_t&#125;，一般对 POST 方法中的上传</span><br><span class=\"hljs-comment\">\t *  文件应用而言，需要调用该函数获得是否是上传数据类型</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">http_request_t</span> <span class=\"hljs-title\">getRequestType</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>以上方法一般都是我们在实际对 HttpServletRequest 类方法使用过程中用得较多的。如：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">getParmeter： 用来获得 <span class=\"hljs-keyword\">http</span> 请求参数<br>getCookieValue：获得浏览器的 cookie 值<br>getSession：获得该 HttpServlet 类对象的 session 会话<br>getInputStream：获得 <span class=\"hljs-keyword\">http</span> 连接的输入流<br>getContentLength：针对 HTTP POST 请求，此函数获得 HTTP 请求数据体的长度<br>getRequestType：针对 HTTP POST 请求，此函数返回 HTTP 请求数据体的传输方式（普通的 name=<span class=\"hljs-built_in\">value</span> 方式，multipart 上传文件格式以及数据流格式）<br></code></pre></td></tr></table></figure>\n<h2 id=\"四、HttpServletResponse-类\"><a href=\"#四、HttpServletResponse-类\" class=\"headerlink\" title=\"四、HttpServletResponse 类\"></a>四、HttpServletResponse 类</h2><p>该类主要与将您写的程序将处理数据结果返回给浏览器的过程相关，下面也仅介绍该类的一些常用的函数，如果您需要更多的功能，请参数 HttpServletResponse.hpp 头文件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 响应数据体的 Content-Type 字段值，可字段值可以为：</span><br><span class=\"hljs-comment\"> * text/html 或 text/html; charset=utf8 格式</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; 字段值</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setContentType</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 响应数据体中字符集，当已经在 setContentType 设置</span><br><span class=\"hljs-comment\"> * 了字符集，则就不必再调用本函数设置字符集</span><br><span class=\"hljs-comment\"> * @param charset &#123;const char*&#125; 响应体数据的字符集</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setCharacterEncoding</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* charset)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 响应头中的状态码：1xx, 2xx, 3xx, 4xx, 5xx</span><br><span class=\"hljs-comment\"> * @param status &#123;int&#125; HTTP 响应状态码, 如：200</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setStatus</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> status)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 添加 cookie</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; cookie 名</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; cookie 值</span><br><span class=\"hljs-comment\"> * @param domain &#123;const char*&#125; cookie 存储域</span><br><span class=\"hljs-comment\"> * @param path &#123;const char*&#125; cookie 存储路径</span><br><span class=\"hljs-comment\"> * @param expires &#123;time_t&#125; cookie 过期时间间隔，当当前时间加</span><br><span class=\"hljs-comment\"> *  该值为 cookie 的过期时间截(秒)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addCookie</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* domain = <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* path = <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-type\">time_t</span> expires = <span class=\"hljs-number\">0</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 发送 HTTP 响应头，用户应该发送数据体前调用此函数将 HTTP</span><br><span class=\"hljs-comment\"> * 响应头发送给客户端</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">sendHeader</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得 HTTP 响应对象的输出流对象，用户在调用 sendHeader 发送</span><br><span class=\"hljs-comment\"> * 完 HTTP 响应头后，通过该输出流来发送 HTTP 数据体</span><br><span class=\"hljs-comment\"> * @return &#123;ostream&amp;&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ostream&amp; <span class=\"hljs-title\">getOutputStream</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>setCharacterEncoding：该方法设置 HTTP 响应头的 HTTP 数据体的字符集，如果通过该函数设置了字符集，即使您在返回的 html 数据中重新设置了其它的字符集，浏览器也会优先使用 HTTP 响应头中设置的字符集，所以用户一定得注意这点；</li>\n<li>setContentType：该方法用来设置 HTTP 响应头中的 Content-Type 字段，对于 xml 数据则设置 text&#x2F;xml，对 html 数据则设置 text&#x2F;html，当然您也可以设置 image&#x2F;jpeg 等数据类型；当然，您也可以直接通过该方法在设置数据类型的同时指定数据的字符集，如可以直接写：setContentType(“text&#x2F;html; charset&#x3D;utf8”)，这个用法等同于：setContentType(“text&#x2F;html”); setCharacterEncoding(“utf8”)。</li>\n<li>setStatus：设置 HTTP 响应头的状态码（一般不用设置状态码，除非是您确实需要单独设置）；</li>\n<li>addCookie：在 HTTP 响应头中添加 cookie 内容；</li>\n<li>sendHeader：发送 HTTP 响应头；</li>\n<li>getOutputStream：该函数返回输出流对象，您可以向输出流中直接写 HTTP 响应的数据体（关于 ostream 类的使用请参数头文件：include&#x2F;ostream.hpp）。</li>\n</ul>\n<p>除了以上三个类外，还有一个类比较重要：HttpSession 类，该类主要实现与 session 会话相关的功能：</p>\n<h2 id=\"五、HttpSession-类\"><a href=\"#五、HttpSession-类\" class=\"headerlink\" title=\"五、HttpSession 类\"></a>五、HttpSession 类</h2><p>该类对象实例用户也不必创建与释放，在 HttpServet 类对象内容自动管理该类对象实例。主要用的方法有：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得客户端在服务端存储的对应 session 变量名，子类可以重载该方法</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; session 名，非空</span><br><span class=\"hljs-comment\"> * @return &#123;const char*&#125; session 值，为空说明不存在或内部</span><br><span class=\"hljs-comment\"> *  查询失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">getAttribute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置服务端对应 session 名的 session 值，子类可以重载该方法</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; session 名，非空</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; session 值，非空</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 false 说明设置失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">setAttribute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>只所以将这两个方法声明为虚方法，是因为 HttpSession 的 session 数据存储目前仅支持 memcached，您如果有精力的话可以实现一个子类用来支持其它的数据存储方式。当然您也可以在您实现的子类中实现自己的产生唯一 session id 的方法，即实现如下虚方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 创建某个 session 会话的唯一 ID 号，子类可以重载该方法</span><br><span class=\"hljs-comment\">\t * @param buf &#123;char*&#125; 存储结果缓冲区</span><br><span class=\"hljs-comment\">\t * @param len &#123;size_t&#125; buf 缓冲区大小，buf 缓冲区大小建议</span><br><span class=\"hljs-comment\">\t *  64 字节左右</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">createSid</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* buf, <span class=\"hljs-type\">size_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>好了，上面说了一大堆类及类函数，下面还是以一个具体的示例来说明这些类的用法：</p>\n<h2 id=\"六、示例\"><a href=\"#六、示例\" class=\"headerlink\" title=\"六、示例\"></a>六、示例</h2><p>下面的例子是一个 CGI 例子，编译后可执行程序可以直接放在 apache 的 cgi-bin&#x2F; 目录，用户可以用浏览器访问。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// http_servlet.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.hpp&quot;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_servlet</span> : <span class=\"hljs-keyword\">public</span> HttpServlet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_servlet</span>(<span class=\"hljs-type\">void</span>)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">http_servlet</span>(<span class=\"hljs-type\">void</span>)<br>\t&#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 实现处理 HTTP GET 请求的功能函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doGet</span><span class=\"hljs-params\">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">doPost</span>(req, res);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 实现处理 HTTP POST 请求的功能函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 获得某浏览器用户的 session 的某个变量值，如果不存在则设置一个</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* sid = req.<span class=\"hljs-built_in\">getSession</span>().<span class=\"hljs-built_in\">getAttribute</span>(<span class=\"hljs-string\">&quot;sid&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (sid == <span class=\"hljs-literal\">NULL</span> || *sid == <span class=\"hljs-number\">0</span>)<br>\t\t\treq.<span class=\"hljs-built_in\">getSession</span>().<span class=\"hljs-built_in\">setAttribute</span>(<span class=\"hljs-string\">&quot;sid&quot;</span>, <span class=\"hljs-string\">&quot;xxxxxx&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 再取一次该浏览器用户的 session 的某个属性值</span><br>\t\tsid = req.<span class=\"hljs-built_in\">getSession</span>().<span class=\"hljs-built_in\">getAttribute</span>(<span class=\"hljs-string\">&quot;sid&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 取得浏览器发来的两个 cookie 值</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* cookie1 = req.<span class=\"hljs-built_in\">getCookieValue</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>);<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* cookie2 = req.<span class=\"hljs-built_in\">getCookieValue</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 开始创建 HTTP 响应头</span><br><br>\t\t<span class=\"hljs-comment\">// 设置 cookie</span><br>  \t\tres.<span class=\"hljs-built_in\">addCookie</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>, <span class=\"hljs-string\">&quot;value1&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 设置具有作用域和过期时间的 cookie</span><br>\t\tres.<span class=\"hljs-built_in\">addCookie</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>, <span class=\"hljs-string\">&quot;value2&quot;</span>, <span class=\"hljs-string\">&quot;.test.com&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-number\">3600</span> * <span class=\"hljs-number\">24</span>);<br>\t\t<span class=\"hljs-comment\">// res.setStatus(200);  // 可以设置返回的状态码</span><br><br>\t\t<span class=\"hljs-comment\">// 两种方式都可以设置字符集</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>)<br>\t\t\tres.<span class=\"hljs-built_in\">setContentType</span>(<span class=\"hljs-string\">&quot;text/xml; charset=gb2312&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-comment\">// 先设置数据类型</span><br>\t\t\tres.<span class=\"hljs-built_in\">setContentType</span>(<span class=\"hljs-string\">&quot;text/xml&quot;</span>);<br><br>\t\t\t<span class=\"hljs-comment\">// 再设置数据字符集</span><br>\t\t\tres.<span class=\"hljs-built_in\">setCharacterEncoding</span>(<span class=\"hljs-string\">&quot;gb2312&quot;</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 获得浏览器请求的两个参数值</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* param1 = req.<span class=\"hljs-built_in\">getParameter</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>);<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* param2 = req.<span class=\"hljs-built_in\">getParameter</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 创建 xml 格式的数据体</span><br>\t\txml body;<br>\t\tbody.<span class=\"hljs-built_in\">get_root</span>().<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;root&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;sessions&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;session&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;sid&quot;</span>, sid ? sid : <span class=\"hljs-string\">&quot;null&quot;</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;cookies&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;cookie&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>, cookie1 ? cookie1 : <span class=\"hljs-string\">&quot;null&quot;</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;cookie&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>, cookie2 ? cookie2 : <span class=\"hljs-string\">&quot;null&quot;</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;params&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;param&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>, param1 ? param1 : <span class=\"hljs-string\">&quot;null&quot;</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;param&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>, param2 ? param2 : <span class=\"hljs-string\">&quot;null&quot;</span>);<br>\t\tstring buf;<br>\t\tbody.<span class=\"hljs-built_in\">build_xml</span>(buf);<br>\t\t<span class=\"hljs-comment\">// 在http 响应头中设置数据体长度</span><br>\t\tres.<span class=\"hljs-built_in\">setContentLength</span>(buf.<span class=\"hljs-built_in\">length</span>());<br>\t\t<span class=\"hljs-comment\">// 发送 http 响应头</span><br>\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-built_in\">sendHeader</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-comment\">// 发送 http 响应体</span><br>\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-built_in\">write</span>(buf) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();  <span class=\"hljs-comment\">// win32 环境下需要初始化库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>\thttp_servlet servle;<br><br>\t<span class=\"hljs-comment\">// cgi 开始运行</span><br>\tservlet.<span class=\"hljs-built_in\">doRun</span>(<span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>);  <span class=\"hljs-comment\">// 开始运行，并设定 memcached 的服务地址为：127.0.0.1:11211</span><br><br>\t<span class=\"hljs-comment\">// 运行完毕，程序退出</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>经常使用 Java HttpServlet 等类进行 web 编程的用户对上面的代码一定不会感到陌生，但它的的确确是一个 CGI 程序，可以放在 Apache 及支持 CGI 的 Webserver 下运行。当然，大家应该都清楚 CGI 在运行时因进程切换而导致了效率较为低下，在另一篇文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中展示了用上面的 http_servlet 类并结合 acl_cpp 的服务器模型实现的一个WEB服务器的例子，效率比 CGI 要高的多(效率也应比 FCGI高，因为其少了 Webserver 层的过滤)；文章《acl_cpp web 编程之文件上传 》中举例讲述了在服务端如何使用 acl_cpp 库处理浏览器上传文件的功能。</p>\n<p>acl 下载<br>github: <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee: <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>互联网刚兴起时，很多项目都是用 C &#x2F;Perl 语言写的一大堆 CGI，一些老程序员可谓是偿尽了编程的苦，因为那时国内的技术水平普遍比较低，如果你会 CGI 编程，就已经算是行业中人了，如果你对 CGI 编程比较熟练，则就可以称得是“专家”了，后来技术不断进步，各种国外的新技术都进入中国并不断得到普及，CGI 就逐渐沦为一种落后的技术，后来的 PHP, JSP&#x2F;Servlet, ASP 逐渐占领了 WEB 编程的技术市场，这个时候如果你说再用 C 写 CGI，别人会感觉是在和古人对话。现在主流的 WEB 开发语言一个很大的优势就是有各种相对成熟的基础库和框架，开发效率很高，而 CGI 则就逊色很多。当然，这些语言也得有执行效率相对较低的问题，毕竟它们都是脚本语言或半编译语言，需要虚拟机解释执行，象 facebook 的 WEB 前端基本都是用 PHP 写的，他们为了解决执行效率问题，在一位华人的领导下开发了可以将 PHP 代码转成 C++ 代码的工具（hiphop)，从而使执行效率大大提高，这也从另一个侧面反映出技术人员还是希望他们的程序能够运行的更快些。</p>\n<p>本文主要描述了 acl_cpp 库中有关 WEB 编程的方法类，为了使大家容易上手，其中的接口设计及命名尽量模仿 JAVA HttpServlet 等相关的类（希望 Oracle 不会告我侵权，呵呵）。如果您会用C&#x2F;C++编程，同时又有使用 Java Servlet 进行 WEB 编程的经验，则该文您读起来一点不会费力，当然如果您多年从事 WEB 开发，我想理解这些类的设计及用法也不应该有什么难度。好了，下面就开始讲如何使用 acl_cpp 库中的 http&#x2F; 模块下的类进行 web 编程。</p>\n<p>在 acl_cpp&#x2F;src&#x2F;http 模块下，有几个类与 WEB 编程相关：HttpServlet，HttpServletRequest, HttpServletResponse, HttpSession, http_header, http_mime, http_client。如果您掌握了这几个类的用法，则进行 WEB 编程就不会有什么问题了，下面一一介绍这几个类：</p>\n<h2 id=\"二、HttpServlet-类\"><a href=\"#二、HttpServlet-类\" class=\"headerlink\" title=\"二、HttpServlet 类\"></a>二、HttpServlet 类</h2><p>构造函数及析构函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构造函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">HttpServlet</span>(<span class=\"hljs-type\">void</span>);<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 纯虚析构函数，即该类必须由子类进行实例化</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">HttpServlet</span>(<span class=\"hljs-type\">void</span>) = <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n\n<p>在构建函数中，为了支持 HttpSession 数据的存储，需要用户给出 memcached 的服务器地址（目前仅支持采用 memcached 来存储 session 数据，将来应该会扩展至可以支持 redis 等），同时用户还需要给出 session 的 cookie ID 标识符以发给浏览器。</p>\n<p>四个虚接口，需要子类实现以应对不同的浏览器的 HTTP 请求：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 GET 方式时的虚函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doGet</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 POST 方式时的虚函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 PUT 方式时的虚函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPut</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 CONNECT 方式时的虚函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doConnect</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 HTTP 请求为 PURGE 方式时的虚函数，该方法在清除 SQUID 的缓存</span><br><span class=\"hljs-comment\"> * 时会用到</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPurge</span><span class=\"hljs-params\">(HttpServletRequest&amp;, HttpServletResponse&amp;)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>用户实现的 HttpServlet 子类中可以实现以上几个虚接口的一个或者几个，以满足不同的 HTTP 请求。</p>\n<p>下面的函数为 HttpServlet 类开始运行的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数</span><br><span class=\"hljs-comment\"> * @param session &#123;session&amp;&#125; 存储 session 数据的对象</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125; 当在 acl_master 服务器框架控制下</span><br><span class=\"hljs-comment\"> *  运行时，该参数必须非空；当在 apache 下以 CGI 方式运行时，该参数</span><br><span class=\"hljs-comment\"> *  设为 NULL；另外，该函数内部不会关闭流连接，应用应自行处理流对象</span><br><span class=\"hljs-comment\"> *  的关闭情况，这样可以方便与 acl_master 架构结合</span><br><span class=\"hljs-comment\"> * @param body_parse &#123;bool&#125; 针对 POST 方法，该参数指定是否需要</span><br><span class=\"hljs-comment\"> *  读取 HTTP 请求数据体并按 n/v 方式进行分析；当为 true 则内</span><br><span class=\"hljs-comment\"> *  部会读取 HTTP 请求体数据，并进行分析，当用户调用 getParameter</span><br><span class=\"hljs-comment\"> *  时，不仅可以获得 URL 中的参数，同时可以获得 POST 数据体中</span><br><span class=\"hljs-comment\"> *  的参数；当该参数为 false 时则不读取数据体</span><br><span class=\"hljs-comment\"> * @param body_limit &#123;int&#125; 针对 POST 方法，当数据体为文本参数</span><br><span class=\"hljs-comment\"> *  类型时，此参数限制数据体的长度；当数据体为数据流或 MIME</span><br><span class=\"hljs-comment\"> *  格式或 body_read 为 false，此参数无效</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回处理结果</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doRun</span><span class=\"hljs-params\">(session&amp; session, socket_stream* stream = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">bool</span> body_parse = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">int</span> body_limit = <span class=\"hljs-number\">102400</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * HttpServlet 对象开始运行，接收 HTTP 请求，并回调以下 doXXX 虚函数，</span><br><span class=\"hljs-comment\"> * 调用本函数意味着采用 memcached 来存储 session 数据</span><br><span class=\"hljs-comment\"> * @param memcached_addr &#123;const char*&#125; memcached 服务器地址，格式：IP:PORT</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125; 含义同上</span><br><span class=\"hljs-comment\"> * @param body_parse &#123;bool&#125; 含义同上</span><br><span class=\"hljs-comment\"> * @param body_limit &#123;int&#125; 含义同上</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回处理结果</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doRun</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* memcached_addr = <span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\tsocket_stream* stream = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">bool</span> body_parse = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">int</span> body_limit = <span class=\"hljs-number\">102400</span>)</span></span>;<br><br></code></pre></td></tr></table></figure>\n\n<p>从上面五个虚方法中，可以看到两个重要的类：HttpServletRequest 和 HttpServletResponse。这两个类分别表示 http 请求类及 http 响应类，这两个类都是由 HttpServlet 类对象创建并释放的，所以用户不必创建和销毁这两个类对象实例。下面分别介绍这两个类：</p>\n<h2 id=\"三、HttpServletRequest-类\"><a href=\"#三、HttpServletRequest-类\" class=\"headerlink\" title=\"三、HttpServletRequest 类\"></a>三、HttpServletRequest 类</h2><p>该类主要是与浏览器的请求过程相关，您可以通过该类的方法获得浏览器的请求数据。该类的方法比较多（基本上是参照了 java HttpServlet 的功能方法及名称），所以下面仅介绍几个主要的方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 请求中的参数值，该值已经被 URL 解码且</span><br><span class=\"hljs-comment\">\t * 转换成本地要求的字符集；针对 GET 方法，则是获得</span><br><span class=\"hljs-comment\">\t * URL 中 ? 后面的参数值；针对 POST 方法，则可以获得</span><br><span class=\"hljs-comment\">\t * URL 中 ? 后面的参数值或请求体中的参数值</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">getParameter</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 客户端请求的某个 cookie 值</span><br><span class=\"hljs-comment\">\t * @param name &#123;const char*&#125; cookie 名称，必须非空</span><br><span class=\"hljs-comment\">\t * @return &#123;const char*&#125; cookie 值，当返回 NULL 时表示</span><br><span class=\"hljs-comment\">\t *  cookie 值不存在</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">getCookieValue</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得与该 HTTP 会话相关的 HttpSession 对象引用</span><br><span class=\"hljs-comment\">\t * @return &#123;HttpSession&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">HttpSession&amp; <span class=\"hljs-title\">getSession</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得与 HTTP 客户端连接关联的输入流对象引用</span><br><span class=\"hljs-comment\">\t * @return &#123;istream&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">istream&amp; <span class=\"hljs-title\">getInputStream</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 请求数据的数据长度</span><br><span class=\"hljs-comment\">\t * @return &#123;acl_int64&#125; 返回 -1 表示可能为 GET 方法，</span><br><span class=\"hljs-comment\">\t *  或 HTTP 请求头中没有 Content-Length 字段</span><br><span class=\"hljs-comment\">\t */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t<span class=\"hljs-function\">__int64 <span class=\"hljs-title\">getContentLength</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">getContentLength</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 当 HTTP 请求头中的 Content-Type 为</span><br><span class=\"hljs-comment\">\t * multipart/form-data; boundary=xxx 格式时，说明为文件上传</span><br><span class=\"hljs-comment\">\t * 数据类型，则可以通过此函数获得 http_mime 对象</span><br><span class=\"hljs-comment\">\t * @return &#123;const http_mime*&#125; 返回 NULL 则说明没有 MIME 对象，</span><br><span class=\"hljs-comment\">\t *  返回的值用户不能手工释放，因为在 HttpServletRequest 的析</span><br><span class=\"hljs-comment\">\t *  构中会自动释放</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">http_mime* <span class=\"hljs-title\">getHttpMime</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 请求数据的类型</span><br><span class=\"hljs-comment\">\t * @return &#123;http_request_t&#125;，一般对 POST 方法中的上传</span><br><span class=\"hljs-comment\">\t *  文件应用而言，需要调用该函数获得是否是上传数据类型</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">http_request_t</span> <span class=\"hljs-title\">getRequestType</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>以上方法一般都是我们在实际对 HttpServletRequest 类方法使用过程中用得较多的。如：</p>\n<figure class=\"highlight livecodeserver\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs livecodeserver\">getParmeter： 用来获得 <span class=\"hljs-keyword\">http</span> 请求参数<br>getCookieValue：获得浏览器的 cookie 值<br>getSession：获得该 HttpServlet 类对象的 session 会话<br>getInputStream：获得 <span class=\"hljs-keyword\">http</span> 连接的输入流<br>getContentLength：针对 HTTP POST 请求，此函数获得 HTTP 请求数据体的长度<br>getRequestType：针对 HTTP POST 请求，此函数返回 HTTP 请求数据体的传输方式（普通的 name=<span class=\"hljs-built_in\">value</span> 方式，multipart 上传文件格式以及数据流格式）<br></code></pre></td></tr></table></figure>\n<h2 id=\"四、HttpServletResponse-类\"><a href=\"#四、HttpServletResponse-类\" class=\"headerlink\" title=\"四、HttpServletResponse 类\"></a>四、HttpServletResponse 类</h2><p>该类主要与将您写的程序将处理数据结果返回给浏览器的过程相关，下面也仅介绍该类的一些常用的函数，如果您需要更多的功能，请参数 HttpServletResponse.hpp 头文件。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 响应数据体的 Content-Type 字段值，可字段值可以为：</span><br><span class=\"hljs-comment\"> * text/html 或 text/html; charset=utf8 格式</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; 字段值</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setContentType</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 响应数据体中字符集，当已经在 setContentType 设置</span><br><span class=\"hljs-comment\"> * 了字符集，则就不必再调用本函数设置字符集</span><br><span class=\"hljs-comment\"> * @param charset &#123;const char*&#125; 响应体数据的字符集</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setCharacterEncoding</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* charset)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 响应头中的状态码：1xx, 2xx, 3xx, 4xx, 5xx</span><br><span class=\"hljs-comment\"> * @param status &#123;int&#125; HTTP 响应状态码, 如：200</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">setStatus</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> status)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 添加 cookie</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; cookie 名</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; cookie 值</span><br><span class=\"hljs-comment\"> * @param domain &#123;const char*&#125; cookie 存储域</span><br><span class=\"hljs-comment\"> * @param path &#123;const char*&#125; cookie 存储路径</span><br><span class=\"hljs-comment\"> * @param expires &#123;time_t&#125; cookie 过期时间间隔，当当前时间加</span><br><span class=\"hljs-comment\"> *  该值为 cookie 的过期时间截(秒)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">addCookie</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* domain = <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* path = <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-type\">time_t</span> expires = <span class=\"hljs-number\">0</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 发送 HTTP 响应头，用户应该发送数据体前调用此函数将 HTTP</span><br><span class=\"hljs-comment\"> * 响应头发送给客户端</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">sendHeader</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得 HTTP 响应对象的输出流对象，用户在调用 sendHeader 发送</span><br><span class=\"hljs-comment\"> * 完 HTTP 响应头后，通过该输出流来发送 HTTP 数据体</span><br><span class=\"hljs-comment\"> * @return &#123;ostream&amp;&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ostream&amp; <span class=\"hljs-title\">getOutputStream</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<ul>\n<li>setCharacterEncoding：该方法设置 HTTP 响应头的 HTTP 数据体的字符集，如果通过该函数设置了字符集，即使您在返回的 html 数据中重新设置了其它的字符集，浏览器也会优先使用 HTTP 响应头中设置的字符集，所以用户一定得注意这点；</li>\n<li>setContentType：该方法用来设置 HTTP 响应头中的 Content-Type 字段，对于 xml 数据则设置 text&#x2F;xml，对 html 数据则设置 text&#x2F;html，当然您也可以设置 image&#x2F;jpeg 等数据类型；当然，您也可以直接通过该方法在设置数据类型的同时指定数据的字符集，如可以直接写：setContentType(“text&#x2F;html; charset&#x3D;utf8”)，这个用法等同于：setContentType(“text&#x2F;html”); setCharacterEncoding(“utf8”)。</li>\n<li>setStatus：设置 HTTP 响应头的状态码（一般不用设置状态码，除非是您确实需要单独设置）；</li>\n<li>addCookie：在 HTTP 响应头中添加 cookie 内容；</li>\n<li>sendHeader：发送 HTTP 响应头；</li>\n<li>getOutputStream：该函数返回输出流对象，您可以向输出流中直接写 HTTP 响应的数据体（关于 ostream 类的使用请参数头文件：include&#x2F;ostream.hpp）。</li>\n</ul>\n<p>除了以上三个类外，还有一个类比较重要：HttpSession 类，该类主要实现与 session 会话相关的功能：</p>\n<h2 id=\"五、HttpSession-类\"><a href=\"#五、HttpSession-类\" class=\"headerlink\" title=\"五、HttpSession 类\"></a>五、HttpSession 类</h2><p>该类对象实例用户也不必创建与释放，在 HttpServet 类对象内容自动管理该类对象实例。主要用的方法有：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得客户端在服务端存储的对应 session 变量名，子类可以重载该方法</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; session 名，非空</span><br><span class=\"hljs-comment\"> * @return &#123;const char*&#125; session 值，为空说明不存在或内部</span><br><span class=\"hljs-comment\"> *  查询失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">getAttribute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置服务端对应 session 名的 session 值，子类可以重载该方法</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; session 名，非空</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; session 值，非空</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 false 说明设置失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">setAttribute</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>只所以将这两个方法声明为虚方法，是因为 HttpSession 的 session 数据存储目前仅支持 memcached，您如果有精力的话可以实现一个子类用来支持其它的数据存储方式。当然您也可以在您实现的子类中实现自己的产生唯一 session id 的方法，即实现如下虚方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 创建某个 session 会话的唯一 ID 号，子类可以重载该方法</span><br><span class=\"hljs-comment\">\t * @param buf &#123;char*&#125; 存储结果缓冲区</span><br><span class=\"hljs-comment\">\t * @param len &#123;size_t&#125; buf 缓冲区大小，buf 缓冲区大小建议</span><br><span class=\"hljs-comment\">\t *  64 字节左右</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">createSid</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* buf, <span class=\"hljs-type\">size_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>好了，上面说了一大堆类及类函数，下面还是以一个具体的示例来说明这些类的用法：</p>\n<h2 id=\"六、示例\"><a href=\"#六、示例\" class=\"headerlink\" title=\"六、示例\"></a>六、示例</h2><p>下面的例子是一个 CGI 例子，编译后可执行程序可以直接放在 apache 的 cgi-bin&#x2F; 目录，用户可以用浏览器访问。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// http_servlet.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.hpp&quot;</span></span><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_servlet</span> : <span class=\"hljs-keyword\">public</span> HttpServlet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_servlet</span>(<span class=\"hljs-type\">void</span>)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">http_servlet</span>(<span class=\"hljs-type\">void</span>)<br>\t&#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 实现处理 HTTP GET 请求的功能函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doGet</span><span class=\"hljs-params\">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">doPost</span>(req, res);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 实现处理 HTTP POST 请求的功能函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 获得某浏览器用户的 session 的某个变量值，如果不存在则设置一个</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* sid = req.<span class=\"hljs-built_in\">getSession</span>().<span class=\"hljs-built_in\">getAttribute</span>(<span class=\"hljs-string\">&quot;sid&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (sid == <span class=\"hljs-literal\">NULL</span> || *sid == <span class=\"hljs-number\">0</span>)<br>\t\t\treq.<span class=\"hljs-built_in\">getSession</span>().<span class=\"hljs-built_in\">setAttribute</span>(<span class=\"hljs-string\">&quot;sid&quot;</span>, <span class=\"hljs-string\">&quot;xxxxxx&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 再取一次该浏览器用户的 session 的某个属性值</span><br>\t\tsid = req.<span class=\"hljs-built_in\">getSession</span>().<span class=\"hljs-built_in\">getAttribute</span>(<span class=\"hljs-string\">&quot;sid&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 取得浏览器发来的两个 cookie 值</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* cookie1 = req.<span class=\"hljs-built_in\">getCookieValue</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>);<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* cookie2 = req.<span class=\"hljs-built_in\">getCookieValue</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 开始创建 HTTP 响应头</span><br><br>\t\t<span class=\"hljs-comment\">// 设置 cookie</span><br>  \t\tres.<span class=\"hljs-built_in\">addCookie</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>, <span class=\"hljs-string\">&quot;value1&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 设置具有作用域和过期时间的 cookie</span><br>\t\tres.<span class=\"hljs-built_in\">addCookie</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>, <span class=\"hljs-string\">&quot;value2&quot;</span>, <span class=\"hljs-string\">&quot;.test.com&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>, <span class=\"hljs-number\">3600</span> * <span class=\"hljs-number\">24</span>);<br>\t\t<span class=\"hljs-comment\">// res.setStatus(200);  // 可以设置返回的状态码</span><br><br>\t\t<span class=\"hljs-comment\">// 两种方式都可以设置字符集</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>)<br>\t\t\tres.<span class=\"hljs-built_in\">setContentType</span>(<span class=\"hljs-string\">&quot;text/xml; charset=gb2312&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\t<span class=\"hljs-comment\">// 先设置数据类型</span><br>\t\t\tres.<span class=\"hljs-built_in\">setContentType</span>(<span class=\"hljs-string\">&quot;text/xml&quot;</span>);<br><br>\t\t\t<span class=\"hljs-comment\">// 再设置数据字符集</span><br>\t\t\tres.<span class=\"hljs-built_in\">setCharacterEncoding</span>(<span class=\"hljs-string\">&quot;gb2312&quot;</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 获得浏览器请求的两个参数值</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* param1 = req.<span class=\"hljs-built_in\">getParameter</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>);<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* param2 = req.<span class=\"hljs-built_in\">getParameter</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 创建 xml 格式的数据体</span><br>\t\txml body;<br>\t\tbody.<span class=\"hljs-built_in\">get_root</span>().<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;root&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;sessions&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;session&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;sid&quot;</span>, sid ? sid : <span class=\"hljs-string\">&quot;null&quot;</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;cookies&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;cookie&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>, cookie1 ? cookie1 : <span class=\"hljs-string\">&quot;null&quot;</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;cookie&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>, cookie2 ? cookie2 : <span class=\"hljs-string\">&quot;null&quot;</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;params&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;param&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>, param1 ? param1 : <span class=\"hljs-string\">&quot;null&quot;</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">get_parent</span>()<br>\t\t\t\t.<span class=\"hljs-built_in\">add_child</span>(<span class=\"hljs-string\">&quot;param&quot;</span>, <span class=\"hljs-literal\">true</span>)<br>\t\t\t\t\t.<span class=\"hljs-built_in\">add_attr</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>, param2 ? param2 : <span class=\"hljs-string\">&quot;null&quot;</span>);<br>\t\tstring buf;<br>\t\tbody.<span class=\"hljs-built_in\">build_xml</span>(buf);<br>\t\t<span class=\"hljs-comment\">// 在http 响应头中设置数据体长度</span><br>\t\tres.<span class=\"hljs-built_in\">setContentLength</span>(buf.<span class=\"hljs-built_in\">length</span>());<br>\t\t<span class=\"hljs-comment\">// 发送 http 响应头</span><br>\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-built_in\">sendHeader</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-comment\">// 发送 http 响应体</span><br>\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-built_in\">write</span>(buf) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();  <span class=\"hljs-comment\">// win32 环境下需要初始化库</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>\thttp_servlet servle;<br><br>\t<span class=\"hljs-comment\">// cgi 开始运行</span><br>\tservlet.<span class=\"hljs-built_in\">doRun</span>(<span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>);  <span class=\"hljs-comment\">// 开始运行，并设定 memcached 的服务地址为：127.0.0.1:11211</span><br><br>\t<span class=\"hljs-comment\">// 运行完毕，程序退出</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>经常使用 Java HttpServlet 等类进行 web 编程的用户对上面的代码一定不会感到陌生，但它的的确确是一个 CGI 程序，可以放在 Apache 及支持 CGI 的 Webserver 下运行。当然，大家应该都清楚 CGI 在运行时因进程切换而导致了效率较为低下，在另一篇文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中展示了用上面的 http_servlet 类并结合 acl_cpp 的服务器模型实现的一个WEB服务器的例子，效率比 CGI 要高的多(效率也应比 FCGI高，因为其少了 Webserver 层的过滤)；文章《acl_cpp web 编程之文件上传 》中举例讲述了在服务端如何使用 acl_cpp 库处理浏览器上传文件的功能。</p>\n<p>acl 下载<br>github: <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee: <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a></p>\n"},{"title":"使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序","date":"2012-05-21T05:08:24.000Z","_content":"\n在 《用C++实现类似于JAVA HttpServlet 的编程接口 》 文章中讲了如何用 HttpServlet 等相关类编写 CGI 程序，于是有网友提出了 CGI 程序低效性，不错，确实 CGI 程序的进程开销是比较大的，本文就将说明依然是这些 HTTP 相关的类，如果在使用 acl_cpp/src/master 下的服务器框架类的条件下，可以非常方便地转为服务器程序。现在依然是使用 《用C++实现类似于JAVA HttpServlet 的编程接口 》示例中的 http_servlet 类，只是稍微修改一下 main 函数，就变成下面的情形：\n\n```c++\n//////////////////////////////////////////////////////////////////////////\n\nclass master_service : public acl::master_proc\n{\npublic:\n\tmaster_service() {}\n\t~master_service() {}\nprotected:\n\t// 基类虚函数，当接收到一个 HTTP 客户端请求时，服务器\n\t// 框架回调此函数将连接流传入\n\tvirtual void on_accept(acl::socket_stream* stream)\n\t{\n\t\t// HttpServlet 的子类实例\n\t\thttp_servlet servlet(\"127.0.0.1:11211\");\n\t\tservlet.setLocalCharset(\"gb2312\");  // 设置本地字符集\n\t\tservlet.doRun(stream);  // 开始处理浏览器请求过程\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nint main(int argc, char* argv[])\n{\n\tacl::acl_cpp_init();  // 初始化 acl_cpp 库\n\tmaster_service service;  // 半驻留进程池服务类对象\n\n\t// 开始运行\n\n\tif (argc >= 2 && strcmp(argv[1], \"alone\") == 0)\n\t{\n\t\t// 当在手工调试时一般采用此方式\n\t\tprintf(\"listen: 127.0.0.1:8888 ...\\r\\n\");\n\t\tservice.run_alone(\"127.0.0.1:8888\", NULL, 1);  // 单独运行方式\n\t}\n\telse  // 生产环境中以半驻留进程池模式运行\n\t\tservice.run_daemon(argc, argv);  // acl_master 控制模式运行\n\n\treturn 0;\n}\n```\n\n上面的例子是一个结合 HttpServlet 类及 master_service 进程池服务类的 HTTP 服务器程序，关于进程池的例子，可以先结合本人原来写过的基于C语言库 acl 的一篇文章《快速创建你的服务器程序－－single进程池模型 》。\n\n不仅可以非常容易地将 HttpServlet 写成进程池方式，同时还可以结合 acl_cpp 的线程池框架模板，将 HttpServlet 类实现为半驻留线程池实例，下面就显示了这一过程：\n\n```c++\nclass master_threads_test : public acl::master_threads\n{\npublic:\n\tmaster_threads_test() {}\n\n\t~master_threads_test() {}\n\nprotected:\n\t// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示\n\t// 继续与客户端保持长连接，否则表示需要关闭客户端连接\n\tbool thread_on_read(acl::socket_stream* stream)\n\t{\n\t\t// HttpServlet 的子类实例\n\t\thttp_servlet servlet;\n\t\tservlet.setLocalCharset(\"gb2312\");  // 设置本地字符集\n\t\tservlet.doRun(“127.0.0.1：11211”， stream);  // 开始处理浏览器请求过程，同时设置 memcached 的监听地址及客户端连接流\n\t}\n\n\t// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许\n\t// 子类事先对客户端连接进行处理，返回 true 表示继续，否则\n\t// 要求关闭该客户端连接\n\tbool thread_on_accept(acl::socket_stream*)\n\t{\n\t\treturn true;  // 返回 true 以允许服务器框架继续调用 thread_on_read 过程\n\t}\n};\n\n// 字符串类配置参数项\n\nstatic char *var_cfg_debug_msg;\n\nstatic acl::master_str_tbl var_conf_str_tab[] = {\n\t{ \"debug_msg\", \"test_msg\", &var_cfg_debug_msg },\n\n\t{ 0, 0, 0 }\n};\n\n// 布尔配置参数项\nstatic int  var_cfg_debug_enable;\nstatic int  var_cfg_keep_alive;\nstatic int  var_cfg_loop;\n\nstatic acl::master_bool_tbl var_conf_bool_tab[] = {\n\t{ \"debug_enable\", 1, &var_cfg_debug_enable },\n\t{ \"keep_alive\", 1, &var_cfg_keep_alive },\n\t{ \"loop_read\", 1, &var_cfg_loop },\n\n\t{ 0, 0, 0 }\n};\n\n// 整数配置参数项\nstatic int  var_cfg_io_timeout;\n\nstatic acl::master_int_tbl var_conf_int_tab[] = {\n\t{ \"io_timeout\", 120, &var_cfg_io_timeout, 0, 0 },\n\n\t{ 0, 0 , 0 , 0, 0 }\n};\n\nint main(int argc, char* argv[])\n{\n\tmaster_threads_test mt;  // 半驻留线程池服务器实例\n\n\t// 设置配置参数表\n\tmt.set_cfg_int(var_conf_int_tab);\n\tmt.set_cfg_int64(NULL);\n\tmt.set_cfg_str(var_conf_str_tab);\n\tmt.set_cfg_bool(var_conf_bool_tab);\n\n\t// 开始运行\n\n\tif (argc >= 2 && strcmp(argv[1], \"alone\") == 0)\n\t{\n\t\t// 当在手工调试时一般采用此方式\n\t\tprintf(\"listen: 127.0.0.1:8888\\r\\n\");\n\t\tmt.run_alone(\"127.0.0.1:8888\", NULL, 2, 10);  // 单独运行方式\n\t}\n\telse  // 生产环境中以半驻留线程池模式运行\n\t\tmt.run_daemon(argc, argv);  // acl_master 控制模式运行\n\treturn 0;\n}\n```\n","source":"_posts/http_web.md","raw":"---\ntitle: 使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序\ndate: 2012-05-21 13:08:24\ntags: http\ncategories: http开发\n---\n\n在 《用C++实现类似于JAVA HttpServlet 的编程接口 》 文章中讲了如何用 HttpServlet 等相关类编写 CGI 程序，于是有网友提出了 CGI 程序低效性，不错，确实 CGI 程序的进程开销是比较大的，本文就将说明依然是这些 HTTP 相关的类，如果在使用 acl_cpp/src/master 下的服务器框架类的条件下，可以非常方便地转为服务器程序。现在依然是使用 《用C++实现类似于JAVA HttpServlet 的编程接口 》示例中的 http_servlet 类，只是稍微修改一下 main 函数，就变成下面的情形：\n\n```c++\n//////////////////////////////////////////////////////////////////////////\n\nclass master_service : public acl::master_proc\n{\npublic:\n\tmaster_service() {}\n\t~master_service() {}\nprotected:\n\t// 基类虚函数，当接收到一个 HTTP 客户端请求时，服务器\n\t// 框架回调此函数将连接流传入\n\tvirtual void on_accept(acl::socket_stream* stream)\n\t{\n\t\t// HttpServlet 的子类实例\n\t\thttp_servlet servlet(\"127.0.0.1:11211\");\n\t\tservlet.setLocalCharset(\"gb2312\");  // 设置本地字符集\n\t\tservlet.doRun(stream);  // 开始处理浏览器请求过程\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nint main(int argc, char* argv[])\n{\n\tacl::acl_cpp_init();  // 初始化 acl_cpp 库\n\tmaster_service service;  // 半驻留进程池服务类对象\n\n\t// 开始运行\n\n\tif (argc >= 2 && strcmp(argv[1], \"alone\") == 0)\n\t{\n\t\t// 当在手工调试时一般采用此方式\n\t\tprintf(\"listen: 127.0.0.1:8888 ...\\r\\n\");\n\t\tservice.run_alone(\"127.0.0.1:8888\", NULL, 1);  // 单独运行方式\n\t}\n\telse  // 生产环境中以半驻留进程池模式运行\n\t\tservice.run_daemon(argc, argv);  // acl_master 控制模式运行\n\n\treturn 0;\n}\n```\n\n上面的例子是一个结合 HttpServlet 类及 master_service 进程池服务类的 HTTP 服务器程序，关于进程池的例子，可以先结合本人原来写过的基于C语言库 acl 的一篇文章《快速创建你的服务器程序－－single进程池模型 》。\n\n不仅可以非常容易地将 HttpServlet 写成进程池方式，同时还可以结合 acl_cpp 的线程池框架模板，将 HttpServlet 类实现为半驻留线程池实例，下面就显示了这一过程：\n\n```c++\nclass master_threads_test : public acl::master_threads\n{\npublic:\n\tmaster_threads_test() {}\n\n\t~master_threads_test() {}\n\nprotected:\n\t// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示\n\t// 继续与客户端保持长连接，否则表示需要关闭客户端连接\n\tbool thread_on_read(acl::socket_stream* stream)\n\t{\n\t\t// HttpServlet 的子类实例\n\t\thttp_servlet servlet;\n\t\tservlet.setLocalCharset(\"gb2312\");  // 设置本地字符集\n\t\tservlet.doRun(“127.0.0.1：11211”， stream);  // 开始处理浏览器请求过程，同时设置 memcached 的监听地址及客户端连接流\n\t}\n\n\t// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许\n\t// 子类事先对客户端连接进行处理，返回 true 表示继续，否则\n\t// 要求关闭该客户端连接\n\tbool thread_on_accept(acl::socket_stream*)\n\t{\n\t\treturn true;  // 返回 true 以允许服务器框架继续调用 thread_on_read 过程\n\t}\n};\n\n// 字符串类配置参数项\n\nstatic char *var_cfg_debug_msg;\n\nstatic acl::master_str_tbl var_conf_str_tab[] = {\n\t{ \"debug_msg\", \"test_msg\", &var_cfg_debug_msg },\n\n\t{ 0, 0, 0 }\n};\n\n// 布尔配置参数项\nstatic int  var_cfg_debug_enable;\nstatic int  var_cfg_keep_alive;\nstatic int  var_cfg_loop;\n\nstatic acl::master_bool_tbl var_conf_bool_tab[] = {\n\t{ \"debug_enable\", 1, &var_cfg_debug_enable },\n\t{ \"keep_alive\", 1, &var_cfg_keep_alive },\n\t{ \"loop_read\", 1, &var_cfg_loop },\n\n\t{ 0, 0, 0 }\n};\n\n// 整数配置参数项\nstatic int  var_cfg_io_timeout;\n\nstatic acl::master_int_tbl var_conf_int_tab[] = {\n\t{ \"io_timeout\", 120, &var_cfg_io_timeout, 0, 0 },\n\n\t{ 0, 0 , 0 , 0, 0 }\n};\n\nint main(int argc, char* argv[])\n{\n\tmaster_threads_test mt;  // 半驻留线程池服务器实例\n\n\t// 设置配置参数表\n\tmt.set_cfg_int(var_conf_int_tab);\n\tmt.set_cfg_int64(NULL);\n\tmt.set_cfg_str(var_conf_str_tab);\n\tmt.set_cfg_bool(var_conf_bool_tab);\n\n\t// 开始运行\n\n\tif (argc >= 2 && strcmp(argv[1], \"alone\") == 0)\n\t{\n\t\t// 当在手工调试时一般采用此方式\n\t\tprintf(\"listen: 127.0.0.1:8888\\r\\n\");\n\t\tmt.run_alone(\"127.0.0.1:8888\", NULL, 2, 10);  // 单独运行方式\n\t}\n\telse  // 生产环境中以半驻留线程池模式运行\n\t\tmt.run_daemon(argc, argv);  // acl_master 控制模式运行\n\treturn 0;\n}\n```\n","slug":"http_web","published":1,"updated":"2023-01-23T13:40:18.258Z","_id":"cld8u4fck0000c79kex87aoiz","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在 《用C++实现类似于JAVA HttpServlet 的编程接口 》 文章中讲了如何用 HttpServlet 等相关类编写 CGI 程序，于是有网友提出了 CGI 程序低效性，不错，确实 CGI 程序的进程开销是比较大的，本文就将说明依然是这些 HTTP 相关的类，如果在使用 acl_cpp&#x2F;src&#x2F;master 下的服务器框架类的条件下，可以非常方便地转为服务器程序。现在依然是使用 《用C++实现类似于JAVA HttpServlet 的编程接口 》示例中的 http_servlet 类，只是稍微修改一下 main 函数，就变成下面的情形：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">master_service</span> : <span class=\"hljs-keyword\">public</span> acl::master_proc<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">master_service</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">master_service</span>() &#123;&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类虚函数，当接收到一个 HTTP 客户端请求时，服务器</span><br>\t<span class=\"hljs-comment\">// 框架回调此函数将连接流传入</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">on_accept</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// HttpServlet 的子类实例</span><br>\t\t<span class=\"hljs-function\">http_servlet <span class=\"hljs-title\">servlet</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>)</span></span>;<br>\t\tservlet.<span class=\"hljs-built_in\">setLocalCharset</span>(<span class=\"hljs-string\">&quot;gb2312&quot;</span>);  <span class=\"hljs-comment\">// 设置本地字符集</span><br>\t\tservlet.<span class=\"hljs-built_in\">doRun</span>(stream);  <span class=\"hljs-comment\">// 开始处理浏览器请求过程</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();  <span class=\"hljs-comment\">// 初始化 acl_cpp 库</span><br>\tmaster_service service;  <span class=\"hljs-comment\">// 半驻留进程池服务类对象</span><br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-string\">&quot;alone&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 当在手工调试时一般采用此方式</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen: 127.0.0.1:8888 ...\\r\\n&quot;</span>);<br>\t\tservice.<span class=\"hljs-built_in\">run_alone</span>(<span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// 单独运行方式</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span>  <span class=\"hljs-comment\">// 生产环境中以半驻留进程池模式运行</span><br>\t\tservice.<span class=\"hljs-built_in\">run_daemon</span>(argc, argv);  <span class=\"hljs-comment\">// acl_master 控制模式运行</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的例子是一个结合 HttpServlet 类及 master_service 进程池服务类的 HTTP 服务器程序，关于进程池的例子，可以先结合本人原来写过的基于C语言库 acl 的一篇文章《快速创建你的服务器程序－－single进程池模型 》。</p>\n<p>不仅可以非常容易地将 HttpServlet 写成进程池方式，同时还可以结合 acl_cpp 的线程池框架模板，将 HttpServlet 类实现为半驻留线程池实例，下面就显示了这一过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">master_threads_test</span> : <span class=\"hljs-keyword\">public</span> acl::master_threads<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">master_threads_test</span>() &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">master_threads_test</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示</span><br>\t<span class=\"hljs-comment\">// 继续与客户端保持长连接，否则表示需要关闭客户端连接</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_read</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// HttpServlet 的子类实例</span><br>\t\thttp_servlet servlet;<br>\t\tservlet.<span class=\"hljs-built_in\">setLocalCharset</span>(<span class=\"hljs-string\">&quot;gb2312&quot;</span>);  <span class=\"hljs-comment\">// 设置本地字符集</span><br>\t\tservlet.<span class=\"hljs-built_in\">doRun</span>(“<span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span>：<span class=\"hljs-number\">11211</span>”， stream);  <span class=\"hljs-comment\">// 开始处理浏览器请求过程，同时设置 memcached 的监听地址及客户端连接流</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许</span><br>\t<span class=\"hljs-comment\">// 子类事先对客户端连接进行处理，返回 true 表示继续，否则</span><br>\t<span class=\"hljs-comment\">// 要求关闭该客户端连接</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_accept</span><span class=\"hljs-params\">(acl::socket_stream*)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;  <span class=\"hljs-comment\">// 返回 true 以允许服务器框架继续调用 thread_on_read 过程</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 字符串类配置参数项</span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_debug_msg;<br><br><span class=\"hljs-type\">static</span> acl::master_str_tbl var_conf_str_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_msg&quot;</span>, <span class=\"hljs-string\">&quot;test_msg&quot;</span>, &amp;var_cfg_debug_msg &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 布尔配置参数项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_debug_enable;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_keep_alive;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_loop;<br><br><span class=\"hljs-type\">static</span> acl::master_bool_tbl var_conf_bool_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_enable&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_debug_enable &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;keep_alive&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_keep_alive &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;loop_read&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_loop &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 整数配置参数项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_io_timeout;<br><br><span class=\"hljs-type\">static</span> acl::master_int_tbl var_conf_int_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;io_timeout&quot;</span>, <span class=\"hljs-number\">120</span>, &amp;var_cfg_io_timeout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmaster_threads_test mt;  <span class=\"hljs-comment\">// 半驻留线程池服务器实例</span><br><br>\t<span class=\"hljs-comment\">// 设置配置参数表</span><br>\tmt.<span class=\"hljs-built_in\">set_cfg_int</span>(var_conf_int_tab);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_int64</span>(<span class=\"hljs-literal\">NULL</span>);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_str</span>(var_conf_str_tab);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_bool</span>(var_conf_bool_tab);<br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-string\">&quot;alone&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 当在手工调试时一般采用此方式</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen: 127.0.0.1:8888\\r\\n&quot;</span>);<br>\t\tmt.<span class=\"hljs-built_in\">run_alone</span>(<span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">// 单独运行方式</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span>  <span class=\"hljs-comment\">// 生产环境中以半驻留线程池模式运行</span><br>\t\tmt.<span class=\"hljs-built_in\">run_daemon</span>(argc, argv);  <span class=\"hljs-comment\">// acl_master 控制模式运行</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>在 《用C++实现类似于JAVA HttpServlet 的编程接口 》 文章中讲了如何用 HttpServlet 等相关类编写 CGI 程序，于是有网友提出了 CGI 程序低效性，不错，确实 CGI 程序的进程开销是比较大的，本文就将说明依然是这些 HTTP 相关的类，如果在使用 acl_cpp&#x2F;src&#x2F;master 下的服务器框架类的条件下，可以非常方便地转为服务器程序。现在依然是使用 《用C++实现类似于JAVA HttpServlet 的编程接口 》示例中的 http_servlet 类，只是稍微修改一下 main 函数，就变成下面的情形：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">master_service</span> : <span class=\"hljs-keyword\">public</span> acl::master_proc<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">master_service</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">master_service</span>() &#123;&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类虚函数，当接收到一个 HTTP 客户端请求时，服务器</span><br>\t<span class=\"hljs-comment\">// 框架回调此函数将连接流传入</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">on_accept</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// HttpServlet 的子类实例</span><br>\t\t<span class=\"hljs-function\">http_servlet <span class=\"hljs-title\">servlet</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>)</span></span>;<br>\t\tservlet.<span class=\"hljs-built_in\">setLocalCharset</span>(<span class=\"hljs-string\">&quot;gb2312&quot;</span>);  <span class=\"hljs-comment\">// 设置本地字符集</span><br>\t\tservlet.<span class=\"hljs-built_in\">doRun</span>(stream);  <span class=\"hljs-comment\">// 开始处理浏览器请求过程</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();  <span class=\"hljs-comment\">// 初始化 acl_cpp 库</span><br>\tmaster_service service;  <span class=\"hljs-comment\">// 半驻留进程池服务类对象</span><br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-string\">&quot;alone&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 当在手工调试时一般采用此方式</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen: 127.0.0.1:8888 ...\\r\\n&quot;</span>);<br>\t\tservice.<span class=\"hljs-built_in\">run_alone</span>(<span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">1</span>);  <span class=\"hljs-comment\">// 单独运行方式</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span>  <span class=\"hljs-comment\">// 生产环境中以半驻留进程池模式运行</span><br>\t\tservice.<span class=\"hljs-built_in\">run_daemon</span>(argc, argv);  <span class=\"hljs-comment\">// acl_master 控制模式运行</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的例子是一个结合 HttpServlet 类及 master_service 进程池服务类的 HTTP 服务器程序，关于进程池的例子，可以先结合本人原来写过的基于C语言库 acl 的一篇文章《快速创建你的服务器程序－－single进程池模型 》。</p>\n<p>不仅可以非常容易地将 HttpServlet 写成进程池方式，同时还可以结合 acl_cpp 的线程池框架模板，将 HttpServlet 类实现为半驻留线程池实例，下面就显示了这一过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">master_threads_test</span> : <span class=\"hljs-keyword\">public</span> acl::master_threads<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">master_threads_test</span>() &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">master_threads_test</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示</span><br>\t<span class=\"hljs-comment\">// 继续与客户端保持长连接，否则表示需要关闭客户端连接</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_read</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// HttpServlet 的子类实例</span><br>\t\thttp_servlet servlet;<br>\t\tservlet.<span class=\"hljs-built_in\">setLocalCharset</span>(<span class=\"hljs-string\">&quot;gb2312&quot;</span>);  <span class=\"hljs-comment\">// 设置本地字符集</span><br>\t\tservlet.<span class=\"hljs-built_in\">doRun</span>(“<span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span>：<span class=\"hljs-number\">11211</span>”， stream);  <span class=\"hljs-comment\">// 开始处理浏览器请求过程，同时设置 memcached 的监听地址及客户端连接流</span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许</span><br>\t<span class=\"hljs-comment\">// 子类事先对客户端连接进行处理，返回 true 表示继续，否则</span><br>\t<span class=\"hljs-comment\">// 要求关闭该客户端连接</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_accept</span><span class=\"hljs-params\">(acl::socket_stream*)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;  <span class=\"hljs-comment\">// 返回 true 以允许服务器框架继续调用 thread_on_read 过程</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 字符串类配置参数项</span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_debug_msg;<br><br><span class=\"hljs-type\">static</span> acl::master_str_tbl var_conf_str_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_msg&quot;</span>, <span class=\"hljs-string\">&quot;test_msg&quot;</span>, &amp;var_cfg_debug_msg &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 布尔配置参数项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_debug_enable;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_keep_alive;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_loop;<br><br><span class=\"hljs-type\">static</span> acl::master_bool_tbl var_conf_bool_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_enable&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_debug_enable &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;keep_alive&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_keep_alive &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;loop_read&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_loop &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 整数配置参数项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_io_timeout;<br><br><span class=\"hljs-type\">static</span> acl::master_int_tbl var_conf_int_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;io_timeout&quot;</span>, <span class=\"hljs-number\">120</span>, &amp;var_cfg_io_timeout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmaster_threads_test mt;  <span class=\"hljs-comment\">// 半驻留线程池服务器实例</span><br><br>\t<span class=\"hljs-comment\">// 设置配置参数表</span><br>\tmt.<span class=\"hljs-built_in\">set_cfg_int</span>(var_conf_int_tab);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_int64</span>(<span class=\"hljs-literal\">NULL</span>);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_str</span>(var_conf_str_tab);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_bool</span>(var_conf_bool_tab);<br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-string\">&quot;alone&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 当在手工调试时一般采用此方式</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen: 127.0.0.1:8888\\r\\n&quot;</span>);<br>\t\tmt.<span class=\"hljs-built_in\">run_alone</span>(<span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">// 单独运行方式</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span>  <span class=\"hljs-comment\">// 生产环境中以半驻留线程池模式运行</span><br>\t\tmt.<span class=\"hljs-built_in\">run_daemon</span>(argc, argv);  <span class=\"hljs-comment\">// acl_master 控制模式运行</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"Web 编程中实现文件上传的服务端实例","date":"2012-05-22T05:08:24.000Z","_content":"\n在文章《用C++实现类似于JAVA HttpServlet 的编程接口 》中讲了如何用 acl_cpp 的 HttpServlet 等类来实现 WEB CGI 的功能，同时在文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中也举例说明如何将基于 HttpServlet 编写的 CGI 程序快速地转为服务器程序的过程。本文主要讲如何用 acl_cpp 的 WEB 编程类实现 HTTP 文件上传过程。为了实现 HTTP 协议的文件上传过程，引入了两个类：http_mime 和 http_mime_node。\n\nhttp_mime 类是有关 HTTP 协议中 mime 格式的流式解析器（即每次仅输入部分 HTTP MIME 数据，等数据输入完毕时，该解析器也解析完毕，流式解析的好处是它可以适用于阻塞或非阻塞的IO模式）；http_mime_node 类对象表示 http mime 数据中每一个 mime 结点对象，该结点的数据可能是文件内容数据，也可能是参数数据。\n\n## 一、http_mime 类\n该类一般由 HttpServletRequest 类内部自动管理（负责分配与释放 http_mide 类对象），当然用户可以在测试 http_mime 类时，自己创建与释放该类对象。下面是该类的构造函数及常用方法：\n\n```c++\n\t/**\n\t * 构建函数\n\t * @param boundary {const char*} 分隔符，不能为空\n\t * @param local_charset {const char*} 本地字符集，非空时会自动将\n\t *  参数内容转为本地字符集\n\t */\n\thttp_mime(const char* boundary, const char* local_charset  = \"gb2312\");\n```\n\n尤其需要指出的是 http mime 的 boundary(分隔符）与邮件的 mime 的分隔符规则略有不同，如邮件的相关头部字段为：Content-Type: multipart/mixed; charset=\"GB2312\"; boundary=\"0_11119_1331286082\"，HTTP MIME 的相关头部字段为：Content-Type: multipart/form-data; boundary=\"--0_11119_1331286082\"。其中，最大的区别就是在 HTTP 头中获得的分隔符与 HTTP 数据体的分隔符（除结尾分隔符多了两个 '-' 后缀）完全相同，而邮件的 mime 的分隔符在头部和 mime 体中是不一样的，mime 体中的分隔符是由头部的分隔符加两个 '-' 作为前导符（结尾分隔符为头部分隔符前面加两个 '-'，尾部加两个 '-'），一定得注意这些不同。在 acl_cpp 中的 http mime 解析模块原来主要是作邮件 mime 解析的，现在依然支持 HTTP 的 mime 解析，唯一不同就是区分分隔符的不同。（当然，邮件的 MIME 数据体还与 HTTP MIME 数据体有另外一个区别：邮件的 MIME 数据一般都是要经过 BASE64 来编码的，而 HTTP MIME 却很少编码）。\n\nhttp_mime 的几个常用方法接口如下：\n```c++\n\t/**\n\t * 设置 MIME 数据的存储路径，当分析完 MIME 数据后，如果想要从中提取数据，\n     * 则必须给出该 MIME 的原始数据的存储位置，否则无法获得相应数据，即\n     * save_xxx/get_nodes/get_node 函数均无法正常使用\n\t * @param path {const char*} 文件路径名, 如果该参数为空, 则不能\n\t *  获得数据体数据, 也不能调用 save_xxx 相关的接口\n\t */\n\tvoid set_saved_path(const char* path);\n\n\t/**\n\t * 调用此函数进行流式方式解析数据体内容\n\t * @param data {const char*} 数据体(可能是数据头也可能是数据体, \n\t *  并且不必是完整的数据行)\n\t * @param len {size_t} data 数据长度\n\t * @return {bool} 针对 multipart 数据, 返回 true 表示解析完毕;\n\t *  对于非 multipart 文件, 该返回值永远为 false, 没有任何意义, \n\t *  需要调用者自己判断数据体的结束位置\n\t * 注意: 调用完此函数后一定需要调用 update_end 函数通知解析器解析完毕\n\t */\n\tbool update(const char* data, size_t len);\n\n\t/**\n\t * 获得所有的 MIME 结点\n\t * @return {const std::list<http_mimde_node*>&}\n\t */\n\tconst std::list<http_mime_node*>& get_nodes(void) const;\n\n\t/**\n\t * 根据变量名取得 HTTP MIME 结点\n\t * @param param name {const char*} 变量名\n\t * @return {http_mime_node*} 返回空则说明对应变量名的结点不存在\n\t */\n\tconst http_mime_node* get_node(const char* name) const;\n```\n\n## 二、http_mime_node 类\n该类实例存储 HTTP MIME 数据体中每个数据结点，同时该类的实例是由 http_mime 类对象自动维护的，所以您一般不必关心该类对象的创建与销毁；另外，http_mime_node 类的继承关系为：http_mime_node -> mime_attach -> mime_node。\n\n该类的构造函数如下：\n```c++\n\t/**\n\t * 原始文件存放路径，不能为空\n\t * @param node {MIME_NODE*} 对应的 MIME 结点，非空\n\t * @param decodeIt {bool} 是否对 MIME 结点的头部数据\n\t *  或数据体数据进行解码\n\t * @param toCharset {const char*} 本机的字符集\n\t * @param off {off_t} 偏移数据位置\n\t */\n\thttp_mime_node(const char* path, const MIME_NODE* node,\n\t\tbool decodeIt = true, const char* toCharset = \"gb2312\", off_t off = 0);\n```\n\n 该类的常用方法为：\n```c++\n\t/**\n\t * 获得该结点的类型\n\t * @return {http_mime_t}\n\t */\n\thttp_mime_t get_mime_type(void) const;\n\n\t/**\n\t * 当 get_mime_type 返回的类型为 HTTP_MIME_PARAM 时，可以\n\t * 调用此函数获得参数值；参数名可以通过基类的 get_name() 获得\n\t * @return {const char*} 返回 NULL 表示参数不存在\n\t */\n\tconst char* get_value(void) const;\n```\n\nhttp_mime_t 为枚举类型，如：\n```c++\ntypedef enum\n{\n\tHTTP_MIME_PARAM,        // http mime 结点为参数类型\n\tHTTP_MIME_FILE          // http mime 结点为文件类型\n} http_mime_t;\n```\n加上两个基类的一些方法，有几个方法也是比较常用的，如下：\n- mime_node::get_name: 获得该 mime 结点的名称\n- mime_attach::get_filename: 当结点为上传文件类型时，此函数获得上传文件的文件名\n## 三、示例\n```c++\n#include \"lib_acl.hpp\"\n\nusing namespace acl;\n\nclass http_servlet : public HttpServlet\n{\npublic:\n\thttp_servlet()\n\t{\n\t\t...\n\t}\n\n\t...\n\t// 基类虚方法：HTTP POST 方法接口\n\tbool doPost(HttpServletRequest& req, HttpServletResponse& res)\n\t{\n\t\t...\n\t\treturn doUpload(req, res);\n\t}\n\n\t// 处理文件上传的函数\n\tbool doUpload(HttpServletRequest& req, HttpServletResponse& res)\n\t{\n\t\t// 先获得 Content-Type 对应的 http_ctype 对象\n\t\thttp_mime* mime = req.getHttpMime();\n\t\tif (mime == NULL)\n\t\t{\n\t\t\tlogger_error(\"http_mime null\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// 获得数据体的长度\n\t\tlong long int len = req.getContentLength();\n\t\tif (len <= 0)\n\t\t{\n\t\t\tlogger_error(\"body empty\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// 获得输入流\n\t\tistream& in = req.getInputStream();\n\t\tchar  buf[8192];\n\t\tint   ret;\n\t\tbool  n = false;\n\n\t\tconst char* filepath = \"./var/mime_file\";\n\t\tofstream out;\n\t\t// 只写方式打开存储上传文件的临时文件句柄\n\t\tout.open_write(filepath);\n\n\t\t// 设置原始文件存入路径\n\t\tmime->set_saved_path(filepath);\n\n\t\t// 读取 HTTP 客户端请求数据\n\t\twhile (len > 0)\n\t\t{\n\t\t\t// 从 HTTP 输入流中读取数据\n\t\t\tret = in.read(buf, sizeof(buf), false);\n\t\t\tif (ret == -1)\n\t\t\t{\n\t\t\t\tlogger_error(\"read POST data error\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// 将数据写入临时文件中\n\t\t\tout.write(buf, ret);\n\t\t\tlen -= ret;\n\n\t\t\t// 将读得到的数据输入至解析器进行解析\n\t\t\tif (mime->update(buf, ret) == true)\n\t\t\t{\n\t\t\t\tn = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tout.close();\n\n\t\tif (len != 0 || n == false)\n\t\t\tlogger_warn(\"not read all data from client\");\n\n\t\tstring path;\n\n\t\t// 遍历所有的 MIME 结点，找出其中为文件结点的部分进行转储\n\t\tconst std::list<http_mime_node*>& nodes = mime->get_nodes();\n\t\tstd::list<http_mime_node*>::const_iterator cit = nodes.begin();\n\t\tfor (; cit != nodes.end(); ++cit)\n\t\t{\n\t\t\t// HTTP MIME 结点的变量名\n\t\t\tconst char* name = (*cit)->get_name();\n\n\t\t\t// HTTP MIME 结点的类型\n\t\t\thttp_mime_t mime_type = (*cit)->get_mime_type();\n\t\t\tif (mime_type == HTTP_MIME_FILE)\n\t\t\t{\n\t\t\t\t// 当该结点为文件数据结点时\n\t\t\t\t// 取得上传文件名\n\t\t\t\tconst char* filename = (*cit)->get_filename();\n\t\t\t\tif (filename == NULL)\n\t\t\t\t{\n\t\t\t\t\tlogger(\"filename null\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (strcmp(name, \"file1\") == 0)\n\t\t\t\t\tfile1_ = filename;\n\t\t\t\telse if (strcmp(name, \"file2\") == 0)\n\t\t\t\t\tfile2_ = filename;\n\t\t\t\telse if (strcmp(name, \"file3\") == 0)\n\t\t\t\t\tfile3_ = filename;\n\n\t\t\t\t// 将文件内容转存\n\t\t\t\tpath.format(\"./var/%s\", filename);\n\t\t\t\t(void) (*cit)->save(path.c_str());\n\t\t\t}\n\t\t}\n\n\t\t// 查找上载的某个文件并转储\n\t\tconst http_mime_node* node = mime->get_node(\"file1\");\n\t\tif (node && node->get_mime_type() == HTTP_MIME_FILE)\n\t\t{\n\t\t\tconst char* ptr = node->get_filename();\n\t\t\tif (ptr)\n\t\t\t{\n\t\t\t\tpath.format(\"./var/1_%s\", ptr);\n\t\t\t\t(void) node->save(path.c_str());\n\t\t\t}\n\t\t}\n\n\t\t// 删除临时文件\n\t\t:unlink(filepath);\n\n\t\t// 发送 http 响应头\n\t\tif (res.sendHeader() == false)\n\t\t\treturn false;\n\t\t// 发送 http 响应体\n\t\tif (res.getOutputStream().write(\"ok\") == -1)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\nprivate:\n\tconst char* file1_;\n\tconst char* file2_;\n\tconst char* file3_;\n};\n\nint main(void)\n{\n#ifdef WIN32\n\tacl::acl_cpp_init();\n#endif\n\n\t// 开始运行\n\thttp_servlet servlet;\n\tservlet.doRun(\"127.0.0.1:11211\"); // 开始运行，并假设 memcached 监听于 127.0.0.1:11211\n\treturn 0;\n}\n```\n\n与上面例子对应的 HTML 页面如下：\n\n```html\n<html>\n<head>\n<meta content=\"text/html; charset=gb2312\" http-equiv=\"Content-Type\">\n</head>\n<body>\n<form enctype=\"multipart/form-data\" method=POST action=\"/cgi-bin/test/upload?name1=中国人\">\n<input type=hidden name=\"name2\" value=\"美国人\"><br>\n<input type=hidden name=\"name3\" value=\"英国人\"><br>\n<input type=submit name=\"submit\", value=\"提交\"><br>\n文件一：<input type=file name=\"file1\" value=\"\"><br>\n文件二：<input type=file name=\"file2\" value=\"\"><br>\n文件三：<input type=file name=\"file3\" value=\"\"><br>\n</form>\n</body>\n</html>\n```\n\n上面例子比较简单地说明了如果使用 acl_cpp 中的 HttpServlet/http_mime 等类来实现文件上传的功能，完整的例子请参考：acl_cpp/samples/cig_upload。该例子虽然是一个 CGI 程序，但您依然可以不费吹灰之力将其改变成一个服务器程序，转换方法可参考：《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》。\n","source":"_posts/http_upload.md","raw":"---\ntitle: Web 编程中实现文件上传的服务端实例\ndate: 2012-05-22 13:08:24\ntags: http\ncategories: http开发\n---\n\n在文章《用C++实现类似于JAVA HttpServlet 的编程接口 》中讲了如何用 acl_cpp 的 HttpServlet 等类来实现 WEB CGI 的功能，同时在文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中也举例说明如何将基于 HttpServlet 编写的 CGI 程序快速地转为服务器程序的过程。本文主要讲如何用 acl_cpp 的 WEB 编程类实现 HTTP 文件上传过程。为了实现 HTTP 协议的文件上传过程，引入了两个类：http_mime 和 http_mime_node。\n\nhttp_mime 类是有关 HTTP 协议中 mime 格式的流式解析器（即每次仅输入部分 HTTP MIME 数据，等数据输入完毕时，该解析器也解析完毕，流式解析的好处是它可以适用于阻塞或非阻塞的IO模式）；http_mime_node 类对象表示 http mime 数据中每一个 mime 结点对象，该结点的数据可能是文件内容数据，也可能是参数数据。\n\n## 一、http_mime 类\n该类一般由 HttpServletRequest 类内部自动管理（负责分配与释放 http_mide 类对象），当然用户可以在测试 http_mime 类时，自己创建与释放该类对象。下面是该类的构造函数及常用方法：\n\n```c++\n\t/**\n\t * 构建函数\n\t * @param boundary {const char*} 分隔符，不能为空\n\t * @param local_charset {const char*} 本地字符集，非空时会自动将\n\t *  参数内容转为本地字符集\n\t */\n\thttp_mime(const char* boundary, const char* local_charset  = \"gb2312\");\n```\n\n尤其需要指出的是 http mime 的 boundary(分隔符）与邮件的 mime 的分隔符规则略有不同，如邮件的相关头部字段为：Content-Type: multipart/mixed; charset=\"GB2312\"; boundary=\"0_11119_1331286082\"，HTTP MIME 的相关头部字段为：Content-Type: multipart/form-data; boundary=\"--0_11119_1331286082\"。其中，最大的区别就是在 HTTP 头中获得的分隔符与 HTTP 数据体的分隔符（除结尾分隔符多了两个 '-' 后缀）完全相同，而邮件的 mime 的分隔符在头部和 mime 体中是不一样的，mime 体中的分隔符是由头部的分隔符加两个 '-' 作为前导符（结尾分隔符为头部分隔符前面加两个 '-'，尾部加两个 '-'），一定得注意这些不同。在 acl_cpp 中的 http mime 解析模块原来主要是作邮件 mime 解析的，现在依然支持 HTTP 的 mime 解析，唯一不同就是区分分隔符的不同。（当然，邮件的 MIME 数据体还与 HTTP MIME 数据体有另外一个区别：邮件的 MIME 数据一般都是要经过 BASE64 来编码的，而 HTTP MIME 却很少编码）。\n\nhttp_mime 的几个常用方法接口如下：\n```c++\n\t/**\n\t * 设置 MIME 数据的存储路径，当分析完 MIME 数据后，如果想要从中提取数据，\n     * 则必须给出该 MIME 的原始数据的存储位置，否则无法获得相应数据，即\n     * save_xxx/get_nodes/get_node 函数均无法正常使用\n\t * @param path {const char*} 文件路径名, 如果该参数为空, 则不能\n\t *  获得数据体数据, 也不能调用 save_xxx 相关的接口\n\t */\n\tvoid set_saved_path(const char* path);\n\n\t/**\n\t * 调用此函数进行流式方式解析数据体内容\n\t * @param data {const char*} 数据体(可能是数据头也可能是数据体, \n\t *  并且不必是完整的数据行)\n\t * @param len {size_t} data 数据长度\n\t * @return {bool} 针对 multipart 数据, 返回 true 表示解析完毕;\n\t *  对于非 multipart 文件, 该返回值永远为 false, 没有任何意义, \n\t *  需要调用者自己判断数据体的结束位置\n\t * 注意: 调用完此函数后一定需要调用 update_end 函数通知解析器解析完毕\n\t */\n\tbool update(const char* data, size_t len);\n\n\t/**\n\t * 获得所有的 MIME 结点\n\t * @return {const std::list<http_mimde_node*>&}\n\t */\n\tconst std::list<http_mime_node*>& get_nodes(void) const;\n\n\t/**\n\t * 根据变量名取得 HTTP MIME 结点\n\t * @param param name {const char*} 变量名\n\t * @return {http_mime_node*} 返回空则说明对应变量名的结点不存在\n\t */\n\tconst http_mime_node* get_node(const char* name) const;\n```\n\n## 二、http_mime_node 类\n该类实例存储 HTTP MIME 数据体中每个数据结点，同时该类的实例是由 http_mime 类对象自动维护的，所以您一般不必关心该类对象的创建与销毁；另外，http_mime_node 类的继承关系为：http_mime_node -> mime_attach -> mime_node。\n\n该类的构造函数如下：\n```c++\n\t/**\n\t * 原始文件存放路径，不能为空\n\t * @param node {MIME_NODE*} 对应的 MIME 结点，非空\n\t * @param decodeIt {bool} 是否对 MIME 结点的头部数据\n\t *  或数据体数据进行解码\n\t * @param toCharset {const char*} 本机的字符集\n\t * @param off {off_t} 偏移数据位置\n\t */\n\thttp_mime_node(const char* path, const MIME_NODE* node,\n\t\tbool decodeIt = true, const char* toCharset = \"gb2312\", off_t off = 0);\n```\n\n 该类的常用方法为：\n```c++\n\t/**\n\t * 获得该结点的类型\n\t * @return {http_mime_t}\n\t */\n\thttp_mime_t get_mime_type(void) const;\n\n\t/**\n\t * 当 get_mime_type 返回的类型为 HTTP_MIME_PARAM 时，可以\n\t * 调用此函数获得参数值；参数名可以通过基类的 get_name() 获得\n\t * @return {const char*} 返回 NULL 表示参数不存在\n\t */\n\tconst char* get_value(void) const;\n```\n\nhttp_mime_t 为枚举类型，如：\n```c++\ntypedef enum\n{\n\tHTTP_MIME_PARAM,        // http mime 结点为参数类型\n\tHTTP_MIME_FILE          // http mime 结点为文件类型\n} http_mime_t;\n```\n加上两个基类的一些方法，有几个方法也是比较常用的，如下：\n- mime_node::get_name: 获得该 mime 结点的名称\n- mime_attach::get_filename: 当结点为上传文件类型时，此函数获得上传文件的文件名\n## 三、示例\n```c++\n#include \"lib_acl.hpp\"\n\nusing namespace acl;\n\nclass http_servlet : public HttpServlet\n{\npublic:\n\thttp_servlet()\n\t{\n\t\t...\n\t}\n\n\t...\n\t// 基类虚方法：HTTP POST 方法接口\n\tbool doPost(HttpServletRequest& req, HttpServletResponse& res)\n\t{\n\t\t...\n\t\treturn doUpload(req, res);\n\t}\n\n\t// 处理文件上传的函数\n\tbool doUpload(HttpServletRequest& req, HttpServletResponse& res)\n\t{\n\t\t// 先获得 Content-Type 对应的 http_ctype 对象\n\t\thttp_mime* mime = req.getHttpMime();\n\t\tif (mime == NULL)\n\t\t{\n\t\t\tlogger_error(\"http_mime null\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// 获得数据体的长度\n\t\tlong long int len = req.getContentLength();\n\t\tif (len <= 0)\n\t\t{\n\t\t\tlogger_error(\"body empty\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// 获得输入流\n\t\tistream& in = req.getInputStream();\n\t\tchar  buf[8192];\n\t\tint   ret;\n\t\tbool  n = false;\n\n\t\tconst char* filepath = \"./var/mime_file\";\n\t\tofstream out;\n\t\t// 只写方式打开存储上传文件的临时文件句柄\n\t\tout.open_write(filepath);\n\n\t\t// 设置原始文件存入路径\n\t\tmime->set_saved_path(filepath);\n\n\t\t// 读取 HTTP 客户端请求数据\n\t\twhile (len > 0)\n\t\t{\n\t\t\t// 从 HTTP 输入流中读取数据\n\t\t\tret = in.read(buf, sizeof(buf), false);\n\t\t\tif (ret == -1)\n\t\t\t{\n\t\t\t\tlogger_error(\"read POST data error\");\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\t// 将数据写入临时文件中\n\t\t\tout.write(buf, ret);\n\t\t\tlen -= ret;\n\n\t\t\t// 将读得到的数据输入至解析器进行解析\n\t\t\tif (mime->update(buf, ret) == true)\n\t\t\t{\n\t\t\t\tn = true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tout.close();\n\n\t\tif (len != 0 || n == false)\n\t\t\tlogger_warn(\"not read all data from client\");\n\n\t\tstring path;\n\n\t\t// 遍历所有的 MIME 结点，找出其中为文件结点的部分进行转储\n\t\tconst std::list<http_mime_node*>& nodes = mime->get_nodes();\n\t\tstd::list<http_mime_node*>::const_iterator cit = nodes.begin();\n\t\tfor (; cit != nodes.end(); ++cit)\n\t\t{\n\t\t\t// HTTP MIME 结点的变量名\n\t\t\tconst char* name = (*cit)->get_name();\n\n\t\t\t// HTTP MIME 结点的类型\n\t\t\thttp_mime_t mime_type = (*cit)->get_mime_type();\n\t\t\tif (mime_type == HTTP_MIME_FILE)\n\t\t\t{\n\t\t\t\t// 当该结点为文件数据结点时\n\t\t\t\t// 取得上传文件名\n\t\t\t\tconst char* filename = (*cit)->get_filename();\n\t\t\t\tif (filename == NULL)\n\t\t\t\t{\n\t\t\t\t\tlogger(\"filename null\");\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (strcmp(name, \"file1\") == 0)\n\t\t\t\t\tfile1_ = filename;\n\t\t\t\telse if (strcmp(name, \"file2\") == 0)\n\t\t\t\t\tfile2_ = filename;\n\t\t\t\telse if (strcmp(name, \"file3\") == 0)\n\t\t\t\t\tfile3_ = filename;\n\n\t\t\t\t// 将文件内容转存\n\t\t\t\tpath.format(\"./var/%s\", filename);\n\t\t\t\t(void) (*cit)->save(path.c_str());\n\t\t\t}\n\t\t}\n\n\t\t// 查找上载的某个文件并转储\n\t\tconst http_mime_node* node = mime->get_node(\"file1\");\n\t\tif (node && node->get_mime_type() == HTTP_MIME_FILE)\n\t\t{\n\t\t\tconst char* ptr = node->get_filename();\n\t\t\tif (ptr)\n\t\t\t{\n\t\t\t\tpath.format(\"./var/1_%s\", ptr);\n\t\t\t\t(void) node->save(path.c_str());\n\t\t\t}\n\t\t}\n\n\t\t// 删除临时文件\n\t\t:unlink(filepath);\n\n\t\t// 发送 http 响应头\n\t\tif (res.sendHeader() == false)\n\t\t\treturn false;\n\t\t// 发送 http 响应体\n\t\tif (res.getOutputStream().write(\"ok\") == -1)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\nprivate:\n\tconst char* file1_;\n\tconst char* file2_;\n\tconst char* file3_;\n};\n\nint main(void)\n{\n#ifdef WIN32\n\tacl::acl_cpp_init();\n#endif\n\n\t// 开始运行\n\thttp_servlet servlet;\n\tservlet.doRun(\"127.0.0.1:11211\"); // 开始运行，并假设 memcached 监听于 127.0.0.1:11211\n\treturn 0;\n}\n```\n\n与上面例子对应的 HTML 页面如下：\n\n```html\n<html>\n<head>\n<meta content=\"text/html; charset=gb2312\" http-equiv=\"Content-Type\">\n</head>\n<body>\n<form enctype=\"multipart/form-data\" method=POST action=\"/cgi-bin/test/upload?name1=中国人\">\n<input type=hidden name=\"name2\" value=\"美国人\"><br>\n<input type=hidden name=\"name3\" value=\"英国人\"><br>\n<input type=submit name=\"submit\", value=\"提交\"><br>\n文件一：<input type=file name=\"file1\" value=\"\"><br>\n文件二：<input type=file name=\"file2\" value=\"\"><br>\n文件三：<input type=file name=\"file3\" value=\"\"><br>\n</form>\n</body>\n</html>\n```\n\n上面例子比较简单地说明了如果使用 acl_cpp 中的 HttpServlet/http_mime 等类来实现文件上传的功能，完整的例子请参考：acl_cpp/samples/cig_upload。该例子虽然是一个 CGI 程序，但您依然可以不费吹灰之力将其改变成一个服务器程序，转换方法可参考：《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》。\n","slug":"http_upload","published":1,"updated":"2023-01-23T13:40:08.782Z","_id":"cld8uubya0000929k3xjqb14b","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在文章《用C++实现类似于JAVA HttpServlet 的编程接口 》中讲了如何用 acl_cpp 的 HttpServlet 等类来实现 WEB CGI 的功能，同时在文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中也举例说明如何将基于 HttpServlet 编写的 CGI 程序快速地转为服务器程序的过程。本文主要讲如何用 acl_cpp 的 WEB 编程类实现 HTTP 文件上传过程。为了实现 HTTP 协议的文件上传过程，引入了两个类：http_mime 和 http_mime_node。</p>\n<p>http_mime 类是有关 HTTP 协议中 mime 格式的流式解析器（即每次仅输入部分 HTTP MIME 数据，等数据输入完毕时，该解析器也解析完毕，流式解析的好处是它可以适用于阻塞或非阻塞的IO模式）；http_mime_node 类对象表示 http mime 数据中每一个 mime 结点对象，该结点的数据可能是文件内容数据，也可能是参数数据。</p>\n<h2 id=\"一、http-mime-类\"><a href=\"#一、http-mime-类\" class=\"headerlink\" title=\"一、http_mime 类\"></a>一、http_mime 类</h2><p>该类一般由 HttpServletRequest 类内部自动管理（负责分配与释放 http_mide 类对象），当然用户可以在测试 http_mime 类时，自己创建与释放该类对象。下面是该类的构造函数及常用方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构建函数</span><br><span class=\"hljs-comment\"> * @param boundary &#123;const char*&#125; 分隔符，不能为空</span><br><span class=\"hljs-comment\"> * @param local_charset &#123;const char*&#125; 本地字符集，非空时会自动将</span><br><span class=\"hljs-comment\"> *  参数内容转为本地字符集</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">http_mime</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* boundary, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* local_charset  = <span class=\"hljs-string\">&quot;gb2312&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>尤其需要指出的是 http mime 的 boundary(分隔符）与邮件的 mime 的分隔符规则略有不同，如邮件的相关头部字段为：Content-Type: multipart&#x2F;mixed; charset&#x3D;”GB2312”; boundary&#x3D;”0_11119_1331286082”，HTTP MIME 的相关头部字段为：Content-Type: multipart&#x2F;form-data; boundary&#x3D;”–0_11119_1331286082”。其中，最大的区别就是在 HTTP 头中获得的分隔符与 HTTP 数据体的分隔符（除结尾分隔符多了两个 ‘-‘ 后缀）完全相同，而邮件的 mime 的分隔符在头部和 mime 体中是不一样的，mime 体中的分隔符是由头部的分隔符加两个 ‘-‘ 作为前导符（结尾分隔符为头部分隔符前面加两个 ‘-‘，尾部加两个 ‘-‘），一定得注意这些不同。在 acl_cpp 中的 http mime 解析模块原来主要是作邮件 mime 解析的，现在依然支持 HTTP 的 mime 解析，唯一不同就是区分分隔符的不同。（当然，邮件的 MIME 数据体还与 HTTP MIME 数据体有另外一个区别：邮件的 MIME 数据一般都是要经过 BASE64 来编码的，而 HTTP MIME 却很少编码）。</p>\n<p>http_mime 的几个常用方法接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 MIME 数据的存储路径，当分析完 MIME 数据后，如果想要从中提取数据，</span><br><span class=\"hljs-comment\">    * 则必须给出该 MIME 的原始数据的存储位置，否则无法获得相应数据，即</span><br><span class=\"hljs-comment\">    * save_xxx/get_nodes/get_node 函数均无法正常使用</span><br><span class=\"hljs-comment\"> * @param path &#123;const char*&#125; 文件路径名, 如果该参数为空, 则不能</span><br><span class=\"hljs-comment\"> *  获得数据体数据, 也不能调用 save_xxx 相关的接口</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_saved_path</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* path)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用此函数进行流式方式解析数据体内容</span><br><span class=\"hljs-comment\"> * @param data &#123;const char*&#125; 数据体(可能是数据头也可能是数据体, </span><br><span class=\"hljs-comment\"> *  并且不必是完整的数据行)</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125; data 数据长度</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 针对 multipart 数据, 返回 true 表示解析完毕;</span><br><span class=\"hljs-comment\"> *  对于非 multipart 文件, 该返回值永远为 false, 没有任何意义, </span><br><span class=\"hljs-comment\"> *  需要调用者自己判断数据体的结束位置</span><br><span class=\"hljs-comment\"> * 注意: 调用完此函数后一定需要调用 update_end 函数通知解析器解析完毕</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* data, <span class=\"hljs-type\">size_t</span> len)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得所有的 MIME 结点</span><br><span class=\"hljs-comment\"> * @return &#123;const std::list&lt;http_mimde_node*&gt;&amp;&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> std::list&lt;http_mime_node*&gt;&amp; <span class=\"hljs-title\">get_nodes</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 根据变量名取得 HTTP MIME 结点</span><br><span class=\"hljs-comment\"> * @param param name &#123;const char*&#125; 变量名</span><br><span class=\"hljs-comment\"> * @return &#123;http_mime_node*&#125; 返回空则说明对应变量名的结点不存在</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> http_mime_node* <span class=\"hljs-title\">get_node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、http-mime-node-类\"><a href=\"#二、http-mime-node-类\" class=\"headerlink\" title=\"二、http_mime_node 类\"></a>二、http_mime_node 类</h2><p>该类实例存储 HTTP MIME 数据体中每个数据结点，同时该类的实例是由 http_mime 类对象自动维护的，所以您一般不必关心该类对象的创建与销毁；另外，http_mime_node 类的继承关系为：http_mime_node -&gt; mime_attach -&gt; mime_node。</p>\n<p>该类的构造函数如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 原始文件存放路径，不能为空</span><br><span class=\"hljs-comment\"> * @param node &#123;MIME_NODE*&#125; 对应的 MIME 结点，非空</span><br><span class=\"hljs-comment\"> * @param decodeIt &#123;bool&#125; 是否对 MIME 结点的头部数据</span><br><span class=\"hljs-comment\"> *  或数据体数据进行解码</span><br><span class=\"hljs-comment\"> * @param toCharset &#123;const char*&#125; 本机的字符集</span><br><span class=\"hljs-comment\"> * @param off &#123;off_t&#125; 偏移数据位置</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">http_mime_node</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* path, <span class=\"hljs-type\">const</span> MIME_NODE* node,<br>\t<span class=\"hljs-type\">bool</span> decodeIt = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* toCharset = <span class=\"hljs-string\">&quot;gb2312&quot;</span>, <span class=\"hljs-type\">off_t</span> off = <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p> 该类的常用方法为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得该结点的类型</span><br><span class=\"hljs-comment\"> * @return &#123;http_mime_t&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">http_mime_t</span> <span class=\"hljs-title\">get_mime_type</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 get_mime_type 返回的类型为 HTTP_MIME_PARAM 时，可以</span><br><span class=\"hljs-comment\"> * 调用此函数获得参数值；参数名可以通过基类的 get_name() 获得</span><br><span class=\"hljs-comment\"> * @return &#123;const char*&#125; 返回 NULL 表示参数不存在</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">get_value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>http_mime_t 为枚举类型，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span><br>&#123;<br>\tHTTP_MIME_PARAM,        <span class=\"hljs-comment\">// http mime 结点为参数类型</span><br>\tHTTP_MIME_FILE          <span class=\"hljs-comment\">// http mime 结点为文件类型</span><br>&#125; <span class=\"hljs-type\">http_mime_t</span>;<br></code></pre></td></tr></table></figure>\n<p>加上两个基类的一些方法，有几个方法也是比较常用的，如下：</p>\n<ul>\n<li>mime_node::get_name: 获得该 mime 结点的名称</li>\n<li>mime_attach::get_filename: 当结点为上传文件类型时，此函数获得上传文件的文件名</li>\n</ul>\n<h2 id=\"三、示例\"><a href=\"#三、示例\" class=\"headerlink\" title=\"三、示例\"></a>三、示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_servlet</span> : <span class=\"hljs-keyword\">public</span> HttpServlet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_servlet</span>()<br>\t&#123;<br>\t\t...<br>\t&#125;<br><br>\t...<br>\t<span class=\"hljs-comment\">// 基类虚方法：HTTP POST 方法接口</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t...<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">doUpload</span>(req, res);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 处理文件上传的函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doUpload</span><span class=\"hljs-params\">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 先获得 Content-Type 对应的 http_ctype 对象</span><br>\t\thttp_mime* mime = req.<span class=\"hljs-built_in\">getHttpMime</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (mime == <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;http_mime null&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 获得数据体的长度</span><br>\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> len = req.<span class=\"hljs-built_in\">getContentLength</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (len &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;body empty&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 获得输入流</span><br>\t\tistream&amp; in = req.<span class=\"hljs-built_in\">getInputStream</span>();<br>\t\t<span class=\"hljs-type\">char</span>  buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-type\">int</span>   ret;<br>\t\t<span class=\"hljs-type\">bool</span>  n = <span class=\"hljs-literal\">false</span>;<br><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* filepath = <span class=\"hljs-string\">&quot;./var/mime_file&quot;</span>;<br>\t\tofstream out;<br>\t\t<span class=\"hljs-comment\">// 只写方式打开存储上传文件的临时文件句柄</span><br>\t\tout.<span class=\"hljs-built_in\">open_write</span>(filepath);<br><br>\t\t<span class=\"hljs-comment\">// 设置原始文件存入路径</span><br>\t\tmime-&gt;<span class=\"hljs-built_in\">set_saved_path</span>(filepath);<br><br>\t\t<span class=\"hljs-comment\">// 读取 HTTP 客户端请求数据</span><br>\t\t<span class=\"hljs-keyword\">while</span> (len &gt; <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 从 HTTP 输入流中读取数据</span><br>\t\t\tret = in.<span class=\"hljs-built_in\">read</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;read POST data error&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 将数据写入临时文件中</span><br>\t\t\tout.<span class=\"hljs-built_in\">write</span>(buf, ret);<br>\t\t\tlen -= ret;<br><br>\t\t\t<span class=\"hljs-comment\">// 将读得到的数据输入至解析器进行解析</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (mime-&gt;<span class=\"hljs-built_in\">update</span>(buf, ret) == <span class=\"hljs-literal\">true</span>)<br>\t\t\t&#123;<br>\t\t\t\tn = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tout.<span class=\"hljs-built_in\">close</span>();<br><br>\t\t<span class=\"hljs-keyword\">if</span> (len != <span class=\"hljs-number\">0</span> || n == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-built_in\">logger_warn</span>(<span class=\"hljs-string\">&quot;not read all data from client&quot;</span>);<br><br>\t\tstring path;<br><br>\t\t<span class=\"hljs-comment\">// 遍历所有的 MIME 结点，找出其中为文件结点的部分进行转储</span><br>\t\t<span class=\"hljs-type\">const</span> std::list&lt;http_mime_node*&gt;&amp; nodes = mime-&gt;<span class=\"hljs-built_in\">get_nodes</span>();<br>\t\tstd::list&lt;http_mime_node*&gt;::const_iterator cit = nodes.<span class=\"hljs-built_in\">begin</span>();<br>\t\t<span class=\"hljs-keyword\">for</span> (; cit != nodes.<span class=\"hljs-built_in\">end</span>(); ++cit)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// HTTP MIME 结点的变量名</span><br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name = (*cit)-&gt;<span class=\"hljs-built_in\">get_name</span>();<br><br>\t\t\t<span class=\"hljs-comment\">// HTTP MIME 结点的类型</span><br>\t\t\t<span class=\"hljs-type\">http_mime_t</span> mime_type = (*cit)-&gt;<span class=\"hljs-built_in\">get_mime_type</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (mime_type == HTTP_MIME_FILE)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-comment\">// 当该结点为文件数据结点时</span><br>\t\t\t\t<span class=\"hljs-comment\">// 取得上传文件名</span><br>\t\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* filename = (*cit)-&gt;<span class=\"hljs-built_in\">get_filename</span>();<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (filename == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t\t&#123;<br>\t\t\t\t\t<span class=\"hljs-built_in\">logger</span>(<span class=\"hljs-string\">&quot;filename null&quot;</span>);<br>\t\t\t\t\t<span class=\"hljs-keyword\">continue</span>;<br>\t\t\t\t&#125;<br><br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcmp</span>(name, <span class=\"hljs-string\">&quot;file1&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t\tfile1_ = filename;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcmp</span>(name, <span class=\"hljs-string\">&quot;file2&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t\tfile2_ = filename;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcmp</span>(name, <span class=\"hljs-string\">&quot;file3&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t\tfile3_ = filename;<br><br>\t\t\t\t<span class=\"hljs-comment\">// 将文件内容转存</span><br>\t\t\t\tpath.format(<span class=\"hljs-string\">&quot;./var/%s&quot;</span>, filename);<br>\t\t\t\t(<span class=\"hljs-type\">void</span>) (*cit)-&gt;<span class=\"hljs-built_in\">save</span>(path.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 查找上载的某个文件并转储</span><br>\t\t<span class=\"hljs-type\">const</span> http_mime_node* node = mime-&gt;<span class=\"hljs-built_in\">get_node</span>(<span class=\"hljs-string\">&quot;file1&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (node &amp;&amp; node-&gt;<span class=\"hljs-built_in\">get_mime_type</span>() == HTTP_MIME_FILE)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ptr = node-&gt;<span class=\"hljs-built_in\">get_filename</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ptr)<br>\t\t\t&#123;<br>\t\t\t\tpath.format(<span class=\"hljs-string\">&quot;./var/1_%s&quot;</span>, ptr);<br>\t\t\t\t(<span class=\"hljs-type\">void</span>) node-&gt;<span class=\"hljs-built_in\">save</span>(path.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 删除临时文件</span><br>\t\t:<span class=\"hljs-built_in\">unlink</span>(filepath);<br><br>\t\t<span class=\"hljs-comment\">// 发送 http 响应头</span><br>\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-built_in\">sendHeader</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-comment\">// 发送 http 响应体</span><br>\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-built_in\">getOutputStream</span>().<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;ok&quot;</span>) == <span class=\"hljs-number\">-1</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* file1_;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* file2_;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* file3_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br>\thttp_servlet servlet;<br>\tservlet.<span class=\"hljs-built_in\">doRun</span>(<span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>); <span class=\"hljs-comment\">// 开始运行，并假设 memcached 监听于 127.0.0.1:11211</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>与上面例子对应的 HTML 页面如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;text/html; charset=gb2312&quot;</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;Content-Type&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">enctype</span>=<span class=\"hljs-string\">&quot;multipart/form-data&quot;</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">POST</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">&quot;/cgi-bin/test/upload?name1=中国人&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">hidden</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;name2&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;美国人&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">hidden</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;name3&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;英国人&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">submit</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>, <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;提交&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>文件一：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">file</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;file1&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>文件二：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">file</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;file2&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>文件三：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">file</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;file3&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>上面例子比较简单地说明了如果使用 acl_cpp 中的 HttpServlet&#x2F;http_mime 等类来实现文件上传的功能，完整的例子请参考：acl_cpp&#x2F;samples&#x2F;cig_upload。该例子虽然是一个 CGI 程序，但您依然可以不费吹灰之力将其改变成一个服务器程序，转换方法可参考：《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在文章《用C++实现类似于JAVA HttpServlet 的编程接口 》中讲了如何用 acl_cpp 的 HttpServlet 等类来实现 WEB CGI 的功能，同时在文章《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》中也举例说明如何将基于 HttpServlet 编写的 CGI 程序快速地转为服务器程序的过程。本文主要讲如何用 acl_cpp 的 WEB 编程类实现 HTTP 文件上传过程。为了实现 HTTP 协议的文件上传过程，引入了两个类：http_mime 和 http_mime_node。</p>\n<p>http_mime 类是有关 HTTP 协议中 mime 格式的流式解析器（即每次仅输入部分 HTTP MIME 数据，等数据输入完毕时，该解析器也解析完毕，流式解析的好处是它可以适用于阻塞或非阻塞的IO模式）；http_mime_node 类对象表示 http mime 数据中每一个 mime 结点对象，该结点的数据可能是文件内容数据，也可能是参数数据。</p>\n<h2 id=\"一、http-mime-类\"><a href=\"#一、http-mime-类\" class=\"headerlink\" title=\"一、http_mime 类\"></a>一、http_mime 类</h2><p>该类一般由 HttpServletRequest 类内部自动管理（负责分配与释放 http_mide 类对象），当然用户可以在测试 http_mime 类时，自己创建与释放该类对象。下面是该类的构造函数及常用方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构建函数</span><br><span class=\"hljs-comment\"> * @param boundary &#123;const char*&#125; 分隔符，不能为空</span><br><span class=\"hljs-comment\"> * @param local_charset &#123;const char*&#125; 本地字符集，非空时会自动将</span><br><span class=\"hljs-comment\"> *  参数内容转为本地字符集</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">http_mime</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* boundary, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* local_charset  = <span class=\"hljs-string\">&quot;gb2312&quot;</span>);<br></code></pre></td></tr></table></figure>\n\n<p>尤其需要指出的是 http mime 的 boundary(分隔符）与邮件的 mime 的分隔符规则略有不同，如邮件的相关头部字段为：Content-Type: multipart&#x2F;mixed; charset&#x3D;”GB2312”; boundary&#x3D;”0_11119_1331286082”，HTTP MIME 的相关头部字段为：Content-Type: multipart&#x2F;form-data; boundary&#x3D;”–0_11119_1331286082”。其中，最大的区别就是在 HTTP 头中获得的分隔符与 HTTP 数据体的分隔符（除结尾分隔符多了两个 ‘-‘ 后缀）完全相同，而邮件的 mime 的分隔符在头部和 mime 体中是不一样的，mime 体中的分隔符是由头部的分隔符加两个 ‘-‘ 作为前导符（结尾分隔符为头部分隔符前面加两个 ‘-‘，尾部加两个 ‘-‘），一定得注意这些不同。在 acl_cpp 中的 http mime 解析模块原来主要是作邮件 mime 解析的，现在依然支持 HTTP 的 mime 解析，唯一不同就是区分分隔符的不同。（当然，邮件的 MIME 数据体还与 HTTP MIME 数据体有另外一个区别：邮件的 MIME 数据一般都是要经过 BASE64 来编码的，而 HTTP MIME 却很少编码）。</p>\n<p>http_mime 的几个常用方法接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 MIME 数据的存储路径，当分析完 MIME 数据后，如果想要从中提取数据，</span><br><span class=\"hljs-comment\">    * 则必须给出该 MIME 的原始数据的存储位置，否则无法获得相应数据，即</span><br><span class=\"hljs-comment\">    * save_xxx/get_nodes/get_node 函数均无法正常使用</span><br><span class=\"hljs-comment\"> * @param path &#123;const char*&#125; 文件路径名, 如果该参数为空, 则不能</span><br><span class=\"hljs-comment\"> *  获得数据体数据, 也不能调用 save_xxx 相关的接口</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_saved_path</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* path)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用此函数进行流式方式解析数据体内容</span><br><span class=\"hljs-comment\"> * @param data &#123;const char*&#125; 数据体(可能是数据头也可能是数据体, </span><br><span class=\"hljs-comment\"> *  并且不必是完整的数据行)</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125; data 数据长度</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 针对 multipart 数据, 返回 true 表示解析完毕;</span><br><span class=\"hljs-comment\"> *  对于非 multipart 文件, 该返回值永远为 false, 没有任何意义, </span><br><span class=\"hljs-comment\"> *  需要调用者自己判断数据体的结束位置</span><br><span class=\"hljs-comment\"> * 注意: 调用完此函数后一定需要调用 update_end 函数通知解析器解析完毕</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">update</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* data, <span class=\"hljs-type\">size_t</span> len)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得所有的 MIME 结点</span><br><span class=\"hljs-comment\"> * @return &#123;const std::list&lt;http_mimde_node*&gt;&amp;&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> std::list&lt;http_mime_node*&gt;&amp; <span class=\"hljs-title\">get_nodes</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 根据变量名取得 HTTP MIME 结点</span><br><span class=\"hljs-comment\"> * @param param name &#123;const char*&#125; 变量名</span><br><span class=\"hljs-comment\"> * @return &#123;http_mime_node*&#125; 返回空则说明对应变量名的结点不存在</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> http_mime_node* <span class=\"hljs-title\">get_node</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、http-mime-node-类\"><a href=\"#二、http-mime-node-类\" class=\"headerlink\" title=\"二、http_mime_node 类\"></a>二、http_mime_node 类</h2><p>该类实例存储 HTTP MIME 数据体中每个数据结点，同时该类的实例是由 http_mime 类对象自动维护的，所以您一般不必关心该类对象的创建与销毁；另外，http_mime_node 类的继承关系为：http_mime_node -&gt; mime_attach -&gt; mime_node。</p>\n<p>该类的构造函数如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 原始文件存放路径，不能为空</span><br><span class=\"hljs-comment\"> * @param node &#123;MIME_NODE*&#125; 对应的 MIME 结点，非空</span><br><span class=\"hljs-comment\"> * @param decodeIt &#123;bool&#125; 是否对 MIME 结点的头部数据</span><br><span class=\"hljs-comment\"> *  或数据体数据进行解码</span><br><span class=\"hljs-comment\"> * @param toCharset &#123;const char*&#125; 本机的字符集</span><br><span class=\"hljs-comment\"> * @param off &#123;off_t&#125; 偏移数据位置</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">http_mime_node</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* path, <span class=\"hljs-type\">const</span> MIME_NODE* node,<br>\t<span class=\"hljs-type\">bool</span> decodeIt = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* toCharset = <span class=\"hljs-string\">&quot;gb2312&quot;</span>, <span class=\"hljs-type\">off_t</span> off = <span class=\"hljs-number\">0</span>);<br></code></pre></td></tr></table></figure>\n\n<p> 该类的常用方法为：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得该结点的类型</span><br><span class=\"hljs-comment\"> * @return &#123;http_mime_t&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">http_mime_t</span> <span class=\"hljs-title\">get_mime_type</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当 get_mime_type 返回的类型为 HTTP_MIME_PARAM 时，可以</span><br><span class=\"hljs-comment\"> * 调用此函数获得参数值；参数名可以通过基类的 get_name() 获得</span><br><span class=\"hljs-comment\"> * @return &#123;const char*&#125; 返回 NULL 表示参数不存在</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">get_value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>http_mime_t 为枚举类型，如：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span><br>&#123;<br>\tHTTP_MIME_PARAM,        <span class=\"hljs-comment\">// http mime 结点为参数类型</span><br>\tHTTP_MIME_FILE          <span class=\"hljs-comment\">// http mime 结点为文件类型</span><br>&#125; <span class=\"hljs-type\">http_mime_t</span>;<br></code></pre></td></tr></table></figure>\n<p>加上两个基类的一些方法，有几个方法也是比较常用的，如下：</p>\n<ul>\n<li>mime_node::get_name: 获得该 mime 结点的名称</li>\n<li>mime_attach::get_filename: 当结点为上传文件类型时，此函数获得上传文件的文件名</li>\n</ul>\n<h2 id=\"三、示例\"><a href=\"#三、示例\" class=\"headerlink\" title=\"三、示例\"></a>三、示例</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_servlet</span> : <span class=\"hljs-keyword\">public</span> HttpServlet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_servlet</span>()<br>\t&#123;<br>\t\t...<br>\t&#125;<br><br>\t...<br>\t<span class=\"hljs-comment\">// 基类虚方法：HTTP POST 方法接口</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t...<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">doUpload</span>(req, res);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 处理文件上传的函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doUpload</span><span class=\"hljs-params\">(HttpServletRequest&amp; req, HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 先获得 Content-Type 对应的 http_ctype 对象</span><br>\t\thttp_mime* mime = req.<span class=\"hljs-built_in\">getHttpMime</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (mime == <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;http_mime null&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 获得数据体的长度</span><br>\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> len = req.<span class=\"hljs-built_in\">getContentLength</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (len &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;body empty&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 获得输入流</span><br>\t\tistream&amp; in = req.<span class=\"hljs-built_in\">getInputStream</span>();<br>\t\t<span class=\"hljs-type\">char</span>  buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-type\">int</span>   ret;<br>\t\t<span class=\"hljs-type\">bool</span>  n = <span class=\"hljs-literal\">false</span>;<br><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* filepath = <span class=\"hljs-string\">&quot;./var/mime_file&quot;</span>;<br>\t\tofstream out;<br>\t\t<span class=\"hljs-comment\">// 只写方式打开存储上传文件的临时文件句柄</span><br>\t\tout.<span class=\"hljs-built_in\">open_write</span>(filepath);<br><br>\t\t<span class=\"hljs-comment\">// 设置原始文件存入路径</span><br>\t\tmime-&gt;<span class=\"hljs-built_in\">set_saved_path</span>(filepath);<br><br>\t\t<span class=\"hljs-comment\">// 读取 HTTP 客户端请求数据</span><br>\t\t<span class=\"hljs-keyword\">while</span> (len &gt; <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 从 HTTP 输入流中读取数据</span><br>\t\t\tret = in.<span class=\"hljs-built_in\">read</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf), <span class=\"hljs-literal\">false</span>);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">-1</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;read POST data error&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t&#125;<br>\t\t\t<span class=\"hljs-comment\">// 将数据写入临时文件中</span><br>\t\t\tout.<span class=\"hljs-built_in\">write</span>(buf, ret);<br>\t\t\tlen -= ret;<br><br>\t\t\t<span class=\"hljs-comment\">// 将读得到的数据输入至解析器进行解析</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (mime-&gt;<span class=\"hljs-built_in\">update</span>(buf, ret) == <span class=\"hljs-literal\">true</span>)<br>\t\t\t&#123;<br>\t\t\t\tn = <span class=\"hljs-literal\">true</span>;<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\tout.<span class=\"hljs-built_in\">close</span>();<br><br>\t\t<span class=\"hljs-keyword\">if</span> (len != <span class=\"hljs-number\">0</span> || n == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-built_in\">logger_warn</span>(<span class=\"hljs-string\">&quot;not read all data from client&quot;</span>);<br><br>\t\tstring path;<br><br>\t\t<span class=\"hljs-comment\">// 遍历所有的 MIME 结点，找出其中为文件结点的部分进行转储</span><br>\t\t<span class=\"hljs-type\">const</span> std::list&lt;http_mime_node*&gt;&amp; nodes = mime-&gt;<span class=\"hljs-built_in\">get_nodes</span>();<br>\t\tstd::list&lt;http_mime_node*&gt;::const_iterator cit = nodes.<span class=\"hljs-built_in\">begin</span>();<br>\t\t<span class=\"hljs-keyword\">for</span> (; cit != nodes.<span class=\"hljs-built_in\">end</span>(); ++cit)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// HTTP MIME 结点的变量名</span><br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name = (*cit)-&gt;<span class=\"hljs-built_in\">get_name</span>();<br><br>\t\t\t<span class=\"hljs-comment\">// HTTP MIME 结点的类型</span><br>\t\t\t<span class=\"hljs-type\">http_mime_t</span> mime_type = (*cit)-&gt;<span class=\"hljs-built_in\">get_mime_type</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (mime_type == HTTP_MIME_FILE)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-comment\">// 当该结点为文件数据结点时</span><br>\t\t\t\t<span class=\"hljs-comment\">// 取得上传文件名</span><br>\t\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* filename = (*cit)-&gt;<span class=\"hljs-built_in\">get_filename</span>();<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (filename == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t\t&#123;<br>\t\t\t\t\t<span class=\"hljs-built_in\">logger</span>(<span class=\"hljs-string\">&quot;filename null&quot;</span>);<br>\t\t\t\t\t<span class=\"hljs-keyword\">continue</span>;<br>\t\t\t\t&#125;<br><br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcmp</span>(name, <span class=\"hljs-string\">&quot;file1&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t\tfile1_ = filename;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcmp</span>(name, <span class=\"hljs-string\">&quot;file2&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t\tfile2_ = filename;<br>\t\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcmp</span>(name, <span class=\"hljs-string\">&quot;file3&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t\tfile3_ = filename;<br><br>\t\t\t\t<span class=\"hljs-comment\">// 将文件内容转存</span><br>\t\t\t\tpath.format(<span class=\"hljs-string\">&quot;./var/%s&quot;</span>, filename);<br>\t\t\t\t(<span class=\"hljs-type\">void</span>) (*cit)-&gt;<span class=\"hljs-built_in\">save</span>(path.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 查找上载的某个文件并转储</span><br>\t\t<span class=\"hljs-type\">const</span> http_mime_node* node = mime-&gt;<span class=\"hljs-built_in\">get_node</span>(<span class=\"hljs-string\">&quot;file1&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (node &amp;&amp; node-&gt;<span class=\"hljs-built_in\">get_mime_type</span>() == HTTP_MIME_FILE)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ptr = node-&gt;<span class=\"hljs-built_in\">get_filename</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ptr)<br>\t\t\t&#123;<br>\t\t\t\tpath.format(<span class=\"hljs-string\">&quot;./var/1_%s&quot;</span>, ptr);<br>\t\t\t\t(<span class=\"hljs-type\">void</span>) node-&gt;<span class=\"hljs-built_in\">save</span>(path.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 删除临时文件</span><br>\t\t:<span class=\"hljs-built_in\">unlink</span>(filepath);<br><br>\t\t<span class=\"hljs-comment\">// 发送 http 响应头</span><br>\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-built_in\">sendHeader</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-comment\">// 发送 http 响应体</span><br>\t\t<span class=\"hljs-keyword\">if</span> (res.<span class=\"hljs-built_in\">getOutputStream</span>().<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;ok&quot;</span>) == <span class=\"hljs-number\">-1</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* file1_;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* file2_;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* file3_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br>\thttp_servlet servlet;<br>\tservlet.<span class=\"hljs-built_in\">doRun</span>(<span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>); <span class=\"hljs-comment\">// 开始运行，并假设 memcached 监听于 127.0.0.1:11211</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>与上面例子对应的 HTML 页面如下：</p>\n<figure class=\"highlight html\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs html\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">meta</span> <span class=\"hljs-attr\">content</span>=<span class=\"hljs-string\">&quot;text/html; charset=gb2312&quot;</span> <span class=\"hljs-attr\">http-equiv</span>=<span class=\"hljs-string\">&quot;Content-Type&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">form</span> <span class=\"hljs-attr\">enctype</span>=<span class=\"hljs-string\">&quot;multipart/form-data&quot;</span> <span class=\"hljs-attr\">method</span>=<span class=\"hljs-string\">POST</span> <span class=\"hljs-attr\">action</span>=<span class=\"hljs-string\">&quot;/cgi-bin/test/upload?name1=中国人&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">hidden</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;name2&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;美国人&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">hidden</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;name3&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;英国人&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">submit</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;submit&quot;</span>, <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;提交&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>文件一：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">file</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;file1&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>文件二：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">file</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;file2&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br>文件三：<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">input</span> <span class=\"hljs-attr\">type</span>=<span class=\"hljs-string\">file</span> <span class=\"hljs-attr\">name</span>=<span class=\"hljs-string\">&quot;file3&quot;</span> <span class=\"hljs-attr\">value</span>=<span class=\"hljs-string\">&quot;&quot;</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">br</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">form</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>上面例子比较简单地说明了如果使用 acl_cpp 中的 HttpServlet&#x2F;http_mime 等类来实现文件上传的功能，完整的例子请参考：acl_cpp&#x2F;samples&#x2F;cig_upload。该例子虽然是一个 CGI 程序，但您依然可以不费吹灰之力将其改变成一个服务器程序，转换方法可参考：《使用 acl_cpp 的 HttpServlet 类及服务器框架编写WEB服务器程序 》。</p>\n"},{"title":"acl库使用FAQ","date":"2019-06-30T05:08:24.000Z","_content":"\n## acl库使用FAQ\n\n* [一、基础问题](#一基础问题)\n    * [1、acl 库是啥、主要包含哪些功能？](#1acl-库是啥主要包含哪些功能)\n    * [2、acl 库支持哪些平台？](#2acl-库支持哪些平台)\n    * [3、acl 库主要包含几个库？](#3acl-库主要包含几个库)\n    * [4、acl 库有哪些外部依赖库？](#4acl-库有哪些外部依赖库)\n    * [5、没有这些第三方库 acl 能否使用？](#5没有这些第三方库-acl-能否使用)\n    * [6、acl 库的源码下载位置在哪儿？](#6acl-库的源码下载位置在哪儿)\n* [二、编译&使用问题](#二编译使用问题)\n    * [1、acl 库的编译过程？](#1acl-库的编译过程)\n    * [2、Linux 平台下库的编译顺序问题？](#2linux-平台下库的编译顺序问题)\n    * [3、Unix/Linux 平台下编译 acl 库时的编译选项是什么](#3unixlinux-平台下编译-acl-库时的编译选项是什么)\n    * [4、请给出 Linux 平台下最简单的一个 Makefile？](#4请给出-linux-平台下最简单的一个-makefile)\n    * [5、Linux 平台下找不到 libz.a 库怎么办？](#5linux-平台下找不到-libza-库怎么办)\n    * [6、Linux 平台下 acl 库能打包成一个库吗？](#6linux-平台下-acl-库能打包成一个库吗)\n    * [7、Linux 平台下如何使用 ssl 功能？](#7linux-平台下如何使用-ssl-功能)\n    * [8、Linux 下如何使用 mysql 功能？](#8linux-下如何使用-mysql-功能)\n* [三、各个功能模块的使用问题](#三各个功能模块的使用问题)\n    * [（一）、网络通信](#一网络通信)\n    * [（二）、HTTP 模块](#二http-模块)\n        * [1. acl HTTP 服务器是否支持断点下载功能？](#1-acl-http-服务器是否支持断点下载功能)\n        * [2. acl HTTP 服务器是否支持文件上传功能？](#2-acl-http-服务器是否支持文件上传功能)\n        * [3. acl HTTP 模块是否支持服务器/客户端两种模式？](#3-acl-http-模块是否支持服务器客户端两种模式)\n        * [4. acl HTTP 模块是否支持 websocket 通信协议？](#4-acl-http-模块是否支持-websocket-通信协议)\n        * [5. acl HTTP 模块是否支持 session？](#5-acl-http-模块是否支持-session)\n        * [6. HttpServletRequest 为何读不到 json 或 xml 数据体？](#6-HttpServletRequest-为何读不到-json-或-xml-数据体)\n        * [7. http_request 因未设 Host 字段而出错的问题](#7-http_request-因未设-Host-字段而出错的问题)\n    * [（三）、Redis 模块](#三redis-模块)\n        * [1. acl redis 库是否支持集群功能？](#1-acl-redis-库是否支持集群功能)\n        * [2. acl redis 库是如何划分的？](#2-acl-redis-库是如何划分的)\n        * [3. acl redis 库中的哪些类对象操作是线程安全的？](#3-acl-redis-库中的哪些类对象操作是线程安全的)\n        * [4. acl redis 客户库当连接断开时是否会重连？](#4-acl-redis-客户库当连接断开时是否会重连)\n    * [（四）、协程模块](#四协程模块)\n        * [1. 协程里面的非阻塞是什么原理的？](#1-协程里面的非阻塞是什么原理的)\n        * [2. acl 协程库是否支持多线程？](#2-acl-协程库是否支持多线程)\n        * [3. acl 协程库如何支持多核 CPU？](#3-acl-协程库如何支持多核-cpu)\n        * [4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？](#4-acl-协程里针对-mysql-客户端库的协程化是否修改了-mysql-库的源码)\n        * [5. acl 协程库支持域名解析功能吗？](#5-acl-协程库支持域名解析功能吗)\n        * [6. acl 协程库的系统 errno 号如何处理？](#6-acl-协程库的系统-errno-号如何处理)\n        * [7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？](#7-如果启动的协程过多会不会对于后端例如-mysql-之类服务造成并发压力如何避免)\n    * [（五）、服务器模块](#五服务器模块)\n        * [1. 有几种服务器编程模型？均有何特点？](#1-有几种服务器编程模型均有何特点)\n        * [2. acl_master 的作用是什么？支持哪些平台？](#2-acl_master-的作用是什么支持哪些平台)\n        * [3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？](#3-没有-acl_master-控制管理服务子进程是否可以单独运行)\n        * [4. 手工模式下运行时遇到“idle timeout -- exiting, idle”怎么办？](#4-手工模式下运行时遇到idle-timeout----exiting-idle怎么办)\n        * [5. acl_master 控制模式下，服务子进程如何预启动多个进程？](#5-acl_master-控制模式下服务子进程如何预启动多个进程)\n        * [6. acl_master 控制模式下，如何只监听内网地址？](#6-acl_master-控制模式下如何只监听内网地址)\n    * [（六）、数据库模块](#六数据库模块)\n        * [1. acl 数据库客户端支持哪些数据库？](#1-acl-数据库客户端支持哪些数据库)\n        * [2. acl 数据库模块如何使用？](#2-acl-数据库模块如何使用)\n    * [（七）、邮件&mime模块](#七邮件mime模块)\n\n### 一、基础问题\n### 1、acl 库是啥、主要包含哪些功能？\nacl 工程是一个跨平台（支持LINUX，WIN32，Solaris，MacOS，FreeBSD）的网络通信库及服务器编程框架，同时提供更多的实用功能库。通过该库，用户可以非常容易地编写支持多种模式(多线程、多进程、非阻塞、触发器、UDP方式、协程方式)的服务器程序，WEB 应用程序，数据库应用程序。此外，该库还提供了常见应用的客户端通信库（如：HTTP、SMTP、ICMP、redis、disque、memcache、beanstalk、handler socket），常见流式编解码库：XML/JSON/MIME/BASE64/UUCODE/QPCODE/RFC2047 等。\n### 2、acl 库支持哪些平台？\n目前主要支持 Linux/Windows/Macos/Freebsd/Solaris(x86)。\n### 3、acl 库主要包含几个库？\n主要包括：lib_acl（用 C 语言写的基础库）、lib_protocol（用 C 语言写的一些网络应用协议库）、lib_acl_cpp（用 C++ 语言编写，封装了 lib_acl/lib_protocol 两个库，同时增加更多实用的功能库）、 lib_fiber（用 C 语言编写的支持高性能、高并发的网络协程库）、lib_rpc（用C++语言编写的封装了 google protobuf 网络库）。\n### 4、acl 库有哪些外部依赖库？\nlib_acl/lib_protocol/lib_fiber 仅依赖系统基础库；lib_acl_cpp 库的 db 模块依赖于 mysql 客户端库、sqlite 库，stream 流模块依赖于 polarssl 库（该库源码附在 acl/resource 目录下），另外，在 UNIX/LINUX 平台下还需要压缩库 --- libz 库（一般 LINUX 会自带该压缩库）；lib_rpc 依赖于 protobuf 库。\n### 5、没有这些第三方库 acl 能否使用？\n可以。默认情况下，没有这些第三方库编译和使用 acl 库是没有问题的，只是不能使用 mysql/sqlite/ssl/protobuf 功能。\n### 6、acl 库的源码下载位置在哪儿？\n- github：https://github.com/acl-dev/acl/\n- oschina: https://git.oschina.net/acl-dev/acl/\n- sourceforge：https://sourceforge.net/projects/acl/\n \n### 二、编译&使用问题\n### 1、acl 库的编译过程？\nacl 库的编译过程请参考：[acl 的编译与使用](http://zsxxsz.iteye.com/blog/1506554) 博客。\n### 2、Linux 平台下库的编译顺序问题？\nlib_acl 库是 acl 库中的基础库，其它库均依赖于该库，库的依赖顺序为：lib_protocol 依赖于 lib_acl，lib_acl_cpp 依赖于 lib_acl 和 lib_protocol，lib_fiber 依赖于 lib_acl，lib_rpc 依赖于 lib_acl/lib_protocol/lib_acl_cpp。因此当应用在连接 acl 库时，需要注意连接的顺序为：-l_acl_cpp -l_protocol -l_acl。\n### 3、Unix/Linux 平台下编译 acl 库时的编译选项是什么？\n在 Unix/Linux 平台下编译 acl 库时需要指明 gcc 的编译选项，acl 库自带的 Makefile 会自动识别操作系统而选择不同的编译选项，下面列出不同 Unix 平台的不同编译选项（当前版本已自动识别系统类型，无需添加如下编译选项）：\n- Linux 平台：-DLINUX2\n- MacOS 平台：-DMACOSX\n- FreeBSD 平台：-DFREEBSD\n- Solaris(x86) 平台：-DSUNOS5  \n\n### 4、请给出 Linux 平台下最简单的一个 Makefile？\n下面是使用 acl 库的最简单的编译选项（因为排版问题，当拷贝下面内容至 Makefile 时，需要注意将每行前空格手工转成 TAB 键）：\n~~~\nfiber: main.o\n\tg++ -o fiber main.o \\\n\t\t-L./lib_fiber/lib -lfiber_cpp \\\n\t\t-L./lib_acl_cpp/lib -l_acl_cpp \\\n\t\t-L./lib_protocol/lib -l_protocol \\\n\t\t-L./lib_acl/lib -l_acl \\\n\t\t-L./lib_fiber/lib -lfiber \\\n\t\t-lz -lpthread -ldl\nmain.o: main.cpp\n\tg++ -O3 -Wall -c main.cpp -DLINUX2 \\\n\t\t-I./lib_acl/include \\\n\t\t-I./lib_acl_cpp/include \\\n\t\t-I./lib_fiber/cpp/include \\\n\t\t-I./lib_fiber/c/include\n~~~\n### 5、Linux 平台下找不到 libz.a 库怎么办？\n一般 Unix/Linux 平台下系统会自带 libz.a 或 libz.so 压缩库，如果找不到该库，则可以在线安装或采用编译安装 zlib 库，针对 Centos 和 Ubuntu 可分别通过以下方式在线安装（均需切换至 root 身份）：\n- Centos：yum install zlib-devel\n- Ubuntu：apt-get install zlib1g.dev\n\n### 6、Linux 平台下 acl 库能打包成一个库吗？\n可以。在 acl 目录下运行：make build_one 则可以将 lib_acl/lib_protocol/lib_acl_cpp 打包成一个完整的库：lib_acl.a/lib_acl.so，则应用最终使用时可以仅连接这一个库即可。\n\n### 7、Linux 平台下如何使用 ssl 功能？\n目前 acl 中的 lib_acl_cpp C++ 库通过集成 polarssl 支持 ssl 功能，所支持的 polarssl 源码的下载位置：https://github.com/acl-dev/third_party, 老版本 acl 通过静态连接 libpolarssl.a 实现对 ssl 的支持，当前版本则是通过动态加载 libpolarssl.so 方式实现了对 ssl 的支持，此动态支持方式更加灵活方便，无须特殊编译条件，也更为通用。\n#### 7.1、老版本 acl 对 ssl 的支持方式\n如果使用上面统一的 acl 库，则可以在 acl 根目录下编译时运行：make build_one polarssl=on；如果使用三个库：lib_acl.a，lib_protocol.a，lib_acl_cpp.a，则在编译前需要先指定环境变量：export ENV_FLAGS=HAS_POLARSSL，然后分别编译这三个库；解压 polarssl-1.2.19-gpl.tgz，然后进入 polarssl-1.2.19 目录运行：make 编译后在 polarssl-1.2.19/library 目录得到 libpolarssl.a 库；最后在编译应用时将 libpolarssl.a 连接进你的工程中即可。\n#### 7.2、当前版本 acl 对 ssl 的支持方式\n- 首先下载解压 polarssl 库后进入polarssl-1.2.19 目录，运行 make lib SHARED=yes，在library 目录下会生成 libpolarssl.so 动态库;\n- 在 acl 根目录下运行 make build_one，则会将 acl 的三个基础库：libacl.a, libprotocol.a, libacl_cpp.a 合成 libacl_all.a 一个静态库，将 libacl.so, libprotocol.so, lib_acl_cpp.so 合成 libacl_all.so 一个动态库;\n- 当程序启动时添加代码：acl::polarssl_conf::set_libpath(\"libpolarssl.so\"); 其中的路径根据实际位置而定，这样 acl 模块在需要 ssl 通信时会自动切换至 ssl 方式。\n\n### 8、Linux 下如何使用 mysql 功能？\nlib_acl_cpp 库是以动态加载方式加载 mysql 动态库的，所以在编译 lib_acl_cpp 时，mysql 功能就已经被编译进去 acl库中了。用户仅需要将 mysql 动态库通过函数 acl::db_handle::set_loadpath 注册进 acl 库中即可；至于 mysql 客户端库，用户可以去 mysql 官方下载或在 acl/resource 目录下编译 mysql-connector-c-6.1.6-src.tar.gz。\n \n### 三、各个功能模块的使用问题\n### （一）、网络通信\n### （二）、HTTP 模块\n#### 1. acl HTTP 服务器是否支持断点下载功能？\n支持。acl HTTP 模块支持断点续传功能，一个支持断点下载的服务器示例参照：acl\\app\\wizard_demo\\httpd_download。\n\n#### 2. acl HTTP 服务器是否支持文件上传功能？\n支持。参考示例：acl\\app\\wizard_demo\\httpd_upload。\n\n#### 3. acl HTTP 模块是否支持服务器/客户端两种模式？\n支持。目前 acl 的 HTTP 协议模块同时支持客户端及服务端模式，即你既可以使用 acl HTTP 编写客户端程序，又可以编写服务器程序，其中 acl 中的 http_request/http_request_pool/http_request_manager 类用来编写客户端程序，http_response/HttpServlet/HttpServletRequest/HttpServeletResponse 用来编写服务器程序。\n\n#### 4. acl HTTP 模块是否支持 websocket 通信协议？\n支持。可以参考示例：lib_acl_cpp\\samples\\websocket。\n\n#### 5. acl HTTP 模块是否支持 session？\n支持。acl HTTP 模块当用在服务器编程时支持 session 存储，目前支持使用 memcached 或 redis 存储 session 数据。\n \n#### 6. HttpServletRequest 为何读不到 json 或 xml 数据体\n当 HTTP 客户端请求的数据体为 json 或 xml 时，默认情况下从 acl::HttpServletRequest 对象中是读不到 json/xml 数据的，主要原因在于 HttpServletRequest 内置了自动读取并解析 json/xml/x-www-form-urlencoded 类型数据的功能，使用者只需直接获取解析后的对象即可，如针对 json 类数据体：\n\n```c++\nvoid get_json(acl::HttpServletRequest& req)\n{\n\tacl::json* json = req.getJson();\n\t...\n}\n```\n\n如果应用想自己读取并解析 json 数据，则需要在调用 acl::HttpServlet::setParseBody(false)，禁止 acl::HttpServletRequest 类对象内部自动读取数据。\n\n#### 7. http_request 因未设 Host 字段而出错的问题\n在使用 acl::http_request 类对象访问标准 WEB 服务器（如：nginx）时，如果没有设置 HTTP 请求头中的 Host 字段，nginx 会返回 400 错误，主要是 HTTP/1.1 协议要求 HTTP 客户端必须设置 Host 字段，方法如下：\n\n```c++\nbool http_client(void)\n{\n\tacl::http_request req(\"www.sina.com.cn:80\");\n\tacl::http_header& hdr = req.request_header();\n\thdr.set_url(\"/\").set_host(\"www.sina.com.cn\");\n\tif (!req.request(NULL, 0)) {\n\t\treturn false;\n\t}\n\tacl::string body;\n\tif (req.get_body(body)) {\n\t\tprintf(\"%s\\r\\n\", body.c_str());\n\t}\n\t\n\t... \n}\n\n```\n\n### （三）、Redis 模块\n#### 1. acl redis 库是否支持集群功能？\n答案：是，acl redis 客户端库同时支持集群和单机方式的 redis-server。\n\n#### 2. acl redis 库是如何划分的？\nacl redis 客户端库主要分为两类：命令类和连接类：\n- **命令类主要有**：redis_key, redis_string, redis_hash, redis_list, redis_set, redis_zset, redis_cluster, redis_geo, redis_hyperloglog, redis_pubsub, redis_transaction, redis_server, redis_script, 这些类都继承于基类 redis_command，同时子类 redis 又继承了所有这些命令类，以便于用户可以直接使用 acl::redis 操作所有的 redis 客户端命令；\n- **连接类主要有**：redis_client, redis_client_pool, redis_client_cluster，命令类对象通过这些连接类对象与 redis-server 进行交互，redis_client 为单连接类，redis_client_pool 为连接池类，这两个类仅能在非集群模式的 redis-server 环境中使用，不支持 redis-server 的集群模式，必须使用 redis_client_cluster 连接集群模式的 redis-server，同时 redis_client_cluster 也兼容非集群模式的连接。\n\n#### 3. acl redis 库中的哪些类对象操作是线程安全的？\nacl redis 库中的所有命令类对象及 redis_client 单连接类对象不能同时被多个线程使用（就象 std::string 一样不能跨线程使用）；redis_client_pool，redis_client_cluster 两个连接类对象是线程操作安全的，同一个对象可以被多个线程同时使用。\n\n#### 4. acl redis 客户库当连接断开时是否会重连？\nacl redis 库中的连接类中：redis_client，redis_client_pool，redis_client_cluster 三个连接类对象当检测到网络连接异常断开时会尝试自动重连，上层使用者无需考虑连接断开重试的情况。\n \n### （四）、协程模块\n#### 1. 协程里面的非阻塞是什么原理的？\n比如我现在需要访问数据库，这个动作肯定是个阻塞的操作，如果有10个协程进行数据库访问，这个非阻塞是怎么理解的？\n协程方式在底层将系统的 IO API（read/write 等）都 hook 了，数据库操作也要调用这些API，所以表面上的阻塞式DB操作在协程底层的IO也会被转为非阻塞模式。\n\n#### 2. acl 协程库是否支持多线程？\nacl 协程库支持多线程方式，只是支持的方式与 go 语言有所不同。用户可以创建多个线程，每个线程一个协程调度器，线程之间的协程调度是相互隔离的，正如多进程与多线程之间的关系一样（每个进程内可以启动多个线程，但进程之间的线程的调度过程是隔离的），在每个线程内部可以创建大量 acl 协程，每个协程均由其所属的线程内的协程调度器调度运行。\n\n#### 3. acl 协程库如何支持多核 CPU？\n正如 2）所说，用户可以启动多个线程，每个线程一个 acl 协程调度器，每个协程调度器负责调度与其同属相同线程的协程运行状态。\n\n#### 4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？\n没有。mysql 客户端库使用的系统 IO API 为 read/write/poll，而 acl 协程库 HOOK 了系统底层的 IO 过程，因此当将用户程序与 mysql 库及 acl 协程库一起编译后，mysql 库的 IO 过程直接被 acl 协程库 HOOK 的 API 接管，从而将 mysql 客户端库协程化而无须修改一行 mysql 库代码。\n\n#### 5. acl 协程库支持域名解析功能吗？\n支持。很多 C/C++ 实现的协程库并未实现 gethostbyname(_r) 函数，导致用户在使用协程编程遇到域名解析时还需要借助单独的线程来完成，acl 库本身从 DNS 协议层次实现了域名解析过程，acl 协程库基于此功能模块 HOOK 了系统的 gethostbyname(_r) API 而无须借助第三方函数库或起单独的线程完成域名解析。\n\n#### 6. acl 协程库的系统 errno 号如何处理？\nacl 协程库实现了协程安全的 errno 号，正如之前使用多线程编程时 errno 可以与每个线程绑定一样，在 acl 协程库里 errno 也是与每个 acl 协程进行绑定的。因此，当你调用 strerror(errno) 时也是协程安全的。\n\n#### 7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？\n当启动用协程较多且都需要 mysql 操作时的确会造成 mysql 服务器的并发压力。为避免此并发压力，acl 协程库提供了协程信号量，用来针对后端不支持高并发的服务提供连接保护。\n \n### （五）、服务器模块\n#### 1. 有几种服务器编程模型？均有何特点？\n目前 acl 库中提供：进程池模型、线程池模型、非阻塞模型、协程模型、UDP 通信模型、触发器模型。其中各个编程模型的特点如下：  \n\n__进程池模型：__ 每个进程处理一个客户端连接，当需要处理多个连接时则需要启动多个进程，此模型的最大缺点是并发度低，优点是编程简单；  \n__线程池模型：__ 由多个线程组成线程池处理大量的客户端连接，只有当某个连接有数据可读时该连接才会与一个线程绑定，处理完毕则线程归还给线程池，此模型的优点是启动少数线程便处理较大并发，缺点是需要注意线程编程时的线程安全问题；  \n__非阻塞模型：__ 一个进程内仅有一个工作线程，通过采用非阻塞通信方式可以支持非常大的客户端并发连接，优点是资源消耗小、支持大并发、性能高，缺点是编程复杂度高；  \n__协程模型：__ 每个客户端连接与一个协程绑定，每个进程内一个工作线程，每个线程内可以创建大 量的协程，优点是支持大并发、性能高、编程简单、应用场景比较广，缺点是占用内存要比非阻塞模型高；  \n__UDP通信模型：__ 支持简单的 UDP 通信方式；触发器模型：常用在定时任务的应用场景中。  \n以上的服务模型均可启动多个进程，通过配置文件的配置项来决定启动进程的数量。\n\n#### 2. acl_master 的作用是什么？支持哪些平台？\nacl_master 为由以上各个服务器编写的服务进程的控制管理程序， acl_master\n启动、停止各个服务子进程，控制子进程的启动数量及预启动策略，监控子进程的异常情况；acl_master 有点类似于 LINUX 下的 xinetd 服务进程，不同之处是 acl_master 功能更完善强大，支持服务子进程的常驻留、半驻留，而 xinetd 则只针对一个连接创建一个进程，不能用于高并发的服务应用场景。  \n目前 acl_master 进程仅支持 LINUX/MACOS/FREEBSD/SOLARIS(X86）等 UNIX 平台，不支持 WINDOWS 平台。  \n#### 3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？\n\n可以。在没有 acl_master 的情况下，由以上各个服务模型编写的服务程序可以通过手工方式启动。启动方式一般为：./xxxx alone xxxx.cf，这样服务程序便以 alone 模式启动运行，具体情况可以参考 main.cpp 里的启动方式；在 WINDOWS 平台下只能是以 alone 模式手工启动运行。\n\n#### 4. 手工模式下运行时遇到\"idle timeout -- exiting, idle\"怎么办？\n因为 acl 的服务器编程模型均支持半驻留方式（即运行空闲一段时间或处理连接次数达到设定值后会自动退出，这样的好处是：可以定期通过进程退出释放可能存在的资源泄露，另一方面便于用户在开发时通过 valgrind 进行内存检查），如果让进程不退出，可以在 alone 模式下给服务程序传递启动配置文件，如启动方式为：./xxxx alone xxxx.cf（传递方式可以看 main.cpp 和相关头文件），不同的服务器模型分别采取下面不同的配置项：  \n\n__程池模型：__ 将配置项 single_use_limit 和 single_idle_limit 设为 0；  \n__线程池模型：__ 将配置项 ioctl_use_limit 和 ioctl_idle_limit 设为 0；  \n__非阻塞模型：__ 将配置项 aio_use_limit 和 aio_idle_limit 设为 0；  \n__协程模型：__ 将配置项 fiber_use_limit 和 fiber_idle_limit 设为 0；  \n__UDP通信模型：__ 将配置项 udp_use_limit 和 udp_idle_limit 设为 0；  \n__触发器模型：__ 将配置项 trigger_use_limit 设为 0。\n\n#### 5. acl_master 控制模式下，服务子进程如何预启动多个进程？\n需要修改每个服务子进程的配置文件，将配置项：master_maxproc 及 master_prefork 设置成要启动的进程数（设置值需相同），同时需要将 xxx_use_limit 及 xxx_idle_limit 配置项设成 0 以防止子进程空闲退出，xxx_use_limit 及 xxx_idle_limit  的依每种服务器模型而不同，具体可参考上面（4）中的说明。\n\n#### 6. acl_master 控制模式下，如何只监听内网地址？\n在 acl_master 模式下，可以将 master_service 配置项支持模糊匹配方式，即可以将监听地址写成 `192.168.*.*:8192` 或 `10.0.*.*:8192` 方式，这样 acl_master 会自动扫描服务器所有的网卡地址，但只监听服务匹配条件的内网地址，这样为统一部署提供方便。\n \n### （六）、数据库模块\n#### 1. acl 数据库客户端支持哪些数据库？\n当前 acl 数据库客户端库支持的数据库有：mysql，postgresql，sqlite。\n#### 2. acl 数据库模块如何使用？\nacl 数据库模块封装了官方数据库的驱动（包括 mysql，postgresql，sqlite），所以使用者应先下载所对应的官方数据库驱动，考虑到版本的一致性，建议从 https://github.com/acl-dev/third_party 处下载；\n另外，acl 数据库模块是采用动态加载方式加载数据库驱动的，所以使用者应将编译好的数据库动态库放置在合适的位置，并调用 `acl::db_handle::set_loadpath()` 设置数据库驱动动态库的全路径，以便于 acl 数据库模块内部可以使用该路径进行动态加载。\n\n### （七）、邮件&mime模块\n。。。\n \n- 微博：http://weibo.com/zsxxsz\n- qq 群：242722074\n","source":"_posts/faq.md","raw":"---\ntitle: acl库使用FAQ\ndate: 2019-06-30 13:08:24\ncategories: faq\n---\n\n## acl库使用FAQ\n\n* [一、基础问题](#一基础问题)\n    * [1、acl 库是啥、主要包含哪些功能？](#1acl-库是啥主要包含哪些功能)\n    * [2、acl 库支持哪些平台？](#2acl-库支持哪些平台)\n    * [3、acl 库主要包含几个库？](#3acl-库主要包含几个库)\n    * [4、acl 库有哪些外部依赖库？](#4acl-库有哪些外部依赖库)\n    * [5、没有这些第三方库 acl 能否使用？](#5没有这些第三方库-acl-能否使用)\n    * [6、acl 库的源码下载位置在哪儿？](#6acl-库的源码下载位置在哪儿)\n* [二、编译&使用问题](#二编译使用问题)\n    * [1、acl 库的编译过程？](#1acl-库的编译过程)\n    * [2、Linux 平台下库的编译顺序问题？](#2linux-平台下库的编译顺序问题)\n    * [3、Unix/Linux 平台下编译 acl 库时的编译选项是什么](#3unixlinux-平台下编译-acl-库时的编译选项是什么)\n    * [4、请给出 Linux 平台下最简单的一个 Makefile？](#4请给出-linux-平台下最简单的一个-makefile)\n    * [5、Linux 平台下找不到 libz.a 库怎么办？](#5linux-平台下找不到-libza-库怎么办)\n    * [6、Linux 平台下 acl 库能打包成一个库吗？](#6linux-平台下-acl-库能打包成一个库吗)\n    * [7、Linux 平台下如何使用 ssl 功能？](#7linux-平台下如何使用-ssl-功能)\n    * [8、Linux 下如何使用 mysql 功能？](#8linux-下如何使用-mysql-功能)\n* [三、各个功能模块的使用问题](#三各个功能模块的使用问题)\n    * [（一）、网络通信](#一网络通信)\n    * [（二）、HTTP 模块](#二http-模块)\n        * [1. acl HTTP 服务器是否支持断点下载功能？](#1-acl-http-服务器是否支持断点下载功能)\n        * [2. acl HTTP 服务器是否支持文件上传功能？](#2-acl-http-服务器是否支持文件上传功能)\n        * [3. acl HTTP 模块是否支持服务器/客户端两种模式？](#3-acl-http-模块是否支持服务器客户端两种模式)\n        * [4. acl HTTP 模块是否支持 websocket 通信协议？](#4-acl-http-模块是否支持-websocket-通信协议)\n        * [5. acl HTTP 模块是否支持 session？](#5-acl-http-模块是否支持-session)\n        * [6. HttpServletRequest 为何读不到 json 或 xml 数据体？](#6-HttpServletRequest-为何读不到-json-或-xml-数据体)\n        * [7. http_request 因未设 Host 字段而出错的问题](#7-http_request-因未设-Host-字段而出错的问题)\n    * [（三）、Redis 模块](#三redis-模块)\n        * [1. acl redis 库是否支持集群功能？](#1-acl-redis-库是否支持集群功能)\n        * [2. acl redis 库是如何划分的？](#2-acl-redis-库是如何划分的)\n        * [3. acl redis 库中的哪些类对象操作是线程安全的？](#3-acl-redis-库中的哪些类对象操作是线程安全的)\n        * [4. acl redis 客户库当连接断开时是否会重连？](#4-acl-redis-客户库当连接断开时是否会重连)\n    * [（四）、协程模块](#四协程模块)\n        * [1. 协程里面的非阻塞是什么原理的？](#1-协程里面的非阻塞是什么原理的)\n        * [2. acl 协程库是否支持多线程？](#2-acl-协程库是否支持多线程)\n        * [3. acl 协程库如何支持多核 CPU？](#3-acl-协程库如何支持多核-cpu)\n        * [4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？](#4-acl-协程里针对-mysql-客户端库的协程化是否修改了-mysql-库的源码)\n        * [5. acl 协程库支持域名解析功能吗？](#5-acl-协程库支持域名解析功能吗)\n        * [6. acl 协程库的系统 errno 号如何处理？](#6-acl-协程库的系统-errno-号如何处理)\n        * [7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？](#7-如果启动的协程过多会不会对于后端例如-mysql-之类服务造成并发压力如何避免)\n    * [（五）、服务器模块](#五服务器模块)\n        * [1. 有几种服务器编程模型？均有何特点？](#1-有几种服务器编程模型均有何特点)\n        * [2. acl_master 的作用是什么？支持哪些平台？](#2-acl_master-的作用是什么支持哪些平台)\n        * [3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？](#3-没有-acl_master-控制管理服务子进程是否可以单独运行)\n        * [4. 手工模式下运行时遇到“idle timeout -- exiting, idle”怎么办？](#4-手工模式下运行时遇到idle-timeout----exiting-idle怎么办)\n        * [5. acl_master 控制模式下，服务子进程如何预启动多个进程？](#5-acl_master-控制模式下服务子进程如何预启动多个进程)\n        * [6. acl_master 控制模式下，如何只监听内网地址？](#6-acl_master-控制模式下如何只监听内网地址)\n    * [（六）、数据库模块](#六数据库模块)\n        * [1. acl 数据库客户端支持哪些数据库？](#1-acl-数据库客户端支持哪些数据库)\n        * [2. acl 数据库模块如何使用？](#2-acl-数据库模块如何使用)\n    * [（七）、邮件&mime模块](#七邮件mime模块)\n\n### 一、基础问题\n### 1、acl 库是啥、主要包含哪些功能？\nacl 工程是一个跨平台（支持LINUX，WIN32，Solaris，MacOS，FreeBSD）的网络通信库及服务器编程框架，同时提供更多的实用功能库。通过该库，用户可以非常容易地编写支持多种模式(多线程、多进程、非阻塞、触发器、UDP方式、协程方式)的服务器程序，WEB 应用程序，数据库应用程序。此外，该库还提供了常见应用的客户端通信库（如：HTTP、SMTP、ICMP、redis、disque、memcache、beanstalk、handler socket），常见流式编解码库：XML/JSON/MIME/BASE64/UUCODE/QPCODE/RFC2047 等。\n### 2、acl 库支持哪些平台？\n目前主要支持 Linux/Windows/Macos/Freebsd/Solaris(x86)。\n### 3、acl 库主要包含几个库？\n主要包括：lib_acl（用 C 语言写的基础库）、lib_protocol（用 C 语言写的一些网络应用协议库）、lib_acl_cpp（用 C++ 语言编写，封装了 lib_acl/lib_protocol 两个库，同时增加更多实用的功能库）、 lib_fiber（用 C 语言编写的支持高性能、高并发的网络协程库）、lib_rpc（用C++语言编写的封装了 google protobuf 网络库）。\n### 4、acl 库有哪些外部依赖库？\nlib_acl/lib_protocol/lib_fiber 仅依赖系统基础库；lib_acl_cpp 库的 db 模块依赖于 mysql 客户端库、sqlite 库，stream 流模块依赖于 polarssl 库（该库源码附在 acl/resource 目录下），另外，在 UNIX/LINUX 平台下还需要压缩库 --- libz 库（一般 LINUX 会自带该压缩库）；lib_rpc 依赖于 protobuf 库。\n### 5、没有这些第三方库 acl 能否使用？\n可以。默认情况下，没有这些第三方库编译和使用 acl 库是没有问题的，只是不能使用 mysql/sqlite/ssl/protobuf 功能。\n### 6、acl 库的源码下载位置在哪儿？\n- github：https://github.com/acl-dev/acl/\n- oschina: https://git.oschina.net/acl-dev/acl/\n- sourceforge：https://sourceforge.net/projects/acl/\n \n### 二、编译&使用问题\n### 1、acl 库的编译过程？\nacl 库的编译过程请参考：[acl 的编译与使用](http://zsxxsz.iteye.com/blog/1506554) 博客。\n### 2、Linux 平台下库的编译顺序问题？\nlib_acl 库是 acl 库中的基础库，其它库均依赖于该库，库的依赖顺序为：lib_protocol 依赖于 lib_acl，lib_acl_cpp 依赖于 lib_acl 和 lib_protocol，lib_fiber 依赖于 lib_acl，lib_rpc 依赖于 lib_acl/lib_protocol/lib_acl_cpp。因此当应用在连接 acl 库时，需要注意连接的顺序为：-l_acl_cpp -l_protocol -l_acl。\n### 3、Unix/Linux 平台下编译 acl 库时的编译选项是什么？\n在 Unix/Linux 平台下编译 acl 库时需要指明 gcc 的编译选项，acl 库自带的 Makefile 会自动识别操作系统而选择不同的编译选项，下面列出不同 Unix 平台的不同编译选项（当前版本已自动识别系统类型，无需添加如下编译选项）：\n- Linux 平台：-DLINUX2\n- MacOS 平台：-DMACOSX\n- FreeBSD 平台：-DFREEBSD\n- Solaris(x86) 平台：-DSUNOS5  \n\n### 4、请给出 Linux 平台下最简单的一个 Makefile？\n下面是使用 acl 库的最简单的编译选项（因为排版问题，当拷贝下面内容至 Makefile 时，需要注意将每行前空格手工转成 TAB 键）：\n~~~\nfiber: main.o\n\tg++ -o fiber main.o \\\n\t\t-L./lib_fiber/lib -lfiber_cpp \\\n\t\t-L./lib_acl_cpp/lib -l_acl_cpp \\\n\t\t-L./lib_protocol/lib -l_protocol \\\n\t\t-L./lib_acl/lib -l_acl \\\n\t\t-L./lib_fiber/lib -lfiber \\\n\t\t-lz -lpthread -ldl\nmain.o: main.cpp\n\tg++ -O3 -Wall -c main.cpp -DLINUX2 \\\n\t\t-I./lib_acl/include \\\n\t\t-I./lib_acl_cpp/include \\\n\t\t-I./lib_fiber/cpp/include \\\n\t\t-I./lib_fiber/c/include\n~~~\n### 5、Linux 平台下找不到 libz.a 库怎么办？\n一般 Unix/Linux 平台下系统会自带 libz.a 或 libz.so 压缩库，如果找不到该库，则可以在线安装或采用编译安装 zlib 库，针对 Centos 和 Ubuntu 可分别通过以下方式在线安装（均需切换至 root 身份）：\n- Centos：yum install zlib-devel\n- Ubuntu：apt-get install zlib1g.dev\n\n### 6、Linux 平台下 acl 库能打包成一个库吗？\n可以。在 acl 目录下运行：make build_one 则可以将 lib_acl/lib_protocol/lib_acl_cpp 打包成一个完整的库：lib_acl.a/lib_acl.so，则应用最终使用时可以仅连接这一个库即可。\n\n### 7、Linux 平台下如何使用 ssl 功能？\n目前 acl 中的 lib_acl_cpp C++ 库通过集成 polarssl 支持 ssl 功能，所支持的 polarssl 源码的下载位置：https://github.com/acl-dev/third_party, 老版本 acl 通过静态连接 libpolarssl.a 实现对 ssl 的支持，当前版本则是通过动态加载 libpolarssl.so 方式实现了对 ssl 的支持，此动态支持方式更加灵活方便，无须特殊编译条件，也更为通用。\n#### 7.1、老版本 acl 对 ssl 的支持方式\n如果使用上面统一的 acl 库，则可以在 acl 根目录下编译时运行：make build_one polarssl=on；如果使用三个库：lib_acl.a，lib_protocol.a，lib_acl_cpp.a，则在编译前需要先指定环境变量：export ENV_FLAGS=HAS_POLARSSL，然后分别编译这三个库；解压 polarssl-1.2.19-gpl.tgz，然后进入 polarssl-1.2.19 目录运行：make 编译后在 polarssl-1.2.19/library 目录得到 libpolarssl.a 库；最后在编译应用时将 libpolarssl.a 连接进你的工程中即可。\n#### 7.2、当前版本 acl 对 ssl 的支持方式\n- 首先下载解压 polarssl 库后进入polarssl-1.2.19 目录，运行 make lib SHARED=yes，在library 目录下会生成 libpolarssl.so 动态库;\n- 在 acl 根目录下运行 make build_one，则会将 acl 的三个基础库：libacl.a, libprotocol.a, libacl_cpp.a 合成 libacl_all.a 一个静态库，将 libacl.so, libprotocol.so, lib_acl_cpp.so 合成 libacl_all.so 一个动态库;\n- 当程序启动时添加代码：acl::polarssl_conf::set_libpath(\"libpolarssl.so\"); 其中的路径根据实际位置而定，这样 acl 模块在需要 ssl 通信时会自动切换至 ssl 方式。\n\n### 8、Linux 下如何使用 mysql 功能？\nlib_acl_cpp 库是以动态加载方式加载 mysql 动态库的，所以在编译 lib_acl_cpp 时，mysql 功能就已经被编译进去 acl库中了。用户仅需要将 mysql 动态库通过函数 acl::db_handle::set_loadpath 注册进 acl 库中即可；至于 mysql 客户端库，用户可以去 mysql 官方下载或在 acl/resource 目录下编译 mysql-connector-c-6.1.6-src.tar.gz。\n \n### 三、各个功能模块的使用问题\n### （一）、网络通信\n### （二）、HTTP 模块\n#### 1. acl HTTP 服务器是否支持断点下载功能？\n支持。acl HTTP 模块支持断点续传功能，一个支持断点下载的服务器示例参照：acl\\app\\wizard_demo\\httpd_download。\n\n#### 2. acl HTTP 服务器是否支持文件上传功能？\n支持。参考示例：acl\\app\\wizard_demo\\httpd_upload。\n\n#### 3. acl HTTP 模块是否支持服务器/客户端两种模式？\n支持。目前 acl 的 HTTP 协议模块同时支持客户端及服务端模式，即你既可以使用 acl HTTP 编写客户端程序，又可以编写服务器程序，其中 acl 中的 http_request/http_request_pool/http_request_manager 类用来编写客户端程序，http_response/HttpServlet/HttpServletRequest/HttpServeletResponse 用来编写服务器程序。\n\n#### 4. acl HTTP 模块是否支持 websocket 通信协议？\n支持。可以参考示例：lib_acl_cpp\\samples\\websocket。\n\n#### 5. acl HTTP 模块是否支持 session？\n支持。acl HTTP 模块当用在服务器编程时支持 session 存储，目前支持使用 memcached 或 redis 存储 session 数据。\n \n#### 6. HttpServletRequest 为何读不到 json 或 xml 数据体\n当 HTTP 客户端请求的数据体为 json 或 xml 时，默认情况下从 acl::HttpServletRequest 对象中是读不到 json/xml 数据的，主要原因在于 HttpServletRequest 内置了自动读取并解析 json/xml/x-www-form-urlencoded 类型数据的功能，使用者只需直接获取解析后的对象即可，如针对 json 类数据体：\n\n```c++\nvoid get_json(acl::HttpServletRequest& req)\n{\n\tacl::json* json = req.getJson();\n\t...\n}\n```\n\n如果应用想自己读取并解析 json 数据，则需要在调用 acl::HttpServlet::setParseBody(false)，禁止 acl::HttpServletRequest 类对象内部自动读取数据。\n\n#### 7. http_request 因未设 Host 字段而出错的问题\n在使用 acl::http_request 类对象访问标准 WEB 服务器（如：nginx）时，如果没有设置 HTTP 请求头中的 Host 字段，nginx 会返回 400 错误，主要是 HTTP/1.1 协议要求 HTTP 客户端必须设置 Host 字段，方法如下：\n\n```c++\nbool http_client(void)\n{\n\tacl::http_request req(\"www.sina.com.cn:80\");\n\tacl::http_header& hdr = req.request_header();\n\thdr.set_url(\"/\").set_host(\"www.sina.com.cn\");\n\tif (!req.request(NULL, 0)) {\n\t\treturn false;\n\t}\n\tacl::string body;\n\tif (req.get_body(body)) {\n\t\tprintf(\"%s\\r\\n\", body.c_str());\n\t}\n\t\n\t... \n}\n\n```\n\n### （三）、Redis 模块\n#### 1. acl redis 库是否支持集群功能？\n答案：是，acl redis 客户端库同时支持集群和单机方式的 redis-server。\n\n#### 2. acl redis 库是如何划分的？\nacl redis 客户端库主要分为两类：命令类和连接类：\n- **命令类主要有**：redis_key, redis_string, redis_hash, redis_list, redis_set, redis_zset, redis_cluster, redis_geo, redis_hyperloglog, redis_pubsub, redis_transaction, redis_server, redis_script, 这些类都继承于基类 redis_command，同时子类 redis 又继承了所有这些命令类，以便于用户可以直接使用 acl::redis 操作所有的 redis 客户端命令；\n- **连接类主要有**：redis_client, redis_client_pool, redis_client_cluster，命令类对象通过这些连接类对象与 redis-server 进行交互，redis_client 为单连接类，redis_client_pool 为连接池类，这两个类仅能在非集群模式的 redis-server 环境中使用，不支持 redis-server 的集群模式，必须使用 redis_client_cluster 连接集群模式的 redis-server，同时 redis_client_cluster 也兼容非集群模式的连接。\n\n#### 3. acl redis 库中的哪些类对象操作是线程安全的？\nacl redis 库中的所有命令类对象及 redis_client 单连接类对象不能同时被多个线程使用（就象 std::string 一样不能跨线程使用）；redis_client_pool，redis_client_cluster 两个连接类对象是线程操作安全的，同一个对象可以被多个线程同时使用。\n\n#### 4. acl redis 客户库当连接断开时是否会重连？\nacl redis 库中的连接类中：redis_client，redis_client_pool，redis_client_cluster 三个连接类对象当检测到网络连接异常断开时会尝试自动重连，上层使用者无需考虑连接断开重试的情况。\n \n### （四）、协程模块\n#### 1. 协程里面的非阻塞是什么原理的？\n比如我现在需要访问数据库，这个动作肯定是个阻塞的操作，如果有10个协程进行数据库访问，这个非阻塞是怎么理解的？\n协程方式在底层将系统的 IO API（read/write 等）都 hook 了，数据库操作也要调用这些API，所以表面上的阻塞式DB操作在协程底层的IO也会被转为非阻塞模式。\n\n#### 2. acl 协程库是否支持多线程？\nacl 协程库支持多线程方式，只是支持的方式与 go 语言有所不同。用户可以创建多个线程，每个线程一个协程调度器，线程之间的协程调度是相互隔离的，正如多进程与多线程之间的关系一样（每个进程内可以启动多个线程，但进程之间的线程的调度过程是隔离的），在每个线程内部可以创建大量 acl 协程，每个协程均由其所属的线程内的协程调度器调度运行。\n\n#### 3. acl 协程库如何支持多核 CPU？\n正如 2）所说，用户可以启动多个线程，每个线程一个 acl 协程调度器，每个协程调度器负责调度与其同属相同线程的协程运行状态。\n\n#### 4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？\n没有。mysql 客户端库使用的系统 IO API 为 read/write/poll，而 acl 协程库 HOOK 了系统底层的 IO 过程，因此当将用户程序与 mysql 库及 acl 协程库一起编译后，mysql 库的 IO 过程直接被 acl 协程库 HOOK 的 API 接管，从而将 mysql 客户端库协程化而无须修改一行 mysql 库代码。\n\n#### 5. acl 协程库支持域名解析功能吗？\n支持。很多 C/C++ 实现的协程库并未实现 gethostbyname(_r) 函数，导致用户在使用协程编程遇到域名解析时还需要借助单独的线程来完成，acl 库本身从 DNS 协议层次实现了域名解析过程，acl 协程库基于此功能模块 HOOK 了系统的 gethostbyname(_r) API 而无须借助第三方函数库或起单独的线程完成域名解析。\n\n#### 6. acl 协程库的系统 errno 号如何处理？\nacl 协程库实现了协程安全的 errno 号，正如之前使用多线程编程时 errno 可以与每个线程绑定一样，在 acl 协程库里 errno 也是与每个 acl 协程进行绑定的。因此，当你调用 strerror(errno) 时也是协程安全的。\n\n#### 7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？\n当启动用协程较多且都需要 mysql 操作时的确会造成 mysql 服务器的并发压力。为避免此并发压力，acl 协程库提供了协程信号量，用来针对后端不支持高并发的服务提供连接保护。\n \n### （五）、服务器模块\n#### 1. 有几种服务器编程模型？均有何特点？\n目前 acl 库中提供：进程池模型、线程池模型、非阻塞模型、协程模型、UDP 通信模型、触发器模型。其中各个编程模型的特点如下：  \n\n__进程池模型：__ 每个进程处理一个客户端连接，当需要处理多个连接时则需要启动多个进程，此模型的最大缺点是并发度低，优点是编程简单；  \n__线程池模型：__ 由多个线程组成线程池处理大量的客户端连接，只有当某个连接有数据可读时该连接才会与一个线程绑定，处理完毕则线程归还给线程池，此模型的优点是启动少数线程便处理较大并发，缺点是需要注意线程编程时的线程安全问题；  \n__非阻塞模型：__ 一个进程内仅有一个工作线程，通过采用非阻塞通信方式可以支持非常大的客户端并发连接，优点是资源消耗小、支持大并发、性能高，缺点是编程复杂度高；  \n__协程模型：__ 每个客户端连接与一个协程绑定，每个进程内一个工作线程，每个线程内可以创建大 量的协程，优点是支持大并发、性能高、编程简单、应用场景比较广，缺点是占用内存要比非阻塞模型高；  \n__UDP通信模型：__ 支持简单的 UDP 通信方式；触发器模型：常用在定时任务的应用场景中。  \n以上的服务模型均可启动多个进程，通过配置文件的配置项来决定启动进程的数量。\n\n#### 2. acl_master 的作用是什么？支持哪些平台？\nacl_master 为由以上各个服务器编写的服务进程的控制管理程序， acl_master\n启动、停止各个服务子进程，控制子进程的启动数量及预启动策略，监控子进程的异常情况；acl_master 有点类似于 LINUX 下的 xinetd 服务进程，不同之处是 acl_master 功能更完善强大，支持服务子进程的常驻留、半驻留，而 xinetd 则只针对一个连接创建一个进程，不能用于高并发的服务应用场景。  \n目前 acl_master 进程仅支持 LINUX/MACOS/FREEBSD/SOLARIS(X86）等 UNIX 平台，不支持 WINDOWS 平台。  \n#### 3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？\n\n可以。在没有 acl_master 的情况下，由以上各个服务模型编写的服务程序可以通过手工方式启动。启动方式一般为：./xxxx alone xxxx.cf，这样服务程序便以 alone 模式启动运行，具体情况可以参考 main.cpp 里的启动方式；在 WINDOWS 平台下只能是以 alone 模式手工启动运行。\n\n#### 4. 手工模式下运行时遇到\"idle timeout -- exiting, idle\"怎么办？\n因为 acl 的服务器编程模型均支持半驻留方式（即运行空闲一段时间或处理连接次数达到设定值后会自动退出，这样的好处是：可以定期通过进程退出释放可能存在的资源泄露，另一方面便于用户在开发时通过 valgrind 进行内存检查），如果让进程不退出，可以在 alone 模式下给服务程序传递启动配置文件，如启动方式为：./xxxx alone xxxx.cf（传递方式可以看 main.cpp 和相关头文件），不同的服务器模型分别采取下面不同的配置项：  \n\n__程池模型：__ 将配置项 single_use_limit 和 single_idle_limit 设为 0；  \n__线程池模型：__ 将配置项 ioctl_use_limit 和 ioctl_idle_limit 设为 0；  \n__非阻塞模型：__ 将配置项 aio_use_limit 和 aio_idle_limit 设为 0；  \n__协程模型：__ 将配置项 fiber_use_limit 和 fiber_idle_limit 设为 0；  \n__UDP通信模型：__ 将配置项 udp_use_limit 和 udp_idle_limit 设为 0；  \n__触发器模型：__ 将配置项 trigger_use_limit 设为 0。\n\n#### 5. acl_master 控制模式下，服务子进程如何预启动多个进程？\n需要修改每个服务子进程的配置文件，将配置项：master_maxproc 及 master_prefork 设置成要启动的进程数（设置值需相同），同时需要将 xxx_use_limit 及 xxx_idle_limit 配置项设成 0 以防止子进程空闲退出，xxx_use_limit 及 xxx_idle_limit  的依每种服务器模型而不同，具体可参考上面（4）中的说明。\n\n#### 6. acl_master 控制模式下，如何只监听内网地址？\n在 acl_master 模式下，可以将 master_service 配置项支持模糊匹配方式，即可以将监听地址写成 `192.168.*.*:8192` 或 `10.0.*.*:8192` 方式，这样 acl_master 会自动扫描服务器所有的网卡地址，但只监听服务匹配条件的内网地址，这样为统一部署提供方便。\n \n### （六）、数据库模块\n#### 1. acl 数据库客户端支持哪些数据库？\n当前 acl 数据库客户端库支持的数据库有：mysql，postgresql，sqlite。\n#### 2. acl 数据库模块如何使用？\nacl 数据库模块封装了官方数据库的驱动（包括 mysql，postgresql，sqlite），所以使用者应先下载所对应的官方数据库驱动，考虑到版本的一致性，建议从 https://github.com/acl-dev/third_party 处下载；\n另外，acl 数据库模块是采用动态加载方式加载数据库驱动的，所以使用者应将编译好的数据库动态库放置在合适的位置，并调用 `acl::db_handle::set_loadpath()` 设置数据库驱动动态库的全路径，以便于 acl 数据库模块内部可以使用该路径进行动态加载。\n\n### （七）、邮件&mime模块\n。。。\n \n- 微博：http://weibo.com/zsxxsz\n- qq 群：242722074\n","slug":"faq","published":1,"updated":"2023-01-23T13:56:23.934Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cld8vgtdm0000rt9kgl6i7qw3","content":"<h2 id=\"acl库使用FAQ\"><a href=\"#acl库使用FAQ\" class=\"headerlink\" title=\"acl库使用FAQ\"></a>acl库使用FAQ</h2><ul>\n<li><a href=\"#%E4%B8%80%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98\">一、基础问题</a><ul>\n<li><a href=\"#1acl-%E5%BA%93%E6%98%AF%E5%95%A5%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD\">1、acl 库是啥、主要包含哪些功能？</a></li>\n<li><a href=\"#2acl-%E5%BA%93%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%B9%B3%E5%8F%B0\">2、acl 库支持哪些平台？</a></li>\n<li><a href=\"#3acl-%E5%BA%93%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E5%87%A0%E4%B8%AA%E5%BA%93\">3、acl 库主要包含几个库？</a></li>\n<li><a href=\"#4acl-%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E5%BA%93\">4、acl 库有哪些外部依赖库？</a></li>\n<li><a href=\"#5%E6%B2%A1%E6%9C%89%E8%BF%99%E4%BA%9B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-acl-%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8\">5、没有这些第三方库 acl 能否使用？</a></li>\n<li><a href=\"#6acl-%E5%BA%93%E7%9A%84%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%BD%8D%E7%BD%AE%E5%9C%A8%E5%93%AA%E5%84%BF\">6、acl 库的源码下载位置在哪儿？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8C%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98\">二、编译&amp;使用问题</a><ul>\n<li><a href=\"#1acl-%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B\">1、acl 库的编译过程？</a></li>\n<li><a href=\"#2linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98\">2、Linux 平台下库的编译顺序问题？</a></li>\n<li><a href=\"#3unixlinux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%BC%96%E8%AF%91-acl-%E5%BA%93%E6%97%B6%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E6%98%AF%E4%BB%80%E4%B9%88\">3、Unix&#x2F;Linux 平台下编译 acl 库时的编译选项是什么</a></li>\n<li><a href=\"#4%E8%AF%B7%E7%BB%99%E5%87%BA-linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%80%E4%B8%AA-makefile\">4、请给出 Linux 平台下最简单的一个 Makefile？</a></li>\n<li><a href=\"#5linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%89%BE%E4%B8%8D%E5%88%B0-libza-%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E\">5、Linux 平台下找不到 libz.a 库怎么办？</a></li>\n<li><a href=\"#6linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B-acl-%E5%BA%93%E8%83%BD%E6%89%93%E5%8C%85%E6%88%90%E4%B8%80%E4%B8%AA%E5%BA%93%E5%90%97\">6、Linux 平台下 acl 库能打包成一个库吗？</a></li>\n<li><a href=\"#7linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ssl-%E5%8A%9F%E8%83%BD\">7、Linux 平台下如何使用 ssl 功能？</a></li>\n<li><a href=\"#8linux-%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-mysql-%E5%8A%9F%E8%83%BD\">8、Linux 下如何使用 mysql 功能？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%89%E5%90%84%E4%B8%AA%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98\">三、各个功能模块的使用问题</a><ul>\n<li><a href=\"#%E4%B8%80%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1\">（一）、网络通信</a></li>\n<li><a href=\"#%E4%BA%8Chttp-%E6%A8%A1%E5%9D%97\">（二）、HTTP 模块</a><ul>\n<li><a href=\"#1-acl-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%96%AD%E7%82%B9%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD\">1. acl HTTP 服务器是否支持断点下载功能？</a></li>\n<li><a href=\"#2-acl-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD\">2. acl HTTP 服务器是否支持文件上传功能？</a></li>\n<li><a href=\"#3-acl-http-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F\">3. acl HTTP 模块是否支持服务器&#x2F;客户端两种模式？</a></li>\n<li><a href=\"#4-acl-http-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-websocket-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\">4. acl HTTP 模块是否支持 websocket 通信协议？</a></li>\n<li><a href=\"#5-acl-http-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-session\">5. acl HTTP 模块是否支持 session？</a></li>\n<li><a href=\"#6-HttpServletRequest-%E4%B8%BA%E4%BD%95%E8%AF%BB%E4%B8%8D%E5%88%B0-json-%E6%88%96-xml-%E6%95%B0%E6%8D%AE%E4%BD%93\">6. HttpServletRequest 为何读不到 json 或 xml 数据体？</a></li>\n<li><a href=\"#7-http_request-%E5%9B%A0%E6%9C%AA%E8%AE%BE-Host-%E5%AD%97%E6%AE%B5%E8%80%8C%E5%87%BA%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98\">7. http_request 因未设 Host 字段而出错的问题</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%89redis-%E6%A8%A1%E5%9D%97\">（三）、Redis 模块</a><ul>\n<li><a href=\"#1-acl-redis-%E5%BA%93%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E9%9B%86%E7%BE%A4%E5%8A%9F%E8%83%BD\">1. acl redis 库是否支持集群功能？</a></li>\n<li><a href=\"#2-acl-redis-%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84\">2. acl redis 库是如何划分的？</a></li>\n<li><a href=\"#3-acl-redis-%E5%BA%93%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84\">3. acl redis 库中的哪些类对象操作是线程安全的？</a></li>\n<li><a href=\"#4-acl-redis-%E5%AE%A2%E6%88%B7%E5%BA%93%E5%BD%93%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%E6%97%B6%E6%98%AF%E5%90%A6%E4%BC%9A%E9%87%8D%E8%BF%9E\">4. acl redis 客户库当连接断开时是否会重连？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9B%9B%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97\">（四）、协程模块</a><ul>\n<li><a href=\"#1-%E5%8D%8F%E7%A8%8B%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%E7%9A%84\">1. 协程里面的非阻塞是什么原理的？</a></li>\n<li><a href=\"#2-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B\">2. acl 协程库是否支持多线程？</a></li>\n<li><a href=\"#3-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%A4%9A%E6%A0%B8-cpu\">3. acl 协程库如何支持多核 CPU？</a></li>\n<li><a href=\"#4-acl-%E5%8D%8F%E7%A8%8B%E9%87%8C%E9%92%88%E5%AF%B9-mysql-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%93%E7%9A%84%E5%8D%8F%E7%A8%8B%E5%8C%96%E6%98%AF%E5%90%A6%E4%BF%AE%E6%94%B9%E4%BA%86-mysql-%E5%BA%93%E7%9A%84%E6%BA%90%E7%A0%81\">4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？</a></li>\n<li><a href=\"#5-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E6%94%AF%E6%8C%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E5%90%97\">5. acl 协程库支持域名解析功能吗？</a></li>\n<li><a href=\"#6-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%9A%84%E7%B3%BB%E7%BB%9F-errno-%E5%8F%B7%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86\">6. acl 协程库的系统 errno 号如何处理？</a></li>\n<li><a href=\"#7-%E5%A6%82%E6%9E%9C%E5%90%AF%E5%8A%A8%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%BF%87%E5%A4%9A%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%AF%B9%E4%BA%8E%E5%90%8E%E7%AB%AF%E4%BE%8B%E5%A6%82-mysql-%E4%B9%8B%E7%B1%BB%E6%9C%8D%E5%8A%A1%E9%80%A0%E6%88%90%E5%B9%B6%E5%8F%91%E5%8E%8B%E5%8A%9B%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D\">7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%94%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9D%97\">（五）、服务器模块</a><ul>\n<li><a href=\"#1-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9D%87%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9\">1. 有几种服务器编程模型？均有何特点？</a></li>\n<li><a href=\"#2-acl_master-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%B9%B3%E5%8F%B0\">2. acl_master 的作用是什么？支持哪些平台？</a></li>\n<li><a href=\"#3-%E6%B2%A1%E6%9C%89-acl_master-%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E8%BF%90%E8%A1%8C\">3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？</a></li>\n<li><a href=\"#4-%E6%89%8B%E5%B7%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E9%81%87%E5%88%B0idle-timeout----exiting-idle%E6%80%8E%E4%B9%88%E5%8A%9E\">4. 手工模式下运行时遇到“idle timeout – exiting, idle”怎么办？</a></li>\n<li><a href=\"#5-acl_master-%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E9%A2%84%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B\">5. acl_master 控制模式下，服务子进程如何预启动多个进程？</a></li>\n<li><a href=\"#6-acl_master-%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8F%AA%E7%9B%91%E5%90%AC%E5%86%85%E7%BD%91%E5%9C%B0%E5%9D%80\">6. acl_master 控制模式下，如何只监听内网地址？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97\">（六）、数据库模块</a><ul>\n<li><a href=\"#1-acl-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93\">1. acl 数据库客户端支持哪些数据库？</a></li>\n<li><a href=\"#2-acl-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\">2. acl 数据库模块如何使用？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%83%E9%82%AE%E4%BB%B6mime%E6%A8%A1%E5%9D%97\">（七）、邮件&amp;mime模块</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"一、基础问题\"><a href=\"#一、基础问题\" class=\"headerlink\" title=\"一、基础问题\"></a>一、基础问题</h3><h3 id=\"1、acl-库是啥、主要包含哪些功能？\"><a href=\"#1、acl-库是啥、主要包含哪些功能？\" class=\"headerlink\" title=\"1、acl 库是啥、主要包含哪些功能？\"></a>1、acl 库是啥、主要包含哪些功能？</h3><p>acl 工程是一个跨平台（支持LINUX，WIN32，Solaris，MacOS，FreeBSD）的网络通信库及服务器编程框架，同时提供更多的实用功能库。通过该库，用户可以非常容易地编写支持多种模式(多线程、多进程、非阻塞、触发器、UDP方式、协程方式)的服务器程序，WEB 应用程序，数据库应用程序。此外，该库还提供了常见应用的客户端通信库（如：HTTP、SMTP、ICMP、redis、disque、memcache、beanstalk、handler socket），常见流式编解码库：XML&#x2F;JSON&#x2F;MIME&#x2F;BASE64&#x2F;UUCODE&#x2F;QPCODE&#x2F;RFC2047 等。</p>\n<h3 id=\"2、acl-库支持哪些平台？\"><a href=\"#2、acl-库支持哪些平台？\" class=\"headerlink\" title=\"2、acl 库支持哪些平台？\"></a>2、acl 库支持哪些平台？</h3><p>目前主要支持 Linux&#x2F;Windows&#x2F;Macos&#x2F;Freebsd&#x2F;Solaris(x86)。</p>\n<h3 id=\"3、acl-库主要包含几个库？\"><a href=\"#3、acl-库主要包含几个库？\" class=\"headerlink\" title=\"3、acl 库主要包含几个库？\"></a>3、acl 库主要包含几个库？</h3><p>主要包括：lib_acl（用 C 语言写的基础库）、lib_protocol（用 C 语言写的一些网络应用协议库）、lib_acl_cpp（用 C++ 语言编写，封装了 lib_acl&#x2F;lib_protocol 两个库，同时增加更多实用的功能库）、 lib_fiber（用 C 语言编写的支持高性能、高并发的网络协程库）、lib_rpc（用C++语言编写的封装了 google protobuf 网络库）。</p>\n<h3 id=\"4、acl-库有哪些外部依赖库？\"><a href=\"#4、acl-库有哪些外部依赖库？\" class=\"headerlink\" title=\"4、acl 库有哪些外部依赖库？\"></a>4、acl 库有哪些外部依赖库？</h3><p>lib_acl&#x2F;lib_protocol&#x2F;lib_fiber 仅依赖系统基础库；lib_acl_cpp 库的 db 模块依赖于 mysql 客户端库、sqlite 库，stream 流模块依赖于 polarssl 库（该库源码附在 acl&#x2F;resource 目录下），另外，在 UNIX&#x2F;LINUX 平台下还需要压缩库 — libz 库（一般 LINUX 会自带该压缩库）；lib_rpc 依赖于 protobuf 库。</p>\n<h3 id=\"5、没有这些第三方库-acl-能否使用？\"><a href=\"#5、没有这些第三方库-acl-能否使用？\" class=\"headerlink\" title=\"5、没有这些第三方库 acl 能否使用？\"></a>5、没有这些第三方库 acl 能否使用？</h3><p>可以。默认情况下，没有这些第三方库编译和使用 acl 库是没有问题的，只是不能使用 mysql&#x2F;sqlite&#x2F;ssl&#x2F;protobuf 功能。</p>\n<h3 id=\"6、acl-库的源码下载位置在哪儿？\"><a href=\"#6、acl-库的源码下载位置在哪儿？\" class=\"headerlink\" title=\"6、acl 库的源码下载位置在哪儿？\"></a>6、acl 库的源码下载位置在哪儿？</h3><ul>\n<li>github：<a href=\"https://github.com/acl-dev/acl/\">https://github.com/acl-dev/acl/</a></li>\n<li>oschina: <a href=\"https://git.oschina.net/acl-dev/acl/\">https://git.oschina.net/acl-dev/acl/</a></li>\n<li>sourceforge：<a href=\"https://sourceforge.net/projects/acl/\">https://sourceforge.net/projects/acl/</a></li>\n</ul>\n<h3 id=\"二、编译-amp-使用问题\"><a href=\"#二、编译-amp-使用问题\" class=\"headerlink\" title=\"二、编译&amp;使用问题\"></a>二、编译&amp;使用问题</h3><h3 id=\"1、acl-库的编译过程？\"><a href=\"#1、acl-库的编译过程？\" class=\"headerlink\" title=\"1、acl 库的编译过程？\"></a>1、acl 库的编译过程？</h3><p>acl 库的编译过程请参考：<a href=\"http://zsxxsz.iteye.com/blog/1506554\">acl 的编译与使用</a> 博客。</p>\n<h3 id=\"2、Linux-平台下库的编译顺序问题？\"><a href=\"#2、Linux-平台下库的编译顺序问题？\" class=\"headerlink\" title=\"2、Linux 平台下库的编译顺序问题？\"></a>2、Linux 平台下库的编译顺序问题？</h3><p>lib_acl 库是 acl 库中的基础库，其它库均依赖于该库，库的依赖顺序为：lib_protocol 依赖于 lib_acl，lib_acl_cpp 依赖于 lib_acl 和 lib_protocol，lib_fiber 依赖于 lib_acl，lib_rpc 依赖于 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp。因此当应用在连接 acl 库时，需要注意连接的顺序为：-l_acl_cpp -l_protocol -l_acl。</p>\n<h3 id=\"3、Unix-x2F-Linux-平台下编译-acl-库时的编译选项是什么？\"><a href=\"#3、Unix-x2F-Linux-平台下编译-acl-库时的编译选项是什么？\" class=\"headerlink\" title=\"3、Unix&#x2F;Linux 平台下编译 acl 库时的编译选项是什么？\"></a>3、Unix&#x2F;Linux 平台下编译 acl 库时的编译选项是什么？</h3><p>在 Unix&#x2F;Linux 平台下编译 acl 库时需要指明 gcc 的编译选项，acl 库自带的 Makefile 会自动识别操作系统而选择不同的编译选项，下面列出不同 Unix 平台的不同编译选项（当前版本已自动识别系统类型，无需添加如下编译选项）：</p>\n<ul>\n<li>Linux 平台：-DLINUX2</li>\n<li>MacOS 平台：-DMACOSX</li>\n<li>FreeBSD 平台：-DFREEBSD</li>\n<li>Solaris(x86) 平台：-DSUNOS5</li>\n</ul>\n<h3 id=\"4、请给出-Linux-平台下最简单的一个-Makefile？\"><a href=\"#4、请给出-Linux-平台下最简单的一个-Makefile？\" class=\"headerlink\" title=\"4、请给出 Linux 平台下最简单的一个 Makefile？\"></a>4、请给出 Linux 平台下最简单的一个 Makefile？</h3><p>下面是使用 acl 库的最简单的编译选项（因为排版问题，当拷贝下面内容至 Makefile 时，需要注意将每行前空格手工转成 TAB 键）：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">fiber: main.o<br>\tg++ -o fiber main.o \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_fiber/</span>lib -lfiber_cpp \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_acl_cpp/</span>lib -l_acl_cpp \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_protocol/</span>lib -l_protocol \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_acl/</span>lib -l_acl \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_fiber/</span>lib -lfiber \\<br>\t\t-lz -lpthread -ldl<br>main.o: main.cpp<br>\tg++ -O3 -Wall -c main.cpp -DLINUX2 \\<br>\t\t-I.<span class=\"hljs-regexp\">/lib_acl/i</span>nclude \\<br>\t\t-I.<span class=\"hljs-regexp\">/lib_acl_cpp/i</span>nclude \\<br>\t\t-I.<span class=\"hljs-regexp\">/lib_fiber/</span>cpp/<span class=\"hljs-keyword\">include</span> \\<br>\t\t-I.<span class=\"hljs-regexp\">/lib_fiber/</span>c/<span class=\"hljs-keyword\">include</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"5、Linux-平台下找不到-libz-a-库怎么办？\"><a href=\"#5、Linux-平台下找不到-libz-a-库怎么办？\" class=\"headerlink\" title=\"5、Linux 平台下找不到 libz.a 库怎么办？\"></a>5、Linux 平台下找不到 libz.a 库怎么办？</h3><p>一般 Unix&#x2F;Linux 平台下系统会自带 libz.a 或 libz.so 压缩库，如果找不到该库，则可以在线安装或采用编译安装 zlib 库，针对 Centos 和 Ubuntu 可分别通过以下方式在线安装（均需切换至 root 身份）：</p>\n<ul>\n<li>Centos：yum install zlib-devel</li>\n<li>Ubuntu：apt-get install zlib1g.dev</li>\n</ul>\n<h3 id=\"6、Linux-平台下-acl-库能打包成一个库吗？\"><a href=\"#6、Linux-平台下-acl-库能打包成一个库吗？\" class=\"headerlink\" title=\"6、Linux 平台下 acl 库能打包成一个库吗？\"></a>6、Linux 平台下 acl 库能打包成一个库吗？</h3><p>可以。在 acl 目录下运行：make build_one 则可以将 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp 打包成一个完整的库：lib_acl.a&#x2F;lib_acl.so，则应用最终使用时可以仅连接这一个库即可。</p>\n<h3 id=\"7、Linux-平台下如何使用-ssl-功能？\"><a href=\"#7、Linux-平台下如何使用-ssl-功能？\" class=\"headerlink\" title=\"7、Linux 平台下如何使用 ssl 功能？\"></a>7、Linux 平台下如何使用 ssl 功能？</h3><p>目前 acl 中的 lib_acl_cpp C++ 库通过集成 polarssl 支持 ssl 功能，所支持的 polarssl 源码的下载位置：<a href=\"https://github.com/acl-dev/third_party\">https://github.com/acl-dev/third_party</a>, 老版本 acl 通过静态连接 libpolarssl.a 实现对 ssl 的支持，当前版本则是通过动态加载 libpolarssl.so 方式实现了对 ssl 的支持，此动态支持方式更加灵活方便，无须特殊编译条件，也更为通用。</p>\n<h4 id=\"7-1、老版本-acl-对-ssl-的支持方式\"><a href=\"#7-1、老版本-acl-对-ssl-的支持方式\" class=\"headerlink\" title=\"7.1、老版本 acl 对 ssl 的支持方式\"></a>7.1、老版本 acl 对 ssl 的支持方式</h4><p>如果使用上面统一的 acl 库，则可以在 acl 根目录下编译时运行：make build_one polarssl&#x3D;on；如果使用三个库：lib_acl.a，lib_protocol.a，lib_acl_cpp.a，则在编译前需要先指定环境变量：export ENV_FLAGS&#x3D;HAS_POLARSSL，然后分别编译这三个库；解压 polarssl-1.2.19-gpl.tgz，然后进入 polarssl-1.2.19 目录运行：make 编译后在 polarssl-1.2.19&#x2F;library 目录得到 libpolarssl.a 库；最后在编译应用时将 libpolarssl.a 连接进你的工程中即可。</p>\n<h4 id=\"7-2、当前版本-acl-对-ssl-的支持方式\"><a href=\"#7-2、当前版本-acl-对-ssl-的支持方式\" class=\"headerlink\" title=\"7.2、当前版本 acl 对 ssl 的支持方式\"></a>7.2、当前版本 acl 对 ssl 的支持方式</h4><ul>\n<li>首先下载解压 polarssl 库后进入polarssl-1.2.19 目录，运行 make lib SHARED&#x3D;yes，在library 目录下会生成 libpolarssl.so 动态库;</li>\n<li>在 acl 根目录下运行 make build_one，则会将 acl 的三个基础库：libacl.a, libprotocol.a, libacl_cpp.a 合成 libacl_all.a 一个静态库，将 libacl.so, libprotocol.so, lib_acl_cpp.so 合成 libacl_all.so 一个动态库;</li>\n<li>当程序启动时添加代码：acl::polarssl_conf::set_libpath(“libpolarssl.so”); 其中的路径根据实际位置而定，这样 acl 模块在需要 ssl 通信时会自动切换至 ssl 方式。</li>\n</ul>\n<h3 id=\"8、Linux-下如何使用-mysql-功能？\"><a href=\"#8、Linux-下如何使用-mysql-功能？\" class=\"headerlink\" title=\"8、Linux 下如何使用 mysql 功能？\"></a>8、Linux 下如何使用 mysql 功能？</h3><p>lib_acl_cpp 库是以动态加载方式加载 mysql 动态库的，所以在编译 lib_acl_cpp 时，mysql 功能就已经被编译进去 acl库中了。用户仅需要将 mysql 动态库通过函数 acl::db_handle::set_loadpath 注册进 acl 库中即可；至于 mysql 客户端库，用户可以去 mysql 官方下载或在 acl&#x2F;resource 目录下编译 mysql-connector-c-6.1.6-src.tar.gz。</p>\n<h3 id=\"三、各个功能模块的使用问题\"><a href=\"#三、各个功能模块的使用问题\" class=\"headerlink\" title=\"三、各个功能模块的使用问题\"></a>三、各个功能模块的使用问题</h3><h3 id=\"（一）、网络通信\"><a href=\"#（一）、网络通信\" class=\"headerlink\" title=\"（一）、网络通信\"></a>（一）、网络通信</h3><h3 id=\"（二）、HTTP-模块\"><a href=\"#（二）、HTTP-模块\" class=\"headerlink\" title=\"（二）、HTTP 模块\"></a>（二）、HTTP 模块</h3><h4 id=\"1-acl-HTTP-服务器是否支持断点下载功能？\"><a href=\"#1-acl-HTTP-服务器是否支持断点下载功能？\" class=\"headerlink\" title=\"1. acl HTTP 服务器是否支持断点下载功能？\"></a>1. acl HTTP 服务器是否支持断点下载功能？</h4><p>支持。acl HTTP 模块支持断点续传功能，一个支持断点下载的服务器示例参照：acl\\app\\wizard_demo\\httpd_download。</p>\n<h4 id=\"2-acl-HTTP-服务器是否支持文件上传功能？\"><a href=\"#2-acl-HTTP-服务器是否支持文件上传功能？\" class=\"headerlink\" title=\"2. acl HTTP 服务器是否支持文件上传功能？\"></a>2. acl HTTP 服务器是否支持文件上传功能？</h4><p>支持。参考示例：acl\\app\\wizard_demo\\httpd_upload。</p>\n<h4 id=\"3-acl-HTTP-模块是否支持服务器-x2F-客户端两种模式？\"><a href=\"#3-acl-HTTP-模块是否支持服务器-x2F-客户端两种模式？\" class=\"headerlink\" title=\"3. acl HTTP 模块是否支持服务器&#x2F;客户端两种模式？\"></a>3. acl HTTP 模块是否支持服务器&#x2F;客户端两种模式？</h4><p>支持。目前 acl 的 HTTP 协议模块同时支持客户端及服务端模式，即你既可以使用 acl HTTP 编写客户端程序，又可以编写服务器程序，其中 acl 中的 http_request&#x2F;http_request_pool&#x2F;http_request_manager 类用来编写客户端程序，http_response&#x2F;HttpServlet&#x2F;HttpServletRequest&#x2F;HttpServeletResponse 用来编写服务器程序。</p>\n<h4 id=\"4-acl-HTTP-模块是否支持-websocket-通信协议？\"><a href=\"#4-acl-HTTP-模块是否支持-websocket-通信协议？\" class=\"headerlink\" title=\"4. acl HTTP 模块是否支持 websocket 通信协议？\"></a>4. acl HTTP 模块是否支持 websocket 通信协议？</h4><p>支持。可以参考示例：lib_acl_cpp\\samples\\websocket。</p>\n<h4 id=\"5-acl-HTTP-模块是否支持-session？\"><a href=\"#5-acl-HTTP-模块是否支持-session？\" class=\"headerlink\" title=\"5. acl HTTP 模块是否支持 session？\"></a>5. acl HTTP 模块是否支持 session？</h4><p>支持。acl HTTP 模块当用在服务器编程时支持 session 存储，目前支持使用 memcached 或 redis 存储 session 数据。</p>\n<h4 id=\"6-HttpServletRequest-为何读不到-json-或-xml-数据体\"><a href=\"#6-HttpServletRequest-为何读不到-json-或-xml-数据体\" class=\"headerlink\" title=\"6. HttpServletRequest 为何读不到 json 或 xml 数据体\"></a>6. HttpServletRequest 为何读不到 json 或 xml 数据体</h4><p>当 HTTP 客户端请求的数据体为 json 或 xml 时，默认情况下从 acl::HttpServletRequest 对象中是读不到 json&#x2F;xml 数据的，主要原因在于 HttpServletRequest 内置了自动读取并解析 json&#x2F;xml&#x2F;x-www-form-urlencoded 类型数据的功能，使用者只需直接获取解析后的对象即可，如针对 json 类数据体：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">get_json</span><span class=\"hljs-params\">(acl::HttpServletRequest&amp; req)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::json* json = req.<span class=\"hljs-built_in\">getJson</span>();<br>\t...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果应用想自己读取并解析 json 数据，则需要在调用 acl::HttpServlet::setParseBody(false)，禁止 acl::HttpServletRequest 类对象内部自动读取数据。</p>\n<h4 id=\"7-http-request-因未设-Host-字段而出错的问题\"><a href=\"#7-http-request-因未设-Host-字段而出错的问题\" class=\"headerlink\" title=\"7. http_request 因未设 Host 字段而出错的问题\"></a>7. http_request 因未设 Host 字段而出错的问题</h4><p>在使用 acl::http_request 类对象访问标准 WEB 服务器（如：nginx）时，如果没有设置 HTTP 请求头中的 Host 字段，nginx 会返回 400 错误，主要是 HTTP&#x2F;1.1 协议要求 HTTP 客户端必须设置 Host 字段，方法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">http_client</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">acl::http_request <span class=\"hljs-title\">req</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;www.sina.com.cn:80&quot;</span>)</span></span>;<br>\tacl::http_header&amp; hdr = req.<span class=\"hljs-built_in\">request_header</span>();<br>\thdr.<span class=\"hljs-built_in\">set_url</span>(<span class=\"hljs-string\">&quot;/&quot;</span>).<span class=\"hljs-built_in\">set_host</span>(<span class=\"hljs-string\">&quot;www.sina.com.cn&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span> (!req.<span class=\"hljs-built_in\">request</span>(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>)) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\tacl::string body;<br>\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">get_body</span>(body)) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\r\\n&quot;</span>, body.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br>\t<br>\t... <br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"（三）、Redis-模块\"><a href=\"#（三）、Redis-模块\" class=\"headerlink\" title=\"（三）、Redis 模块\"></a>（三）、Redis 模块</h3><h4 id=\"1-acl-redis-库是否支持集群功能？\"><a href=\"#1-acl-redis-库是否支持集群功能？\" class=\"headerlink\" title=\"1. acl redis 库是否支持集群功能？\"></a>1. acl redis 库是否支持集群功能？</h4><p>答案：是，acl redis 客户端库同时支持集群和单机方式的 redis-server。</p>\n<h4 id=\"2-acl-redis-库是如何划分的？\"><a href=\"#2-acl-redis-库是如何划分的？\" class=\"headerlink\" title=\"2. acl redis 库是如何划分的？\"></a>2. acl redis 库是如何划分的？</h4><p>acl redis 客户端库主要分为两类：命令类和连接类：</p>\n<ul>\n<li><strong>命令类主要有</strong>：redis_key, redis_string, redis_hash, redis_list, redis_set, redis_zset, redis_cluster, redis_geo, redis_hyperloglog, redis_pubsub, redis_transaction, redis_server, redis_script, 这些类都继承于基类 redis_command，同时子类 redis 又继承了所有这些命令类，以便于用户可以直接使用 acl::redis 操作所有的 redis 客户端命令；</li>\n<li><strong>连接类主要有</strong>：redis_client, redis_client_pool, redis_client_cluster，命令类对象通过这些连接类对象与 redis-server 进行交互，redis_client 为单连接类，redis_client_pool 为连接池类，这两个类仅能在非集群模式的 redis-server 环境中使用，不支持 redis-server 的集群模式，必须使用 redis_client_cluster 连接集群模式的 redis-server，同时 redis_client_cluster 也兼容非集群模式的连接。</li>\n</ul>\n<h4 id=\"3-acl-redis-库中的哪些类对象操作是线程安全的？\"><a href=\"#3-acl-redis-库中的哪些类对象操作是线程安全的？\" class=\"headerlink\" title=\"3. acl redis 库中的哪些类对象操作是线程安全的？\"></a>3. acl redis 库中的哪些类对象操作是线程安全的？</h4><p>acl redis 库中的所有命令类对象及 redis_client 单连接类对象不能同时被多个线程使用（就象 std::string 一样不能跨线程使用）；redis_client_pool，redis_client_cluster 两个连接类对象是线程操作安全的，同一个对象可以被多个线程同时使用。</p>\n<h4 id=\"4-acl-redis-客户库当连接断开时是否会重连？\"><a href=\"#4-acl-redis-客户库当连接断开时是否会重连？\" class=\"headerlink\" title=\"4. acl redis 客户库当连接断开时是否会重连？\"></a>4. acl redis 客户库当连接断开时是否会重连？</h4><p>acl redis 库中的连接类中：redis_client，redis_client_pool，redis_client_cluster 三个连接类对象当检测到网络连接异常断开时会尝试自动重连，上层使用者无需考虑连接断开重试的情况。</p>\n<h3 id=\"（四）、协程模块\"><a href=\"#（四）、协程模块\" class=\"headerlink\" title=\"（四）、协程模块\"></a>（四）、协程模块</h3><h4 id=\"1-协程里面的非阻塞是什么原理的？\"><a href=\"#1-协程里面的非阻塞是什么原理的？\" class=\"headerlink\" title=\"1. 协程里面的非阻塞是什么原理的？\"></a>1. 协程里面的非阻塞是什么原理的？</h4><p>比如我现在需要访问数据库，这个动作肯定是个阻塞的操作，如果有10个协程进行数据库访问，这个非阻塞是怎么理解的？<br>协程方式在底层将系统的 IO API（read&#x2F;write 等）都 hook 了，数据库操作也要调用这些API，所以表面上的阻塞式DB操作在协程底层的IO也会被转为非阻塞模式。</p>\n<h4 id=\"2-acl-协程库是否支持多线程？\"><a href=\"#2-acl-协程库是否支持多线程？\" class=\"headerlink\" title=\"2. acl 协程库是否支持多线程？\"></a>2. acl 协程库是否支持多线程？</h4><p>acl 协程库支持多线程方式，只是支持的方式与 go 语言有所不同。用户可以创建多个线程，每个线程一个协程调度器，线程之间的协程调度是相互隔离的，正如多进程与多线程之间的关系一样（每个进程内可以启动多个线程，但进程之间的线程的调度过程是隔离的），在每个线程内部可以创建大量 acl 协程，每个协程均由其所属的线程内的协程调度器调度运行。</p>\n<h4 id=\"3-acl-协程库如何支持多核-CPU？\"><a href=\"#3-acl-协程库如何支持多核-CPU？\" class=\"headerlink\" title=\"3. acl 协程库如何支持多核 CPU？\"></a>3. acl 协程库如何支持多核 CPU？</h4><p>正如 2）所说，用户可以启动多个线程，每个线程一个 acl 协程调度器，每个协程调度器负责调度与其同属相同线程的协程运行状态。</p>\n<h4 id=\"4-acl-协程里针对-mysql-客户端库的协程化是否修改了-mysql-库的源码？\"><a href=\"#4-acl-协程里针对-mysql-客户端库的协程化是否修改了-mysql-库的源码？\" class=\"headerlink\" title=\"4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？\"></a>4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？</h4><p>没有。mysql 客户端库使用的系统 IO API 为 read&#x2F;write&#x2F;poll，而 acl 协程库 HOOK 了系统底层的 IO 过程，因此当将用户程序与 mysql 库及 acl 协程库一起编译后，mysql 库的 IO 过程直接被 acl 协程库 HOOK 的 API 接管，从而将 mysql 客户端库协程化而无须修改一行 mysql 库代码。</p>\n<h4 id=\"5-acl-协程库支持域名解析功能吗？\"><a href=\"#5-acl-协程库支持域名解析功能吗？\" class=\"headerlink\" title=\"5. acl 协程库支持域名解析功能吗？\"></a>5. acl 协程库支持域名解析功能吗？</h4><p>支持。很多 C&#x2F;C++ 实现的协程库并未实现 gethostbyname(_r) 函数，导致用户在使用协程编程遇到域名解析时还需要借助单独的线程来完成，acl 库本身从 DNS 协议层次实现了域名解析过程，acl 协程库基于此功能模块 HOOK 了系统的 gethostbyname(_r) API 而无须借助第三方函数库或起单独的线程完成域名解析。</p>\n<h4 id=\"6-acl-协程库的系统-errno-号如何处理？\"><a href=\"#6-acl-协程库的系统-errno-号如何处理？\" class=\"headerlink\" title=\"6. acl 协程库的系统 errno 号如何处理？\"></a>6. acl 协程库的系统 errno 号如何处理？</h4><p>acl 协程库实现了协程安全的 errno 号，正如之前使用多线程编程时 errno 可以与每个线程绑定一样，在 acl 协程库里 errno 也是与每个 acl 协程进行绑定的。因此，当你调用 strerror(errno) 时也是协程安全的。</p>\n<h4 id=\"7-如果启动的协程过多，会不会对于后端例如-mysql-之类服务造成并发压力？如何避免？\"><a href=\"#7-如果启动的协程过多，会不会对于后端例如-mysql-之类服务造成并发压力？如何避免？\" class=\"headerlink\" title=\"7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？\"></a>7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？</h4><p>当启动用协程较多且都需要 mysql 操作时的确会造成 mysql 服务器的并发压力。为避免此并发压力，acl 协程库提供了协程信号量，用来针对后端不支持高并发的服务提供连接保护。</p>\n<h3 id=\"（五）、服务器模块\"><a href=\"#（五）、服务器模块\" class=\"headerlink\" title=\"（五）、服务器模块\"></a>（五）、服务器模块</h3><h4 id=\"1-有几种服务器编程模型？均有何特点？\"><a href=\"#1-有几种服务器编程模型？均有何特点？\" class=\"headerlink\" title=\"1. 有几种服务器编程模型？均有何特点？\"></a>1. 有几种服务器编程模型？均有何特点？</h4><p>目前 acl 库中提供：进程池模型、线程池模型、非阻塞模型、协程模型、UDP 通信模型、触发器模型。其中各个编程模型的特点如下：  </p>\n<p><strong>进程池模型：</strong> 每个进程处理一个客户端连接，当需要处理多个连接时则需要启动多个进程，此模型的最大缺点是并发度低，优点是编程简单；<br><strong>线程池模型：</strong> 由多个线程组成线程池处理大量的客户端连接，只有当某个连接有数据可读时该连接才会与一个线程绑定，处理完毕则线程归还给线程池，此模型的优点是启动少数线程便处理较大并发，缺点是需要注意线程编程时的线程安全问题；<br><strong>非阻塞模型：</strong> 一个进程内仅有一个工作线程，通过采用非阻塞通信方式可以支持非常大的客户端并发连接，优点是资源消耗小、支持大并发、性能高，缺点是编程复杂度高；<br><strong>协程模型：</strong> 每个客户端连接与一个协程绑定，每个进程内一个工作线程，每个线程内可以创建大 量的协程，优点是支持大并发、性能高、编程简单、应用场景比较广，缺点是占用内存要比非阻塞模型高；<br><strong>UDP通信模型：</strong> 支持简单的 UDP 通信方式；触发器模型：常用在定时任务的应用场景中。<br>以上的服务模型均可启动多个进程，通过配置文件的配置项来决定启动进程的数量。</p>\n<h4 id=\"2-acl-master-的作用是什么？支持哪些平台？\"><a href=\"#2-acl-master-的作用是什么？支持哪些平台？\" class=\"headerlink\" title=\"2. acl_master 的作用是什么？支持哪些平台？\"></a>2. acl_master 的作用是什么？支持哪些平台？</h4><p>acl_master 为由以上各个服务器编写的服务进程的控制管理程序， acl_master<br>启动、停止各个服务子进程，控制子进程的启动数量及预启动策略，监控子进程的异常情况；acl_master 有点类似于 LINUX 下的 xinetd 服务进程，不同之处是 acl_master 功能更完善强大，支持服务子进程的常驻留、半驻留，而 xinetd 则只针对一个连接创建一个进程，不能用于高并发的服务应用场景。<br>目前 acl_master 进程仅支持 LINUX&#x2F;MACOS&#x2F;FREEBSD&#x2F;SOLARIS(X86）等 UNIX 平台，不支持 WINDOWS 平台。  </p>\n<h4 id=\"3-没有-acl-master-控制管理，服务子进程是否可以单独运行？\"><a href=\"#3-没有-acl-master-控制管理，服务子进程是否可以单独运行？\" class=\"headerlink\" title=\"3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？\"></a>3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？</h4><p>可以。在没有 acl_master 的情况下，由以上各个服务模型编写的服务程序可以通过手工方式启动。启动方式一般为：.&#x2F;xxxx alone xxxx.cf，这样服务程序便以 alone 模式启动运行，具体情况可以参考 main.cpp 里的启动方式；在 WINDOWS 平台下只能是以 alone 模式手工启动运行。</p>\n<h4 id=\"4-手工模式下运行时遇到”idle-timeout-–-exiting-idle”怎么办？\"><a href=\"#4-手工模式下运行时遇到”idle-timeout-–-exiting-idle”怎么办？\" class=\"headerlink\" title=\"4. 手工模式下运行时遇到”idle timeout – exiting, idle”怎么办？\"></a>4. 手工模式下运行时遇到”idle timeout – exiting, idle”怎么办？</h4><p>因为 acl 的服务器编程模型均支持半驻留方式（即运行空闲一段时间或处理连接次数达到设定值后会自动退出，这样的好处是：可以定期通过进程退出释放可能存在的资源泄露，另一方面便于用户在开发时通过 valgrind 进行内存检查），如果让进程不退出，可以在 alone 模式下给服务程序传递启动配置文件，如启动方式为：.&#x2F;xxxx alone xxxx.cf（传递方式可以看 main.cpp 和相关头文件），不同的服务器模型分别采取下面不同的配置项：  </p>\n<p><strong>程池模型：</strong> 将配置项 single_use_limit 和 single_idle_limit 设为 0；<br><strong>线程池模型：</strong> 将配置项 ioctl_use_limit 和 ioctl_idle_limit 设为 0；<br><strong>非阻塞模型：</strong> 将配置项 aio_use_limit 和 aio_idle_limit 设为 0；<br><strong>协程模型：</strong> 将配置项 fiber_use_limit 和 fiber_idle_limit 设为 0；<br><strong>UDP通信模型：</strong> 将配置项 udp_use_limit 和 udp_idle_limit 设为 0；<br><strong>触发器模型：</strong> 将配置项 trigger_use_limit 设为 0。</p>\n<h4 id=\"5-acl-master-控制模式下，服务子进程如何预启动多个进程？\"><a href=\"#5-acl-master-控制模式下，服务子进程如何预启动多个进程？\" class=\"headerlink\" title=\"5. acl_master 控制模式下，服务子进程如何预启动多个进程？\"></a>5. acl_master 控制模式下，服务子进程如何预启动多个进程？</h4><p>需要修改每个服务子进程的配置文件，将配置项：master_maxproc 及 master_prefork 设置成要启动的进程数（设置值需相同），同时需要将 xxx_use_limit 及 xxx_idle_limit 配置项设成 0 以防止子进程空闲退出，xxx_use_limit 及 xxx_idle_limit  的依每种服务器模型而不同，具体可参考上面（4）中的说明。</p>\n<h4 id=\"6-acl-master-控制模式下，如何只监听内网地址？\"><a href=\"#6-acl-master-控制模式下，如何只监听内网地址？\" class=\"headerlink\" title=\"6. acl_master 控制模式下，如何只监听内网地址？\"></a>6. acl_master 控制模式下，如何只监听内网地址？</h4><p>在 acl_master 模式下，可以将 master_service 配置项支持模糊匹配方式，即可以将监听地址写成 <code>192.168.*.*:8192</code> 或 <code>10.0.*.*:8192</code> 方式，这样 acl_master 会自动扫描服务器所有的网卡地址，但只监听服务匹配条件的内网地址，这样为统一部署提供方便。</p>\n<h3 id=\"（六）、数据库模块\"><a href=\"#（六）、数据库模块\" class=\"headerlink\" title=\"（六）、数据库模块\"></a>（六）、数据库模块</h3><h4 id=\"1-acl-数据库客户端支持哪些数据库？\"><a href=\"#1-acl-数据库客户端支持哪些数据库？\" class=\"headerlink\" title=\"1. acl 数据库客户端支持哪些数据库？\"></a>1. acl 数据库客户端支持哪些数据库？</h4><p>当前 acl 数据库客户端库支持的数据库有：mysql，postgresql，sqlite。</p>\n<h4 id=\"2-acl-数据库模块如何使用？\"><a href=\"#2-acl-数据库模块如何使用？\" class=\"headerlink\" title=\"2. acl 数据库模块如何使用？\"></a>2. acl 数据库模块如何使用？</h4><p>acl 数据库模块封装了官方数据库的驱动（包括 mysql，postgresql，sqlite），所以使用者应先下载所对应的官方数据库驱动，考虑到版本的一致性，建议从 <a href=\"https://github.com/acl-dev/third_party\">https://github.com/acl-dev/third_party</a> 处下载；<br>另外，acl 数据库模块是采用动态加载方式加载数据库驱动的，所以使用者应将编译好的数据库动态库放置在合适的位置，并调用 <code>acl::db_handle::set_loadpath()</code> 设置数据库驱动动态库的全路径，以便于 acl 数据库模块内部可以使用该路径进行动态加载。</p>\n<h3 id=\"（七）、邮件-amp-mime模块\"><a href=\"#（七）、邮件-amp-mime模块\" class=\"headerlink\" title=\"（七）、邮件&amp;mime模块\"></a>（七）、邮件&amp;mime模块</h3><p>。。。</p>\n<ul>\n<li>微博：<a href=\"http://weibo.com/zsxxsz\">http://weibo.com/zsxxsz</a></li>\n<li>qq 群：242722074</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"acl库使用FAQ\"><a href=\"#acl库使用FAQ\" class=\"headerlink\" title=\"acl库使用FAQ\"></a>acl库使用FAQ</h2><ul>\n<li><a href=\"#%E4%B8%80%E5%9F%BA%E7%A1%80%E9%97%AE%E9%A2%98\">一、基础问题</a><ul>\n<li><a href=\"#1acl-%E5%BA%93%E6%98%AF%E5%95%A5%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E5%93%AA%E4%BA%9B%E5%8A%9F%E8%83%BD\">1、acl 库是啥、主要包含哪些功能？</a></li>\n<li><a href=\"#2acl-%E5%BA%93%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%B9%B3%E5%8F%B0\">2、acl 库支持哪些平台？</a></li>\n<li><a href=\"#3acl-%E5%BA%93%E4%B8%BB%E8%A6%81%E5%8C%85%E5%90%AB%E5%87%A0%E4%B8%AA%E5%BA%93\">3、acl 库主要包含几个库？</a></li>\n<li><a href=\"#4acl-%E5%BA%93%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A4%96%E9%83%A8%E4%BE%9D%E8%B5%96%E5%BA%93\">4、acl 库有哪些外部依赖库？</a></li>\n<li><a href=\"#5%E6%B2%A1%E6%9C%89%E8%BF%99%E4%BA%9B%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93-acl-%E8%83%BD%E5%90%A6%E4%BD%BF%E7%94%A8\">5、没有这些第三方库 acl 能否使用？</a></li>\n<li><a href=\"#6acl-%E5%BA%93%E7%9A%84%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E4%BD%8D%E7%BD%AE%E5%9C%A8%E5%93%AA%E5%84%BF\">6、acl 库的源码下载位置在哪儿？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%8C%E7%BC%96%E8%AF%91%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98\">二、编译&amp;使用问题</a><ul>\n<li><a href=\"#1acl-%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E8%BF%87%E7%A8%8B\">1、acl 库的编译过程？</a></li>\n<li><a href=\"#2linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%BA%93%E7%9A%84%E7%BC%96%E8%AF%91%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98\">2、Linux 平台下库的编译顺序问题？</a></li>\n<li><a href=\"#3unixlinux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E7%BC%96%E8%AF%91-acl-%E5%BA%93%E6%97%B6%E7%9A%84%E7%BC%96%E8%AF%91%E9%80%89%E9%A1%B9%E6%98%AF%E4%BB%80%E4%B9%88\">3、Unix&#x2F;Linux 平台下编译 acl 库时的编译选项是什么</a></li>\n<li><a href=\"#4%E8%AF%B7%E7%BB%99%E5%87%BA-linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%9C%80%E7%AE%80%E5%8D%95%E7%9A%84%E4%B8%80%E4%B8%AA-makefile\">4、请给出 Linux 平台下最简单的一个 Makefile？</a></li>\n<li><a href=\"#5linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E6%89%BE%E4%B8%8D%E5%88%B0-libza-%E5%BA%93%E6%80%8E%E4%B9%88%E5%8A%9E\">5、Linux 平台下找不到 libz.a 库怎么办？</a></li>\n<li><a href=\"#6linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B-acl-%E5%BA%93%E8%83%BD%E6%89%93%E5%8C%85%E6%88%90%E4%B8%80%E4%B8%AA%E5%BA%93%E5%90%97\">6、Linux 平台下 acl 库能打包成一个库吗？</a></li>\n<li><a href=\"#7linux-%E5%B9%B3%E5%8F%B0%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-ssl-%E5%8A%9F%E8%83%BD\">7、Linux 平台下如何使用 ssl 功能？</a></li>\n<li><a href=\"#8linux-%E4%B8%8B%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-mysql-%E5%8A%9F%E8%83%BD\">8、Linux 下如何使用 mysql 功能？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%89%E5%90%84%E4%B8%AA%E5%8A%9F%E8%83%BD%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E9%97%AE%E9%A2%98\">三、各个功能模块的使用问题</a><ul>\n<li><a href=\"#%E4%B8%80%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1\">（一）、网络通信</a></li>\n<li><a href=\"#%E4%BA%8Chttp-%E6%A8%A1%E5%9D%97\">（二）、HTTP 模块</a><ul>\n<li><a href=\"#1-acl-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%96%AD%E7%82%B9%E4%B8%8B%E8%BD%BD%E5%8A%9F%E8%83%BD\">1. acl HTTP 服务器是否支持断点下载功能？</a></li>\n<li><a href=\"#2-acl-http-%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%8A%9F%E8%83%BD\">2. acl HTTP 服务器是否支持文件上传功能？</a></li>\n<li><a href=\"#3-acl-http-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%A4%E7%A7%8D%E6%A8%A1%E5%BC%8F\">3. acl HTTP 模块是否支持服务器&#x2F;客户端两种模式？</a></li>\n<li><a href=\"#4-acl-http-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-websocket-%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE\">4. acl HTTP 模块是否支持 websocket 通信协议？</a></li>\n<li><a href=\"#5-acl-http-%E6%A8%A1%E5%9D%97%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81-session\">5. acl HTTP 模块是否支持 session？</a></li>\n<li><a href=\"#6-HttpServletRequest-%E4%B8%BA%E4%BD%95%E8%AF%BB%E4%B8%8D%E5%88%B0-json-%E6%88%96-xml-%E6%95%B0%E6%8D%AE%E4%BD%93\">6. HttpServletRequest 为何读不到 json 或 xml 数据体？</a></li>\n<li><a href=\"#7-http_request-%E5%9B%A0%E6%9C%AA%E8%AE%BE-Host-%E5%AD%97%E6%AE%B5%E8%80%8C%E5%87%BA%E9%94%99%E7%9A%84%E9%97%AE%E9%A2%98\">7. http_request 因未设 Host 字段而出错的问题</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%89redis-%E6%A8%A1%E5%9D%97\">（三）、Redis 模块</a><ul>\n<li><a href=\"#1-acl-redis-%E5%BA%93%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E9%9B%86%E7%BE%A4%E5%8A%9F%E8%83%BD\">1. acl redis 库是否支持集群功能？</a></li>\n<li><a href=\"#2-acl-redis-%E5%BA%93%E6%98%AF%E5%A6%82%E4%BD%95%E5%88%92%E5%88%86%E7%9A%84\">2. acl redis 库是如何划分的？</a></li>\n<li><a href=\"#3-acl-redis-%E5%BA%93%E4%B8%AD%E7%9A%84%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84\">3. acl redis 库中的哪些类对象操作是线程安全的？</a></li>\n<li><a href=\"#4-acl-redis-%E5%AE%A2%E6%88%B7%E5%BA%93%E5%BD%93%E8%BF%9E%E6%8E%A5%E6%96%AD%E5%BC%80%E6%97%B6%E6%98%AF%E5%90%A6%E4%BC%9A%E9%87%8D%E8%BF%9E\">4. acl redis 客户库当连接断开时是否会重连？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%9B%9B%E5%8D%8F%E7%A8%8B%E6%A8%A1%E5%9D%97\">（四）、协程模块</a><ul>\n<li><a href=\"#1-%E5%8D%8F%E7%A8%8B%E9%87%8C%E9%9D%A2%E7%9A%84%E9%9D%9E%E9%98%BB%E5%A1%9E%E6%98%AF%E4%BB%80%E4%B9%88%E5%8E%9F%E7%90%86%E7%9A%84\">1. 协程里面的非阻塞是什么原理的？</a></li>\n<li><a href=\"#2-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E6%98%AF%E5%90%A6%E6%94%AF%E6%8C%81%E5%A4%9A%E7%BA%BF%E7%A8%8B\">2. acl 协程库是否支持多线程？</a></li>\n<li><a href=\"#3-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E5%A6%82%E4%BD%95%E6%94%AF%E6%8C%81%E5%A4%9A%E6%A0%B8-cpu\">3. acl 协程库如何支持多核 CPU？</a></li>\n<li><a href=\"#4-acl-%E5%8D%8F%E7%A8%8B%E9%87%8C%E9%92%88%E5%AF%B9-mysql-%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%BA%93%E7%9A%84%E5%8D%8F%E7%A8%8B%E5%8C%96%E6%98%AF%E5%90%A6%E4%BF%AE%E6%94%B9%E4%BA%86-mysql-%E5%BA%93%E7%9A%84%E6%BA%90%E7%A0%81\">4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？</a></li>\n<li><a href=\"#5-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E6%94%AF%E6%8C%81%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E5%8A%9F%E8%83%BD%E5%90%97\">5. acl 协程库支持域名解析功能吗？</a></li>\n<li><a href=\"#6-acl-%E5%8D%8F%E7%A8%8B%E5%BA%93%E7%9A%84%E7%B3%BB%E7%BB%9F-errno-%E5%8F%B7%E5%A6%82%E4%BD%95%E5%A4%84%E7%90%86\">6. acl 协程库的系统 errno 号如何处理？</a></li>\n<li><a href=\"#7-%E5%A6%82%E6%9E%9C%E5%90%AF%E5%8A%A8%E7%9A%84%E5%8D%8F%E7%A8%8B%E8%BF%87%E5%A4%9A%E4%BC%9A%E4%B8%8D%E4%BC%9A%E5%AF%B9%E4%BA%8E%E5%90%8E%E7%AB%AF%E4%BE%8B%E5%A6%82-mysql-%E4%B9%8B%E7%B1%BB%E6%9C%8D%E5%8A%A1%E9%80%A0%E6%88%90%E5%B9%B6%E5%8F%91%E5%8E%8B%E5%8A%9B%E5%A6%82%E4%BD%95%E9%81%BF%E5%85%8D\">7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%BA%94%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%A8%A1%E5%9D%97\">（五）、服务器模块</a><ul>\n<li><a href=\"#1-%E6%9C%89%E5%87%A0%E7%A7%8D%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%BC%96%E7%A8%8B%E6%A8%A1%E5%9E%8B%E5%9D%87%E6%9C%89%E4%BD%95%E7%89%B9%E7%82%B9\">1. 有几种服务器编程模型？均有何特点？</a></li>\n<li><a href=\"#2-acl_master-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E5%B9%B3%E5%8F%B0\">2. acl_master 的作用是什么？支持哪些平台？</a></li>\n<li><a href=\"#3-%E6%B2%A1%E6%9C%89-acl_master-%E6%8E%A7%E5%88%B6%E7%AE%A1%E7%90%86%E6%9C%8D%E5%8A%A1%E5%AD%90%E8%BF%9B%E7%A8%8B%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E5%8D%95%E7%8B%AC%E8%BF%90%E8%A1%8C\">3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？</a></li>\n<li><a href=\"#4-%E6%89%8B%E5%B7%A5%E6%A8%A1%E5%BC%8F%E4%B8%8B%E8%BF%90%E8%A1%8C%E6%97%B6%E9%81%87%E5%88%B0idle-timeout----exiting-idle%E6%80%8E%E4%B9%88%E5%8A%9E\">4. 手工模式下运行时遇到“idle timeout – exiting, idle”怎么办？</a></li>\n<li><a href=\"#5-acl_master-%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%AD%90%E8%BF%9B%E7%A8%8B%E5%A6%82%E4%BD%95%E9%A2%84%E5%90%AF%E5%8A%A8%E5%A4%9A%E4%B8%AA%E8%BF%9B%E7%A8%8B\">5. acl_master 控制模式下，服务子进程如何预启动多个进程？</a></li>\n<li><a href=\"#6-acl_master-%E6%8E%A7%E5%88%B6%E6%A8%A1%E5%BC%8F%E4%B8%8B%E5%A6%82%E4%BD%95%E5%8F%AA%E7%9B%91%E5%90%AC%E5%86%85%E7%BD%91%E5%9C%B0%E5%9D%80\">6. acl_master 控制模式下，如何只监听内网地址？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E5%85%AD%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97\">（六）、数据库模块</a><ul>\n<li><a href=\"#1-acl-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%94%AF%E6%8C%81%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E5%BA%93\">1. acl 数据库客户端支持哪些数据库？</a></li>\n<li><a href=\"#2-acl-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A8%A1%E5%9D%97%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8\">2. acl 数据库模块如何使用？</a></li>\n</ul>\n</li>\n<li><a href=\"#%E4%B8%83%E9%82%AE%E4%BB%B6mime%E6%A8%A1%E5%9D%97\">（七）、邮件&amp;mime模块</a></li>\n</ul>\n</li>\n</ul>\n<h3 id=\"一、基础问题\"><a href=\"#一、基础问题\" class=\"headerlink\" title=\"一、基础问题\"></a>一、基础问题</h3><h3 id=\"1、acl-库是啥、主要包含哪些功能？\"><a href=\"#1、acl-库是啥、主要包含哪些功能？\" class=\"headerlink\" title=\"1、acl 库是啥、主要包含哪些功能？\"></a>1、acl 库是啥、主要包含哪些功能？</h3><p>acl 工程是一个跨平台（支持LINUX，WIN32，Solaris，MacOS，FreeBSD）的网络通信库及服务器编程框架，同时提供更多的实用功能库。通过该库，用户可以非常容易地编写支持多种模式(多线程、多进程、非阻塞、触发器、UDP方式、协程方式)的服务器程序，WEB 应用程序，数据库应用程序。此外，该库还提供了常见应用的客户端通信库（如：HTTP、SMTP、ICMP、redis、disque、memcache、beanstalk、handler socket），常见流式编解码库：XML&#x2F;JSON&#x2F;MIME&#x2F;BASE64&#x2F;UUCODE&#x2F;QPCODE&#x2F;RFC2047 等。</p>\n<h3 id=\"2、acl-库支持哪些平台？\"><a href=\"#2、acl-库支持哪些平台？\" class=\"headerlink\" title=\"2、acl 库支持哪些平台？\"></a>2、acl 库支持哪些平台？</h3><p>目前主要支持 Linux&#x2F;Windows&#x2F;Macos&#x2F;Freebsd&#x2F;Solaris(x86)。</p>\n<h3 id=\"3、acl-库主要包含几个库？\"><a href=\"#3、acl-库主要包含几个库？\" class=\"headerlink\" title=\"3、acl 库主要包含几个库？\"></a>3、acl 库主要包含几个库？</h3><p>主要包括：lib_acl（用 C 语言写的基础库）、lib_protocol（用 C 语言写的一些网络应用协议库）、lib_acl_cpp（用 C++ 语言编写，封装了 lib_acl&#x2F;lib_protocol 两个库，同时增加更多实用的功能库）、 lib_fiber（用 C 语言编写的支持高性能、高并发的网络协程库）、lib_rpc（用C++语言编写的封装了 google protobuf 网络库）。</p>\n<h3 id=\"4、acl-库有哪些外部依赖库？\"><a href=\"#4、acl-库有哪些外部依赖库？\" class=\"headerlink\" title=\"4、acl 库有哪些外部依赖库？\"></a>4、acl 库有哪些外部依赖库？</h3><p>lib_acl&#x2F;lib_protocol&#x2F;lib_fiber 仅依赖系统基础库；lib_acl_cpp 库的 db 模块依赖于 mysql 客户端库、sqlite 库，stream 流模块依赖于 polarssl 库（该库源码附在 acl&#x2F;resource 目录下），另外，在 UNIX&#x2F;LINUX 平台下还需要压缩库 — libz 库（一般 LINUX 会自带该压缩库）；lib_rpc 依赖于 protobuf 库。</p>\n<h3 id=\"5、没有这些第三方库-acl-能否使用？\"><a href=\"#5、没有这些第三方库-acl-能否使用？\" class=\"headerlink\" title=\"5、没有这些第三方库 acl 能否使用？\"></a>5、没有这些第三方库 acl 能否使用？</h3><p>可以。默认情况下，没有这些第三方库编译和使用 acl 库是没有问题的，只是不能使用 mysql&#x2F;sqlite&#x2F;ssl&#x2F;protobuf 功能。</p>\n<h3 id=\"6、acl-库的源码下载位置在哪儿？\"><a href=\"#6、acl-库的源码下载位置在哪儿？\" class=\"headerlink\" title=\"6、acl 库的源码下载位置在哪儿？\"></a>6、acl 库的源码下载位置在哪儿？</h3><ul>\n<li>github：<a href=\"https://github.com/acl-dev/acl/\">https://github.com/acl-dev/acl/</a></li>\n<li>oschina: <a href=\"https://git.oschina.net/acl-dev/acl/\">https://git.oschina.net/acl-dev/acl/</a></li>\n<li>sourceforge：<a href=\"https://sourceforge.net/projects/acl/\">https://sourceforge.net/projects/acl/</a></li>\n</ul>\n<h3 id=\"二、编译-amp-使用问题\"><a href=\"#二、编译-amp-使用问题\" class=\"headerlink\" title=\"二、编译&amp;使用问题\"></a>二、编译&amp;使用问题</h3><h3 id=\"1、acl-库的编译过程？\"><a href=\"#1、acl-库的编译过程？\" class=\"headerlink\" title=\"1、acl 库的编译过程？\"></a>1、acl 库的编译过程？</h3><p>acl 库的编译过程请参考：<a href=\"http://zsxxsz.iteye.com/blog/1506554\">acl 的编译与使用</a> 博客。</p>\n<h3 id=\"2、Linux-平台下库的编译顺序问题？\"><a href=\"#2、Linux-平台下库的编译顺序问题？\" class=\"headerlink\" title=\"2、Linux 平台下库的编译顺序问题？\"></a>2、Linux 平台下库的编译顺序问题？</h3><p>lib_acl 库是 acl 库中的基础库，其它库均依赖于该库，库的依赖顺序为：lib_protocol 依赖于 lib_acl，lib_acl_cpp 依赖于 lib_acl 和 lib_protocol，lib_fiber 依赖于 lib_acl，lib_rpc 依赖于 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp。因此当应用在连接 acl 库时，需要注意连接的顺序为：-l_acl_cpp -l_protocol -l_acl。</p>\n<h3 id=\"3、Unix-x2F-Linux-平台下编译-acl-库时的编译选项是什么？\"><a href=\"#3、Unix-x2F-Linux-平台下编译-acl-库时的编译选项是什么？\" class=\"headerlink\" title=\"3、Unix&#x2F;Linux 平台下编译 acl 库时的编译选项是什么？\"></a>3、Unix&#x2F;Linux 平台下编译 acl 库时的编译选项是什么？</h3><p>在 Unix&#x2F;Linux 平台下编译 acl 库时需要指明 gcc 的编译选项，acl 库自带的 Makefile 会自动识别操作系统而选择不同的编译选项，下面列出不同 Unix 平台的不同编译选项（当前版本已自动识别系统类型，无需添加如下编译选项）：</p>\n<ul>\n<li>Linux 平台：-DLINUX2</li>\n<li>MacOS 平台：-DMACOSX</li>\n<li>FreeBSD 平台：-DFREEBSD</li>\n<li>Solaris(x86) 平台：-DSUNOS5</li>\n</ul>\n<h3 id=\"4、请给出-Linux-平台下最简单的一个-Makefile？\"><a href=\"#4、请给出-Linux-平台下最简单的一个-Makefile？\" class=\"headerlink\" title=\"4、请给出 Linux 平台下最简单的一个 Makefile？\"></a>4、请给出 Linux 平台下最简单的一个 Makefile？</h3><p>下面是使用 acl 库的最简单的编译选项（因为排版问题，当拷贝下面内容至 Makefile 时，需要注意将每行前空格手工转成 TAB 键）：</p>\n<figure class=\"highlight gradle\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gradle\">fiber: main.o<br>\tg++ -o fiber main.o \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_fiber/</span>lib -lfiber_cpp \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_acl_cpp/</span>lib -l_acl_cpp \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_protocol/</span>lib -l_protocol \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_acl/</span>lib -l_acl \\<br>\t\t-L.<span class=\"hljs-regexp\">/lib_fiber/</span>lib -lfiber \\<br>\t\t-lz -lpthread -ldl<br>main.o: main.cpp<br>\tg++ -O3 -Wall -c main.cpp -DLINUX2 \\<br>\t\t-I.<span class=\"hljs-regexp\">/lib_acl/i</span>nclude \\<br>\t\t-I.<span class=\"hljs-regexp\">/lib_acl_cpp/i</span>nclude \\<br>\t\t-I.<span class=\"hljs-regexp\">/lib_fiber/</span>cpp/<span class=\"hljs-keyword\">include</span> \\<br>\t\t-I.<span class=\"hljs-regexp\">/lib_fiber/</span>c/<span class=\"hljs-keyword\">include</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"5、Linux-平台下找不到-libz-a-库怎么办？\"><a href=\"#5、Linux-平台下找不到-libz-a-库怎么办？\" class=\"headerlink\" title=\"5、Linux 平台下找不到 libz.a 库怎么办？\"></a>5、Linux 平台下找不到 libz.a 库怎么办？</h3><p>一般 Unix&#x2F;Linux 平台下系统会自带 libz.a 或 libz.so 压缩库，如果找不到该库，则可以在线安装或采用编译安装 zlib 库，针对 Centos 和 Ubuntu 可分别通过以下方式在线安装（均需切换至 root 身份）：</p>\n<ul>\n<li>Centos：yum install zlib-devel</li>\n<li>Ubuntu：apt-get install zlib1g.dev</li>\n</ul>\n<h3 id=\"6、Linux-平台下-acl-库能打包成一个库吗？\"><a href=\"#6、Linux-平台下-acl-库能打包成一个库吗？\" class=\"headerlink\" title=\"6、Linux 平台下 acl 库能打包成一个库吗？\"></a>6、Linux 平台下 acl 库能打包成一个库吗？</h3><p>可以。在 acl 目录下运行：make build_one 则可以将 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp 打包成一个完整的库：lib_acl.a&#x2F;lib_acl.so，则应用最终使用时可以仅连接这一个库即可。</p>\n<h3 id=\"7、Linux-平台下如何使用-ssl-功能？\"><a href=\"#7、Linux-平台下如何使用-ssl-功能？\" class=\"headerlink\" title=\"7、Linux 平台下如何使用 ssl 功能？\"></a>7、Linux 平台下如何使用 ssl 功能？</h3><p>目前 acl 中的 lib_acl_cpp C++ 库通过集成 polarssl 支持 ssl 功能，所支持的 polarssl 源码的下载位置：<a href=\"https://github.com/acl-dev/third_party\">https://github.com/acl-dev/third_party</a>, 老版本 acl 通过静态连接 libpolarssl.a 实现对 ssl 的支持，当前版本则是通过动态加载 libpolarssl.so 方式实现了对 ssl 的支持，此动态支持方式更加灵活方便，无须特殊编译条件，也更为通用。</p>\n<h4 id=\"7-1、老版本-acl-对-ssl-的支持方式\"><a href=\"#7-1、老版本-acl-对-ssl-的支持方式\" class=\"headerlink\" title=\"7.1、老版本 acl 对 ssl 的支持方式\"></a>7.1、老版本 acl 对 ssl 的支持方式</h4><p>如果使用上面统一的 acl 库，则可以在 acl 根目录下编译时运行：make build_one polarssl&#x3D;on；如果使用三个库：lib_acl.a，lib_protocol.a，lib_acl_cpp.a，则在编译前需要先指定环境变量：export ENV_FLAGS&#x3D;HAS_POLARSSL，然后分别编译这三个库；解压 polarssl-1.2.19-gpl.tgz，然后进入 polarssl-1.2.19 目录运行：make 编译后在 polarssl-1.2.19&#x2F;library 目录得到 libpolarssl.a 库；最后在编译应用时将 libpolarssl.a 连接进你的工程中即可。</p>\n<h4 id=\"7-2、当前版本-acl-对-ssl-的支持方式\"><a href=\"#7-2、当前版本-acl-对-ssl-的支持方式\" class=\"headerlink\" title=\"7.2、当前版本 acl 对 ssl 的支持方式\"></a>7.2、当前版本 acl 对 ssl 的支持方式</h4><ul>\n<li>首先下载解压 polarssl 库后进入polarssl-1.2.19 目录，运行 make lib SHARED&#x3D;yes，在library 目录下会生成 libpolarssl.so 动态库;</li>\n<li>在 acl 根目录下运行 make build_one，则会将 acl 的三个基础库：libacl.a, libprotocol.a, libacl_cpp.a 合成 libacl_all.a 一个静态库，将 libacl.so, libprotocol.so, lib_acl_cpp.so 合成 libacl_all.so 一个动态库;</li>\n<li>当程序启动时添加代码：acl::polarssl_conf::set_libpath(“libpolarssl.so”); 其中的路径根据实际位置而定，这样 acl 模块在需要 ssl 通信时会自动切换至 ssl 方式。</li>\n</ul>\n<h3 id=\"8、Linux-下如何使用-mysql-功能？\"><a href=\"#8、Linux-下如何使用-mysql-功能？\" class=\"headerlink\" title=\"8、Linux 下如何使用 mysql 功能？\"></a>8、Linux 下如何使用 mysql 功能？</h3><p>lib_acl_cpp 库是以动态加载方式加载 mysql 动态库的，所以在编译 lib_acl_cpp 时，mysql 功能就已经被编译进去 acl库中了。用户仅需要将 mysql 动态库通过函数 acl::db_handle::set_loadpath 注册进 acl 库中即可；至于 mysql 客户端库，用户可以去 mysql 官方下载或在 acl&#x2F;resource 目录下编译 mysql-connector-c-6.1.6-src.tar.gz。</p>\n<h3 id=\"三、各个功能模块的使用问题\"><a href=\"#三、各个功能模块的使用问题\" class=\"headerlink\" title=\"三、各个功能模块的使用问题\"></a>三、各个功能模块的使用问题</h3><h3 id=\"（一）、网络通信\"><a href=\"#（一）、网络通信\" class=\"headerlink\" title=\"（一）、网络通信\"></a>（一）、网络通信</h3><h3 id=\"（二）、HTTP-模块\"><a href=\"#（二）、HTTP-模块\" class=\"headerlink\" title=\"（二）、HTTP 模块\"></a>（二）、HTTP 模块</h3><h4 id=\"1-acl-HTTP-服务器是否支持断点下载功能？\"><a href=\"#1-acl-HTTP-服务器是否支持断点下载功能？\" class=\"headerlink\" title=\"1. acl HTTP 服务器是否支持断点下载功能？\"></a>1. acl HTTP 服务器是否支持断点下载功能？</h4><p>支持。acl HTTP 模块支持断点续传功能，一个支持断点下载的服务器示例参照：acl\\app\\wizard_demo\\httpd_download。</p>\n<h4 id=\"2-acl-HTTP-服务器是否支持文件上传功能？\"><a href=\"#2-acl-HTTP-服务器是否支持文件上传功能？\" class=\"headerlink\" title=\"2. acl HTTP 服务器是否支持文件上传功能？\"></a>2. acl HTTP 服务器是否支持文件上传功能？</h4><p>支持。参考示例：acl\\app\\wizard_demo\\httpd_upload。</p>\n<h4 id=\"3-acl-HTTP-模块是否支持服务器-x2F-客户端两种模式？\"><a href=\"#3-acl-HTTP-模块是否支持服务器-x2F-客户端两种模式？\" class=\"headerlink\" title=\"3. acl HTTP 模块是否支持服务器&#x2F;客户端两种模式？\"></a>3. acl HTTP 模块是否支持服务器&#x2F;客户端两种模式？</h4><p>支持。目前 acl 的 HTTP 协议模块同时支持客户端及服务端模式，即你既可以使用 acl HTTP 编写客户端程序，又可以编写服务器程序，其中 acl 中的 http_request&#x2F;http_request_pool&#x2F;http_request_manager 类用来编写客户端程序，http_response&#x2F;HttpServlet&#x2F;HttpServletRequest&#x2F;HttpServeletResponse 用来编写服务器程序。</p>\n<h4 id=\"4-acl-HTTP-模块是否支持-websocket-通信协议？\"><a href=\"#4-acl-HTTP-模块是否支持-websocket-通信协议？\" class=\"headerlink\" title=\"4. acl HTTP 模块是否支持 websocket 通信协议？\"></a>4. acl HTTP 模块是否支持 websocket 通信协议？</h4><p>支持。可以参考示例：lib_acl_cpp\\samples\\websocket。</p>\n<h4 id=\"5-acl-HTTP-模块是否支持-session？\"><a href=\"#5-acl-HTTP-模块是否支持-session？\" class=\"headerlink\" title=\"5. acl HTTP 模块是否支持 session？\"></a>5. acl HTTP 模块是否支持 session？</h4><p>支持。acl HTTP 模块当用在服务器编程时支持 session 存储，目前支持使用 memcached 或 redis 存储 session 数据。</p>\n<h4 id=\"6-HttpServletRequest-为何读不到-json-或-xml-数据体\"><a href=\"#6-HttpServletRequest-为何读不到-json-或-xml-数据体\" class=\"headerlink\" title=\"6. HttpServletRequest 为何读不到 json 或 xml 数据体\"></a>6. HttpServletRequest 为何读不到 json 或 xml 数据体</h4><p>当 HTTP 客户端请求的数据体为 json 或 xml 时，默认情况下从 acl::HttpServletRequest 对象中是读不到 json&#x2F;xml 数据的，主要原因在于 HttpServletRequest 内置了自动读取并解析 json&#x2F;xml&#x2F;x-www-form-urlencoded 类型数据的功能，使用者只需直接获取解析后的对象即可，如针对 json 类数据体：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">get_json</span><span class=\"hljs-params\">(acl::HttpServletRequest&amp; req)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::json* json = req.<span class=\"hljs-built_in\">getJson</span>();<br>\t...<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如果应用想自己读取并解析 json 数据，则需要在调用 acl::HttpServlet::setParseBody(false)，禁止 acl::HttpServletRequest 类对象内部自动读取数据。</p>\n<h4 id=\"7-http-request-因未设-Host-字段而出错的问题\"><a href=\"#7-http-request-因未设-Host-字段而出错的问题\" class=\"headerlink\" title=\"7. http_request 因未设 Host 字段而出错的问题\"></a>7. http_request 因未设 Host 字段而出错的问题</h4><p>在使用 acl::http_request 类对象访问标准 WEB 服务器（如：nginx）时，如果没有设置 HTTP 请求头中的 Host 字段，nginx 会返回 400 错误，主要是 HTTP&#x2F;1.1 协议要求 HTTP 客户端必须设置 Host 字段，方法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">http_client</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">acl::http_request <span class=\"hljs-title\">req</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;www.sina.com.cn:80&quot;</span>)</span></span>;<br>\tacl::http_header&amp; hdr = req.<span class=\"hljs-built_in\">request_header</span>();<br>\thdr.<span class=\"hljs-built_in\">set_url</span>(<span class=\"hljs-string\">&quot;/&quot;</span>).<span class=\"hljs-built_in\">set_host</span>(<span class=\"hljs-string\">&quot;www.sina.com.cn&quot;</span>);<br>\t<span class=\"hljs-keyword\">if</span> (!req.<span class=\"hljs-built_in\">request</span>(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>)) &#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\tacl::string body;<br>\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">get_body</span>(body)) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\r\\n&quot;</span>, body.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br>\t<br>\t... <br>&#125;<br><br></code></pre></td></tr></table></figure>\n\n<h3 id=\"（三）、Redis-模块\"><a href=\"#（三）、Redis-模块\" class=\"headerlink\" title=\"（三）、Redis 模块\"></a>（三）、Redis 模块</h3><h4 id=\"1-acl-redis-库是否支持集群功能？\"><a href=\"#1-acl-redis-库是否支持集群功能？\" class=\"headerlink\" title=\"1. acl redis 库是否支持集群功能？\"></a>1. acl redis 库是否支持集群功能？</h4><p>答案：是，acl redis 客户端库同时支持集群和单机方式的 redis-server。</p>\n<h4 id=\"2-acl-redis-库是如何划分的？\"><a href=\"#2-acl-redis-库是如何划分的？\" class=\"headerlink\" title=\"2. acl redis 库是如何划分的？\"></a>2. acl redis 库是如何划分的？</h4><p>acl redis 客户端库主要分为两类：命令类和连接类：</p>\n<ul>\n<li><strong>命令类主要有</strong>：redis_key, redis_string, redis_hash, redis_list, redis_set, redis_zset, redis_cluster, redis_geo, redis_hyperloglog, redis_pubsub, redis_transaction, redis_server, redis_script, 这些类都继承于基类 redis_command，同时子类 redis 又继承了所有这些命令类，以便于用户可以直接使用 acl::redis 操作所有的 redis 客户端命令；</li>\n<li><strong>连接类主要有</strong>：redis_client, redis_client_pool, redis_client_cluster，命令类对象通过这些连接类对象与 redis-server 进行交互，redis_client 为单连接类，redis_client_pool 为连接池类，这两个类仅能在非集群模式的 redis-server 环境中使用，不支持 redis-server 的集群模式，必须使用 redis_client_cluster 连接集群模式的 redis-server，同时 redis_client_cluster 也兼容非集群模式的连接。</li>\n</ul>\n<h4 id=\"3-acl-redis-库中的哪些类对象操作是线程安全的？\"><a href=\"#3-acl-redis-库中的哪些类对象操作是线程安全的？\" class=\"headerlink\" title=\"3. acl redis 库中的哪些类对象操作是线程安全的？\"></a>3. acl redis 库中的哪些类对象操作是线程安全的？</h4><p>acl redis 库中的所有命令类对象及 redis_client 单连接类对象不能同时被多个线程使用（就象 std::string 一样不能跨线程使用）；redis_client_pool，redis_client_cluster 两个连接类对象是线程操作安全的，同一个对象可以被多个线程同时使用。</p>\n<h4 id=\"4-acl-redis-客户库当连接断开时是否会重连？\"><a href=\"#4-acl-redis-客户库当连接断开时是否会重连？\" class=\"headerlink\" title=\"4. acl redis 客户库当连接断开时是否会重连？\"></a>4. acl redis 客户库当连接断开时是否会重连？</h4><p>acl redis 库中的连接类中：redis_client，redis_client_pool，redis_client_cluster 三个连接类对象当检测到网络连接异常断开时会尝试自动重连，上层使用者无需考虑连接断开重试的情况。</p>\n<h3 id=\"（四）、协程模块\"><a href=\"#（四）、协程模块\" class=\"headerlink\" title=\"（四）、协程模块\"></a>（四）、协程模块</h3><h4 id=\"1-协程里面的非阻塞是什么原理的？\"><a href=\"#1-协程里面的非阻塞是什么原理的？\" class=\"headerlink\" title=\"1. 协程里面的非阻塞是什么原理的？\"></a>1. 协程里面的非阻塞是什么原理的？</h4><p>比如我现在需要访问数据库，这个动作肯定是个阻塞的操作，如果有10个协程进行数据库访问，这个非阻塞是怎么理解的？<br>协程方式在底层将系统的 IO API（read&#x2F;write 等）都 hook 了，数据库操作也要调用这些API，所以表面上的阻塞式DB操作在协程底层的IO也会被转为非阻塞模式。</p>\n<h4 id=\"2-acl-协程库是否支持多线程？\"><a href=\"#2-acl-协程库是否支持多线程？\" class=\"headerlink\" title=\"2. acl 协程库是否支持多线程？\"></a>2. acl 协程库是否支持多线程？</h4><p>acl 协程库支持多线程方式，只是支持的方式与 go 语言有所不同。用户可以创建多个线程，每个线程一个协程调度器，线程之间的协程调度是相互隔离的，正如多进程与多线程之间的关系一样（每个进程内可以启动多个线程，但进程之间的线程的调度过程是隔离的），在每个线程内部可以创建大量 acl 协程，每个协程均由其所属的线程内的协程调度器调度运行。</p>\n<h4 id=\"3-acl-协程库如何支持多核-CPU？\"><a href=\"#3-acl-协程库如何支持多核-CPU？\" class=\"headerlink\" title=\"3. acl 协程库如何支持多核 CPU？\"></a>3. acl 协程库如何支持多核 CPU？</h4><p>正如 2）所说，用户可以启动多个线程，每个线程一个 acl 协程调度器，每个协程调度器负责调度与其同属相同线程的协程运行状态。</p>\n<h4 id=\"4-acl-协程里针对-mysql-客户端库的协程化是否修改了-mysql-库的源码？\"><a href=\"#4-acl-协程里针对-mysql-客户端库的协程化是否修改了-mysql-库的源码？\" class=\"headerlink\" title=\"4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？\"></a>4. acl 协程里针对 mysql 客户端库的协程化是否修改了 mysql 库的源码？</h4><p>没有。mysql 客户端库使用的系统 IO API 为 read&#x2F;write&#x2F;poll，而 acl 协程库 HOOK 了系统底层的 IO 过程，因此当将用户程序与 mysql 库及 acl 协程库一起编译后，mysql 库的 IO 过程直接被 acl 协程库 HOOK 的 API 接管，从而将 mysql 客户端库协程化而无须修改一行 mysql 库代码。</p>\n<h4 id=\"5-acl-协程库支持域名解析功能吗？\"><a href=\"#5-acl-协程库支持域名解析功能吗？\" class=\"headerlink\" title=\"5. acl 协程库支持域名解析功能吗？\"></a>5. acl 协程库支持域名解析功能吗？</h4><p>支持。很多 C&#x2F;C++ 实现的协程库并未实现 gethostbyname(_r) 函数，导致用户在使用协程编程遇到域名解析时还需要借助单独的线程来完成，acl 库本身从 DNS 协议层次实现了域名解析过程，acl 协程库基于此功能模块 HOOK 了系统的 gethostbyname(_r) API 而无须借助第三方函数库或起单独的线程完成域名解析。</p>\n<h4 id=\"6-acl-协程库的系统-errno-号如何处理？\"><a href=\"#6-acl-协程库的系统-errno-号如何处理？\" class=\"headerlink\" title=\"6. acl 协程库的系统 errno 号如何处理？\"></a>6. acl 协程库的系统 errno 号如何处理？</h4><p>acl 协程库实现了协程安全的 errno 号，正如之前使用多线程编程时 errno 可以与每个线程绑定一样，在 acl 协程库里 errno 也是与每个 acl 协程进行绑定的。因此，当你调用 strerror(errno) 时也是协程安全的。</p>\n<h4 id=\"7-如果启动的协程过多，会不会对于后端例如-mysql-之类服务造成并发压力？如何避免？\"><a href=\"#7-如果启动的协程过多，会不会对于后端例如-mysql-之类服务造成并发压力？如何避免？\" class=\"headerlink\" title=\"7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？\"></a>7. 如果启动的协程过多，会不会对于后端例如 mysql 之类服务造成并发压力？如何避免？</h4><p>当启动用协程较多且都需要 mysql 操作时的确会造成 mysql 服务器的并发压力。为避免此并发压力，acl 协程库提供了协程信号量，用来针对后端不支持高并发的服务提供连接保护。</p>\n<h3 id=\"（五）、服务器模块\"><a href=\"#（五）、服务器模块\" class=\"headerlink\" title=\"（五）、服务器模块\"></a>（五）、服务器模块</h3><h4 id=\"1-有几种服务器编程模型？均有何特点？\"><a href=\"#1-有几种服务器编程模型？均有何特点？\" class=\"headerlink\" title=\"1. 有几种服务器编程模型？均有何特点？\"></a>1. 有几种服务器编程模型？均有何特点？</h4><p>目前 acl 库中提供：进程池模型、线程池模型、非阻塞模型、协程模型、UDP 通信模型、触发器模型。其中各个编程模型的特点如下：  </p>\n<p><strong>进程池模型：</strong> 每个进程处理一个客户端连接，当需要处理多个连接时则需要启动多个进程，此模型的最大缺点是并发度低，优点是编程简单；<br><strong>线程池模型：</strong> 由多个线程组成线程池处理大量的客户端连接，只有当某个连接有数据可读时该连接才会与一个线程绑定，处理完毕则线程归还给线程池，此模型的优点是启动少数线程便处理较大并发，缺点是需要注意线程编程时的线程安全问题；<br><strong>非阻塞模型：</strong> 一个进程内仅有一个工作线程，通过采用非阻塞通信方式可以支持非常大的客户端并发连接，优点是资源消耗小、支持大并发、性能高，缺点是编程复杂度高；<br><strong>协程模型：</strong> 每个客户端连接与一个协程绑定，每个进程内一个工作线程，每个线程内可以创建大 量的协程，优点是支持大并发、性能高、编程简单、应用场景比较广，缺点是占用内存要比非阻塞模型高；<br><strong>UDP通信模型：</strong> 支持简单的 UDP 通信方式；触发器模型：常用在定时任务的应用场景中。<br>以上的服务模型均可启动多个进程，通过配置文件的配置项来决定启动进程的数量。</p>\n<h4 id=\"2-acl-master-的作用是什么？支持哪些平台？\"><a href=\"#2-acl-master-的作用是什么？支持哪些平台？\" class=\"headerlink\" title=\"2. acl_master 的作用是什么？支持哪些平台？\"></a>2. acl_master 的作用是什么？支持哪些平台？</h4><p>acl_master 为由以上各个服务器编写的服务进程的控制管理程序， acl_master<br>启动、停止各个服务子进程，控制子进程的启动数量及预启动策略，监控子进程的异常情况；acl_master 有点类似于 LINUX 下的 xinetd 服务进程，不同之处是 acl_master 功能更完善强大，支持服务子进程的常驻留、半驻留，而 xinetd 则只针对一个连接创建一个进程，不能用于高并发的服务应用场景。<br>目前 acl_master 进程仅支持 LINUX&#x2F;MACOS&#x2F;FREEBSD&#x2F;SOLARIS(X86）等 UNIX 平台，不支持 WINDOWS 平台。  </p>\n<h4 id=\"3-没有-acl-master-控制管理，服务子进程是否可以单独运行？\"><a href=\"#3-没有-acl-master-控制管理，服务子进程是否可以单独运行？\" class=\"headerlink\" title=\"3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？\"></a>3. 没有 acl_master 控制管理，服务子进程是否可以单独运行？</h4><p>可以。在没有 acl_master 的情况下，由以上各个服务模型编写的服务程序可以通过手工方式启动。启动方式一般为：.&#x2F;xxxx alone xxxx.cf，这样服务程序便以 alone 模式启动运行，具体情况可以参考 main.cpp 里的启动方式；在 WINDOWS 平台下只能是以 alone 模式手工启动运行。</p>\n<h4 id=\"4-手工模式下运行时遇到”idle-timeout-–-exiting-idle”怎么办？\"><a href=\"#4-手工模式下运行时遇到”idle-timeout-–-exiting-idle”怎么办？\" class=\"headerlink\" title=\"4. 手工模式下运行时遇到”idle timeout – exiting, idle”怎么办？\"></a>4. 手工模式下运行时遇到”idle timeout – exiting, idle”怎么办？</h4><p>因为 acl 的服务器编程模型均支持半驻留方式（即运行空闲一段时间或处理连接次数达到设定值后会自动退出，这样的好处是：可以定期通过进程退出释放可能存在的资源泄露，另一方面便于用户在开发时通过 valgrind 进行内存检查），如果让进程不退出，可以在 alone 模式下给服务程序传递启动配置文件，如启动方式为：.&#x2F;xxxx alone xxxx.cf（传递方式可以看 main.cpp 和相关头文件），不同的服务器模型分别采取下面不同的配置项：  </p>\n<p><strong>程池模型：</strong> 将配置项 single_use_limit 和 single_idle_limit 设为 0；<br><strong>线程池模型：</strong> 将配置项 ioctl_use_limit 和 ioctl_idle_limit 设为 0；<br><strong>非阻塞模型：</strong> 将配置项 aio_use_limit 和 aio_idle_limit 设为 0；<br><strong>协程模型：</strong> 将配置项 fiber_use_limit 和 fiber_idle_limit 设为 0；<br><strong>UDP通信模型：</strong> 将配置项 udp_use_limit 和 udp_idle_limit 设为 0；<br><strong>触发器模型：</strong> 将配置项 trigger_use_limit 设为 0。</p>\n<h4 id=\"5-acl-master-控制模式下，服务子进程如何预启动多个进程？\"><a href=\"#5-acl-master-控制模式下，服务子进程如何预启动多个进程？\" class=\"headerlink\" title=\"5. acl_master 控制模式下，服务子进程如何预启动多个进程？\"></a>5. acl_master 控制模式下，服务子进程如何预启动多个进程？</h4><p>需要修改每个服务子进程的配置文件，将配置项：master_maxproc 及 master_prefork 设置成要启动的进程数（设置值需相同），同时需要将 xxx_use_limit 及 xxx_idle_limit 配置项设成 0 以防止子进程空闲退出，xxx_use_limit 及 xxx_idle_limit  的依每种服务器模型而不同，具体可参考上面（4）中的说明。</p>\n<h4 id=\"6-acl-master-控制模式下，如何只监听内网地址？\"><a href=\"#6-acl-master-控制模式下，如何只监听内网地址？\" class=\"headerlink\" title=\"6. acl_master 控制模式下，如何只监听内网地址？\"></a>6. acl_master 控制模式下，如何只监听内网地址？</h4><p>在 acl_master 模式下，可以将 master_service 配置项支持模糊匹配方式，即可以将监听地址写成 <code>192.168.*.*:8192</code> 或 <code>10.0.*.*:8192</code> 方式，这样 acl_master 会自动扫描服务器所有的网卡地址，但只监听服务匹配条件的内网地址，这样为统一部署提供方便。</p>\n<h3 id=\"（六）、数据库模块\"><a href=\"#（六）、数据库模块\" class=\"headerlink\" title=\"（六）、数据库模块\"></a>（六）、数据库模块</h3><h4 id=\"1-acl-数据库客户端支持哪些数据库？\"><a href=\"#1-acl-数据库客户端支持哪些数据库？\" class=\"headerlink\" title=\"1. acl 数据库客户端支持哪些数据库？\"></a>1. acl 数据库客户端支持哪些数据库？</h4><p>当前 acl 数据库客户端库支持的数据库有：mysql，postgresql，sqlite。</p>\n<h4 id=\"2-acl-数据库模块如何使用？\"><a href=\"#2-acl-数据库模块如何使用？\" class=\"headerlink\" title=\"2. acl 数据库模块如何使用？\"></a>2. acl 数据库模块如何使用？</h4><p>acl 数据库模块封装了官方数据库的驱动（包括 mysql，postgresql，sqlite），所以使用者应先下载所对应的官方数据库驱动，考虑到版本的一致性，建议从 <a href=\"https://github.com/acl-dev/third_party\">https://github.com/acl-dev/third_party</a> 处下载；<br>另外，acl 数据库模块是采用动态加载方式加载数据库驱动的，所以使用者应将编译好的数据库动态库放置在合适的位置，并调用 <code>acl::db_handle::set_loadpath()</code> 设置数据库驱动动态库的全路径，以便于 acl 数据库模块内部可以使用该路径进行动态加载。</p>\n<h3 id=\"（七）、邮件-amp-mime模块\"><a href=\"#（七）、邮件-amp-mime模块\" class=\"headerlink\" title=\"（七）、邮件&amp;mime模块\"></a>（七）、邮件&amp;mime模块</h3><p>。。。</p>\n<ul>\n<li>微博：<a href=\"http://weibo.com/zsxxsz\">http://weibo.com/zsxxsz</a></li>\n<li>qq 群：242722074</li>\n</ul>\n"},{"title":"iQiYi使用网络协程编写高并发应用实践","date":"2020-06-05T05:08:24.000Z","_content":"\n# iQiYi使用网络协程编写高并发应用实践\n## 一、概述\n 在早期程序员为了支持多个用户并发访问服务应用，往往采用多进程方式，即针对每一个 TCP 网络连接创建一个服务进程。在 2000 年左右，比较流行使用 CGI 方式编写 Web 服务，当时人们用的比较多的 Web 服务器是基于多进程模式开发的 Apache1.3.x 系列，因为进程占用系统资源较多，所以人们开始使用多线程方式编写 Web 服务应用，因为线程占用的资源更少，这使单台服务器支撑的用户并发度提高了，但依然存在资源浪费的问题。因为在多进程或多线程编程方式下，均采用了阻塞通信方式，这会使得服务端的进程或线程因『等待』客户端的请求数据而变得『空闲』，而且在该空闲期间还不能做别的事情，白白浪费了操作系统的调度时间和内存资源。这种一对一的服务方式在广域网的环境下显示变得不够廉价，于是人们开始采用非阻塞网络编程方式来提升网络服务并发度，比较著名的 Web 服务器 Nginx 就是非阻塞服务的典型代表，另外还有象 Java Netty 这样的非阻塞网络开发库。  \n 非阻塞网络编程一直以高并发和高难度而著称，这种编程方式虽然有效的提升了服务器的利用率和处理性能，但却对广大程序员提出了较大挑战，因为非阻塞 IO 的编程方式往往会把业务逻辑分隔的支离破碎，需要在通信过程中记录大量的中间状态，而且还需要处理各种异常情况，最终带来的后果就是开发周期长、复杂度高，而且难于维护。\n阻塞式网络编程实现容易但并发度不高，非阻塞网络编程并发度高但编写难，针对这两种网络编程方式优缺点，人们提出了使用协程方式编写网络程序的思想，其实协程本身并不是一个新概念，早在2000年前 Windows NT 上就出现了『纤程』的 API，号称可以创建成千上万个纤程来处理业务任务，在 BSD Unix 上可以用来实现协程切换的 API <ucontext.h> 在 2002 年就已经存在了，当然另外用于上下文跳转的 API <setjmp.h> 出现的更早（1993年）。虽然协程的概念出现的较早，但人们终不能发现其广大的应用场景，象『longjmp』这些 API 多用在一些异常跳转上，如 Postfix（著名的邮件MTA）在处理网络异常时用其实现程序跳转。直到 Russ Cox 在 Go 语言中加入了协程（Goroutine）的功能，使用协程进行高并发网络编程才变得的简单易行。  \nRuss Cox 早在 2002 年就编写了一个简单的网络协程库 libtask（https://swtch.com/libtask/ ），代码量不多，却可以使我们比较清晰地看到『通过使网络 IO 协程化，使编写高并发网络程序变得如此简单』。  \n本文以爱奇艺开源的网络协程库（https://github.com/iqiyi/libfiber ）为例，讲解网络协程的设计原理、编程实践、性能优化等方面内容。\n\n## 二、网络协程基本原理\n\n**`网络协程`** 的 **`本质`** 是将应用层的阻塞式 IO 过程在底层转换成非阻塞 IO 过程，并通过程序运行栈的上下文切换使 **IO** 准备就绪的协程交替运行，从而达到以简单方式编写高并发网络程序的目的。既然网络协程的底层也是非阻塞IO过程，所以在网络在介绍网络协程基本原理前，我们先了解一下非阻塞网络通信的基本过程。\n\n### 2.1、网络非阻塞编程\n下面给出了网络非阻塞编程的常见设计方式：\n![aio_architecture](/img/aio_architecture.png)\n- 使用操作系统提供的多路复用事件引擎 API（select/poll/epoll/kqueue etc），将网络套接字的网络读写事件注册到事件引擎中；\n- 当套接字满足可读或可写条件时，事件引擎设置套接字对应的事件状态并返回给调用者；\n- 调用者根据套接字的事件状态分别『回调』对应的处理过程；\n- 对于大部分基于 TCP 的网络应用，数据的读写往往不是一次 IO 就能完成的，这样，对于一次会话过程就会有多次 IO 读写过程，在每次 IO 过程中都需要缓存读写的数据，直至本次数据会话完成。  \n\n下图以非阻塞读为例展示了整个异步非阻塞读及回调处理过程：  \n\n![nio_read](/img/nio_read.png)\n\n相对于阻塞式读的处理过程（循环读数据直至读完成或关闭），非阻塞读过程的确要复杂很多：\n- 一次完整的 IO 会话过程会被分割成多次的 IO 过程；\n- 每次 IO 过程需要缓存部分数据及当前会话的处理状态；\n- 要求相关的解析器（如：Json/Xml/Mime 解析器）最好能支持流式解析方式，否则就得需要读到完整数据后才能交给解析器去处理，当遇到业数据较大时就需要分配较大的连续内存块，势必造成系统的内存分配压力；\n- 因为当前绝大部分后台系统（如数据库、存储系统、缓存系统）所提供的客户端驱动都是阻塞式的，所以无法直接应用在非阻塞通信应用中，从而限制了非阻塞通信方式的应用场景；\n- 因为多次 IO 过程将应用的业务处理逻辑分割的支离破碎，大大增加了业务编写过程的复杂度，降低了开发效率，同时加大了后期的不易维护性。\n\n### 2.2、网络协程编程\n#### 2.2.1、几个概念\n在了解使用协程编写网络程序之前，需要先了解几个概念：\n- **最小调度单元：** 当前大部分操作系统的最小调度单元是线程，即在单核或多核 CPU 环境中，操作系统是以线程为基本调度单元的，操作系统负责将多个线程任务唤入唤出；\n- **上下文切换：** 当操作系统需要将某个线程挂起时，会将该线程在 CPU 寄存器中的栈指针、状态字等保存至该线程的内存栈中；当操作系统需要唤醒某个被挂起的线程时（重新放置在CPU中运行），会将该线程之前被挂起的栈指针重新置入 CPU 寄存器中，并恢复之前保留的，从而使该线程得以运行；通过这样的挂起与唤醒操作，便完成了不同线程间的上下文切换；\n- **并行与网络并发：** 并行是指同一『时刻』同时运行的任务数，并行任务数量取决于 CPU 核心数量；而网络并发是指在某一『时刻』网络连接的数量；类似于二八定律，在客户端与服务端保持 TCP 长连接时，大部分连接是空闲的，所以服务端只需响应少量活跃的网络连接即可，服务端采用多路复用技术，即使使用单核也可以支持 100K 个网络连接。\n\n#### 2.2.2、协程的切换过程\n前面提到操作系统进行任务调度的最小单元是线程，操作系统无法感知这些协程的存在，自然也就无法对其进行调度，因此存在于线程中的大量协程需要相互协作，合理地占用 CPU 时间片，在合适的运行点（如：网络阻塞点）主动让出 CPU，给其它协程提供运行的机会。  \n每个协程都会经历如下过程：  \n\n![fiber_running](/img/fiber_running.png)\n\n协程之间的切换一般可分为『星形切换』和『环形切换』，参照下图：\n![fiber_switch](/img/fiber_switch.png)\n\n当有大量的协程需要运行时，在『环形切换』模式下，前一个协程运行完毕后直接『唤醒』并切换至下一个协程，而无需象『星形切换』那样先切换至调度原点，再从调度原点来『唤醒』下一个协程；因为『环形切换』要比『星形切换』节省了一次上下文的切换过程，所以『环形切换』方式的切换效率更高。\n\n#### 2.2.3、网络过程协程化\n下图是使网络过程协程化的示意图：\n\n![fiber_schedule](/img/fiber_schedule.png)\n\n- 在网络协程库中，内部有一个缺省的 `IO调度协程`，其负责处理与网络 IO 相关的协程调度过程，故称之为『**IO 调度协程**』；\n- 每一个网络连接绑定一个套接字句柄，该套接字绑定一个协程；\n- 当对网络套接字进行读写操作时，将该套接字添加至 IO 调度协程的事件引擎中并设置读写事件，然后将该协程挂起；这样所有处于读写等待状态的网络协程都被挂起，且与之关联的网络套接字均由 IO 调度协程的事件引擎统一监控管理；\n- 当某些网络套接字满足可读或可写条件时，IO 调度协程的事件引擎返回这些套接字的状态，IO 调度协程找到与这些套接字绑定的协程对象，然后分别唤醒这些协程，使之依次运行；\n- IO 事件协程内部本身也是由系统事件引擎（如：Linux 下的 epoll 事件引擎）驱动的，其内部 IO 事件的驱动机制和上面介绍的非阻塞过程相似，当某个套接字句柄『准备就绪』时，IO 调度协程便将其所绑定的协程添加进协程调度队列中，待本次 IO 调度协程返回后，会依次运行协程调度队列里的所有协程。\n\n#### 2.2.4、网络协程示例\n下面给出一个使用协程方式编写的网络服务器程序，该程序位于：https://github.com/iqiyi/libfiber 。\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"fiber/lib_fiber.h\"\n#include \"patch.h\"  // 主要包含：SOCKET, socket_close(), socket_listen(), socket_accept()\nstatic size_t __stack_size  = 128000;  // 协程栈大小设为 128 KB 左右\n\nstatic void fiber_client(ACL_FIBER *fb, void *ctx) {\n    SOCKET fd = (int *) ctx;\n    char buf[8192];\n    free(ctx);\n    while (1) {\n        int ret = acl_fiber_recv(fd, buf, sizeof(buf), 0);  // 读客户端请求数据\n        if (ret == 0) {  // 说明网络连接关闭\n            break;\n        } else if (ret < 0) {\n            if (acl_fiber_last_error() == FIBER_EINTR) {\n                continue;\n            }\n            break;\n        }\n        if (acl_fiber_send(fd, buf, ret, 0) < 0) {  // 回写数据\n            break;\n        }\n    }\n    socket_close(fd);  // 关闭套接字\n}\nstatic void fiber_accept(ACL_FIBER *fb, void *ctx) {\n    const char *addr = (const char *) ctx;\n    SOCKET lfd = socket_listen(\"127.0.0.1\", 9001);  // 创建监听套接字\n    assert(lfd >= 0);\n    for (;;) {\n        SOCKET *pfd, cfd = socket_accept(lfd);  // 等待客户端连接\n        if (cfd == -1) {\n            printf(\"accept error %s\\r\\n\", acl_fiber_last_serror());\n            break;\n        }\n        pfd  = (int *) malloc(sizeof(SOCKET));\n        *pfd = cfd;\n        acl_fiber_create(fiber_client, pfd, __stack_size);  // 创建协程处理连接请求\n    }\n    acl_fiber_schedule_stop();  // 停止协程调度器\n}\nint main(void) {\n    // 指定 IO 事件引擎类型，在 Linux 下将采用 epoll\n    int event_mode = FIBER_EVENT_KERNEL;\n\n    // 创建网络监听协程，用来接收客户端连接请求\n    acl_fiber_create(fiber_accept, NULL, __stack_size);\n\n    // 开始运行协程调度器\n    acl_fiber_schedule_with(event_mode);\n    return 0;\n}\n```\n该网络协程服务器程序处理流程为：\n- 创建一个监听协程，其『堵』在  `accept()` 调用上，等待客户端连接；\n- 启动协程调度器，开始运行新创建的监听协程；\n- 监听协程每当接收一个客户端连接，便创建一个客户端协程单独处理该网络连接，然后监听协程继续等待下一个客户端连接；\n- 客户端协程以『阻塞』方式读写网络连接数据；\n- 客户端连接处理完毕，关闭连接，并退出协程。\n\n从该例子可以看出，网络协程的处理过程都是顺序方式，比较符合人的思维模式；我们很容易将该例子改成线程方式，处理逻辑和协程方式相似，但协程方式更加轻量、占用资源更少，并发处理能力更强。  \n简单的表面必定隐藏着复杂的底层设计，因为网络协程过程在底层还是需要转为『非阻塞』处理过程，只是使用者并未感知而已。\n\n## 三、网络协程核心设计要点\n在介绍了网络协程的基本设计原理后，本章节主要介绍 `libfiber` 网络协程的核心设计要点，为网络协程应用实践化提供了基本的设计思路。\n\n### 3.1、协程调度\nlibfiber 采用了单线程调度方式，主要是为了避免设计的复杂性及效率上的影响。如果设计成多线程调度模式，则必须首先需要考虑：\n- 多核环境下 CPU 缓存亲和性：因为 CPU 本身有高效的多级缓存，虽然 CPU 多级缓存容量较内存小的多，但访问效率却远高于内存，单线程调度方式下，可以方便编译器有效地进行 CPU 缓存使用优化，使运行指令和共享数据尽可能放置在 CPU 缓存中，而如果采用多线程调度方式，多个线程间共享的数据就可能使 CPU 缓存失效，会造成调度线程越多，协程的运行效率越低的问题；\n- 多线程分配任务时的同步问题：当多个线程需要从公共协程任务资源中获取协程任务时，必然需要采用增加『锁』保护机制，一旦产生大量的『锁』冲突，则势必会造成运行性能的严重损耗；\n- 事件引擎操作优化：下面会介绍在单线程调度模式下的事件引擎操作优化，在多线程调度则很难进行如此优化。\n\n当然，单线程调度也需解决如下问题：\n- 如何有效地使用多核：在单线程调度方式下，该线程内的多个协程在运行时仅能使用单核，这显示是不合理的，解决方案为：\n  - 启动多个进程，每个进程运行一个线程;\n  - 同一进程内启动多个线程，每个线程运行独立的协程调度过程；\n- 多个线程之间的资源共享：因为协程调度是不跨线程的，在设计协程互斥锁时需要考虑：\n  - 协程锁需要支持『同一线程内的协程之间、不同线程的协程之间、协程线程与非协程线程之间』的互斥；\n  - 网络连接池的线程隔离机制，即需要为每个线程建立各自独立的连接池，防止连接对象在不同线程的协程之间共享，否则便会造成同一网络连接在不同线程的协程之间使用，破坏单线程调度规则；\n- 需要防止线程内的某个协程『疯狂』占用 CPU 资源，导致本线程内的其它协程得不到运行的机会，虽然此类问题在多线程调度时也会造成问题，但显然在单线程调度时造成的后果更为严重。\n\n### 3.2、协程事件引擎设计\n#### 3.2.1、跨平台性\nlibfiber 的事件引擎支持现在主流的操作系统，从而为 libfiber 的跨平台特性提供了有力的支撑，下面为 libfiber 事件引擎所支持的平台：\n- **Linux：** sekect/poll/epoll/io_uring，epoll 为 Linux 内核级事件引擎，采用事件触发机制，不象 select/poll 的轮循方式，所以 epoll 在处理大并发网络连接时运行效率更高；而 io_uring 引擎是在内核5.1以后出现的新的事件引擎，由 Facebook 的 Jens Axboe(IO 压测工作 fio 作者) 设计完成，该引擎为真正的异步 IO 模型（为 IO 完成模型），统一了网络 IO 与文件 IO 过程（不象 epoll 仅支持网络，因为其是事件通知方式，无法预知 IO 何时完成）；\n- **BSD/MacOS：** select/poll/kqueue，kqueue 也为内核级事件引擎，在大并发环境下具有更高的性能；\n- **Windows：** select/poll/iocp/Windows 窗口消息，其中 iocp 为 Windows 平台下的内核级高效事件引擎；libfiber 支持采用界面消息引擎做为底层的事件引擎，这样在编写 Windows 界面程序的网络模块时便可以使用协程方式了，之前人们在 Windows 平台编写界面程序的网络模块时，一般采用以下两种方式：\n  - 采用非阻塞方式，网络模块与界面模块在同一线程中；\n  - 将网络模块放到独立的线程中运行，运行结果通过界面消息『传递』到界面线程中；\n\n现在 libfiber 支持 Windows 界面消息引擎，我们就可以在界面线程中直接创建网络协程，直接进行阻塞式网络编程了。(Windows 界面网络协程示例：https://github.com/iqiyi/libfiber/tree/master/samples/WinEchod )\n\n#### 3.2.2、运行效率\n大家在谈论网络协程程序的运行效率时，往往只重视协程的切换效率，但却忽视了事件引擎对于性能影响的重要性，虽然现在很网络协程库所采用的事件引擎都是内核级的，但仍需要合理使用才能发挥其最佳性能。 \n\n在使用 libfiber 的早期版本编译网络协程服务程序时，虽然在 Linux 平台上也是采用了 `epoll` 事件引擎，但在对网络协程服务程序进行性能压测（使用用系统命令 『`# perf top -p pid`』 观察运行状态）时，却发现 `epoll_ctl` API 占用了较高的 CPU，分析原因是 `epoll_ctl` 使用次数过多导致的：因为 `epoll_ctl` 内部在对套接字句柄进行添加、修改或删除事件操作时，需要先通过红黑树的查找算法找到其对应的内部套接字对象（红黑树的查找效率并不是\bO(1)的），如果 epoll_ctl 的调用次数过多必然会造成 CPU 的占用较高。 \n\n因为 TCP 数据在传输时是流式的，这就意味着数据接收者经常需要多次读操作才能获得完整的数据，反映到网络协程处理流程上如下图所示：\n\n![fiber_io_switch](/img/fiber_io_switch.png)\n\n仔细观察上面处理流程，可以发现在图中的标注4（唤醒协程）和标注5（挂起协程）之间的两个事件操作：`标注2取消读事件` 与 `标注3注册读事件`，再结合 `标注1注册读事件`，完全可以把注2和标注3处的两个事件取消，因为标注1至标注3的目标是 `注册读事件`。最后，通过缓存事件操作的中间状态，合并中间态的事件操作过程，使 libfiber 的 IO 处理性能提升 20% 左右。\n\n下图给出了采用 libfiber 编写的回显服务器与采用其它网络协程库编写的回显服务器的性能对比（对比单核条件下的 IO 处理能力）：\n\n![benchmark](/img/benchmark.png)\n\n在 libfiber 中之所以可以针对中间的事件操作过程进行合并处理，主要是因为 libfiber 的调度过程是单线程模式的，如果想要在多线程调度器中实现事件过程的合并处理则难度就要大的多：当套接字所绑定的协程因IO可读被唤醒时，假设不取消该套接字的读事件，则该协程被某个线程『拿走』后，内核又因接收到新数据而通知协程调度器，此时协程调度器就不知该如何处理了。\n\n### 3.3、协程同步机制\n#### 3.3.1、单一线程内部的协程互斥\n对于象 libfiber 这样的采用单线程调度方案的协程库而言，如果互斥加锁过程仅限于同一个调度线程内部，则实现一个协程互斥锁是比较容易的，下图为 libfiber 中单线程内部使用的协程互斥锁的处理流程图（参考源文件：fiber_lock.c）：\n\n![fiber_lock](/img/fiber_lock.png)\n\n同一线程内的协程在等待锁资源时，该协程将被挂起并被加入锁等待队列中，当加锁协程解锁后会唤醒锁等待队列中的第一个协程，单线程内部的协程互斥锁正是利用了协程的挂起和唤醒机制。  \n\n#### 3.3.2、多线程之间的协程互斥\n虽然 libfiber 的协程调度器是单线程模式的，但却可以启动多个线程使每个线程运行独立的协程调度器，如果一些资源需要在多个线程中的协程间共享，则就需要有一把可以跨线程使用的协程互斥锁。在将 libfiber 应用在多线程的简单场景时，也许直接使用系统提供的线程锁就可以解决很多问题，但线程锁当遇到如下场景时就显得无能为力：\n\n![dead_lock](/img/dead_lock.png)\n\n上述显示了系统线程互斥锁在 libfiber 使用时遇到的死锁问题：\n- 线程A 中的协程A1 成功对线程锁1加锁；\n- 线程B 中的协程B2 对线程锁2成功加锁；\n- 当线程A 中的协程A2 想要对线程锁2 加锁而阻塞时，则会使线程A 的协程调度器阻塞，从而导致整个线程A 中的所有协程被系统挂起；同样，线程B 也会因协程B1 阻塞在线程锁1 上而被阻塞；最终造成了死锁问题。\n\n产生上述死锁的根本原因是单线程调度机制以及操作系统的最小调度单元是线程，系统对于协程是无感知的。因此，在 libfiber 中专门设计了可用于在线程的协程之间使用的事件互斥锁（源码参见 fiber_event.c, 当前最新的是 fiber_mutex.c，性能更好且占用资源更少），其设计原理如下：\n\n![fiber_event](/img/fiber_event.png)\n\n该可用于在线程之间的协程进行互斥的事件互斥锁的处理流程为：\n- 协程B（假设其属于线程b）已经对事件锁加锁后；\n- 协程A（假设其属于线程a）想对该事件锁加锁时，对原子数加锁失败后创建IO管道，将IO读管道置入该事件锁的IO读等待队列中，此时协程A被挂起；\n- 当协程B 对事件锁解锁时，会首先获得协程A 的读管道，解锁后再向管道中写入消息，从而唤醒协程A；\n- 协程A 被唤醒后读取管道中的消息，然后再次尝试对事件锁中的原子数加锁，如加速成功便可以继续运行，否则会再次进入睡眠状态（有可能此事件锁又被其它协程提前抢占）。\n\n在上述事件锁的加/解锁处理流程中，使用原子数和IO管道的好处是：\n- 通过使用原子数可以使协程快速加锁空闲的事件锁，原子数在多线程或协程环境中的行为相同的，可以保证安全性；\n- 当锁被占用时，通过等待管道IO 方式使当前协程挂起，而又不会干扰该协程所属线程的正常运行；\n- 在 Linux 平台上可以使用 eventfd 代替管道，占用资源更少。\n\n#### 3.3.3、协程条件变量\n我们在使用线程编程时，都知道线程条件变量的价值：在线程之间传递消息时往往需要组合线程条件变量和线程锁。因此，在 libfiber 中同样设计了协程条件变量（源码见 fiber_cond.c），通过组合使用 libfiber 中的协程事件锁（fiber_event.c，目前使用 fiber_mutex.c）和协程条件变量，用户可以编写出用于在线程之间、线程与协程之间、线程内的协程之间、线程间的协程之间进行消息传递的消息队列。下图为使用 libfiber 中协程条件变量时的交互过程：\n\n![fiber_cond](/img/fiber_cond.png)\n\n这是一个典型的 `生产者-消费者` 问题，通过组合使用协程条件变量和事件锁可以轻松实现。\n\n#### 3.3.4、协程信号量\n使用网络协程库编写的网络服务很容易实现高并发功能，可以接入大量的客户端连接，但是后台系统（如：数据库）却未必支持高并发，即使是支持高并的缓存系统（如 Redis）当连接数达高时性能也会下降，所以协程服务模块不能将前端的并发压力传递到后端，给后台系统造成很大的压力，我们需要提供一种高并发连接卸载机制，以保证后台系统可以平稳地运行，在 libfiber 中提供了协程信号量（源码见：fiber_semc.c），下面是使用 libfiber 中的协程信号量对于后台系统的并发连接卸载保护示意图：\n\n![fiber_sem](/img/fiber_sem.png)\n\n当有大量协程需要访问后台系统时，通过协程信号量将大量的协程『挡在外面』，只允许部分协程与后端系统建立连接。  \n**注：** 目前 libfiber 的协程信号量仅用在同一线程内部，还不能跨线程使用，要想在多线程环境中使用，需在每个线程内部为协程创建独立的协程信号量。\n\n### 3.4、协程共享栈\n协程网络编程相对于非阻塞网络编程简单太多，大大方便了开发者编写支持高并发的服务程序；但对于有栈协程，意味着每个协程都要占用一段内存用来存放协程栈，所以并发越高，内存占用越多也成为有栈协程的一大弊端，但仔细分析函数压栈出栈及协程挂起唤醒过程，我们会发现在协程挂起时所占用的栈空间大小要远小于协程实际运行过程中占用的最大栈空间大小（考虑到应用业务逻辑的复杂性，可能会存在大量的函数及变量压栈过程，所以占用的栈空间会比较大），而在一个 libfiber 线程空间中只有一个运行栈，所以只需保证一个较大的运行栈空间即可，当协程被挂起时只需将其栈从运行栈中拷贝并保存出来（这个栈空间相对要小一些），而被挂起的协程被唤醒时，只需将其保存的栈拷贝到线程的运行栈上即可。在实践中这的确可以大幅减少高并发时的内存使用，虽然进行栈拷贝时会耗费一些时间，但整体影响并不太大。\n\n相对于栈拷贝时的时间损耗，在使用共享栈方式编程时有一点需要特别注意：创建在栈上的变量不能在协程之间或协程与线程之间共享，即是说，一个协程 F1 中的变量 A 传递给另一个协程 F2，并等待 F2 处理后返回，此时的 A 变量不能被创建在 F1 的栈上，因为运行栈在由 F1 切换到 F2 时，变量 A 的地址空间“暂时消失了”，此时变成了 F2 的栈空间，如果该变量在 F2 中继续被使用的话，就会存在地址非法使用的问题；解决变量在协程间共享的方法是将变量创建在堆上（即用 malloc 或 new 创建）。\n\n注：共享栈的想法最初应该是在腾讯的 libco 中提出的，应该也是为了解决大并发时的内存占用问题。\n\n### 3.5、域名解析\n网络协程库既然面向网络，自然离不开域名的协程化支持，现在很多网络协程库的设计者往往忽视了这一点，有些网络协程库在使用系统 API 进行域名解析时为了防止阻塞协程调度器，将域名解析过程（即调用 gethostbyname/getaddrinfo）扔给独立的线程去执行，当调用系统 API 进行域名解析并发量较大时必然会造成很多线程资源被占用。在 libfiber 早期通过集成第三方 dns 源码，实现了域名解析过程的协程化，基本满足了大部分服务端应用系统对于域名解析的需求；后来因为跨平台性及代码安全性的需要，在 libfiber 中实现了与域名解析相关的 DNS 协议，替换了第三方 DNS 库。\n\n### 3.6、Hook 系统 API\n相对于网络协程的出现时间，很多网络库很早就存在了，并且大部分已有的网络库都是阻塞式的，要改造这些网络库使之协程化的成本是非常巨大的，我们不可能采用协程方式将这些网络库重新实现一遍，目前一个广泛采用的方案是 Hook 与 IO 相关的系统中 API，在 Unix 平台上 Hook 系统 API 相对简单，在初始化时，先加载并保留系统 API 的原始地址，然后编写一个与系统 API 函数名相同且参数也相同的函数，将这段代码与应用代码一起编译，则编译器会优先使用这些 Hook API，下面的代码给出了在 Unix 平台上 Hook 系统 API 的简单示例：\n```C\ntypedef ssize_t (*read_fn)(int, void *, size_t);\nstatic read_fn __sys_read = NULL;\n\nstatic void hook_init(void) {\n    __sys_read = (read_fn) dlsym(RTLD_NEXT, \"read\");\n    assert(__sys_read);\n}\n\nssize_t read(int fd, void *buf, size_t count) {\n    if (__sys_read == NULL) {\n        hook_init();\n    }\n    return __sys_read(fd, buf, count);\n}\n```\n在 libfiber 中 hook 了大部分与 IO 及网络相关的系统 API，下面列出 libfiber 所 Hook 的系统 API：\n- **IO 相关 API**\n  - **读 API：** read/readv/recv/recvfrom/recvmsg；\n  - **写 API：** write/writev/send/sendto/sendmsg/sendfile64；\n- **网络相关 API**\n  - **套接字 API：** socket/listen/accept/connect；\n  - **事件引擎 API：** select/poll，epoll: epoll_create, epoll_ctl, epoll_wait；\n  - **域名解析 API：** gethostbyname/gethostbyname_r, getaddrinfo/freeaddrinfo。\n\n通过 Hook API 方式，libfiber 已经可以使 Mysql 客户端库、一些 HTTP 通信库及 Redis 客户端库的网络通信部分协程化，这样在使用网络协程编写服务端应用程序时，大大降低了编程复杂度及改造成本。\n\n为了在 Windows 平台上 Hook IO API，libfiber 集成了微软的一个开源库 detours，但该库是用 C++ 编写的，所以只能集成在 libfiber 的 c++ 模块中，即用户在使用时只能通过使用 libfiber c++ 库达到 Hook 系统 IO API 的目的。\n\n## 四、爱奇艺核心业务的协程实践\n### 4.1、CDN 核心模块使用协程\n在爱奇艺的自建 CDN 系统中，作为数据回源及本地缓存的核心软件，奇迅承担了重要角色，该模块采用多线程多协程的软件架构设计，如下所示：\n\n![qixun](/img/qixun.png)\n\n奇迅回源架构设计的特点总结如下：\n\n特性|说明\n------|--------------------------------------------------\n高并发|采用网络协程方式，支持高并发接入，同时简化程序设计\n高性能|采用线程池 + 协程 + 连接池 + 内存池技术，提高业务处理性能\n高吞吐|采用磁盘内存映射及零拷贝技术，提升磁盘及网络 IO 吞吐能力\n低回源|合并相同请求，支持部分回源及部分缓存，大大降低回源带宽\n开播快|采用流式数据读取方式，提升视频开播速度\n可扩展|模块化分层设计，易于扩展新功能\n易维护|采用统一服务器编程框架，易管理，好维护\n\n奇迅的前后端通信模块均采用网络协程方式，分为前端连接接入层和后端下载任务层，为了有效地使用多核，前后端模块均启动多个线程（每个线程运行一个独立的协程调度器）；对于前端连接接入模块，由于采用协程方式，所以：\n- 支持更高的客户端并发连接；\n- 允许更多慢连接的存在，而不会消耗更多秕资源；\n- 更有助于客户端与奇迅之间保持长连接，提升响应性能。\n\n对于后端下载模块，由于采用协程方式，在数据回源时允许建立更多的并发连接去多个源站下载数据，从而获得更快的下载速度；同时，为了节省带宽，奇迅采用合并回源策略，即当前端多个客户端请求同一段数据时，下载模块将会合并相同的请求，向源站发起一份数据请求，在合并回源请求过程中，因数据共享原因，必然存在如 “3.3.2、多线程之间的协程互斥”章节所提到的多个线程之间的协程同步互斥的需求，通过使用 libfiber 中的事件锁完美地解决了一这需求（其实，当初事件锁就是为了满足奇迅的这一需求而设计编写）。\n\n### 4.2、高性能 DNS 模块使用协程\nDNS 做为互联网的基础设施，在整个互联网中发挥着举足轻重的作用，爱奇艺为了满足自身业务的发展需要，自研了高性能 DNS（简称 HPDNS），该 DNS 的软件架构如下图所示：\n\n![hpdns](/img/hpdns.png)\n\nHPDNS 服务的特点如下：\n\n<style>\ntable th:first-of-type {\n\twidth: 50px;\n}\n</style>\n优点|说明\n-|-\n高性能|启用 Linux 3.0 内核的 REUSEPORT 功能，提升多线程并行收发包的能力\n&nbsp;|采用 Linux 3.0 内核的 recvmmsg/sendmmsg API，提升单次 IO 数据包收发能力\n&nbsp;|采用内存预分配策略，减少内存动态分配/释放时的“锁”冲突\n&nbsp;|针对 TCP 服务模式，采用网络协程框架，最大化 TCP 并发怎能能力\n高可用|采用RCU（Read Copy Update）方式更新视图数据及配置项，无需停止服务，且不影响性能\n&nbsp;|网卡 IP 地址变化自动感知（即可自动添加新 IP 或摘除老IP而不必停止服务）\n&nbsp;|采用 Keepalived 保证服务高可用\n易管理|由 master 服务管理模块管理 DNS 进程，控制 DNS 进程的启动、停止、重读配置/数据、异常重启及异常报警等\n\n由于 DNS 协议要求 DNS 服务端需要同时支持 UDP 及 TCP 两种通信方式，除了要求 UDP 模块具备高性能外，对 TCP 模块也要求支持高并发及高性能，该模块的网络通信部分使用 libfiber 编写，从而支持更高的并发连接，同时具备更高的性能，又因启用多个线程调度器，从而可以更加方便地使用多核。\n\n## 五、总结\n本文讲述了爱奇艺开源项目 libfiber 网络协程库的设计原理及核心设计要点，描述了 libfiber 的设计特点及优缺点，方便读者了解网络协程的设计原理及运行机制，做到知其然更知其所以然；本文还从爱奇艺自身的项目实践出发，总结了在应用网络协程编程时遇到的问题及解决方案，使读者能够更加全面地了解编写网络协程类应用的注意事项。\n","source":"_posts/about_fiber.md","raw":"---\ntitle: iQiYi使用网络协程编写高并发应用实践\ndate: 2020-06-05 13:08:24\ntags: 协程编程\ncategories: 协程编程\n---\n\n# iQiYi使用网络协程编写高并发应用实践\n## 一、概述\n 在早期程序员为了支持多个用户并发访问服务应用，往往采用多进程方式，即针对每一个 TCP 网络连接创建一个服务进程。在 2000 年左右，比较流行使用 CGI 方式编写 Web 服务，当时人们用的比较多的 Web 服务器是基于多进程模式开发的 Apache1.3.x 系列，因为进程占用系统资源较多，所以人们开始使用多线程方式编写 Web 服务应用，因为线程占用的资源更少，这使单台服务器支撑的用户并发度提高了，但依然存在资源浪费的问题。因为在多进程或多线程编程方式下，均采用了阻塞通信方式，这会使得服务端的进程或线程因『等待』客户端的请求数据而变得『空闲』，而且在该空闲期间还不能做别的事情，白白浪费了操作系统的调度时间和内存资源。这种一对一的服务方式在广域网的环境下显示变得不够廉价，于是人们开始采用非阻塞网络编程方式来提升网络服务并发度，比较著名的 Web 服务器 Nginx 就是非阻塞服务的典型代表，另外还有象 Java Netty 这样的非阻塞网络开发库。  \n 非阻塞网络编程一直以高并发和高难度而著称，这种编程方式虽然有效的提升了服务器的利用率和处理性能，但却对广大程序员提出了较大挑战，因为非阻塞 IO 的编程方式往往会把业务逻辑分隔的支离破碎，需要在通信过程中记录大量的中间状态，而且还需要处理各种异常情况，最终带来的后果就是开发周期长、复杂度高，而且难于维护。\n阻塞式网络编程实现容易但并发度不高，非阻塞网络编程并发度高但编写难，针对这两种网络编程方式优缺点，人们提出了使用协程方式编写网络程序的思想，其实协程本身并不是一个新概念，早在2000年前 Windows NT 上就出现了『纤程』的 API，号称可以创建成千上万个纤程来处理业务任务，在 BSD Unix 上可以用来实现协程切换的 API <ucontext.h> 在 2002 年就已经存在了，当然另外用于上下文跳转的 API <setjmp.h> 出现的更早（1993年）。虽然协程的概念出现的较早，但人们终不能发现其广大的应用场景，象『longjmp』这些 API 多用在一些异常跳转上，如 Postfix（著名的邮件MTA）在处理网络异常时用其实现程序跳转。直到 Russ Cox 在 Go 语言中加入了协程（Goroutine）的功能，使用协程进行高并发网络编程才变得的简单易行。  \nRuss Cox 早在 2002 年就编写了一个简单的网络协程库 libtask（https://swtch.com/libtask/ ），代码量不多，却可以使我们比较清晰地看到『通过使网络 IO 协程化，使编写高并发网络程序变得如此简单』。  \n本文以爱奇艺开源的网络协程库（https://github.com/iqiyi/libfiber ）为例，讲解网络协程的设计原理、编程实践、性能优化等方面内容。\n\n## 二、网络协程基本原理\n\n**`网络协程`** 的 **`本质`** 是将应用层的阻塞式 IO 过程在底层转换成非阻塞 IO 过程，并通过程序运行栈的上下文切换使 **IO** 准备就绪的协程交替运行，从而达到以简单方式编写高并发网络程序的目的。既然网络协程的底层也是非阻塞IO过程，所以在网络在介绍网络协程基本原理前，我们先了解一下非阻塞网络通信的基本过程。\n\n### 2.1、网络非阻塞编程\n下面给出了网络非阻塞编程的常见设计方式：\n![aio_architecture](/img/aio_architecture.png)\n- 使用操作系统提供的多路复用事件引擎 API（select/poll/epoll/kqueue etc），将网络套接字的网络读写事件注册到事件引擎中；\n- 当套接字满足可读或可写条件时，事件引擎设置套接字对应的事件状态并返回给调用者；\n- 调用者根据套接字的事件状态分别『回调』对应的处理过程；\n- 对于大部分基于 TCP 的网络应用，数据的读写往往不是一次 IO 就能完成的，这样，对于一次会话过程就会有多次 IO 读写过程，在每次 IO 过程中都需要缓存读写的数据，直至本次数据会话完成。  \n\n下图以非阻塞读为例展示了整个异步非阻塞读及回调处理过程：  \n\n![nio_read](/img/nio_read.png)\n\n相对于阻塞式读的处理过程（循环读数据直至读完成或关闭），非阻塞读过程的确要复杂很多：\n- 一次完整的 IO 会话过程会被分割成多次的 IO 过程；\n- 每次 IO 过程需要缓存部分数据及当前会话的处理状态；\n- 要求相关的解析器（如：Json/Xml/Mime 解析器）最好能支持流式解析方式，否则就得需要读到完整数据后才能交给解析器去处理，当遇到业数据较大时就需要分配较大的连续内存块，势必造成系统的内存分配压力；\n- 因为当前绝大部分后台系统（如数据库、存储系统、缓存系统）所提供的客户端驱动都是阻塞式的，所以无法直接应用在非阻塞通信应用中，从而限制了非阻塞通信方式的应用场景；\n- 因为多次 IO 过程将应用的业务处理逻辑分割的支离破碎，大大增加了业务编写过程的复杂度，降低了开发效率，同时加大了后期的不易维护性。\n\n### 2.2、网络协程编程\n#### 2.2.1、几个概念\n在了解使用协程编写网络程序之前，需要先了解几个概念：\n- **最小调度单元：** 当前大部分操作系统的最小调度单元是线程，即在单核或多核 CPU 环境中，操作系统是以线程为基本调度单元的，操作系统负责将多个线程任务唤入唤出；\n- **上下文切换：** 当操作系统需要将某个线程挂起时，会将该线程在 CPU 寄存器中的栈指针、状态字等保存至该线程的内存栈中；当操作系统需要唤醒某个被挂起的线程时（重新放置在CPU中运行），会将该线程之前被挂起的栈指针重新置入 CPU 寄存器中，并恢复之前保留的，从而使该线程得以运行；通过这样的挂起与唤醒操作，便完成了不同线程间的上下文切换；\n- **并行与网络并发：** 并行是指同一『时刻』同时运行的任务数，并行任务数量取决于 CPU 核心数量；而网络并发是指在某一『时刻』网络连接的数量；类似于二八定律，在客户端与服务端保持 TCP 长连接时，大部分连接是空闲的，所以服务端只需响应少量活跃的网络连接即可，服务端采用多路复用技术，即使使用单核也可以支持 100K 个网络连接。\n\n#### 2.2.2、协程的切换过程\n前面提到操作系统进行任务调度的最小单元是线程，操作系统无法感知这些协程的存在，自然也就无法对其进行调度，因此存在于线程中的大量协程需要相互协作，合理地占用 CPU 时间片，在合适的运行点（如：网络阻塞点）主动让出 CPU，给其它协程提供运行的机会。  \n每个协程都会经历如下过程：  \n\n![fiber_running](/img/fiber_running.png)\n\n协程之间的切换一般可分为『星形切换』和『环形切换』，参照下图：\n![fiber_switch](/img/fiber_switch.png)\n\n当有大量的协程需要运行时，在『环形切换』模式下，前一个协程运行完毕后直接『唤醒』并切换至下一个协程，而无需象『星形切换』那样先切换至调度原点，再从调度原点来『唤醒』下一个协程；因为『环形切换』要比『星形切换』节省了一次上下文的切换过程，所以『环形切换』方式的切换效率更高。\n\n#### 2.2.3、网络过程协程化\n下图是使网络过程协程化的示意图：\n\n![fiber_schedule](/img/fiber_schedule.png)\n\n- 在网络协程库中，内部有一个缺省的 `IO调度协程`，其负责处理与网络 IO 相关的协程调度过程，故称之为『**IO 调度协程**』；\n- 每一个网络连接绑定一个套接字句柄，该套接字绑定一个协程；\n- 当对网络套接字进行读写操作时，将该套接字添加至 IO 调度协程的事件引擎中并设置读写事件，然后将该协程挂起；这样所有处于读写等待状态的网络协程都被挂起，且与之关联的网络套接字均由 IO 调度协程的事件引擎统一监控管理；\n- 当某些网络套接字满足可读或可写条件时，IO 调度协程的事件引擎返回这些套接字的状态，IO 调度协程找到与这些套接字绑定的协程对象，然后分别唤醒这些协程，使之依次运行；\n- IO 事件协程内部本身也是由系统事件引擎（如：Linux 下的 epoll 事件引擎）驱动的，其内部 IO 事件的驱动机制和上面介绍的非阻塞过程相似，当某个套接字句柄『准备就绪』时，IO 调度协程便将其所绑定的协程添加进协程调度队列中，待本次 IO 调度协程返回后，会依次运行协程调度队列里的所有协程。\n\n#### 2.2.4、网络协程示例\n下面给出一个使用协程方式编写的网络服务器程序，该程序位于：https://github.com/iqiyi/libfiber 。\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <assert.h>\n#include \"fiber/lib_fiber.h\"\n#include \"patch.h\"  // 主要包含：SOCKET, socket_close(), socket_listen(), socket_accept()\nstatic size_t __stack_size  = 128000;  // 协程栈大小设为 128 KB 左右\n\nstatic void fiber_client(ACL_FIBER *fb, void *ctx) {\n    SOCKET fd = (int *) ctx;\n    char buf[8192];\n    free(ctx);\n    while (1) {\n        int ret = acl_fiber_recv(fd, buf, sizeof(buf), 0);  // 读客户端请求数据\n        if (ret == 0) {  // 说明网络连接关闭\n            break;\n        } else if (ret < 0) {\n            if (acl_fiber_last_error() == FIBER_EINTR) {\n                continue;\n            }\n            break;\n        }\n        if (acl_fiber_send(fd, buf, ret, 0) < 0) {  // 回写数据\n            break;\n        }\n    }\n    socket_close(fd);  // 关闭套接字\n}\nstatic void fiber_accept(ACL_FIBER *fb, void *ctx) {\n    const char *addr = (const char *) ctx;\n    SOCKET lfd = socket_listen(\"127.0.0.1\", 9001);  // 创建监听套接字\n    assert(lfd >= 0);\n    for (;;) {\n        SOCKET *pfd, cfd = socket_accept(lfd);  // 等待客户端连接\n        if (cfd == -1) {\n            printf(\"accept error %s\\r\\n\", acl_fiber_last_serror());\n            break;\n        }\n        pfd  = (int *) malloc(sizeof(SOCKET));\n        *pfd = cfd;\n        acl_fiber_create(fiber_client, pfd, __stack_size);  // 创建协程处理连接请求\n    }\n    acl_fiber_schedule_stop();  // 停止协程调度器\n}\nint main(void) {\n    // 指定 IO 事件引擎类型，在 Linux 下将采用 epoll\n    int event_mode = FIBER_EVENT_KERNEL;\n\n    // 创建网络监听协程，用来接收客户端连接请求\n    acl_fiber_create(fiber_accept, NULL, __stack_size);\n\n    // 开始运行协程调度器\n    acl_fiber_schedule_with(event_mode);\n    return 0;\n}\n```\n该网络协程服务器程序处理流程为：\n- 创建一个监听协程，其『堵』在  `accept()` 调用上，等待客户端连接；\n- 启动协程调度器，开始运行新创建的监听协程；\n- 监听协程每当接收一个客户端连接，便创建一个客户端协程单独处理该网络连接，然后监听协程继续等待下一个客户端连接；\n- 客户端协程以『阻塞』方式读写网络连接数据；\n- 客户端连接处理完毕，关闭连接，并退出协程。\n\n从该例子可以看出，网络协程的处理过程都是顺序方式，比较符合人的思维模式；我们很容易将该例子改成线程方式，处理逻辑和协程方式相似，但协程方式更加轻量、占用资源更少，并发处理能力更强。  \n简单的表面必定隐藏着复杂的底层设计，因为网络协程过程在底层还是需要转为『非阻塞』处理过程，只是使用者并未感知而已。\n\n## 三、网络协程核心设计要点\n在介绍了网络协程的基本设计原理后，本章节主要介绍 `libfiber` 网络协程的核心设计要点，为网络协程应用实践化提供了基本的设计思路。\n\n### 3.1、协程调度\nlibfiber 采用了单线程调度方式，主要是为了避免设计的复杂性及效率上的影响。如果设计成多线程调度模式，则必须首先需要考虑：\n- 多核环境下 CPU 缓存亲和性：因为 CPU 本身有高效的多级缓存，虽然 CPU 多级缓存容量较内存小的多，但访问效率却远高于内存，单线程调度方式下，可以方便编译器有效地进行 CPU 缓存使用优化，使运行指令和共享数据尽可能放置在 CPU 缓存中，而如果采用多线程调度方式，多个线程间共享的数据就可能使 CPU 缓存失效，会造成调度线程越多，协程的运行效率越低的问题；\n- 多线程分配任务时的同步问题：当多个线程需要从公共协程任务资源中获取协程任务时，必然需要采用增加『锁』保护机制，一旦产生大量的『锁』冲突，则势必会造成运行性能的严重损耗；\n- 事件引擎操作优化：下面会介绍在单线程调度模式下的事件引擎操作优化，在多线程调度则很难进行如此优化。\n\n当然，单线程调度也需解决如下问题：\n- 如何有效地使用多核：在单线程调度方式下，该线程内的多个协程在运行时仅能使用单核，这显示是不合理的，解决方案为：\n  - 启动多个进程，每个进程运行一个线程;\n  - 同一进程内启动多个线程，每个线程运行独立的协程调度过程；\n- 多个线程之间的资源共享：因为协程调度是不跨线程的，在设计协程互斥锁时需要考虑：\n  - 协程锁需要支持『同一线程内的协程之间、不同线程的协程之间、协程线程与非协程线程之间』的互斥；\n  - 网络连接池的线程隔离机制，即需要为每个线程建立各自独立的连接池，防止连接对象在不同线程的协程之间共享，否则便会造成同一网络连接在不同线程的协程之间使用，破坏单线程调度规则；\n- 需要防止线程内的某个协程『疯狂』占用 CPU 资源，导致本线程内的其它协程得不到运行的机会，虽然此类问题在多线程调度时也会造成问题，但显然在单线程调度时造成的后果更为严重。\n\n### 3.2、协程事件引擎设计\n#### 3.2.1、跨平台性\nlibfiber 的事件引擎支持现在主流的操作系统，从而为 libfiber 的跨平台特性提供了有力的支撑，下面为 libfiber 事件引擎所支持的平台：\n- **Linux：** sekect/poll/epoll/io_uring，epoll 为 Linux 内核级事件引擎，采用事件触发机制，不象 select/poll 的轮循方式，所以 epoll 在处理大并发网络连接时运行效率更高；而 io_uring 引擎是在内核5.1以后出现的新的事件引擎，由 Facebook 的 Jens Axboe(IO 压测工作 fio 作者) 设计完成，该引擎为真正的异步 IO 模型（为 IO 完成模型），统一了网络 IO 与文件 IO 过程（不象 epoll 仅支持网络，因为其是事件通知方式，无法预知 IO 何时完成）；\n- **BSD/MacOS：** select/poll/kqueue，kqueue 也为内核级事件引擎，在大并发环境下具有更高的性能；\n- **Windows：** select/poll/iocp/Windows 窗口消息，其中 iocp 为 Windows 平台下的内核级高效事件引擎；libfiber 支持采用界面消息引擎做为底层的事件引擎，这样在编写 Windows 界面程序的网络模块时便可以使用协程方式了，之前人们在 Windows 平台编写界面程序的网络模块时，一般采用以下两种方式：\n  - 采用非阻塞方式，网络模块与界面模块在同一线程中；\n  - 将网络模块放到独立的线程中运行，运行结果通过界面消息『传递』到界面线程中；\n\n现在 libfiber 支持 Windows 界面消息引擎，我们就可以在界面线程中直接创建网络协程，直接进行阻塞式网络编程了。(Windows 界面网络协程示例：https://github.com/iqiyi/libfiber/tree/master/samples/WinEchod )\n\n#### 3.2.2、运行效率\n大家在谈论网络协程程序的运行效率时，往往只重视协程的切换效率，但却忽视了事件引擎对于性能影响的重要性，虽然现在很网络协程库所采用的事件引擎都是内核级的，但仍需要合理使用才能发挥其最佳性能。 \n\n在使用 libfiber 的早期版本编译网络协程服务程序时，虽然在 Linux 平台上也是采用了 `epoll` 事件引擎，但在对网络协程服务程序进行性能压测（使用用系统命令 『`# perf top -p pid`』 观察运行状态）时，却发现 `epoll_ctl` API 占用了较高的 CPU，分析原因是 `epoll_ctl` 使用次数过多导致的：因为 `epoll_ctl` 内部在对套接字句柄进行添加、修改或删除事件操作时，需要先通过红黑树的查找算法找到其对应的内部套接字对象（红黑树的查找效率并不是\bO(1)的），如果 epoll_ctl 的调用次数过多必然会造成 CPU 的占用较高。 \n\n因为 TCP 数据在传输时是流式的，这就意味着数据接收者经常需要多次读操作才能获得完整的数据，反映到网络协程处理流程上如下图所示：\n\n![fiber_io_switch](/img/fiber_io_switch.png)\n\n仔细观察上面处理流程，可以发现在图中的标注4（唤醒协程）和标注5（挂起协程）之间的两个事件操作：`标注2取消读事件` 与 `标注3注册读事件`，再结合 `标注1注册读事件`，完全可以把注2和标注3处的两个事件取消，因为标注1至标注3的目标是 `注册读事件`。最后，通过缓存事件操作的中间状态，合并中间态的事件操作过程，使 libfiber 的 IO 处理性能提升 20% 左右。\n\n下图给出了采用 libfiber 编写的回显服务器与采用其它网络协程库编写的回显服务器的性能对比（对比单核条件下的 IO 处理能力）：\n\n![benchmark](/img/benchmark.png)\n\n在 libfiber 中之所以可以针对中间的事件操作过程进行合并处理，主要是因为 libfiber 的调度过程是单线程模式的，如果想要在多线程调度器中实现事件过程的合并处理则难度就要大的多：当套接字所绑定的协程因IO可读被唤醒时，假设不取消该套接字的读事件，则该协程被某个线程『拿走』后，内核又因接收到新数据而通知协程调度器，此时协程调度器就不知该如何处理了。\n\n### 3.3、协程同步机制\n#### 3.3.1、单一线程内部的协程互斥\n对于象 libfiber 这样的采用单线程调度方案的协程库而言，如果互斥加锁过程仅限于同一个调度线程内部，则实现一个协程互斥锁是比较容易的，下图为 libfiber 中单线程内部使用的协程互斥锁的处理流程图（参考源文件：fiber_lock.c）：\n\n![fiber_lock](/img/fiber_lock.png)\n\n同一线程内的协程在等待锁资源时，该协程将被挂起并被加入锁等待队列中，当加锁协程解锁后会唤醒锁等待队列中的第一个协程，单线程内部的协程互斥锁正是利用了协程的挂起和唤醒机制。  \n\n#### 3.3.2、多线程之间的协程互斥\n虽然 libfiber 的协程调度器是单线程模式的，但却可以启动多个线程使每个线程运行独立的协程调度器，如果一些资源需要在多个线程中的协程间共享，则就需要有一把可以跨线程使用的协程互斥锁。在将 libfiber 应用在多线程的简单场景时，也许直接使用系统提供的线程锁就可以解决很多问题，但线程锁当遇到如下场景时就显得无能为力：\n\n![dead_lock](/img/dead_lock.png)\n\n上述显示了系统线程互斥锁在 libfiber 使用时遇到的死锁问题：\n- 线程A 中的协程A1 成功对线程锁1加锁；\n- 线程B 中的协程B2 对线程锁2成功加锁；\n- 当线程A 中的协程A2 想要对线程锁2 加锁而阻塞时，则会使线程A 的协程调度器阻塞，从而导致整个线程A 中的所有协程被系统挂起；同样，线程B 也会因协程B1 阻塞在线程锁1 上而被阻塞；最终造成了死锁问题。\n\n产生上述死锁的根本原因是单线程调度机制以及操作系统的最小调度单元是线程，系统对于协程是无感知的。因此，在 libfiber 中专门设计了可用于在线程的协程之间使用的事件互斥锁（源码参见 fiber_event.c, 当前最新的是 fiber_mutex.c，性能更好且占用资源更少），其设计原理如下：\n\n![fiber_event](/img/fiber_event.png)\n\n该可用于在线程之间的协程进行互斥的事件互斥锁的处理流程为：\n- 协程B（假设其属于线程b）已经对事件锁加锁后；\n- 协程A（假设其属于线程a）想对该事件锁加锁时，对原子数加锁失败后创建IO管道，将IO读管道置入该事件锁的IO读等待队列中，此时协程A被挂起；\n- 当协程B 对事件锁解锁时，会首先获得协程A 的读管道，解锁后再向管道中写入消息，从而唤醒协程A；\n- 协程A 被唤醒后读取管道中的消息，然后再次尝试对事件锁中的原子数加锁，如加速成功便可以继续运行，否则会再次进入睡眠状态（有可能此事件锁又被其它协程提前抢占）。\n\n在上述事件锁的加/解锁处理流程中，使用原子数和IO管道的好处是：\n- 通过使用原子数可以使协程快速加锁空闲的事件锁，原子数在多线程或协程环境中的行为相同的，可以保证安全性；\n- 当锁被占用时，通过等待管道IO 方式使当前协程挂起，而又不会干扰该协程所属线程的正常运行；\n- 在 Linux 平台上可以使用 eventfd 代替管道，占用资源更少。\n\n#### 3.3.3、协程条件变量\n我们在使用线程编程时，都知道线程条件变量的价值：在线程之间传递消息时往往需要组合线程条件变量和线程锁。因此，在 libfiber 中同样设计了协程条件变量（源码见 fiber_cond.c），通过组合使用 libfiber 中的协程事件锁（fiber_event.c，目前使用 fiber_mutex.c）和协程条件变量，用户可以编写出用于在线程之间、线程与协程之间、线程内的协程之间、线程间的协程之间进行消息传递的消息队列。下图为使用 libfiber 中协程条件变量时的交互过程：\n\n![fiber_cond](/img/fiber_cond.png)\n\n这是一个典型的 `生产者-消费者` 问题，通过组合使用协程条件变量和事件锁可以轻松实现。\n\n#### 3.3.4、协程信号量\n使用网络协程库编写的网络服务很容易实现高并发功能，可以接入大量的客户端连接，但是后台系统（如：数据库）却未必支持高并发，即使是支持高并的缓存系统（如 Redis）当连接数达高时性能也会下降，所以协程服务模块不能将前端的并发压力传递到后端，给后台系统造成很大的压力，我们需要提供一种高并发连接卸载机制，以保证后台系统可以平稳地运行，在 libfiber 中提供了协程信号量（源码见：fiber_semc.c），下面是使用 libfiber 中的协程信号量对于后台系统的并发连接卸载保护示意图：\n\n![fiber_sem](/img/fiber_sem.png)\n\n当有大量协程需要访问后台系统时，通过协程信号量将大量的协程『挡在外面』，只允许部分协程与后端系统建立连接。  \n**注：** 目前 libfiber 的协程信号量仅用在同一线程内部，还不能跨线程使用，要想在多线程环境中使用，需在每个线程内部为协程创建独立的协程信号量。\n\n### 3.4、协程共享栈\n协程网络编程相对于非阻塞网络编程简单太多，大大方便了开发者编写支持高并发的服务程序；但对于有栈协程，意味着每个协程都要占用一段内存用来存放协程栈，所以并发越高，内存占用越多也成为有栈协程的一大弊端，但仔细分析函数压栈出栈及协程挂起唤醒过程，我们会发现在协程挂起时所占用的栈空间大小要远小于协程实际运行过程中占用的最大栈空间大小（考虑到应用业务逻辑的复杂性，可能会存在大量的函数及变量压栈过程，所以占用的栈空间会比较大），而在一个 libfiber 线程空间中只有一个运行栈，所以只需保证一个较大的运行栈空间即可，当协程被挂起时只需将其栈从运行栈中拷贝并保存出来（这个栈空间相对要小一些），而被挂起的协程被唤醒时，只需将其保存的栈拷贝到线程的运行栈上即可。在实践中这的确可以大幅减少高并发时的内存使用，虽然进行栈拷贝时会耗费一些时间，但整体影响并不太大。\n\n相对于栈拷贝时的时间损耗，在使用共享栈方式编程时有一点需要特别注意：创建在栈上的变量不能在协程之间或协程与线程之间共享，即是说，一个协程 F1 中的变量 A 传递给另一个协程 F2，并等待 F2 处理后返回，此时的 A 变量不能被创建在 F1 的栈上，因为运行栈在由 F1 切换到 F2 时，变量 A 的地址空间“暂时消失了”，此时变成了 F2 的栈空间，如果该变量在 F2 中继续被使用的话，就会存在地址非法使用的问题；解决变量在协程间共享的方法是将变量创建在堆上（即用 malloc 或 new 创建）。\n\n注：共享栈的想法最初应该是在腾讯的 libco 中提出的，应该也是为了解决大并发时的内存占用问题。\n\n### 3.5、域名解析\n网络协程库既然面向网络，自然离不开域名的协程化支持，现在很多网络协程库的设计者往往忽视了这一点，有些网络协程库在使用系统 API 进行域名解析时为了防止阻塞协程调度器，将域名解析过程（即调用 gethostbyname/getaddrinfo）扔给独立的线程去执行，当调用系统 API 进行域名解析并发量较大时必然会造成很多线程资源被占用。在 libfiber 早期通过集成第三方 dns 源码，实现了域名解析过程的协程化，基本满足了大部分服务端应用系统对于域名解析的需求；后来因为跨平台性及代码安全性的需要，在 libfiber 中实现了与域名解析相关的 DNS 协议，替换了第三方 DNS 库。\n\n### 3.6、Hook 系统 API\n相对于网络协程的出现时间，很多网络库很早就存在了，并且大部分已有的网络库都是阻塞式的，要改造这些网络库使之协程化的成本是非常巨大的，我们不可能采用协程方式将这些网络库重新实现一遍，目前一个广泛采用的方案是 Hook 与 IO 相关的系统中 API，在 Unix 平台上 Hook 系统 API 相对简单，在初始化时，先加载并保留系统 API 的原始地址，然后编写一个与系统 API 函数名相同且参数也相同的函数，将这段代码与应用代码一起编译，则编译器会优先使用这些 Hook API，下面的代码给出了在 Unix 平台上 Hook 系统 API 的简单示例：\n```C\ntypedef ssize_t (*read_fn)(int, void *, size_t);\nstatic read_fn __sys_read = NULL;\n\nstatic void hook_init(void) {\n    __sys_read = (read_fn) dlsym(RTLD_NEXT, \"read\");\n    assert(__sys_read);\n}\n\nssize_t read(int fd, void *buf, size_t count) {\n    if (__sys_read == NULL) {\n        hook_init();\n    }\n    return __sys_read(fd, buf, count);\n}\n```\n在 libfiber 中 hook 了大部分与 IO 及网络相关的系统 API，下面列出 libfiber 所 Hook 的系统 API：\n- **IO 相关 API**\n  - **读 API：** read/readv/recv/recvfrom/recvmsg；\n  - **写 API：** write/writev/send/sendto/sendmsg/sendfile64；\n- **网络相关 API**\n  - **套接字 API：** socket/listen/accept/connect；\n  - **事件引擎 API：** select/poll，epoll: epoll_create, epoll_ctl, epoll_wait；\n  - **域名解析 API：** gethostbyname/gethostbyname_r, getaddrinfo/freeaddrinfo。\n\n通过 Hook API 方式，libfiber 已经可以使 Mysql 客户端库、一些 HTTP 通信库及 Redis 客户端库的网络通信部分协程化，这样在使用网络协程编写服务端应用程序时，大大降低了编程复杂度及改造成本。\n\n为了在 Windows 平台上 Hook IO API，libfiber 集成了微软的一个开源库 detours，但该库是用 C++ 编写的，所以只能集成在 libfiber 的 c++ 模块中，即用户在使用时只能通过使用 libfiber c++ 库达到 Hook 系统 IO API 的目的。\n\n## 四、爱奇艺核心业务的协程实践\n### 4.1、CDN 核心模块使用协程\n在爱奇艺的自建 CDN 系统中，作为数据回源及本地缓存的核心软件，奇迅承担了重要角色，该模块采用多线程多协程的软件架构设计，如下所示：\n\n![qixun](/img/qixun.png)\n\n奇迅回源架构设计的特点总结如下：\n\n特性|说明\n------|--------------------------------------------------\n高并发|采用网络协程方式，支持高并发接入，同时简化程序设计\n高性能|采用线程池 + 协程 + 连接池 + 内存池技术，提高业务处理性能\n高吞吐|采用磁盘内存映射及零拷贝技术，提升磁盘及网络 IO 吞吐能力\n低回源|合并相同请求，支持部分回源及部分缓存，大大降低回源带宽\n开播快|采用流式数据读取方式，提升视频开播速度\n可扩展|模块化分层设计，易于扩展新功能\n易维护|采用统一服务器编程框架，易管理，好维护\n\n奇迅的前后端通信模块均采用网络协程方式，分为前端连接接入层和后端下载任务层，为了有效地使用多核，前后端模块均启动多个线程（每个线程运行一个独立的协程调度器）；对于前端连接接入模块，由于采用协程方式，所以：\n- 支持更高的客户端并发连接；\n- 允许更多慢连接的存在，而不会消耗更多秕资源；\n- 更有助于客户端与奇迅之间保持长连接，提升响应性能。\n\n对于后端下载模块，由于采用协程方式，在数据回源时允许建立更多的并发连接去多个源站下载数据，从而获得更快的下载速度；同时，为了节省带宽，奇迅采用合并回源策略，即当前端多个客户端请求同一段数据时，下载模块将会合并相同的请求，向源站发起一份数据请求，在合并回源请求过程中，因数据共享原因，必然存在如 “3.3.2、多线程之间的协程互斥”章节所提到的多个线程之间的协程同步互斥的需求，通过使用 libfiber 中的事件锁完美地解决了一这需求（其实，当初事件锁就是为了满足奇迅的这一需求而设计编写）。\n\n### 4.2、高性能 DNS 模块使用协程\nDNS 做为互联网的基础设施，在整个互联网中发挥着举足轻重的作用，爱奇艺为了满足自身业务的发展需要，自研了高性能 DNS（简称 HPDNS），该 DNS 的软件架构如下图所示：\n\n![hpdns](/img/hpdns.png)\n\nHPDNS 服务的特点如下：\n\n<style>\ntable th:first-of-type {\n\twidth: 50px;\n}\n</style>\n优点|说明\n-|-\n高性能|启用 Linux 3.0 内核的 REUSEPORT 功能，提升多线程并行收发包的能力\n&nbsp;|采用 Linux 3.0 内核的 recvmmsg/sendmmsg API，提升单次 IO 数据包收发能力\n&nbsp;|采用内存预分配策略，减少内存动态分配/释放时的“锁”冲突\n&nbsp;|针对 TCP 服务模式，采用网络协程框架，最大化 TCP 并发怎能能力\n高可用|采用RCU（Read Copy Update）方式更新视图数据及配置项，无需停止服务，且不影响性能\n&nbsp;|网卡 IP 地址变化自动感知（即可自动添加新 IP 或摘除老IP而不必停止服务）\n&nbsp;|采用 Keepalived 保证服务高可用\n易管理|由 master 服务管理模块管理 DNS 进程，控制 DNS 进程的启动、停止、重读配置/数据、异常重启及异常报警等\n\n由于 DNS 协议要求 DNS 服务端需要同时支持 UDP 及 TCP 两种通信方式，除了要求 UDP 模块具备高性能外，对 TCP 模块也要求支持高并发及高性能，该模块的网络通信部分使用 libfiber 编写，从而支持更高的并发连接，同时具备更高的性能，又因启用多个线程调度器，从而可以更加方便地使用多核。\n\n## 五、总结\n本文讲述了爱奇艺开源项目 libfiber 网络协程库的设计原理及核心设计要点，描述了 libfiber 的设计特点及优缺点，方便读者了解网络协程的设计原理及运行机制，做到知其然更知其所以然；本文还从爱奇艺自身的项目实践出发，总结了在应用网络协程编程时遇到的问题及解决方案，使读者能够更加全面地了解编写网络协程类应用的注意事项。\n","slug":"about_fiber","published":1,"updated":"2023-01-27T09:38:50.149Z","_id":"cld8wuane0009q79k687c3ocz","comments":1,"layout":"post","photos":[],"link":"","content":"<h1 id=\"iQiYi使用网络协程编写高并发应用实践\"><a href=\"#iQiYi使用网络协程编写高并发应用实践\" class=\"headerlink\" title=\"iQiYi使用网络协程编写高并发应用实践\"></a>iQiYi使用网络协程编写高并发应用实践</h1><h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p> 在早期程序员为了支持多个用户并发访问服务应用，往往采用多进程方式，即针对每一个 TCP 网络连接创建一个服务进程。在 2000 年左右，比较流行使用 CGI 方式编写 Web 服务，当时人们用的比较多的 Web 服务器是基于多进程模式开发的 Apache1.3.x 系列，因为进程占用系统资源较多，所以人们开始使用多线程方式编写 Web 服务应用，因为线程占用的资源更少，这使单台服务器支撑的用户并发度提高了，但依然存在资源浪费的问题。因为在多进程或多线程编程方式下，均采用了阻塞通信方式，这会使得服务端的进程或线程因『等待』客户端的请求数据而变得『空闲』，而且在该空闲期间还不能做别的事情，白白浪费了操作系统的调度时间和内存资源。这种一对一的服务方式在广域网的环境下显示变得不够廉价，于是人们开始采用非阻塞网络编程方式来提升网络服务并发度，比较著名的 Web 服务器 Nginx 就是非阻塞服务的典型代表，另外还有象 Java Netty 这样的非阻塞网络开发库。<br> 非阻塞网络编程一直以高并发和高难度而著称，这种编程方式虽然有效的提升了服务器的利用率和处理性能，但却对广大程序员提出了较大挑战，因为非阻塞 IO 的编程方式往往会把业务逻辑分隔的支离破碎，需要在通信过程中记录大量的中间状态，而且还需要处理各种异常情况，最终带来的后果就是开发周期长、复杂度高，而且难于维护。<br>阻塞式网络编程实现容易但并发度不高，非阻塞网络编程并发度高但编写难，针对这两种网络编程方式优缺点，人们提出了使用协程方式编写网络程序的思想，其实协程本身并不是一个新概念，早在2000年前 Windows NT 上就出现了『纤程』的 API，号称可以创建成千上万个纤程来处理业务任务，在 BSD Unix 上可以用来实现协程切换的 API &lt;ucontext.h&gt; 在 2002 年就已经存在了，当然另外用于上下文跳转的 API &lt;setjmp.h&gt; 出现的更早（1993年）。虽然协程的概念出现的较早，但人们终不能发现其广大的应用场景，象『longjmp』这些 API 多用在一些异常跳转上，如 Postfix（著名的邮件MTA）在处理网络异常时用其实现程序跳转。直到 Russ Cox 在 Go 语言中加入了协程（Goroutine）的功能，使用协程进行高并发网络编程才变得的简单易行。<br>Russ Cox 早在 2002 年就编写了一个简单的网络协程库 libtask（<a href=\"https://swtch.com/libtask/\">https://swtch.com/libtask/</a> ），代码量不多，却可以使我们比较清晰地看到『通过使网络 IO 协程化，使编写高并发网络程序变得如此简单』。<br>本文以爱奇艺开源的网络协程库（<a href=\"https://github.com/iqiyi/libfiber\">https://github.com/iqiyi/libfiber</a> ）为例，讲解网络协程的设计原理、编程实践、性能优化等方面内容。</p>\n<h2 id=\"二、网络协程基本原理\"><a href=\"#二、网络协程基本原理\" class=\"headerlink\" title=\"二、网络协程基本原理\"></a>二、网络协程基本原理</h2><p><strong><code>网络协程</code></strong> 的 <strong><code>本质</code></strong> 是将应用层的阻塞式 IO 过程在底层转换成非阻塞 IO 过程，并通过程序运行栈的上下文切换使 <strong>IO</strong> 准备就绪的协程交替运行，从而达到以简单方式编写高并发网络程序的目的。既然网络协程的底层也是非阻塞IO过程，所以在网络在介绍网络协程基本原理前，我们先了解一下非阻塞网络通信的基本过程。</p>\n<h3 id=\"2-1、网络非阻塞编程\"><a href=\"#2-1、网络非阻塞编程\" class=\"headerlink\" title=\"2.1、网络非阻塞编程\"></a>2.1、网络非阻塞编程</h3><p>下面给出了网络非阻塞编程的常见设计方式：<br><img src=\"/img/aio_architecture.png\" alt=\"aio_architecture\"></p>\n<ul>\n<li>使用操作系统提供的多路复用事件引擎 API（select&#x2F;poll&#x2F;epoll&#x2F;kqueue etc），将网络套接字的网络读写事件注册到事件引擎中；</li>\n<li>当套接字满足可读或可写条件时，事件引擎设置套接字对应的事件状态并返回给调用者；</li>\n<li>调用者根据套接字的事件状态分别『回调』对应的处理过程；</li>\n<li>对于大部分基于 TCP 的网络应用，数据的读写往往不是一次 IO 就能完成的，这样，对于一次会话过程就会有多次 IO 读写过程，在每次 IO 过程中都需要缓存读写的数据，直至本次数据会话完成。</li>\n</ul>\n<p>下图以非阻塞读为例展示了整个异步非阻塞读及回调处理过程：  </p>\n<p><img src=\"/img/nio_read.png\" alt=\"nio_read\"></p>\n<p>相对于阻塞式读的处理过程（循环读数据直至读完成或关闭），非阻塞读过程的确要复杂很多：</p>\n<ul>\n<li>一次完整的 IO 会话过程会被分割成多次的 IO 过程；</li>\n<li>每次 IO 过程需要缓存部分数据及当前会话的处理状态；</li>\n<li>要求相关的解析器（如：Json&#x2F;Xml&#x2F;Mime 解析器）最好能支持流式解析方式，否则就得需要读到完整数据后才能交给解析器去处理，当遇到业数据较大时就需要分配较大的连续内存块，势必造成系统的内存分配压力；</li>\n<li>因为当前绝大部分后台系统（如数据库、存储系统、缓存系统）所提供的客户端驱动都是阻塞式的，所以无法直接应用在非阻塞通信应用中，从而限制了非阻塞通信方式的应用场景；</li>\n<li>因为多次 IO 过程将应用的业务处理逻辑分割的支离破碎，大大增加了业务编写过程的复杂度，降低了开发效率，同时加大了后期的不易维护性。</li>\n</ul>\n<h3 id=\"2-2、网络协程编程\"><a href=\"#2-2、网络协程编程\" class=\"headerlink\" title=\"2.2、网络协程编程\"></a>2.2、网络协程编程</h3><h4 id=\"2-2-1、几个概念\"><a href=\"#2-2-1、几个概念\" class=\"headerlink\" title=\"2.2.1、几个概念\"></a>2.2.1、几个概念</h4><p>在了解使用协程编写网络程序之前，需要先了解几个概念：</p>\n<ul>\n<li><strong>最小调度单元：</strong> 当前大部分操作系统的最小调度单元是线程，即在单核或多核 CPU 环境中，操作系统是以线程为基本调度单元的，操作系统负责将多个线程任务唤入唤出；</li>\n<li><strong>上下文切换：</strong> 当操作系统需要将某个线程挂起时，会将该线程在 CPU 寄存器中的栈指针、状态字等保存至该线程的内存栈中；当操作系统需要唤醒某个被挂起的线程时（重新放置在CPU中运行），会将该线程之前被挂起的栈指针重新置入 CPU 寄存器中，并恢复之前保留的，从而使该线程得以运行；通过这样的挂起与唤醒操作，便完成了不同线程间的上下文切换；</li>\n<li><strong>并行与网络并发：</strong> 并行是指同一『时刻』同时运行的任务数，并行任务数量取决于 CPU 核心数量；而网络并发是指在某一『时刻』网络连接的数量；类似于二八定律，在客户端与服务端保持 TCP 长连接时，大部分连接是空闲的，所以服务端只需响应少量活跃的网络连接即可，服务端采用多路复用技术，即使使用单核也可以支持 100K 个网络连接。</li>\n</ul>\n<h4 id=\"2-2-2、协程的切换过程\"><a href=\"#2-2-2、协程的切换过程\" class=\"headerlink\" title=\"2.2.2、协程的切换过程\"></a>2.2.2、协程的切换过程</h4><p>前面提到操作系统进行任务调度的最小单元是线程，操作系统无法感知这些协程的存在，自然也就无法对其进行调度，因此存在于线程中的大量协程需要相互协作，合理地占用 CPU 时间片，在合适的运行点（如：网络阻塞点）主动让出 CPU，给其它协程提供运行的机会。<br>每个协程都会经历如下过程：  </p>\n<p><img src=\"/img/fiber_running.png\" alt=\"fiber_running\"></p>\n<p>协程之间的切换一般可分为『星形切换』和『环形切换』，参照下图：<br><img src=\"/img/fiber_switch.png\" alt=\"fiber_switch\"></p>\n<p>当有大量的协程需要运行时，在『环形切换』模式下，前一个协程运行完毕后直接『唤醒』并切换至下一个协程，而无需象『星形切换』那样先切换至调度原点，再从调度原点来『唤醒』下一个协程；因为『环形切换』要比『星形切换』节省了一次上下文的切换过程，所以『环形切换』方式的切换效率更高。</p>\n<h4 id=\"2-2-3、网络过程协程化\"><a href=\"#2-2-3、网络过程协程化\" class=\"headerlink\" title=\"2.2.3、网络过程协程化\"></a>2.2.3、网络过程协程化</h4><p>下图是使网络过程协程化的示意图：</p>\n<p><img src=\"/img/fiber_schedule.png\" alt=\"fiber_schedule\"></p>\n<ul>\n<li>在网络协程库中，内部有一个缺省的 <code>IO调度协程</code>，其负责处理与网络 IO 相关的协程调度过程，故称之为『<strong>IO 调度协程</strong>』；</li>\n<li>每一个网络连接绑定一个套接字句柄，该套接字绑定一个协程；</li>\n<li>当对网络套接字进行读写操作时，将该套接字添加至 IO 调度协程的事件引擎中并设置读写事件，然后将该协程挂起；这样所有处于读写等待状态的网络协程都被挂起，且与之关联的网络套接字均由 IO 调度协程的事件引擎统一监控管理；</li>\n<li>当某些网络套接字满足可读或可写条件时，IO 调度协程的事件引擎返回这些套接字的状态，IO 调度协程找到与这些套接字绑定的协程对象，然后分别唤醒这些协程，使之依次运行；</li>\n<li>IO 事件协程内部本身也是由系统事件引擎（如：Linux 下的 epoll 事件引擎）驱动的，其内部 IO 事件的驱动机制和上面介绍的非阻塞过程相似，当某个套接字句柄『准备就绪』时，IO 调度协程便将其所绑定的协程添加进协程调度队列中，待本次 IO 调度协程返回后，会依次运行协程调度队列里的所有协程。</li>\n</ul>\n<h4 id=\"2-2-4、网络协程示例\"><a href=\"#2-2-4、网络协程示例\" class=\"headerlink\" title=\"2.2.4、网络协程示例\"></a>2.2.4、网络协程示例</h4><p>下面给出一个使用协程方式编写的网络服务器程序，该程序位于：<a href=\"https://github.com/iqiyi/libfiber\">https://github.com/iqiyi/libfiber</a> 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;patch.h&quot;</span>  <span class=\"hljs-comment\">// 主要包含：SOCKET, socket_close(), socket_listen(), socket_accept()</span></span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">size_t</span> __stack_size  = <span class=\"hljs-number\">128000</span>;  <span class=\"hljs-comment\">// 协程栈大小设为 128 KB 左右</span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">fiber_client</span><span class=\"hljs-params\">(ACL_FIBER *fb, <span class=\"hljs-type\">void</span> *ctx)</span> &#123;<br>    SOCKET fd = (<span class=\"hljs-type\">int</span> *) ctx;<br>    <span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>    <span class=\"hljs-built_in\">free</span>(ctx);<br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-type\">int</span> ret = acl_fiber_recv(fd, buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-number\">0</span>);  <span class=\"hljs-comment\">// 读客户端请求数据</span><br>        <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">// 说明网络连接关闭</span><br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span> (acl_fiber_last_error() == FIBER_EINTR) &#123;<br>                <span class=\"hljs-keyword\">continue</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (acl_fiber_send(fd, buf, ret, <span class=\"hljs-number\">0</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">// 回写数据</span><br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br>    socket_close(fd);  <span class=\"hljs-comment\">// 关闭套接字</span><br>&#125;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">fiber_accept</span><span class=\"hljs-params\">(ACL_FIBER *fb, <span class=\"hljs-type\">void</span> *ctx)</span> &#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *addr = (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *) ctx;<br>    SOCKET lfd = socket_listen(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>, <span class=\"hljs-number\">9001</span>);  <span class=\"hljs-comment\">// 创建监听套接字</span><br>    assert(lfd &gt;= <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        SOCKET *pfd, cfd = socket_accept(lfd);  <span class=\"hljs-comment\">// 等待客户端连接</span><br>        <span class=\"hljs-keyword\">if</span> (cfd == <span class=\"hljs-number\">-1</span>) &#123;<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept error %s\\r\\n&quot;</span>, acl_fiber_last_serror());<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        pfd  = (<span class=\"hljs-type\">int</span> *) <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(SOCKET));<br>        *pfd = cfd;<br>        acl_fiber_create(fiber_client, pfd, __stack_size);  <span class=\"hljs-comment\">// 创建协程处理连接请求</span><br>    &#125;<br>    acl_fiber_schedule_stop();  <span class=\"hljs-comment\">// 停止协程调度器</span><br>&#125;<br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 指定 IO 事件引擎类型，在 Linux 下将采用 epoll</span><br>    <span class=\"hljs-type\">int</span> event_mode = FIBER_EVENT_KERNEL;<br><br>    <span class=\"hljs-comment\">// 创建网络监听协程，用来接收客户端连接请求</span><br>    acl_fiber_create(fiber_accept, <span class=\"hljs-literal\">NULL</span>, __stack_size);<br><br>    <span class=\"hljs-comment\">// 开始运行协程调度器</span><br>    acl_fiber_schedule_with(event_mode);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>该网络协程服务器程序处理流程为：</p>\n<ul>\n<li>创建一个监听协程，其『堵』在  <code>accept()</code> 调用上，等待客户端连接；</li>\n<li>启动协程调度器，开始运行新创建的监听协程；</li>\n<li>监听协程每当接收一个客户端连接，便创建一个客户端协程单独处理该网络连接，然后监听协程继续等待下一个客户端连接；</li>\n<li>客户端协程以『阻塞』方式读写网络连接数据；</li>\n<li>客户端连接处理完毕，关闭连接，并退出协程。</li>\n</ul>\n<p>从该例子可以看出，网络协程的处理过程都是顺序方式，比较符合人的思维模式；我们很容易将该例子改成线程方式，处理逻辑和协程方式相似，但协程方式更加轻量、占用资源更少，并发处理能力更强。<br>简单的表面必定隐藏着复杂的底层设计，因为网络协程过程在底层还是需要转为『非阻塞』处理过程，只是使用者并未感知而已。</p>\n<h2 id=\"三、网络协程核心设计要点\"><a href=\"#三、网络协程核心设计要点\" class=\"headerlink\" title=\"三、网络协程核心设计要点\"></a>三、网络协程核心设计要点</h2><p>在介绍了网络协程的基本设计原理后，本章节主要介绍 <code>libfiber</code> 网络协程的核心设计要点，为网络协程应用实践化提供了基本的设计思路。</p>\n<h3 id=\"3-1、协程调度\"><a href=\"#3-1、协程调度\" class=\"headerlink\" title=\"3.1、协程调度\"></a>3.1、协程调度</h3><p>libfiber 采用了单线程调度方式，主要是为了避免设计的复杂性及效率上的影响。如果设计成多线程调度模式，则必须首先需要考虑：</p>\n<ul>\n<li>多核环境下 CPU 缓存亲和性：因为 CPU 本身有高效的多级缓存，虽然 CPU 多级缓存容量较内存小的多，但访问效率却远高于内存，单线程调度方式下，可以方便编译器有效地进行 CPU 缓存使用优化，使运行指令和共享数据尽可能放置在 CPU 缓存中，而如果采用多线程调度方式，多个线程间共享的数据就可能使 CPU 缓存失效，会造成调度线程越多，协程的运行效率越低的问题；</li>\n<li>多线程分配任务时的同步问题：当多个线程需要从公共协程任务资源中获取协程任务时，必然需要采用增加『锁』保护机制，一旦产生大量的『锁』冲突，则势必会造成运行性能的严重损耗；</li>\n<li>事件引擎操作优化：下面会介绍在单线程调度模式下的事件引擎操作优化，在多线程调度则很难进行如此优化。</li>\n</ul>\n<p>当然，单线程调度也需解决如下问题：</p>\n<ul>\n<li>如何有效地使用多核：在单线程调度方式下，该线程内的多个协程在运行时仅能使用单核，这显示是不合理的，解决方案为：<ul>\n<li>启动多个进程，每个进程运行一个线程;</li>\n<li>同一进程内启动多个线程，每个线程运行独立的协程调度过程；</li>\n</ul>\n</li>\n<li>多个线程之间的资源共享：因为协程调度是不跨线程的，在设计协程互斥锁时需要考虑：<ul>\n<li>协程锁需要支持『同一线程内的协程之间、不同线程的协程之间、协程线程与非协程线程之间』的互斥；</li>\n<li>网络连接池的线程隔离机制，即需要为每个线程建立各自独立的连接池，防止连接对象在不同线程的协程之间共享，否则便会造成同一网络连接在不同线程的协程之间使用，破坏单线程调度规则；</li>\n</ul>\n</li>\n<li>需要防止线程内的某个协程『疯狂』占用 CPU 资源，导致本线程内的其它协程得不到运行的机会，虽然此类问题在多线程调度时也会造成问题，但显然在单线程调度时造成的后果更为严重。</li>\n</ul>\n<h3 id=\"3-2、协程事件引擎设计\"><a href=\"#3-2、协程事件引擎设计\" class=\"headerlink\" title=\"3.2、协程事件引擎设计\"></a>3.2、协程事件引擎设计</h3><h4 id=\"3-2-1、跨平台性\"><a href=\"#3-2-1、跨平台性\" class=\"headerlink\" title=\"3.2.1、跨平台性\"></a>3.2.1、跨平台性</h4><p>libfiber 的事件引擎支持现在主流的操作系统，从而为 libfiber 的跨平台特性提供了有力的支撑，下面为 libfiber 事件引擎所支持的平台：</p>\n<ul>\n<li><strong>Linux：</strong> sekect&#x2F;poll&#x2F;epoll&#x2F;io_uring，epoll 为 Linux 内核级事件引擎，采用事件触发机制，不象 select&#x2F;poll 的轮循方式，所以 epoll 在处理大并发网络连接时运行效率更高；而 io_uring 引擎是在内核5.1以后出现的新的事件引擎，由 Facebook 的 Jens Axboe(IO 压测工作 fio 作者) 设计完成，该引擎为真正的异步 IO 模型（为 IO 完成模型），统一了网络 IO 与文件 IO 过程（不象 epoll 仅支持网络，因为其是事件通知方式，无法预知 IO 何时完成）；</li>\n<li><strong>BSD&#x2F;MacOS：</strong> select&#x2F;poll&#x2F;kqueue，kqueue 也为内核级事件引擎，在大并发环境下具有更高的性能；</li>\n<li><strong>Windows：</strong> select&#x2F;poll&#x2F;iocp&#x2F;Windows 窗口消息，其中 iocp 为 Windows 平台下的内核级高效事件引擎；libfiber 支持采用界面消息引擎做为底层的事件引擎，这样在编写 Windows 界面程序的网络模块时便可以使用协程方式了，之前人们在 Windows 平台编写界面程序的网络模块时，一般采用以下两种方式：<ul>\n<li>采用非阻塞方式，网络模块与界面模块在同一线程中；</li>\n<li>将网络模块放到独立的线程中运行，运行结果通过界面消息『传递』到界面线程中；</li>\n</ul>\n</li>\n</ul>\n<p>现在 libfiber 支持 Windows 界面消息引擎，我们就可以在界面线程中直接创建网络协程，直接进行阻塞式网络编程了。(Windows 界面网络协程示例：<a href=\"https://github.com/iqiyi/libfiber/tree/master/samples/WinEchod\">https://github.com/iqiyi/libfiber/tree/master/samples/WinEchod</a> )</p>\n<h4 id=\"3-2-2、运行效率\"><a href=\"#3-2-2、运行效率\" class=\"headerlink\" title=\"3.2.2、运行效率\"></a>3.2.2、运行效率</h4><p>大家在谈论网络协程程序的运行效率时，往往只重视协程的切换效率，但却忽视了事件引擎对于性能影响的重要性，虽然现在很网络协程库所采用的事件引擎都是内核级的，但仍需要合理使用才能发挥其最佳性能。 </p>\n<p>在使用 libfiber 的早期版本编译网络协程服务程序时，虽然在 Linux 平台上也是采用了 <code>epoll</code> 事件引擎，但在对网络协程服务程序进行性能压测（使用用系统命令 『<code># perf top -p pid</code>』 观察运行状态）时，却发现 <code>epoll_ctl</code> API 占用了较高的 CPU，分析原因是 <code>epoll_ctl</code> 使用次数过多导致的：因为 <code>epoll_ctl</code> 内部在对套接字句柄进行添加、修改或删除事件操作时，需要先通过红黑树的查找算法找到其对应的内部套接字对象（红黑树的查找效率并不是\bO(1)的），如果 epoll_ctl 的调用次数过多必然会造成 CPU 的占用较高。 </p>\n<p>因为 TCP 数据在传输时是流式的，这就意味着数据接收者经常需要多次读操作才能获得完整的数据，反映到网络协程处理流程上如下图所示：</p>\n<p><img src=\"/img/fiber_io_switch.png\" alt=\"fiber_io_switch\"></p>\n<p>仔细观察上面处理流程，可以发现在图中的标注4（唤醒协程）和标注5（挂起协程）之间的两个事件操作：<code>标注2取消读事件</code> 与 <code>标注3注册读事件</code>，再结合 <code>标注1注册读事件</code>，完全可以把注2和标注3处的两个事件取消，因为标注1至标注3的目标是 <code>注册读事件</code>。最后，通过缓存事件操作的中间状态，合并中间态的事件操作过程，使 libfiber 的 IO 处理性能提升 20% 左右。</p>\n<p>下图给出了采用 libfiber 编写的回显服务器与采用其它网络协程库编写的回显服务器的性能对比（对比单核条件下的 IO 处理能力）：</p>\n<p><img src=\"/img/benchmark.png\" alt=\"benchmark\"></p>\n<p>在 libfiber 中之所以可以针对中间的事件操作过程进行合并处理，主要是因为 libfiber 的调度过程是单线程模式的，如果想要在多线程调度器中实现事件过程的合并处理则难度就要大的多：当套接字所绑定的协程因IO可读被唤醒时，假设不取消该套接字的读事件，则该协程被某个线程『拿走』后，内核又因接收到新数据而通知协程调度器，此时协程调度器就不知该如何处理了。</p>\n<h3 id=\"3-3、协程同步机制\"><a href=\"#3-3、协程同步机制\" class=\"headerlink\" title=\"3.3、协程同步机制\"></a>3.3、协程同步机制</h3><h4 id=\"3-3-1、单一线程内部的协程互斥\"><a href=\"#3-3-1、单一线程内部的协程互斥\" class=\"headerlink\" title=\"3.3.1、单一线程内部的协程互斥\"></a>3.3.1、单一线程内部的协程互斥</h4><p>对于象 libfiber 这样的采用单线程调度方案的协程库而言，如果互斥加锁过程仅限于同一个调度线程内部，则实现一个协程互斥锁是比较容易的，下图为 libfiber 中单线程内部使用的协程互斥锁的处理流程图（参考源文件：fiber_lock.c）：</p>\n<p><img src=\"/img/fiber_lock.png\" alt=\"fiber_lock\"></p>\n<p>同一线程内的协程在等待锁资源时，该协程将被挂起并被加入锁等待队列中，当加锁协程解锁后会唤醒锁等待队列中的第一个协程，单线程内部的协程互斥锁正是利用了协程的挂起和唤醒机制。  </p>\n<h4 id=\"3-3-2、多线程之间的协程互斥\"><a href=\"#3-3-2、多线程之间的协程互斥\" class=\"headerlink\" title=\"3.3.2、多线程之间的协程互斥\"></a>3.3.2、多线程之间的协程互斥</h4><p>虽然 libfiber 的协程调度器是单线程模式的，但却可以启动多个线程使每个线程运行独立的协程调度器，如果一些资源需要在多个线程中的协程间共享，则就需要有一把可以跨线程使用的协程互斥锁。在将 libfiber 应用在多线程的简单场景时，也许直接使用系统提供的线程锁就可以解决很多问题，但线程锁当遇到如下场景时就显得无能为力：</p>\n<p><img src=\"/img/dead_lock.png\" alt=\"dead_lock\"></p>\n<p>上述显示了系统线程互斥锁在 libfiber 使用时遇到的死锁问题：</p>\n<ul>\n<li>线程A 中的协程A1 成功对线程锁1加锁；</li>\n<li>线程B 中的协程B2 对线程锁2成功加锁；</li>\n<li>当线程A 中的协程A2 想要对线程锁2 加锁而阻塞时，则会使线程A 的协程调度器阻塞，从而导致整个线程A 中的所有协程被系统挂起；同样，线程B 也会因协程B1 阻塞在线程锁1 上而被阻塞；最终造成了死锁问题。</li>\n</ul>\n<p>产生上述死锁的根本原因是单线程调度机制以及操作系统的最小调度单元是线程，系统对于协程是无感知的。因此，在 libfiber 中专门设计了可用于在线程的协程之间使用的事件互斥锁（源码参见 fiber_event.c, 当前最新的是 fiber_mutex.c，性能更好且占用资源更少），其设计原理如下：</p>\n<p><img src=\"/img/fiber_event.png\" alt=\"fiber_event\"></p>\n<p>该可用于在线程之间的协程进行互斥的事件互斥锁的处理流程为：</p>\n<ul>\n<li>协程B（假设其属于线程b）已经对事件锁加锁后；</li>\n<li>协程A（假设其属于线程a）想对该事件锁加锁时，对原子数加锁失败后创建IO管道，将IO读管道置入该事件锁的IO读等待队列中，此时协程A被挂起；</li>\n<li>当协程B 对事件锁解锁时，会首先获得协程A 的读管道，解锁后再向管道中写入消息，从而唤醒协程A；</li>\n<li>协程A 被唤醒后读取管道中的消息，然后再次尝试对事件锁中的原子数加锁，如加速成功便可以继续运行，否则会再次进入睡眠状态（有可能此事件锁又被其它协程提前抢占）。</li>\n</ul>\n<p>在上述事件锁的加&#x2F;解锁处理流程中，使用原子数和IO管道的好处是：</p>\n<ul>\n<li>通过使用原子数可以使协程快速加锁空闲的事件锁，原子数在多线程或协程环境中的行为相同的，可以保证安全性；</li>\n<li>当锁被占用时，通过等待管道IO 方式使当前协程挂起，而又不会干扰该协程所属线程的正常运行；</li>\n<li>在 Linux 平台上可以使用 eventfd 代替管道，占用资源更少。</li>\n</ul>\n<h4 id=\"3-3-3、协程条件变量\"><a href=\"#3-3-3、协程条件变量\" class=\"headerlink\" title=\"3.3.3、协程条件变量\"></a>3.3.3、协程条件变量</h4><p>我们在使用线程编程时，都知道线程条件变量的价值：在线程之间传递消息时往往需要组合线程条件变量和线程锁。因此，在 libfiber 中同样设计了协程条件变量（源码见 fiber_cond.c），通过组合使用 libfiber 中的协程事件锁（fiber_event.c，目前使用 fiber_mutex.c）和协程条件变量，用户可以编写出用于在线程之间、线程与协程之间、线程内的协程之间、线程间的协程之间进行消息传递的消息队列。下图为使用 libfiber 中协程条件变量时的交互过程：</p>\n<p><img src=\"/img/fiber_cond.png\" alt=\"fiber_cond\"></p>\n<p>这是一个典型的 <code>生产者-消费者</code> 问题，通过组合使用协程条件变量和事件锁可以轻松实现。</p>\n<h4 id=\"3-3-4、协程信号量\"><a href=\"#3-3-4、协程信号量\" class=\"headerlink\" title=\"3.3.4、协程信号量\"></a>3.3.4、协程信号量</h4><p>使用网络协程库编写的网络服务很容易实现高并发功能，可以接入大量的客户端连接，但是后台系统（如：数据库）却未必支持高并发，即使是支持高并的缓存系统（如 Redis）当连接数达高时性能也会下降，所以协程服务模块不能将前端的并发压力传递到后端，给后台系统造成很大的压力，我们需要提供一种高并发连接卸载机制，以保证后台系统可以平稳地运行，在 libfiber 中提供了协程信号量（源码见：fiber_semc.c），下面是使用 libfiber 中的协程信号量对于后台系统的并发连接卸载保护示意图：</p>\n<p><img src=\"/img/fiber_sem.png\" alt=\"fiber_sem\"></p>\n<p>当有大量协程需要访问后台系统时，通过协程信号量将大量的协程『挡在外面』，只允许部分协程与后端系统建立连接。<br><strong>注：</strong> 目前 libfiber 的协程信号量仅用在同一线程内部，还不能跨线程使用，要想在多线程环境中使用，需在每个线程内部为协程创建独立的协程信号量。</p>\n<h3 id=\"3-4、协程共享栈\"><a href=\"#3-4、协程共享栈\" class=\"headerlink\" title=\"3.4、协程共享栈\"></a>3.4、协程共享栈</h3><p>协程网络编程相对于非阻塞网络编程简单太多，大大方便了开发者编写支持高并发的服务程序；但对于有栈协程，意味着每个协程都要占用一段内存用来存放协程栈，所以并发越高，内存占用越多也成为有栈协程的一大弊端，但仔细分析函数压栈出栈及协程挂起唤醒过程，我们会发现在协程挂起时所占用的栈空间大小要远小于协程实际运行过程中占用的最大栈空间大小（考虑到应用业务逻辑的复杂性，可能会存在大量的函数及变量压栈过程，所以占用的栈空间会比较大），而在一个 libfiber 线程空间中只有一个运行栈，所以只需保证一个较大的运行栈空间即可，当协程被挂起时只需将其栈从运行栈中拷贝并保存出来（这个栈空间相对要小一些），而被挂起的协程被唤醒时，只需将其保存的栈拷贝到线程的运行栈上即可。在实践中这的确可以大幅减少高并发时的内存使用，虽然进行栈拷贝时会耗费一些时间，但整体影响并不太大。</p>\n<p>相对于栈拷贝时的时间损耗，在使用共享栈方式编程时有一点需要特别注意：创建在栈上的变量不能在协程之间或协程与线程之间共享，即是说，一个协程 F1 中的变量 A 传递给另一个协程 F2，并等待 F2 处理后返回，此时的 A 变量不能被创建在 F1 的栈上，因为运行栈在由 F1 切换到 F2 时，变量 A 的地址空间“暂时消失了”，此时变成了 F2 的栈空间，如果该变量在 F2 中继续被使用的话，就会存在地址非法使用的问题；解决变量在协程间共享的方法是将变量创建在堆上（即用 malloc 或 new 创建）。</p>\n<p>注：共享栈的想法最初应该是在腾讯的 libco 中提出的，应该也是为了解决大并发时的内存占用问题。</p>\n<h3 id=\"3-5、域名解析\"><a href=\"#3-5、域名解析\" class=\"headerlink\" title=\"3.5、域名解析\"></a>3.5、域名解析</h3><p>网络协程库既然面向网络，自然离不开域名的协程化支持，现在很多网络协程库的设计者往往忽视了这一点，有些网络协程库在使用系统 API 进行域名解析时为了防止阻塞协程调度器，将域名解析过程（即调用 gethostbyname&#x2F;getaddrinfo）扔给独立的线程去执行，当调用系统 API 进行域名解析并发量较大时必然会造成很多线程资源被占用。在 libfiber 早期通过集成第三方 dns 源码，实现了域名解析过程的协程化，基本满足了大部分服务端应用系统对于域名解析的需求；后来因为跨平台性及代码安全性的需要，在 libfiber 中实现了与域名解析相关的 DNS 协议，替换了第三方 DNS 库。</p>\n<h3 id=\"3-6、Hook-系统-API\"><a href=\"#3-6、Hook-系统-API\" class=\"headerlink\" title=\"3.6、Hook 系统 API\"></a>3.6、Hook 系统 API</h3><p>相对于网络协程的出现时间，很多网络库很早就存在了，并且大部分已有的网络库都是阻塞式的，要改造这些网络库使之协程化的成本是非常巨大的，我们不可能采用协程方式将这些网络库重新实现一遍，目前一个广泛采用的方案是 Hook 与 IO 相关的系统中 API，在 Unix 平台上 Hook 系统 API 相对简单，在初始化时，先加载并保留系统 API 的原始地址，然后编写一个与系统 API 函数名相同且参数也相同的函数，将这段代码与应用代码一起编译，则编译器会优先使用这些 Hook API，下面的代码给出了在 Unix 平台上 Hook 系统 API 的简单示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title function_\">ssize_t</span> <span class=\"hljs-params\">(*read_fn)</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">void</span> *, <span class=\"hljs-type\">size_t</span>)</span>;<br><span class=\"hljs-type\">static</span> read_fn __sys_read = <span class=\"hljs-literal\">NULL</span>;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">hook_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>    __sys_read = (read_fn) dlsym(RTLD_NEXT, <span class=\"hljs-string\">&quot;read&quot;</span>);<br>    assert(__sys_read);<br>&#125;<br><br><span class=\"hljs-type\">ssize_t</span> <span class=\"hljs-title function_\">read</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> fd, <span class=\"hljs-type\">void</span> *buf, <span class=\"hljs-type\">size_t</span> count)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (__sys_read == <span class=\"hljs-literal\">NULL</span>) &#123;<br>        hook_init();<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> __sys_read(fd, buf, count);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在 libfiber 中 hook 了大部分与 IO 及网络相关的系统 API，下面列出 libfiber 所 Hook 的系统 API：</p>\n<ul>\n<li><strong>IO 相关 API</strong><ul>\n<li><strong>读 API：</strong> read&#x2F;readv&#x2F;recv&#x2F;recvfrom&#x2F;recvmsg；</li>\n<li><strong>写 API：</strong> write&#x2F;writev&#x2F;send&#x2F;sendto&#x2F;sendmsg&#x2F;sendfile64；</li>\n</ul>\n</li>\n<li><strong>网络相关 API</strong><ul>\n<li><strong>套接字 API：</strong> socket&#x2F;listen&#x2F;accept&#x2F;connect；</li>\n<li><strong>事件引擎 API：</strong> select&#x2F;poll，epoll: epoll_create, epoll_ctl, epoll_wait；</li>\n<li><strong>域名解析 API：</strong> gethostbyname&#x2F;gethostbyname_r, getaddrinfo&#x2F;freeaddrinfo。</li>\n</ul>\n</li>\n</ul>\n<p>通过 Hook API 方式，libfiber 已经可以使 Mysql 客户端库、一些 HTTP 通信库及 Redis 客户端库的网络通信部分协程化，这样在使用网络协程编写服务端应用程序时，大大降低了编程复杂度及改造成本。</p>\n<p>为了在 Windows 平台上 Hook IO API，libfiber 集成了微软的一个开源库 detours，但该库是用 C++ 编写的，所以只能集成在 libfiber 的 c++ 模块中，即用户在使用时只能通过使用 libfiber c++ 库达到 Hook 系统 IO API 的目的。</p>\n<h2 id=\"四、爱奇艺核心业务的协程实践\"><a href=\"#四、爱奇艺核心业务的协程实践\" class=\"headerlink\" title=\"四、爱奇艺核心业务的协程实践\"></a>四、爱奇艺核心业务的协程实践</h2><h3 id=\"4-1、CDN-核心模块使用协程\"><a href=\"#4-1、CDN-核心模块使用协程\" class=\"headerlink\" title=\"4.1、CDN 核心模块使用协程\"></a>4.1、CDN 核心模块使用协程</h3><p>在爱奇艺的自建 CDN 系统中，作为数据回源及本地缓存的核心软件，奇迅承担了重要角色，该模块采用多线程多协程的软件架构设计，如下所示：</p>\n<p><img src=\"/img/qixun.png\" alt=\"qixun\"></p>\n<p>奇迅回源架构设计的特点总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>高并发</td>\n<td>采用网络协程方式，支持高并发接入，同时简化程序设计</td>\n</tr>\n<tr>\n<td>高性能</td>\n<td>采用线程池 + 协程 + 连接池 + 内存池技术，提高业务处理性能</td>\n</tr>\n<tr>\n<td>高吞吐</td>\n<td>采用磁盘内存映射及零拷贝技术，提升磁盘及网络 IO 吞吐能力</td>\n</tr>\n<tr>\n<td>低回源</td>\n<td>合并相同请求，支持部分回源及部分缓存，大大降低回源带宽</td>\n</tr>\n<tr>\n<td>开播快</td>\n<td>采用流式数据读取方式，提升视频开播速度</td>\n</tr>\n<tr>\n<td>可扩展</td>\n<td>模块化分层设计，易于扩展新功能</td>\n</tr>\n<tr>\n<td>易维护</td>\n<td>采用统一服务器编程框架，易管理，好维护</td>\n</tr>\n</tbody></table>\n<p>奇迅的前后端通信模块均采用网络协程方式，分为前端连接接入层和后端下载任务层，为了有效地使用多核，前后端模块均启动多个线程（每个线程运行一个独立的协程调度器）；对于前端连接接入模块，由于采用协程方式，所以：</p>\n<ul>\n<li>支持更高的客户端并发连接；</li>\n<li>允许更多慢连接的存在，而不会消耗更多秕资源；</li>\n<li>更有助于客户端与奇迅之间保持长连接，提升响应性能。</li>\n</ul>\n<p>对于后端下载模块，由于采用协程方式，在数据回源时允许建立更多的并发连接去多个源站下载数据，从而获得更快的下载速度；同时，为了节省带宽，奇迅采用合并回源策略，即当前端多个客户端请求同一段数据时，下载模块将会合并相同的请求，向源站发起一份数据请求，在合并回源请求过程中，因数据共享原因，必然存在如 “3.3.2、多线程之间的协程互斥”章节所提到的多个线程之间的协程同步互斥的需求，通过使用 libfiber 中的事件锁完美地解决了一这需求（其实，当初事件锁就是为了满足奇迅的这一需求而设计编写）。</p>\n<h3 id=\"4-2、高性能-DNS-模块使用协程\"><a href=\"#4-2、高性能-DNS-模块使用协程\" class=\"headerlink\" title=\"4.2、高性能 DNS 模块使用协程\"></a>4.2、高性能 DNS 模块使用协程</h3><p>DNS 做为互联网的基础设施，在整个互联网中发挥着举足轻重的作用，爱奇艺为了满足自身业务的发展需要，自研了高性能 DNS（简称 HPDNS），该 DNS 的软件架构如下图所示：</p>\n<p><img src=\"/img/hpdns.png\" alt=\"hpdns\"></p>\n<p>HPDNS 服务的特点如下：</p>\n<style>\ntable th:first-of-type {\n    width: 50px;\n}\n</style>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>高性能</td>\n<td>启用 Linux 3.0 内核的 REUSEPORT 功能，提升多线程并行收发包的能力</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>采用 Linux 3.0 内核的 recvmmsg&#x2F;sendmmsg API，提升单次 IO 数据包收发能力</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>采用内存预分配策略，减少内存动态分配&#x2F;释放时的“锁”冲突</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>针对 TCP 服务模式，采用网络协程框架，最大化 TCP 并发怎能能力</td>\n</tr>\n<tr>\n<td>高可用</td>\n<td>采用RCU（Read Copy Update）方式更新视图数据及配置项，无需停止服务，且不影响性能</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>网卡 IP 地址变化自动感知（即可自动添加新 IP 或摘除老IP而不必停止服务）</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>采用 Keepalived 保证服务高可用</td>\n</tr>\n<tr>\n<td>易管理</td>\n<td>由 master 服务管理模块管理 DNS 进程，控制 DNS 进程的启动、停止、重读配置&#x2F;数据、异常重启及异常报警等</td>\n</tr>\n</tbody></table>\n<p>由于 DNS 协议要求 DNS 服务端需要同时支持 UDP 及 TCP 两种通信方式，除了要求 UDP 模块具备高性能外，对 TCP 模块也要求支持高并发及高性能，该模块的网络通信部分使用 libfiber 编写，从而支持更高的并发连接，同时具备更高的性能，又因启用多个线程调度器，从而可以更加方便地使用多核。</p>\n<h2 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h2><p>本文讲述了爱奇艺开源项目 libfiber 网络协程库的设计原理及核心设计要点，描述了 libfiber 的设计特点及优缺点，方便读者了解网络协程的设计原理及运行机制，做到知其然更知其所以然；本文还从爱奇艺自身的项目实践出发，总结了在应用网络协程编程时遇到的问题及解决方案，使读者能够更加全面地了解编写网络协程类应用的注意事项。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"iQiYi使用网络协程编写高并发应用实践\"><a href=\"#iQiYi使用网络协程编写高并发应用实践\" class=\"headerlink\" title=\"iQiYi使用网络协程编写高并发应用实践\"></a>iQiYi使用网络协程编写高并发应用实践</h1><h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p> 在早期程序员为了支持多个用户并发访问服务应用，往往采用多进程方式，即针对每一个 TCP 网络连接创建一个服务进程。在 2000 年左右，比较流行使用 CGI 方式编写 Web 服务，当时人们用的比较多的 Web 服务器是基于多进程模式开发的 Apache1.3.x 系列，因为进程占用系统资源较多，所以人们开始使用多线程方式编写 Web 服务应用，因为线程占用的资源更少，这使单台服务器支撑的用户并发度提高了，但依然存在资源浪费的问题。因为在多进程或多线程编程方式下，均采用了阻塞通信方式，这会使得服务端的进程或线程因『等待』客户端的请求数据而变得『空闲』，而且在该空闲期间还不能做别的事情，白白浪费了操作系统的调度时间和内存资源。这种一对一的服务方式在广域网的环境下显示变得不够廉价，于是人们开始采用非阻塞网络编程方式来提升网络服务并发度，比较著名的 Web 服务器 Nginx 就是非阻塞服务的典型代表，另外还有象 Java Netty 这样的非阻塞网络开发库。<br> 非阻塞网络编程一直以高并发和高难度而著称，这种编程方式虽然有效的提升了服务器的利用率和处理性能，但却对广大程序员提出了较大挑战，因为非阻塞 IO 的编程方式往往会把业务逻辑分隔的支离破碎，需要在通信过程中记录大量的中间状态，而且还需要处理各种异常情况，最终带来的后果就是开发周期长、复杂度高，而且难于维护。<br>阻塞式网络编程实现容易但并发度不高，非阻塞网络编程并发度高但编写难，针对这两种网络编程方式优缺点，人们提出了使用协程方式编写网络程序的思想，其实协程本身并不是一个新概念，早在2000年前 Windows NT 上就出现了『纤程』的 API，号称可以创建成千上万个纤程来处理业务任务，在 BSD Unix 上可以用来实现协程切换的 API &lt;ucontext.h&gt; 在 2002 年就已经存在了，当然另外用于上下文跳转的 API &lt;setjmp.h&gt; 出现的更早（1993年）。虽然协程的概念出现的较早，但人们终不能发现其广大的应用场景，象『longjmp』这些 API 多用在一些异常跳转上，如 Postfix（著名的邮件MTA）在处理网络异常时用其实现程序跳转。直到 Russ Cox 在 Go 语言中加入了协程（Goroutine）的功能，使用协程进行高并发网络编程才变得的简单易行。<br>Russ Cox 早在 2002 年就编写了一个简单的网络协程库 libtask（<a href=\"https://swtch.com/libtask/\">https://swtch.com/libtask/</a> ），代码量不多，却可以使我们比较清晰地看到『通过使网络 IO 协程化，使编写高并发网络程序变得如此简单』。<br>本文以爱奇艺开源的网络协程库（<a href=\"https://github.com/iqiyi/libfiber\">https://github.com/iqiyi/libfiber</a> ）为例，讲解网络协程的设计原理、编程实践、性能优化等方面内容。</p>\n<h2 id=\"二、网络协程基本原理\"><a href=\"#二、网络协程基本原理\" class=\"headerlink\" title=\"二、网络协程基本原理\"></a>二、网络协程基本原理</h2><p><strong><code>网络协程</code></strong> 的 <strong><code>本质</code></strong> 是将应用层的阻塞式 IO 过程在底层转换成非阻塞 IO 过程，并通过程序运行栈的上下文切换使 <strong>IO</strong> 准备就绪的协程交替运行，从而达到以简单方式编写高并发网络程序的目的。既然网络协程的底层也是非阻塞IO过程，所以在网络在介绍网络协程基本原理前，我们先了解一下非阻塞网络通信的基本过程。</p>\n<h3 id=\"2-1、网络非阻塞编程\"><a href=\"#2-1、网络非阻塞编程\" class=\"headerlink\" title=\"2.1、网络非阻塞编程\"></a>2.1、网络非阻塞编程</h3><p>下面给出了网络非阻塞编程的常见设计方式：<br><img src=\"/img/aio_architecture.png\" alt=\"aio_architecture\"></p>\n<ul>\n<li>使用操作系统提供的多路复用事件引擎 API（select&#x2F;poll&#x2F;epoll&#x2F;kqueue etc），将网络套接字的网络读写事件注册到事件引擎中；</li>\n<li>当套接字满足可读或可写条件时，事件引擎设置套接字对应的事件状态并返回给调用者；</li>\n<li>调用者根据套接字的事件状态分别『回调』对应的处理过程；</li>\n<li>对于大部分基于 TCP 的网络应用，数据的读写往往不是一次 IO 就能完成的，这样，对于一次会话过程就会有多次 IO 读写过程，在每次 IO 过程中都需要缓存读写的数据，直至本次数据会话完成。</li>\n</ul>\n<p>下图以非阻塞读为例展示了整个异步非阻塞读及回调处理过程：  </p>\n<p><img src=\"/img/nio_read.png\" alt=\"nio_read\"></p>\n<p>相对于阻塞式读的处理过程（循环读数据直至读完成或关闭），非阻塞读过程的确要复杂很多：</p>\n<ul>\n<li>一次完整的 IO 会话过程会被分割成多次的 IO 过程；</li>\n<li>每次 IO 过程需要缓存部分数据及当前会话的处理状态；</li>\n<li>要求相关的解析器（如：Json&#x2F;Xml&#x2F;Mime 解析器）最好能支持流式解析方式，否则就得需要读到完整数据后才能交给解析器去处理，当遇到业数据较大时就需要分配较大的连续内存块，势必造成系统的内存分配压力；</li>\n<li>因为当前绝大部分后台系统（如数据库、存储系统、缓存系统）所提供的客户端驱动都是阻塞式的，所以无法直接应用在非阻塞通信应用中，从而限制了非阻塞通信方式的应用场景；</li>\n<li>因为多次 IO 过程将应用的业务处理逻辑分割的支离破碎，大大增加了业务编写过程的复杂度，降低了开发效率，同时加大了后期的不易维护性。</li>\n</ul>\n<h3 id=\"2-2、网络协程编程\"><a href=\"#2-2、网络协程编程\" class=\"headerlink\" title=\"2.2、网络协程编程\"></a>2.2、网络协程编程</h3><h4 id=\"2-2-1、几个概念\"><a href=\"#2-2-1、几个概念\" class=\"headerlink\" title=\"2.2.1、几个概念\"></a>2.2.1、几个概念</h4><p>在了解使用协程编写网络程序之前，需要先了解几个概念：</p>\n<ul>\n<li><strong>最小调度单元：</strong> 当前大部分操作系统的最小调度单元是线程，即在单核或多核 CPU 环境中，操作系统是以线程为基本调度单元的，操作系统负责将多个线程任务唤入唤出；</li>\n<li><strong>上下文切换：</strong> 当操作系统需要将某个线程挂起时，会将该线程在 CPU 寄存器中的栈指针、状态字等保存至该线程的内存栈中；当操作系统需要唤醒某个被挂起的线程时（重新放置在CPU中运行），会将该线程之前被挂起的栈指针重新置入 CPU 寄存器中，并恢复之前保留的，从而使该线程得以运行；通过这样的挂起与唤醒操作，便完成了不同线程间的上下文切换；</li>\n<li><strong>并行与网络并发：</strong> 并行是指同一『时刻』同时运行的任务数，并行任务数量取决于 CPU 核心数量；而网络并发是指在某一『时刻』网络连接的数量；类似于二八定律，在客户端与服务端保持 TCP 长连接时，大部分连接是空闲的，所以服务端只需响应少量活跃的网络连接即可，服务端采用多路复用技术，即使使用单核也可以支持 100K 个网络连接。</li>\n</ul>\n<h4 id=\"2-2-2、协程的切换过程\"><a href=\"#2-2-2、协程的切换过程\" class=\"headerlink\" title=\"2.2.2、协程的切换过程\"></a>2.2.2、协程的切换过程</h4><p>前面提到操作系统进行任务调度的最小单元是线程，操作系统无法感知这些协程的存在，自然也就无法对其进行调度，因此存在于线程中的大量协程需要相互协作，合理地占用 CPU 时间片，在合适的运行点（如：网络阻塞点）主动让出 CPU，给其它协程提供运行的机会。<br>每个协程都会经历如下过程：  </p>\n<p><img src=\"/img/fiber_running.png\" alt=\"fiber_running\"></p>\n<p>协程之间的切换一般可分为『星形切换』和『环形切换』，参照下图：<br><img src=\"/img/fiber_switch.png\" alt=\"fiber_switch\"></p>\n<p>当有大量的协程需要运行时，在『环形切换』模式下，前一个协程运行完毕后直接『唤醒』并切换至下一个协程，而无需象『星形切换』那样先切换至调度原点，再从调度原点来『唤醒』下一个协程；因为『环形切换』要比『星形切换』节省了一次上下文的切换过程，所以『环形切换』方式的切换效率更高。</p>\n<h4 id=\"2-2-3、网络过程协程化\"><a href=\"#2-2-3、网络过程协程化\" class=\"headerlink\" title=\"2.2.3、网络过程协程化\"></a>2.2.3、网络过程协程化</h4><p>下图是使网络过程协程化的示意图：</p>\n<p><img src=\"/img/fiber_schedule.png\" alt=\"fiber_schedule\"></p>\n<ul>\n<li>在网络协程库中，内部有一个缺省的 <code>IO调度协程</code>，其负责处理与网络 IO 相关的协程调度过程，故称之为『<strong>IO 调度协程</strong>』；</li>\n<li>每一个网络连接绑定一个套接字句柄，该套接字绑定一个协程；</li>\n<li>当对网络套接字进行读写操作时，将该套接字添加至 IO 调度协程的事件引擎中并设置读写事件，然后将该协程挂起；这样所有处于读写等待状态的网络协程都被挂起，且与之关联的网络套接字均由 IO 调度协程的事件引擎统一监控管理；</li>\n<li>当某些网络套接字满足可读或可写条件时，IO 调度协程的事件引擎返回这些套接字的状态，IO 调度协程找到与这些套接字绑定的协程对象，然后分别唤醒这些协程，使之依次运行；</li>\n<li>IO 事件协程内部本身也是由系统事件引擎（如：Linux 下的 epoll 事件引擎）驱动的，其内部 IO 事件的驱动机制和上面介绍的非阻塞过程相似，当某个套接字句柄『准备就绪』时，IO 调度协程便将其所绑定的协程添加进协程调度队列中，待本次 IO 调度协程返回后，会依次运行协程调度队列里的所有协程。</li>\n</ul>\n<h4 id=\"2-2-4、网络协程示例\"><a href=\"#2-2-4、网络协程示例\" class=\"headerlink\" title=\"2.2.4、网络协程示例\"></a>2.2.4、网络协程示例</h4><p>下面给出一个使用协程方式编写的网络服务器程序，该程序位于：<a href=\"https://github.com/iqiyi/libfiber\">https://github.com/iqiyi/libfiber</a> 。</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdlib.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;patch.h&quot;</span>  <span class=\"hljs-comment\">// 主要包含：SOCKET, socket_close(), socket_listen(), socket_accept()</span></span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">size_t</span> __stack_size  = <span class=\"hljs-number\">128000</span>;  <span class=\"hljs-comment\">// 协程栈大小设为 128 KB 左右</span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">fiber_client</span><span class=\"hljs-params\">(ACL_FIBER *fb, <span class=\"hljs-type\">void</span> *ctx)</span> &#123;<br>    SOCKET fd = (<span class=\"hljs-type\">int</span> *) ctx;<br>    <span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>    <span class=\"hljs-built_in\">free</span>(ctx);<br>    <span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>        <span class=\"hljs-type\">int</span> ret = acl_fiber_recv(fd, buf, <span class=\"hljs-keyword\">sizeof</span>(buf), <span class=\"hljs-number\">0</span>);  <span class=\"hljs-comment\">// 读客户端请求数据</span><br>        <span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">// 说明网络连接关闭</span><br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>            <span class=\"hljs-keyword\">if</span> (acl_fiber_last_error() == FIBER_EINTR) &#123;<br>                <span class=\"hljs-keyword\">continue</span>;<br>            &#125;<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        <span class=\"hljs-keyword\">if</span> (acl_fiber_send(fd, buf, ret, <span class=\"hljs-number\">0</span>) &lt; <span class=\"hljs-number\">0</span>) &#123;  <span class=\"hljs-comment\">// 回写数据</span><br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>    &#125;<br>    socket_close(fd);  <span class=\"hljs-comment\">// 关闭套接字</span><br>&#125;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">fiber_accept</span><span class=\"hljs-params\">(ACL_FIBER *fb, <span class=\"hljs-type\">void</span> *ctx)</span> &#123;<br>    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *addr = (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *) ctx;<br>    SOCKET lfd = socket_listen(<span class=\"hljs-string\">&quot;127.0.0.1&quot;</span>, <span class=\"hljs-number\">9001</span>);  <span class=\"hljs-comment\">// 创建监听套接字</span><br>    assert(lfd &gt;= <span class=\"hljs-number\">0</span>);<br>    <span class=\"hljs-keyword\">for</span> (;;) &#123;<br>        SOCKET *pfd, cfd = socket_accept(lfd);  <span class=\"hljs-comment\">// 等待客户端连接</span><br>        <span class=\"hljs-keyword\">if</span> (cfd == <span class=\"hljs-number\">-1</span>) &#123;<br>            <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept error %s\\r\\n&quot;</span>, acl_fiber_last_serror());<br>            <span class=\"hljs-keyword\">break</span>;<br>        &#125;<br>        pfd  = (<span class=\"hljs-type\">int</span> *) <span class=\"hljs-built_in\">malloc</span>(<span class=\"hljs-keyword\">sizeof</span>(SOCKET));<br>        *pfd = cfd;<br>        acl_fiber_create(fiber_client, pfd, __stack_size);  <span class=\"hljs-comment\">// 创建协程处理连接请求</span><br>    &#125;<br>    acl_fiber_schedule_stop();  <span class=\"hljs-comment\">// 停止协程调度器</span><br>&#125;<br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>    <span class=\"hljs-comment\">// 指定 IO 事件引擎类型，在 Linux 下将采用 epoll</span><br>    <span class=\"hljs-type\">int</span> event_mode = FIBER_EVENT_KERNEL;<br><br>    <span class=\"hljs-comment\">// 创建网络监听协程，用来接收客户端连接请求</span><br>    acl_fiber_create(fiber_accept, <span class=\"hljs-literal\">NULL</span>, __stack_size);<br><br>    <span class=\"hljs-comment\">// 开始运行协程调度器</span><br>    acl_fiber_schedule_with(event_mode);<br>    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>该网络协程服务器程序处理流程为：</p>\n<ul>\n<li>创建一个监听协程，其『堵』在  <code>accept()</code> 调用上，等待客户端连接；</li>\n<li>启动协程调度器，开始运行新创建的监听协程；</li>\n<li>监听协程每当接收一个客户端连接，便创建一个客户端协程单独处理该网络连接，然后监听协程继续等待下一个客户端连接；</li>\n<li>客户端协程以『阻塞』方式读写网络连接数据；</li>\n<li>客户端连接处理完毕，关闭连接，并退出协程。</li>\n</ul>\n<p>从该例子可以看出，网络协程的处理过程都是顺序方式，比较符合人的思维模式；我们很容易将该例子改成线程方式，处理逻辑和协程方式相似，但协程方式更加轻量、占用资源更少，并发处理能力更强。<br>简单的表面必定隐藏着复杂的底层设计，因为网络协程过程在底层还是需要转为『非阻塞』处理过程，只是使用者并未感知而已。</p>\n<h2 id=\"三、网络协程核心设计要点\"><a href=\"#三、网络协程核心设计要点\" class=\"headerlink\" title=\"三、网络协程核心设计要点\"></a>三、网络协程核心设计要点</h2><p>在介绍了网络协程的基本设计原理后，本章节主要介绍 <code>libfiber</code> 网络协程的核心设计要点，为网络协程应用实践化提供了基本的设计思路。</p>\n<h3 id=\"3-1、协程调度\"><a href=\"#3-1、协程调度\" class=\"headerlink\" title=\"3.1、协程调度\"></a>3.1、协程调度</h3><p>libfiber 采用了单线程调度方式，主要是为了避免设计的复杂性及效率上的影响。如果设计成多线程调度模式，则必须首先需要考虑：</p>\n<ul>\n<li>多核环境下 CPU 缓存亲和性：因为 CPU 本身有高效的多级缓存，虽然 CPU 多级缓存容量较内存小的多，但访问效率却远高于内存，单线程调度方式下，可以方便编译器有效地进行 CPU 缓存使用优化，使运行指令和共享数据尽可能放置在 CPU 缓存中，而如果采用多线程调度方式，多个线程间共享的数据就可能使 CPU 缓存失效，会造成调度线程越多，协程的运行效率越低的问题；</li>\n<li>多线程分配任务时的同步问题：当多个线程需要从公共协程任务资源中获取协程任务时，必然需要采用增加『锁』保护机制，一旦产生大量的『锁』冲突，则势必会造成运行性能的严重损耗；</li>\n<li>事件引擎操作优化：下面会介绍在单线程调度模式下的事件引擎操作优化，在多线程调度则很难进行如此优化。</li>\n</ul>\n<p>当然，单线程调度也需解决如下问题：</p>\n<ul>\n<li>如何有效地使用多核：在单线程调度方式下，该线程内的多个协程在运行时仅能使用单核，这显示是不合理的，解决方案为：<ul>\n<li>启动多个进程，每个进程运行一个线程;</li>\n<li>同一进程内启动多个线程，每个线程运行独立的协程调度过程；</li>\n</ul>\n</li>\n<li>多个线程之间的资源共享：因为协程调度是不跨线程的，在设计协程互斥锁时需要考虑：<ul>\n<li>协程锁需要支持『同一线程内的协程之间、不同线程的协程之间、协程线程与非协程线程之间』的互斥；</li>\n<li>网络连接池的线程隔离机制，即需要为每个线程建立各自独立的连接池，防止连接对象在不同线程的协程之间共享，否则便会造成同一网络连接在不同线程的协程之间使用，破坏单线程调度规则；</li>\n</ul>\n</li>\n<li>需要防止线程内的某个协程『疯狂』占用 CPU 资源，导致本线程内的其它协程得不到运行的机会，虽然此类问题在多线程调度时也会造成问题，但显然在单线程调度时造成的后果更为严重。</li>\n</ul>\n<h3 id=\"3-2、协程事件引擎设计\"><a href=\"#3-2、协程事件引擎设计\" class=\"headerlink\" title=\"3.2、协程事件引擎设计\"></a>3.2、协程事件引擎设计</h3><h4 id=\"3-2-1、跨平台性\"><a href=\"#3-2-1、跨平台性\" class=\"headerlink\" title=\"3.2.1、跨平台性\"></a>3.2.1、跨平台性</h4><p>libfiber 的事件引擎支持现在主流的操作系统，从而为 libfiber 的跨平台特性提供了有力的支撑，下面为 libfiber 事件引擎所支持的平台：</p>\n<ul>\n<li><strong>Linux：</strong> sekect&#x2F;poll&#x2F;epoll&#x2F;io_uring，epoll 为 Linux 内核级事件引擎，采用事件触发机制，不象 select&#x2F;poll 的轮循方式，所以 epoll 在处理大并发网络连接时运行效率更高；而 io_uring 引擎是在内核5.1以后出现的新的事件引擎，由 Facebook 的 Jens Axboe(IO 压测工作 fio 作者) 设计完成，该引擎为真正的异步 IO 模型（为 IO 完成模型），统一了网络 IO 与文件 IO 过程（不象 epoll 仅支持网络，因为其是事件通知方式，无法预知 IO 何时完成）；</li>\n<li><strong>BSD&#x2F;MacOS：</strong> select&#x2F;poll&#x2F;kqueue，kqueue 也为内核级事件引擎，在大并发环境下具有更高的性能；</li>\n<li><strong>Windows：</strong> select&#x2F;poll&#x2F;iocp&#x2F;Windows 窗口消息，其中 iocp 为 Windows 平台下的内核级高效事件引擎；libfiber 支持采用界面消息引擎做为底层的事件引擎，这样在编写 Windows 界面程序的网络模块时便可以使用协程方式了，之前人们在 Windows 平台编写界面程序的网络模块时，一般采用以下两种方式：<ul>\n<li>采用非阻塞方式，网络模块与界面模块在同一线程中；</li>\n<li>将网络模块放到独立的线程中运行，运行结果通过界面消息『传递』到界面线程中；</li>\n</ul>\n</li>\n</ul>\n<p>现在 libfiber 支持 Windows 界面消息引擎，我们就可以在界面线程中直接创建网络协程，直接进行阻塞式网络编程了。(Windows 界面网络协程示例：<a href=\"https://github.com/iqiyi/libfiber/tree/master/samples/WinEchod\">https://github.com/iqiyi/libfiber/tree/master/samples/WinEchod</a> )</p>\n<h4 id=\"3-2-2、运行效率\"><a href=\"#3-2-2、运行效率\" class=\"headerlink\" title=\"3.2.2、运行效率\"></a>3.2.2、运行效率</h4><p>大家在谈论网络协程程序的运行效率时，往往只重视协程的切换效率，但却忽视了事件引擎对于性能影响的重要性，虽然现在很网络协程库所采用的事件引擎都是内核级的，但仍需要合理使用才能发挥其最佳性能。 </p>\n<p>在使用 libfiber 的早期版本编译网络协程服务程序时，虽然在 Linux 平台上也是采用了 <code>epoll</code> 事件引擎，但在对网络协程服务程序进行性能压测（使用用系统命令 『<code># perf top -p pid</code>』 观察运行状态）时，却发现 <code>epoll_ctl</code> API 占用了较高的 CPU，分析原因是 <code>epoll_ctl</code> 使用次数过多导致的：因为 <code>epoll_ctl</code> 内部在对套接字句柄进行添加、修改或删除事件操作时，需要先通过红黑树的查找算法找到其对应的内部套接字对象（红黑树的查找效率并不是\bO(1)的），如果 epoll_ctl 的调用次数过多必然会造成 CPU 的占用较高。 </p>\n<p>因为 TCP 数据在传输时是流式的，这就意味着数据接收者经常需要多次读操作才能获得完整的数据，反映到网络协程处理流程上如下图所示：</p>\n<p><img src=\"/img/fiber_io_switch.png\" alt=\"fiber_io_switch\"></p>\n<p>仔细观察上面处理流程，可以发现在图中的标注4（唤醒协程）和标注5（挂起协程）之间的两个事件操作：<code>标注2取消读事件</code> 与 <code>标注3注册读事件</code>，再结合 <code>标注1注册读事件</code>，完全可以把注2和标注3处的两个事件取消，因为标注1至标注3的目标是 <code>注册读事件</code>。最后，通过缓存事件操作的中间状态，合并中间态的事件操作过程，使 libfiber 的 IO 处理性能提升 20% 左右。</p>\n<p>下图给出了采用 libfiber 编写的回显服务器与采用其它网络协程库编写的回显服务器的性能对比（对比单核条件下的 IO 处理能力）：</p>\n<p><img src=\"/img/benchmark.png\" alt=\"benchmark\"></p>\n<p>在 libfiber 中之所以可以针对中间的事件操作过程进行合并处理，主要是因为 libfiber 的调度过程是单线程模式的，如果想要在多线程调度器中实现事件过程的合并处理则难度就要大的多：当套接字所绑定的协程因IO可读被唤醒时，假设不取消该套接字的读事件，则该协程被某个线程『拿走』后，内核又因接收到新数据而通知协程调度器，此时协程调度器就不知该如何处理了。</p>\n<h3 id=\"3-3、协程同步机制\"><a href=\"#3-3、协程同步机制\" class=\"headerlink\" title=\"3.3、协程同步机制\"></a>3.3、协程同步机制</h3><h4 id=\"3-3-1、单一线程内部的协程互斥\"><a href=\"#3-3-1、单一线程内部的协程互斥\" class=\"headerlink\" title=\"3.3.1、单一线程内部的协程互斥\"></a>3.3.1、单一线程内部的协程互斥</h4><p>对于象 libfiber 这样的采用单线程调度方案的协程库而言，如果互斥加锁过程仅限于同一个调度线程内部，则实现一个协程互斥锁是比较容易的，下图为 libfiber 中单线程内部使用的协程互斥锁的处理流程图（参考源文件：fiber_lock.c）：</p>\n<p><img src=\"/img/fiber_lock.png\" alt=\"fiber_lock\"></p>\n<p>同一线程内的协程在等待锁资源时，该协程将被挂起并被加入锁等待队列中，当加锁协程解锁后会唤醒锁等待队列中的第一个协程，单线程内部的协程互斥锁正是利用了协程的挂起和唤醒机制。  </p>\n<h4 id=\"3-3-2、多线程之间的协程互斥\"><a href=\"#3-3-2、多线程之间的协程互斥\" class=\"headerlink\" title=\"3.3.2、多线程之间的协程互斥\"></a>3.3.2、多线程之间的协程互斥</h4><p>虽然 libfiber 的协程调度器是单线程模式的，但却可以启动多个线程使每个线程运行独立的协程调度器，如果一些资源需要在多个线程中的协程间共享，则就需要有一把可以跨线程使用的协程互斥锁。在将 libfiber 应用在多线程的简单场景时，也许直接使用系统提供的线程锁就可以解决很多问题，但线程锁当遇到如下场景时就显得无能为力：</p>\n<p><img src=\"/img/dead_lock.png\" alt=\"dead_lock\"></p>\n<p>上述显示了系统线程互斥锁在 libfiber 使用时遇到的死锁问题：</p>\n<ul>\n<li>线程A 中的协程A1 成功对线程锁1加锁；</li>\n<li>线程B 中的协程B2 对线程锁2成功加锁；</li>\n<li>当线程A 中的协程A2 想要对线程锁2 加锁而阻塞时，则会使线程A 的协程调度器阻塞，从而导致整个线程A 中的所有协程被系统挂起；同样，线程B 也会因协程B1 阻塞在线程锁1 上而被阻塞；最终造成了死锁问题。</li>\n</ul>\n<p>产生上述死锁的根本原因是单线程调度机制以及操作系统的最小调度单元是线程，系统对于协程是无感知的。因此，在 libfiber 中专门设计了可用于在线程的协程之间使用的事件互斥锁（源码参见 fiber_event.c, 当前最新的是 fiber_mutex.c，性能更好且占用资源更少），其设计原理如下：</p>\n<p><img src=\"/img/fiber_event.png\" alt=\"fiber_event\"></p>\n<p>该可用于在线程之间的协程进行互斥的事件互斥锁的处理流程为：</p>\n<ul>\n<li>协程B（假设其属于线程b）已经对事件锁加锁后；</li>\n<li>协程A（假设其属于线程a）想对该事件锁加锁时，对原子数加锁失败后创建IO管道，将IO读管道置入该事件锁的IO读等待队列中，此时协程A被挂起；</li>\n<li>当协程B 对事件锁解锁时，会首先获得协程A 的读管道，解锁后再向管道中写入消息，从而唤醒协程A；</li>\n<li>协程A 被唤醒后读取管道中的消息，然后再次尝试对事件锁中的原子数加锁，如加速成功便可以继续运行，否则会再次进入睡眠状态（有可能此事件锁又被其它协程提前抢占）。</li>\n</ul>\n<p>在上述事件锁的加&#x2F;解锁处理流程中，使用原子数和IO管道的好处是：</p>\n<ul>\n<li>通过使用原子数可以使协程快速加锁空闲的事件锁，原子数在多线程或协程环境中的行为相同的，可以保证安全性；</li>\n<li>当锁被占用时，通过等待管道IO 方式使当前协程挂起，而又不会干扰该协程所属线程的正常运行；</li>\n<li>在 Linux 平台上可以使用 eventfd 代替管道，占用资源更少。</li>\n</ul>\n<h4 id=\"3-3-3、协程条件变量\"><a href=\"#3-3-3、协程条件变量\" class=\"headerlink\" title=\"3.3.3、协程条件变量\"></a>3.3.3、协程条件变量</h4><p>我们在使用线程编程时，都知道线程条件变量的价值：在线程之间传递消息时往往需要组合线程条件变量和线程锁。因此，在 libfiber 中同样设计了协程条件变量（源码见 fiber_cond.c），通过组合使用 libfiber 中的协程事件锁（fiber_event.c，目前使用 fiber_mutex.c）和协程条件变量，用户可以编写出用于在线程之间、线程与协程之间、线程内的协程之间、线程间的协程之间进行消息传递的消息队列。下图为使用 libfiber 中协程条件变量时的交互过程：</p>\n<p><img src=\"/img/fiber_cond.png\" alt=\"fiber_cond\"></p>\n<p>这是一个典型的 <code>生产者-消费者</code> 问题，通过组合使用协程条件变量和事件锁可以轻松实现。</p>\n<h4 id=\"3-3-4、协程信号量\"><a href=\"#3-3-4、协程信号量\" class=\"headerlink\" title=\"3.3.4、协程信号量\"></a>3.3.4、协程信号量</h4><p>使用网络协程库编写的网络服务很容易实现高并发功能，可以接入大量的客户端连接，但是后台系统（如：数据库）却未必支持高并发，即使是支持高并的缓存系统（如 Redis）当连接数达高时性能也会下降，所以协程服务模块不能将前端的并发压力传递到后端，给后台系统造成很大的压力，我们需要提供一种高并发连接卸载机制，以保证后台系统可以平稳地运行，在 libfiber 中提供了协程信号量（源码见：fiber_semc.c），下面是使用 libfiber 中的协程信号量对于后台系统的并发连接卸载保护示意图：</p>\n<p><img src=\"/img/fiber_sem.png\" alt=\"fiber_sem\"></p>\n<p>当有大量协程需要访问后台系统时，通过协程信号量将大量的协程『挡在外面』，只允许部分协程与后端系统建立连接。<br><strong>注：</strong> 目前 libfiber 的协程信号量仅用在同一线程内部，还不能跨线程使用，要想在多线程环境中使用，需在每个线程内部为协程创建独立的协程信号量。</p>\n<h3 id=\"3-4、协程共享栈\"><a href=\"#3-4、协程共享栈\" class=\"headerlink\" title=\"3.4、协程共享栈\"></a>3.4、协程共享栈</h3><p>协程网络编程相对于非阻塞网络编程简单太多，大大方便了开发者编写支持高并发的服务程序；但对于有栈协程，意味着每个协程都要占用一段内存用来存放协程栈，所以并发越高，内存占用越多也成为有栈协程的一大弊端，但仔细分析函数压栈出栈及协程挂起唤醒过程，我们会发现在协程挂起时所占用的栈空间大小要远小于协程实际运行过程中占用的最大栈空间大小（考虑到应用业务逻辑的复杂性，可能会存在大量的函数及变量压栈过程，所以占用的栈空间会比较大），而在一个 libfiber 线程空间中只有一个运行栈，所以只需保证一个较大的运行栈空间即可，当协程被挂起时只需将其栈从运行栈中拷贝并保存出来（这个栈空间相对要小一些），而被挂起的协程被唤醒时，只需将其保存的栈拷贝到线程的运行栈上即可。在实践中这的确可以大幅减少高并发时的内存使用，虽然进行栈拷贝时会耗费一些时间，但整体影响并不太大。</p>\n<p>相对于栈拷贝时的时间损耗，在使用共享栈方式编程时有一点需要特别注意：创建在栈上的变量不能在协程之间或协程与线程之间共享，即是说，一个协程 F1 中的变量 A 传递给另一个协程 F2，并等待 F2 处理后返回，此时的 A 变量不能被创建在 F1 的栈上，因为运行栈在由 F1 切换到 F2 时，变量 A 的地址空间“暂时消失了”，此时变成了 F2 的栈空间，如果该变量在 F2 中继续被使用的话，就会存在地址非法使用的问题；解决变量在协程间共享的方法是将变量创建在堆上（即用 malloc 或 new 创建）。</p>\n<p>注：共享栈的想法最初应该是在腾讯的 libco 中提出的，应该也是为了解决大并发时的内存占用问题。</p>\n<h3 id=\"3-5、域名解析\"><a href=\"#3-5、域名解析\" class=\"headerlink\" title=\"3.5、域名解析\"></a>3.5、域名解析</h3><p>网络协程库既然面向网络，自然离不开域名的协程化支持，现在很多网络协程库的设计者往往忽视了这一点，有些网络协程库在使用系统 API 进行域名解析时为了防止阻塞协程调度器，将域名解析过程（即调用 gethostbyname&#x2F;getaddrinfo）扔给独立的线程去执行，当调用系统 API 进行域名解析并发量较大时必然会造成很多线程资源被占用。在 libfiber 早期通过集成第三方 dns 源码，实现了域名解析过程的协程化，基本满足了大部分服务端应用系统对于域名解析的需求；后来因为跨平台性及代码安全性的需要，在 libfiber 中实现了与域名解析相关的 DNS 协议，替换了第三方 DNS 库。</p>\n<h3 id=\"3-6、Hook-系统-API\"><a href=\"#3-6、Hook-系统-API\" class=\"headerlink\" title=\"3.6、Hook 系统 API\"></a>3.6、Hook 系统 API</h3><p>相对于网络协程的出现时间，很多网络库很早就存在了，并且大部分已有的网络库都是阻塞式的，要改造这些网络库使之协程化的成本是非常巨大的，我们不可能采用协程方式将这些网络库重新实现一遍，目前一个广泛采用的方案是 Hook 与 IO 相关的系统中 API，在 Unix 平台上 Hook 系统 API 相对简单，在初始化时，先加载并保留系统 API 的原始地址，然后编写一个与系统 API 函数名相同且参数也相同的函数，将这段代码与应用代码一起编译，则编译器会优先使用这些 Hook API，下面的代码给出了在 Unix 平台上 Hook 系统 API 的简单示例：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs C\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-title function_\">ssize_t</span> <span class=\"hljs-params\">(*read_fn)</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span>, <span class=\"hljs-type\">void</span> *, <span class=\"hljs-type\">size_t</span>)</span>;<br><span class=\"hljs-type\">static</span> read_fn __sys_read = <span class=\"hljs-literal\">NULL</span>;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">hook_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> &#123;<br>    __sys_read = (read_fn) dlsym(RTLD_NEXT, <span class=\"hljs-string\">&quot;read&quot;</span>);<br>    assert(__sys_read);<br>&#125;<br><br><span class=\"hljs-type\">ssize_t</span> <span class=\"hljs-title function_\">read</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> fd, <span class=\"hljs-type\">void</span> *buf, <span class=\"hljs-type\">size_t</span> count)</span> &#123;<br>    <span class=\"hljs-keyword\">if</span> (__sys_read == <span class=\"hljs-literal\">NULL</span>) &#123;<br>        hook_init();<br>    &#125;<br>    <span class=\"hljs-keyword\">return</span> __sys_read(fd, buf, count);<br>&#125;<br></code></pre></td></tr></table></figure>\n<p>在 libfiber 中 hook 了大部分与 IO 及网络相关的系统 API，下面列出 libfiber 所 Hook 的系统 API：</p>\n<ul>\n<li><strong>IO 相关 API</strong><ul>\n<li><strong>读 API：</strong> read&#x2F;readv&#x2F;recv&#x2F;recvfrom&#x2F;recvmsg；</li>\n<li><strong>写 API：</strong> write&#x2F;writev&#x2F;send&#x2F;sendto&#x2F;sendmsg&#x2F;sendfile64；</li>\n</ul>\n</li>\n<li><strong>网络相关 API</strong><ul>\n<li><strong>套接字 API：</strong> socket&#x2F;listen&#x2F;accept&#x2F;connect；</li>\n<li><strong>事件引擎 API：</strong> select&#x2F;poll，epoll: epoll_create, epoll_ctl, epoll_wait；</li>\n<li><strong>域名解析 API：</strong> gethostbyname&#x2F;gethostbyname_r, getaddrinfo&#x2F;freeaddrinfo。</li>\n</ul>\n</li>\n</ul>\n<p>通过 Hook API 方式，libfiber 已经可以使 Mysql 客户端库、一些 HTTP 通信库及 Redis 客户端库的网络通信部分协程化，这样在使用网络协程编写服务端应用程序时，大大降低了编程复杂度及改造成本。</p>\n<p>为了在 Windows 平台上 Hook IO API，libfiber 集成了微软的一个开源库 detours，但该库是用 C++ 编写的，所以只能集成在 libfiber 的 c++ 模块中，即用户在使用时只能通过使用 libfiber c++ 库达到 Hook 系统 IO API 的目的。</p>\n<h2 id=\"四、爱奇艺核心业务的协程实践\"><a href=\"#四、爱奇艺核心业务的协程实践\" class=\"headerlink\" title=\"四、爱奇艺核心业务的协程实践\"></a>四、爱奇艺核心业务的协程实践</h2><h3 id=\"4-1、CDN-核心模块使用协程\"><a href=\"#4-1、CDN-核心模块使用协程\" class=\"headerlink\" title=\"4.1、CDN 核心模块使用协程\"></a>4.1、CDN 核心模块使用协程</h3><p>在爱奇艺的自建 CDN 系统中，作为数据回源及本地缓存的核心软件，奇迅承担了重要角色，该模块采用多线程多协程的软件架构设计，如下所示：</p>\n<p><img src=\"/img/qixun.png\" alt=\"qixun\"></p>\n<p>奇迅回源架构设计的特点总结如下：</p>\n<table>\n<thead>\n<tr>\n<th>特性</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>高并发</td>\n<td>采用网络协程方式，支持高并发接入，同时简化程序设计</td>\n</tr>\n<tr>\n<td>高性能</td>\n<td>采用线程池 + 协程 + 连接池 + 内存池技术，提高业务处理性能</td>\n</tr>\n<tr>\n<td>高吞吐</td>\n<td>采用磁盘内存映射及零拷贝技术，提升磁盘及网络 IO 吞吐能力</td>\n</tr>\n<tr>\n<td>低回源</td>\n<td>合并相同请求，支持部分回源及部分缓存，大大降低回源带宽</td>\n</tr>\n<tr>\n<td>开播快</td>\n<td>采用流式数据读取方式，提升视频开播速度</td>\n</tr>\n<tr>\n<td>可扩展</td>\n<td>模块化分层设计，易于扩展新功能</td>\n</tr>\n<tr>\n<td>易维护</td>\n<td>采用统一服务器编程框架，易管理，好维护</td>\n</tr>\n</tbody></table>\n<p>奇迅的前后端通信模块均采用网络协程方式，分为前端连接接入层和后端下载任务层，为了有效地使用多核，前后端模块均启动多个线程（每个线程运行一个独立的协程调度器）；对于前端连接接入模块，由于采用协程方式，所以：</p>\n<ul>\n<li>支持更高的客户端并发连接；</li>\n<li>允许更多慢连接的存在，而不会消耗更多秕资源；</li>\n<li>更有助于客户端与奇迅之间保持长连接，提升响应性能。</li>\n</ul>\n<p>对于后端下载模块，由于采用协程方式，在数据回源时允许建立更多的并发连接去多个源站下载数据，从而获得更快的下载速度；同时，为了节省带宽，奇迅采用合并回源策略，即当前端多个客户端请求同一段数据时，下载模块将会合并相同的请求，向源站发起一份数据请求，在合并回源请求过程中，因数据共享原因，必然存在如 “3.3.2、多线程之间的协程互斥”章节所提到的多个线程之间的协程同步互斥的需求，通过使用 libfiber 中的事件锁完美地解决了一这需求（其实，当初事件锁就是为了满足奇迅的这一需求而设计编写）。</p>\n<h3 id=\"4-2、高性能-DNS-模块使用协程\"><a href=\"#4-2、高性能-DNS-模块使用协程\" class=\"headerlink\" title=\"4.2、高性能 DNS 模块使用协程\"></a>4.2、高性能 DNS 模块使用协程</h3><p>DNS 做为互联网的基础设施，在整个互联网中发挥着举足轻重的作用，爱奇艺为了满足自身业务的发展需要，自研了高性能 DNS（简称 HPDNS），该 DNS 的软件架构如下图所示：</p>\n<p><img src=\"/img/hpdns.png\" alt=\"hpdns\"></p>\n<p>HPDNS 服务的特点如下：</p>\n<style>\ntable th:first-of-type {\n    width: 50px;\n}\n</style>\n<table>\n<thead>\n<tr>\n<th>优点</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>高性能</td>\n<td>启用 Linux 3.0 内核的 REUSEPORT 功能，提升多线程并行收发包的能力</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>采用 Linux 3.0 内核的 recvmmsg&#x2F;sendmmsg API，提升单次 IO 数据包收发能力</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>采用内存预分配策略，减少内存动态分配&#x2F;释放时的“锁”冲突</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>针对 TCP 服务模式，采用网络协程框架，最大化 TCP 并发怎能能力</td>\n</tr>\n<tr>\n<td>高可用</td>\n<td>采用RCU（Read Copy Update）方式更新视图数据及配置项，无需停止服务，且不影响性能</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>网卡 IP 地址变化自动感知（即可自动添加新 IP 或摘除老IP而不必停止服务）</td>\n</tr>\n<tr>\n<td>&amp;nbsp;</td>\n<td>采用 Keepalived 保证服务高可用</td>\n</tr>\n<tr>\n<td>易管理</td>\n<td>由 master 服务管理模块管理 DNS 进程，控制 DNS 进程的启动、停止、重读配置&#x2F;数据、异常重启及异常报警等</td>\n</tr>\n</tbody></table>\n<p>由于 DNS 协议要求 DNS 服务端需要同时支持 UDP 及 TCP 两种通信方式，除了要求 UDP 模块具备高性能外，对 TCP 模块也要求支持高并发及高性能，该模块的网络通信部分使用 libfiber 编写，从而支持更高的并发连接，同时具备更高的性能，又因启用多个线程调度器，从而可以更加方便地使用多核。</p>\n<h2 id=\"五、总结\"><a href=\"#五、总结\" class=\"headerlink\" title=\"五、总结\"></a>五、总结</h2><p>本文讲述了爱奇艺开源项目 libfiber 网络协程库的设计原理及核心设计要点，描述了 libfiber 的设计特点及优缺点，方便读者了解网络协程的设计原理及运行机制，做到知其然更知其所以然；本文还从爱奇艺自身的项目实践出发，总结了在应用网络协程编程时遇到的问题及解决方案，使读者能够更加全面地了解编写网络协程类应用的注意事项。</p>\n"},{"title":"使用协程方式编写高并发的WEB服务","date":"2016-07-06T13:01:24.000Z","_content":"\n在《使用 acl 协程编写高并发网络服务》中介绍了一个使用 acl 协程库编写高并发网络服务的应用示例，本节将展示一个稍微复杂些且更具实际意义的例子：基于协程的 WEB 服务器程序。下面首先展示这个 WEB 服务器程序：\n\n```c++\n#include \"lib_acl.h\"\t\t\t// acl 基础库头文件\n#include \"fiber/lib_fiber.h\"\t// acl 协程库头文件\n#include \"acl_cpp/lib_acl.hpp\"\t// acl C++ 封装库头文件\n\nclass http_servlet : public acl::HttpServlet\n{\npublic:\n\thttp_servlet(acl::socket_stream* stream, acl::session* session)\n\t\t\t: HttpServlet(stream, session)\n\t{\n\t}\n\n\t~http_servlet(void)\n\t{\n\t}\n\n\t// override\n\tbool doGet(acl::HttpServletRequest& req, acl::HttpServletResponse& res)\n\t{\n\t\treturn doPost(req, res);\n\t}\n\n\t// override\n\tbool doPost(acl::HttpServletRequest&, acl::HttpServletResponse& res)\n\t{\n\t\tconst char* buf = \"hello world!\";\n\t\tsize_t len = strlen(buf);\n\n\t\tres.setContentLength(len);\n\t\tres.setKeepAlive(true);\n\n\t\t// 发送 http 响应体\n\t\treturn res.write(buf, len) && res.write(NULL, 0);\n\t}\n};\n\n#define\t STACK_SIZE\t320000          // 指定协程堆栈大小(字节)\nstatic int __rw_timeout = 0;\t\t// 网络 IO 超时时间(秒)\n\nstatic void http_server(ACL_FIBER *, void *ctx)\n{\n\tacl::socket_stream *conn = (acl::socket_stream *) ctx;\n\n\tprintf(\"start one http_server\\r\\n\");\n\n\tacl::memcache_session session(\"127.0.0.1:11211\");\n\n\t// 基于 ACL HTTP 模块的 Http 服务类\n\thttp_servlet servlet(conn, &session);\n\tservlet.setLocalCharset(\"gb2312\");\n\n\t// 循环处理客户端的 HTTP 请求\n\twhile (true)\n\t{\n\t\t// 调用 acl::HttpServlet 类中的方法，从而触发子类重载的 doPost/doGet 方法\n\t\tif (servlet.doRun() == false)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"close one connection: %d, %s\\r\\n\", conn->sock_handle(), acl::last_serror());\n\n\t// 销毁客户端连接对象\n\tdelete conn;\n}\n\nstatic void fiber_accept(ACL_FIBER *, void *ctx)\n{\n\tconst char* addr = (const char* ) ctx;\n\tacl::server_socket server;\n\n\t// 监听本机服务端口\n\tif (server.open(addr) == false)\n\t{\n\t\tprintf(\"open %s error\\r\\n\", addr);\n\t\texit (1);\n\t}\n\telse\n\t\tprintf(\"open %s ok\\r\\n\", addr);\n\n\twhile (true)\n\t{\n\t\t// 等待接收外来 HTTP 客户端连接\n\t\tacl::socket_stream* client = server.accept();\n\t\tif (client == NULL)\n\t\t{\n\t\t\tprintf(\"accept failed: %s\\r\\n\", acl::last_serror());\n\t\t\tbreak;\n\t\t}\n\n\t\tclient->set_rw_timeout(__rw_timeout);\n\t\tprintf(\"accept one: %d\\r\\n\", client->sock_handle());\n\n\t\t// 创建协程处理 HTTP 客户端连接请求\n\t\tacl_fiber_create(http_server, client, STACK_SIZE);\n\t}\n\n\texit (0);\n}\n\nstatic void usage(const char* procname)\n{\n\tprintf(\"usage: %s -h [help] -s listen_addr -r rw_timeout\\r\\n\", procname);\n}\n\nint main(int argc, char *argv[])\n{\n\tacl::string addr(\"127.0.0.1:9001\");\n\tint  ch;\n\n\twhile ((ch = getopt(argc, argv, \"hs:r:\")) > 0)\n\t{\n\t\tswitch (ch)\n\t\t{\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\treturn 0;\n\t\tcase 's':\n\t\t\taddr = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\t__rw_timeout = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tacl::acl_cpp_init();\n\tacl::log::stdout_open(true);\n\n\t// 创建服务监听协程\n\tacl_fiber_create(fiber_accept, addr.c_str(), STACK_SIZE);\n\n\t// 启动协程调度过程\n\tacl_fiber_schedule();\n\n\treturn 0;\n}\n```\n\n此例子的流程为：创建服务监听协程 ---> 启动协程调度过程 ---> 监听协程收到 HTTP 客户端连接后，创建 HTTP 协程处理该连接 ---> HTTP 协程与 HTTP 客户端进行交互。\n\n因为协程相对于线程来说是非常轻量级的，所以虽然针对每一个 HTTP 客户端连接都会创建一个新的协程，但这并不会费太多系统资源，因而可以支持非常高的并发连接。\n\ngithub：https://github.com/acl-dev/acl\ngitee：http://git.oschina.net/acl-dev/acl\n ","source":"_posts/fiber_web.md","raw":"---\ntitle: 使用协程方式编写高并发的WEB服务\ndate: 2016-07-06 21:01:24\ntags: 协程编程\ncategories: 协程编程\n---\n\n在《使用 acl 协程编写高并发网络服务》中介绍了一个使用 acl 协程库编写高并发网络服务的应用示例，本节将展示一个稍微复杂些且更具实际意义的例子：基于协程的 WEB 服务器程序。下面首先展示这个 WEB 服务器程序：\n\n```c++\n#include \"lib_acl.h\"\t\t\t// acl 基础库头文件\n#include \"fiber/lib_fiber.h\"\t// acl 协程库头文件\n#include \"acl_cpp/lib_acl.hpp\"\t// acl C++ 封装库头文件\n\nclass http_servlet : public acl::HttpServlet\n{\npublic:\n\thttp_servlet(acl::socket_stream* stream, acl::session* session)\n\t\t\t: HttpServlet(stream, session)\n\t{\n\t}\n\n\t~http_servlet(void)\n\t{\n\t}\n\n\t// override\n\tbool doGet(acl::HttpServletRequest& req, acl::HttpServletResponse& res)\n\t{\n\t\treturn doPost(req, res);\n\t}\n\n\t// override\n\tbool doPost(acl::HttpServletRequest&, acl::HttpServletResponse& res)\n\t{\n\t\tconst char* buf = \"hello world!\";\n\t\tsize_t len = strlen(buf);\n\n\t\tres.setContentLength(len);\n\t\tres.setKeepAlive(true);\n\n\t\t// 发送 http 响应体\n\t\treturn res.write(buf, len) && res.write(NULL, 0);\n\t}\n};\n\n#define\t STACK_SIZE\t320000          // 指定协程堆栈大小(字节)\nstatic int __rw_timeout = 0;\t\t// 网络 IO 超时时间(秒)\n\nstatic void http_server(ACL_FIBER *, void *ctx)\n{\n\tacl::socket_stream *conn = (acl::socket_stream *) ctx;\n\n\tprintf(\"start one http_server\\r\\n\");\n\n\tacl::memcache_session session(\"127.0.0.1:11211\");\n\n\t// 基于 ACL HTTP 模块的 Http 服务类\n\thttp_servlet servlet(conn, &session);\n\tservlet.setLocalCharset(\"gb2312\");\n\n\t// 循环处理客户端的 HTTP 请求\n\twhile (true)\n\t{\n\t\t// 调用 acl::HttpServlet 类中的方法，从而触发子类重载的 doPost/doGet 方法\n\t\tif (servlet.doRun() == false)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"close one connection: %d, %s\\r\\n\", conn->sock_handle(), acl::last_serror());\n\n\t// 销毁客户端连接对象\n\tdelete conn;\n}\n\nstatic void fiber_accept(ACL_FIBER *, void *ctx)\n{\n\tconst char* addr = (const char* ) ctx;\n\tacl::server_socket server;\n\n\t// 监听本机服务端口\n\tif (server.open(addr) == false)\n\t{\n\t\tprintf(\"open %s error\\r\\n\", addr);\n\t\texit (1);\n\t}\n\telse\n\t\tprintf(\"open %s ok\\r\\n\", addr);\n\n\twhile (true)\n\t{\n\t\t// 等待接收外来 HTTP 客户端连接\n\t\tacl::socket_stream* client = server.accept();\n\t\tif (client == NULL)\n\t\t{\n\t\t\tprintf(\"accept failed: %s\\r\\n\", acl::last_serror());\n\t\t\tbreak;\n\t\t}\n\n\t\tclient->set_rw_timeout(__rw_timeout);\n\t\tprintf(\"accept one: %d\\r\\n\", client->sock_handle());\n\n\t\t// 创建协程处理 HTTP 客户端连接请求\n\t\tacl_fiber_create(http_server, client, STACK_SIZE);\n\t}\n\n\texit (0);\n}\n\nstatic void usage(const char* procname)\n{\n\tprintf(\"usage: %s -h [help] -s listen_addr -r rw_timeout\\r\\n\", procname);\n}\n\nint main(int argc, char *argv[])\n{\n\tacl::string addr(\"127.0.0.1:9001\");\n\tint  ch;\n\n\twhile ((ch = getopt(argc, argv, \"hs:r:\")) > 0)\n\t{\n\t\tswitch (ch)\n\t\t{\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\treturn 0;\n\t\tcase 's':\n\t\t\taddr = optarg;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\t__rw_timeout = atoi(optarg);\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tacl::acl_cpp_init();\n\tacl::log::stdout_open(true);\n\n\t// 创建服务监听协程\n\tacl_fiber_create(fiber_accept, addr.c_str(), STACK_SIZE);\n\n\t// 启动协程调度过程\n\tacl_fiber_schedule();\n\n\treturn 0;\n}\n```\n\n此例子的流程为：创建服务监听协程 ---> 启动协程调度过程 ---> 监听协程收到 HTTP 客户端连接后，创建 HTTP 协程处理该连接 ---> HTTP 协程与 HTTP 客户端进行交互。\n\n因为协程相对于线程来说是非常轻量级的，所以虽然针对每一个 HTTP 客户端连接都会创建一个新的协程，但这并不会费太多系统资源，因而可以支持非常高的并发连接。\n\ngithub：https://github.com/acl-dev/acl\ngitee：http://git.oschina.net/acl-dev/acl\n ","slug":"fiber_web","published":1,"updated":"2023-01-24T02:11:27.284Z","_id":"cld9lmhgf0000p8fyh62ih70w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在《使用 acl 协程编写高并发网络服务》中介绍了一个使用 acl 协程库编写高并发网络服务的应用示例，本节将展示一个稍微复杂些且更具实际意义的例子：基于协程的 WEB 服务器程序。下面首先展示这个 WEB 服务器程序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span>\t\t\t<span class=\"hljs-comment\">// acl 基础库头文件</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.h&quot;</span>\t<span class=\"hljs-comment\">// acl 协程库头文件</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span>\t<span class=\"hljs-comment\">// acl C++ 封装库头文件</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_servlet</span> : <span class=\"hljs-keyword\">public</span> acl::HttpServlet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_servlet</span>(acl::socket_stream* stream, acl::session* session)<br>\t\t\t: <span class=\"hljs-built_in\">HttpServlet</span>(stream, session)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">http_servlet</span>(<span class=\"hljs-type\">void</span>)<br>\t&#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// override</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doGet</span><span class=\"hljs-params\">(acl::HttpServletRequest&amp; req, acl::HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">doPost</span>(req, res);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// override</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(acl::HttpServletRequest&amp;, acl::HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* buf = <span class=\"hljs-string\">&quot;hello world!&quot;</span>;<br>\t\t<span class=\"hljs-type\">size_t</span> len = <span class=\"hljs-built_in\">strlen</span>(buf);<br><br>\t\tres.<span class=\"hljs-built_in\">setContentLength</span>(len);<br>\t\tres.<span class=\"hljs-built_in\">setKeepAlive</span>(<span class=\"hljs-literal\">true</span>);<br><br>\t\t<span class=\"hljs-comment\">// 发送 http 响应体</span><br>\t\t<span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-built_in\">write</span>(buf, len) &amp;&amp; res.<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>\t STACK_SIZE\t320000          <span class=\"hljs-comment\">// 指定协程堆栈大小(字节)</span></span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __rw_timeout = <span class=\"hljs-number\">0</span>;\t\t<span class=\"hljs-comment\">// 网络 IO 超时时间(秒)</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_server</span><span class=\"hljs-params\">(ACL_FIBER *, <span class=\"hljs-type\">void</span> *ctx)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::socket_stream *conn = (acl::socket_stream *) ctx;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;start one http_server\\r\\n&quot;</span>);<br><br>\t<span class=\"hljs-function\">acl::memcache_session <span class=\"hljs-title\">session</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>)</span></span>;<br><br>\t<span class=\"hljs-comment\">// 基于 ACL HTTP 模块的 Http 服务类</span><br>\t<span class=\"hljs-function\">http_servlet <span class=\"hljs-title\">servlet</span><span class=\"hljs-params\">(conn, &amp;session)</span></span>;<br>\tservlet.<span class=\"hljs-built_in\">setLocalCharset</span>(<span class=\"hljs-string\">&quot;gb2312&quot;</span>);<br><br>\t<span class=\"hljs-comment\">// 循环处理客户端的 HTTP 请求</span><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 调用 acl::HttpServlet 类中的方法，从而触发子类重载的 doPost/doGet 方法</span><br>\t\t<span class=\"hljs-keyword\">if</span> (servlet.<span class=\"hljs-built_in\">doRun</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;close one connection: %d, %s\\r\\n&quot;</span>, conn-&gt;<span class=\"hljs-built_in\">sock_handle</span>(), acl::<span class=\"hljs-built_in\">last_serror</span>());<br><br>\t<span class=\"hljs-comment\">// 销毁客户端连接对象</span><br>\t<span class=\"hljs-keyword\">delete</span> conn;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fiber_accept</span><span class=\"hljs-params\">(ACL_FIBER *, <span class=\"hljs-type\">void</span> *ctx)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ) ctx;<br>\tacl::server_socket server;<br><br>\t<span class=\"hljs-comment\">// 监听本机服务端口</span><br>\t<span class=\"hljs-keyword\">if</span> (server.<span class=\"hljs-built_in\">open</span>(addr) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open %s error\\r\\n&quot;</span>, addr);<br>\t\t<span class=\"hljs-built_in\">exit</span> (<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open %s ok\\r\\n&quot;</span>, addr);<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 等待接收外来 HTTP 客户端连接</span><br>\t\tacl::socket_stream* client = server.<span class=\"hljs-built_in\">accept</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (client == <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept failed: %s\\r\\n&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br><br>\t\tclient-&gt;<span class=\"hljs-built_in\">set_rw_timeout</span>(__rw_timeout);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept one: %d\\r\\n&quot;</span>, client-&gt;<span class=\"hljs-built_in\">sock_handle</span>());<br><br>\t\t<span class=\"hljs-comment\">// 创建协程处理 HTTP 客户端连接请求</span><br>\t\t<span class=\"hljs-built_in\">acl_fiber_create</span>(http_server, client, STACK_SIZE);<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">exit</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* procname)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h [help] -s listen_addr -r rw_timeout\\r\\n&quot;</span>, procname);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">acl::string <span class=\"hljs-title\">addr</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;127.0.0.1:9001&quot;</span>)</span></span>;<br>\t<span class=\"hljs-type\">int</span>  ch;<br><br>\t<span class=\"hljs-keyword\">while</span> ((ch = <span class=\"hljs-built_in\">getopt</span>(argc, argv, <span class=\"hljs-string\">&quot;hs:r:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> (ch)<br>\t\t&#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;s&#x27;</span>:<br>\t\t\taddr = optarg;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;r&#x27;</span>:<br>\t\t\t__rw_timeout = <span class=\"hljs-built_in\">atoi</span>(optarg);<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();<br>\tacl::log::<span class=\"hljs-built_in\">stdout_open</span>(<span class=\"hljs-literal\">true</span>);<br><br>\t<span class=\"hljs-comment\">// 创建服务监听协程</span><br>\t<span class=\"hljs-built_in\">acl_fiber_create</span>(fiber_accept, addr.<span class=\"hljs-built_in\">c_str</span>(), STACK_SIZE);<br><br>\t<span class=\"hljs-comment\">// 启动协程调度过程</span><br>\t<span class=\"hljs-built_in\">acl_fiber_schedule</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>此例子的流程为：创建服务监听协程 —&gt; 启动协程调度过程 —&gt; 监听协程收到 HTTP 客户端连接后，创建 HTTP 协程处理该连接 —&gt; HTTP 协程与 HTTP 客户端进行交互。</p>\n<p>因为协程相对于线程来说是非常轻量级的，所以虽然针对每一个 HTTP 客户端连接都会创建一个新的协程，但这并不会费太多系统资源，因而可以支持非常高的并发连接。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"http://git.oschina.net/acl-dev/acl\">http://git.oschina.net/acl-dev/acl</a>\n </p>\n","site":{"data":{}},"excerpt":"","more":"<p>在《使用 acl 协程编写高并发网络服务》中介绍了一个使用 acl 协程库编写高并发网络服务的应用示例，本节将展示一个稍微复杂些且更具实际意义的例子：基于协程的 WEB 服务器程序。下面首先展示这个 WEB 服务器程序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span>\t\t\t<span class=\"hljs-comment\">// acl 基础库头文件</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;fiber/lib_fiber.h&quot;</span>\t<span class=\"hljs-comment\">// acl 协程库头文件</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span>\t<span class=\"hljs-comment\">// acl C++ 封装库头文件</span></span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_servlet</span> : <span class=\"hljs-keyword\">public</span> acl::HttpServlet<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_servlet</span>(acl::socket_stream* stream, acl::session* session)<br>\t\t\t: <span class=\"hljs-built_in\">HttpServlet</span>(stream, session)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">http_servlet</span>(<span class=\"hljs-type\">void</span>)<br>\t&#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// override</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doGet</span><span class=\"hljs-params\">(acl::HttpServletRequest&amp; req, acl::HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">doPost</span>(req, res);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// override</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">doPost</span><span class=\"hljs-params\">(acl::HttpServletRequest&amp;, acl::HttpServletResponse&amp; res)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* buf = <span class=\"hljs-string\">&quot;hello world!&quot;</span>;<br>\t\t<span class=\"hljs-type\">size_t</span> len = <span class=\"hljs-built_in\">strlen</span>(buf);<br><br>\t\tres.<span class=\"hljs-built_in\">setContentLength</span>(len);<br>\t\tres.<span class=\"hljs-built_in\">setKeepAlive</span>(<span class=\"hljs-literal\">true</span>);<br><br>\t\t<span class=\"hljs-comment\">// 发送 http 响应体</span><br>\t\t<span class=\"hljs-keyword\">return</span> res.<span class=\"hljs-built_in\">write</span>(buf, len) &amp;&amp; res.<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>\t STACK_SIZE\t320000          <span class=\"hljs-comment\">// 指定协程堆栈大小(字节)</span></span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __rw_timeout = <span class=\"hljs-number\">0</span>;\t\t<span class=\"hljs-comment\">// 网络 IO 超时时间(秒)</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_server</span><span class=\"hljs-params\">(ACL_FIBER *, <span class=\"hljs-type\">void</span> *ctx)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::socket_stream *conn = (acl::socket_stream *) ctx;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;start one http_server\\r\\n&quot;</span>);<br><br>\t<span class=\"hljs-function\">acl::memcache_session <span class=\"hljs-title\">session</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;127.0.0.1:11211&quot;</span>)</span></span>;<br><br>\t<span class=\"hljs-comment\">// 基于 ACL HTTP 模块的 Http 服务类</span><br>\t<span class=\"hljs-function\">http_servlet <span class=\"hljs-title\">servlet</span><span class=\"hljs-params\">(conn, &amp;session)</span></span>;<br>\tservlet.<span class=\"hljs-built_in\">setLocalCharset</span>(<span class=\"hljs-string\">&quot;gb2312&quot;</span>);<br><br>\t<span class=\"hljs-comment\">// 循环处理客户端的 HTTP 请求</span><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 调用 acl::HttpServlet 类中的方法，从而触发子类重载的 doPost/doGet 方法</span><br>\t\t<span class=\"hljs-keyword\">if</span> (servlet.<span class=\"hljs-built_in\">doRun</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;close one connection: %d, %s\\r\\n&quot;</span>, conn-&gt;<span class=\"hljs-built_in\">sock_handle</span>(), acl::<span class=\"hljs-built_in\">last_serror</span>());<br><br>\t<span class=\"hljs-comment\">// 销毁客户端连接对象</span><br>\t<span class=\"hljs-keyword\">delete</span> conn;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">fiber_accept</span><span class=\"hljs-params\">(ACL_FIBER *, <span class=\"hljs-type\">void</span> *ctx)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = (<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ) ctx;<br>\tacl::server_socket server;<br><br>\t<span class=\"hljs-comment\">// 监听本机服务端口</span><br>\t<span class=\"hljs-keyword\">if</span> (server.<span class=\"hljs-built_in\">open</span>(addr) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open %s error\\r\\n&quot;</span>, addr);<br>\t\t<span class=\"hljs-built_in\">exit</span> (<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open %s ok\\r\\n&quot;</span>, addr);<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 等待接收外来 HTTP 客户端连接</span><br>\t\tacl::socket_stream* client = server.<span class=\"hljs-built_in\">accept</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (client == <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept failed: %s\\r\\n&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br><br>\t\tclient-&gt;<span class=\"hljs-built_in\">set_rw_timeout</span>(__rw_timeout);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept one: %d\\r\\n&quot;</span>, client-&gt;<span class=\"hljs-built_in\">sock_handle</span>());<br><br>\t\t<span class=\"hljs-comment\">// 创建协程处理 HTTP 客户端连接请求</span><br>\t\t<span class=\"hljs-built_in\">acl_fiber_create</span>(http_server, client, STACK_SIZE);<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">exit</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* procname)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h [help] -s listen_addr -r rw_timeout\\r\\n&quot;</span>, procname);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">acl::string <span class=\"hljs-title\">addr</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;127.0.0.1:9001&quot;</span>)</span></span>;<br>\t<span class=\"hljs-type\">int</span>  ch;<br><br>\t<span class=\"hljs-keyword\">while</span> ((ch = <span class=\"hljs-built_in\">getopt</span>(argc, argv, <span class=\"hljs-string\">&quot;hs:r:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> (ch)<br>\t\t&#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;s&#x27;</span>:<br>\t\t\taddr = optarg;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;r&#x27;</span>:<br>\t\t\t__rw_timeout = <span class=\"hljs-built_in\">atoi</span>(optarg);<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();<br>\tacl::log::<span class=\"hljs-built_in\">stdout_open</span>(<span class=\"hljs-literal\">true</span>);<br><br>\t<span class=\"hljs-comment\">// 创建服务监听协程</span><br>\t<span class=\"hljs-built_in\">acl_fiber_create</span>(fiber_accept, addr.<span class=\"hljs-built_in\">c_str</span>(), STACK_SIZE);<br><br>\t<span class=\"hljs-comment\">// 启动协程调度过程</span><br>\t<span class=\"hljs-built_in\">acl_fiber_schedule</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>此例子的流程为：创建服务监听协程 —&gt; 启动协程调度过程 —&gt; 监听协程收到 HTTP 客户端连接后，创建 HTTP 协程处理该连接 —&gt; HTTP 协程与 HTTP 客户端进行交互。</p>\n<p>因为协程相对于线程来说是非常轻量级的，所以虽然针对每一个 HTTP 客户端连接都会创建一个新的协程，但这并不会费太多系统资源，因而可以支持非常高的并发连接。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"http://git.oschina.net/acl-dev/acl\">http://git.oschina.net/acl-dev/acl</a>\n </p>\n"},{"title":"使用 acl_cpp 库中的 http_request 类实现一个 HTTP 客户端请求的例子","date":"2014-06-02T12:06:24.000Z","_content":"\n之前写过几篇如何使用 acl 库来实现 HTTP 客户端的例子都是基于 C 语言(使用 acl 较为底层的 HTTP 协议库写 HTTP 下载客户端举例, 使用 acl 库开发一个 HTTP 下载客户端)，其实在 acl 的 C++ 库(lib_acl_cpp) 中 HTTP 类功能更为强大，本节将介绍如何使用 acl::http_request 类来写一些简单的 HTTP 客户端示例。\n\n##  一、 acl::http_request 类的一些常用接口\n该 HTTP 请求类有两个构造函数，如下 ：\n\n```c++\n\t/**\n\t * 构造函数：通过该构造函数传入的 socket_stream 流对象并\n\t * 不会被关闭，需要调用者自己关闭\n\t * @param client {socket_stream*} 数据连接流，非空，\n\t *  在本类对象被销毁时该流对象并不会被销毁，所以用户需自行释放\n\t * @param conn_timeout {int} 如果传入的流关闭，则内部会\n\t *  自动重试，此时需要该值表示连接服务器的超时时间(秒)，\n\t *  至于重连流的 IO 读写超时时间是从 输入的流中继承的\n\t * @param unzip {bool} 是否对服务器响应的数据自动进行解压\n\t * 注：当该类实例被多次使用时，用户应该在每次调用前调用\n\t * request_header::http_header::reset()\n\t */\n\thttp_request(socket_stream* client, int conn_timeout = 60,\n\t\tbool unzip = true);\n\n\t/**\n\t * 构造函数：该构造函数内部创建的 socket_stream 流会自行关闭\n\t * @param addr {const char*} WEB 服务器地址\n\t * @param conn_timeout {int} 远程连接服务器超时时间(秒)\n\t * @param rw_timeout {int} IO 读写超时时间(秒)\n\t * @param unzip {bool} 是否对服务器响应的数据自动进行解压\n\t */\n\thttp_request(const char* addr, int conn_timeout = 60,\n\t\tint rw_timeout = 60, bool unzip = true);\n```\n第一个是以已经连接成功的套接字流为参数的构造函数，该构造函数把连接 HTTP 服务器的工作交给用户来完成；第二个是以 HTTP 服务器地址为参数的构造函数，使用该构造函数，则该类对象内部会自动连接 HTTP 服务器。\n\n下面的几个函数接口与 HTTP 发送相关：\n\n```c++\n\t/**\n\t * 获得 HTTP 请求头对象，然后在返回的 HTTP 请求头对象中添加\n\t * 自己的请求头字段或 http_header::reset()重置请求头状态，\n\t * 参考：http_header 类\n\t * @return {http_header&}\n\t */\n\thttp_header& request_header(void);\n\n\t/**\n\t * 向 HTTP 服务器发送 HTTP 请求头及 HTTP 请求体，同时从\n\t * HTTP 服务器读取 HTTP 响应头，对于长连接，当连接中断时\n\t * 会再重试一次，在调用下面的几个 get_body 函数前必须先\n\t * 调用本函数(或调用 write_head/write_body)；\n\t * 正常情况下，该函数在发送完请求数据后会读 HTTP 响应头，\n\t * 所以用户在本函数返回 true 后可以调用：get_body() 或\n\t * http_request::get_clinet()->read_body(char*, size_t)\n\t * 继续读 HTTP 响应的数据体\n\t * @param data {const void*} 发送的数据体地址，非空时自动按\n\t *  POST 方法发送，否则按 GET 方法发送\n\t * @param len {size_} data 非空时指定 data 数据长度\n\t * @return {bool} 发送请求数据及读 HTTP 响应头数据是否成功\n\t */\n\tbool request(const void* data, size_t len);\n\n\t/**\n\t * 当采用流式写数据时，需要首先调用本函数发送 HTTP 请求头\n\t * @return {bool} 是否成功，如果成功才可以继续调用 write_body\n\t */\n\tbool write_head();\n\n\t/**\n\t * 当采用流式写数据时，在调用 write_head 后，可以循环调用本函数\n\t * 发送 HTTP 请求体数据；当输入的两个参数为空值时则表示数据写完；\n\t * 当发送完数据后，该函数内部会自动读取 HTTP 响应头数据，用户可\n\t * 继续调用 get_body/read_body 获取 HTTP 响应体数据\n\t * @param data {const void*} 数据地址指针，当该值为空指针时表示\n\t *  数据发送完毕\n\t * @param len {size_t} data 非空指针时表示数据长度\n\t * @return {bool} 发送数据体是否成功\n\t *  注：当应用发送完数据后，必须再调用一次本函数，同时将两个参数都赋空\n\t */\n\tbool write_body(const void* data, size_t len);\n```\n\n构建及发送 HTTP 请求的过程如下：\n\n- 1、使用两个构造函数之一创建 acl::http_request 请求对象\n- 2、调用 http_request::request_header 获得 HTTP 请求头对象的引用（http_header&），然后对该 HTTP 请求头设置 HTTP 请求的参数\n- 3、http_request 类提供了两种 HTTP 请求调用 方式：\n  - 3.1、当 HTTP 请求方法为 HTTP GET 方法或为 HTTP POST 但数据体可以一次性写入时，可以使用 http_request::request 方法，在调用 http_request::request 时会将 HTTP 请求头及请求体一次性发给 HTTP 服务器；\n  - 3.2   如果为 HTTP POST 请求方法，且 HTTP 数据体内容是流式的（即每次只是要发送部分数据），则应该使用 http_request::write_head 和 http_request::write_body 两个函数，即使用流式方式发送数据时，应首先调用 http_request::write_head 发送 HTTP 请求头，当该函数返回成功后，可以循环调用 http_request::write_body 来发送 HTTP 请求数据体，为了表示 HTTP 请求体数据完毕，必须最后调用一次 http_request::write_body 且两个参数为 0 时以表示数据体发送完毕。\n\n在调用以上 3.1 或 3.2 过程成功发送完 HTTP 请求数据后，这两个过程内部会自动读取 HTTP 服务器发来的 HTTP 响应头。\n\n在上面的步骤 2 获得 HTTP 请求头对象（http_header）后，应该先调用下面的方法设置 HTTP 请求头中的参数：\n\n```c++\n\t/**\n\t * 设置请求的 URL，url 格式示例如下：\n\t * 1、http://www.test.com/\n\t * 2、/cgi-bin/test.cgi\n\t * 3、http://www.test.com/cgi-bin/test.cgi\n\t * 3、http://www.test.com/cgi-bin/test.cgi?name=value\n\t * 4、/cgi-bin/test.cgi?name=value\n\t * 5、http://www.test.com\n\t * 如果该 url 中有主机字段，则内部自动添加主机；\n\t * 如果该 url 中有参数字段，则内部自动进行处理并调用 add_param 方法；\n\t * 调用该函数后用户仍可以调用 add_param 等函数添加其它参数；\n\t * 当参数字段只有参数名没有参数值时，该参数将会被忽略，所以如果想\n\t * 单独添加参数名，应该调用 add_param 方法来添加\n\t * @param url {const char*} 请求的 url，非空指针\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_url(const char* url);\n\n\t/**\n\t * 设置 HTTP 请求头的 HOST 字段\n\t * @param value {const char*} 请求头的 HOST 字段值\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_host(const char* value);\n\n\t/**\n\t * 向请求的 URL 中添加参数对，当只有参数名没有参数值时则：\n\t * 1、参数名非空串，但参数值为空指针，则 URL 参数中只有：{name}\n\t * 2、参数名非空串，但参数值为空串，则 URL参数中为：{name}=\n\t * @param name {const char*} 参数名，不能为空指针\n\t * @param value {const char*} 参数值，当为空指针时，仅添加参数名，\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& add_param(const char* name, const char* value);\n\thttp_header& add_int(const char* name, short value);\n\thttp_header& add_int(const char* name, int value);\n\thttp_header& add_int(const char* name, long value);\n\thttp_header& add_int(const char* name, unsigned short value);\n\thttp_header& add_int(const char* name, unsigned int value);\n\thttp_header& add_int(const char* name, unsigned long value);\n\thttp_header& add_format(const char* name, const char* fmt, ...)\n\t\tACL_CPP_PRINTF(3, 4);\n\n\t/**\n\t * 向 HTTP 头中添加 cookie\n\t * @param name {const char*} cookie 名\n\t * @param value {const char*} cookie 值\n\t * @param domain {const char*} 所属域\n\t * @param path {const char*} 存储路径\n\t * @param expires {time_t} 过期时间，当该值为 0 时表示不过期，\n\t *  > 0 时，则从现在起再增加 expires 即为过期时间，单位为秒\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& add_cookie(const char* name, const char* value,\n\t\tconst char* domain = NULL, const char* path = NULL,\n\t\ttime_t expires = 0);\n\n\t/**\n\t * 设置 HTTP 头中的 Connection 字段，是否保持长连接\n\t * 不过，目前并未真正支持长连接，即使设置了该标志位，\n\t * 则得到响应数据后也会主动关闭连接\n\t * @param on {bool} 是否保持长连接\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_keep_alive(bool on);\n\n\t/**\n\t * 设置 HTTP 头中的 Content-Length 字段\n\t * @param n {long long int} 设置值\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_content_length(long long int n);\n\n\t/**\n\t * 设置 HTTP 头中的 Content-Type 字段\n\t * @param value {const char*} 设置值\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_content_type(const char* value);\n```\n\n以上仅列出了 http_header 类设置 HTTP 请求参数的一些常用方法，其它的方法请参考 http_header.hpp 头文件中的说明。\n\n## 二、acl::http_request 类获得 HTTP 服务器响应数据的常用方法\n上面介绍了使用 acl::http_request 构建 HTTP 请求头及发送请求的接口方法，下面介绍使用 acl::http_request 类中的方法来接收 HTTP 服务器响应过程，在调用 http_request 类中的 request 或 write_body 成功发送完请求数据后，该类对象在这两个方法内部会首先自动接收 HTTP 服务器的响应头数据，若接收过程失败，这两个方法也会返回 false 表示失败，若返回成功，则可以调用 http_request 类对象的 http_status 方法获得 HTTP 服务器的响应状态码（2xx, 3xx, 4xx, 5xx），还可调用 body_length 方法获得 HTTP 响应数据体的长度（当 HTTP 服务器返回的数据格式为 HTTP 块传输时，该函数会返回 -1，所以一般不用显示调用该方法）。下面介绍了主要的与 HTTP 响应相关的方法：\n\n首先是与 HTTP 响应头相关的接口函数，如下：\n\n```c++\n\t/**\n\t * 当发送完请求数据后，内部会自动调用读 HTTP 响应头过程，可以通过此函数获得服务端\n\t * 响应的 HTTP 状态字(2xx, 3xx, 4xx, 5xx)；\n\t * 其实该函数内部只是调用了 http_client::response_status 方法\n\t * @return {int}\n\t */\n\tint http_status() const;\n\n\t/**\n\t * 获得 HTTP 响应的数据体长度\n\t * @return {int64) 返回值若为 -1 则表明 HTTP 头不存在或没有长度字段\n\t */\n#ifdef WIN32\n\t__int64 body_length(void) const;\n#else\n\tlong long int body_length(void) const;\n#endif\n\t/**\n\t * HTTP 数据流(响应流是否允许保持长连接)\n\t * @return {bool}\n\t */\n\tbool keep_alive(void) const;\n\n\t/**\n\t * 获得 HTTP 响应头中某个字段名的字段值\n\t * @param name {const char*} 字段名\n\t * @return {const char*} 字段值，为空时表示不存在\n\t */\n\tconst char* header_value(const char* name) const;\n\n\t/**\n\t * 获得服务器返回的 Set-Cookie 设置的某个 cookie 对象\n\t * @param name {const char*} cookie 名\n\t * @param case_insensitive {bool} 是否区分大小写，true 表示\n\t *  不区分大小写\n\t * @return {const HttpCookie*} 返回 NULL 表示不存在\n\t */\n\tconst HttpCookie* get_cookie(const char* name,\n\t\tbool case_insensitive = true) const;\n```\n\n然后是与读 HTTP 响应数据体相关的接口函数：\n\n```c++\n\t/**\n\t * 是否读完了数据体\n\t * @return {bool}\n\t */\n\tbool body_finish() const;\n\n\t/**\n\t * 当调用 request 成功后调用本函数，读取服务器响应体数据\n\t * 并将结果存储于规定的 xml 对象中\n\t * @param out {xml&} HTTP 响应体数据存储于该 xml 对象中\n\t * @param to_charset {const char*} 当该项非空，内部自动\n\t *  将数据转成该字符集存储于 xml 对象中\n\t * @return {bool} 读数据是否成功\n\t * 注：当响应数据体特别大时不应用此函数，以免内存耗光\n\t */\n\tbool get_body(xml& out, const char* to_charset = NULL);\n\n\t/**\n\t * 当调用 request 成功后调用本函数，读取服务器响应体数据\n\t * 并将结果存储于规定的 json 对象中\n\t * @param out {json&} HTTP 响应体数据存储于该 json 对象中\n\t * @param to_charset {const char*} 当该项非空，内部自动\n\t *  将数据转成该字符集存储于 json 对象中\n\t * @return {bool} 读数据是否成功\n\t * 注：当响应数据体特别大时不应用此函数，以免内存耗光\n\t */\n\tbool get_body(json& out, const char* to_charset = NULL);\n\n\t/*\n\t * 当调用 request 成功后调用本函数，读取服务器全部响应数据\n\t * 存储于输入的缓冲区中\n\t * @param out {string&} 存储响应数据体\n\t * @param to_charset {const char*} 当该项非空，内部自动\n\t *  将数据转成该字符集存储于 out 对象中\n\t * 注：当响应数据体特别大时不应用此函数，以免内存耗光\n\t */\n\tbool get_body(string& out, const char* to_charset = NULL);\n\n\t/*\n\t * 当调用 request 成功后调用本函数，读取服务器响应数据并\n\t * 存储于输入的缓冲区中，可以循环调用本函数，直至数据读完了，\n\t * @param buf {char*} 存储部分响应数据体\n\t * @param size {size_t} buf 缓冲区大小\n\t * @return {int} 返回值 == 0 表示正常读完毕，< 0 表示服务器\n\t *  关闭连接，> 0 表示已经读到的数据，用户应该一直读数据直到\n\t *  返回值 <= 0 为止\n\t *  注：该函数读到的是原始 HTTP 数据体数据，不做解压和字符集\n\t *  解码，用户自己根据需要进行处理\n\t */\n\tint read_body(char* buf, size_t size);\n\n\t/**\n\t * 当调用 request 成功后调用本函数读 HTTP 响应数据体，可以循环调用\n\t * 本函数，本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用\n\t * set_charset 设置了本地字符集，则还同时对数据进行字符集转码操作\n\t * @param out {string&} 存储结果数据\n\t * @param clean {bool} 每次调用本函数时，是否要求先自动将缓冲区 out\n\t *  的数据清空\n\t * @param real_size {int*} 当该指针非空时，存储解压前读到的真正数据\n\t *  长度，如果在构造函数中指定了非自动解压模式且读到的数据 > 0，则该\n\t *  值存储的长度值应该与本函数返回值相同；当读出错或未读到任何数据时，\n\t *  该值存储的长度值为 0\n\t * @return {int} == 0 表示读完毕，可能连接并未关闭；>0 表示本次读操作\n\t *  读到的数据长度(当为解压后的数据时，则表示为解压之后的数据长度，\n\t *  与真实读到的数据不同，真实读到的数据长度应该通过参数 real_size 来\n\t *  获得); < 0 表示数据流关闭，此时若 real_size 非空，则 real_size 存\n\t *  储的值应该为 0\n\t */\n\tint read_body(string& out, bool clean = false, int* real_size = NULL);\n\n\t/**\n\t * 当调用 request 成功后调用本函数来从 HTTP 服务端读一行数据，可以循环调用\n\t * 本函数，直到返回 false 或 body_finish() 返回 true 为止；\n\t * 本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用 set_charset 设置了\n\t * 本地字符集，则还同时对数据进行字符集转码操作\n\t * @param out {string&} 存储结果数据\n\t * @param nonl {bool} 读到的一行数据是否自动去掉尾部的 \"\\r\\n\" 或 \"\\n\"\n\t * @param size {size_t*} 该指针非空时存放读到的数据长度\n\t * @return {bool} 是否读到了一行数据：当返回 true 时表示读到了一行数据，可以\n\t *  通过 body_finish() 是否为 true 来判断是否读数据体已经结束，当读到一个空行\n\t *  且 nonl = true 时，则 *size = 0；当返回 false 时表示未读完整行且读完毕，\n\t *  *size 中存放着读到的数据长度\n\t */\n\tbool body_gets(string& out, bool nonl = true, size_t* size = NULL);\n```\n\n虽然上面提供了多个读 HTTP 响应体数据的方法，但可以分为两大类：1、一次性读所有的数据体；2、以流式方式循环读数据体。 其中，对于“一次性读取所有数据体”的读方法，适合于响应数据体比较小的情形，当响应数据为 xml 或 json 格式时，还提供了直接将响应数据体转为 xml 或 json 对象的读方法；如果响应数据体非常大（如几兆甚至几十兆以上）则应该采用流式方法循环读数据体。\n\n有一点需要注意，除了 \" int read_body(char* buf, size_t size);\" 可以直接读原生的响应数据体外，其它的读方法会将读到数据体自动进行解压、字符集转换操作后将最终结果返回调用者。\n\n此外，为了方便一些文本类应用，在 http_request 类中还提供了 body_gets 方法，用来以行为单位读取 HTTP 响应数据体（当服务器也是以行为单位发送响应数据时才可使用 body_gets 方法）。\n\nacl::http_request 类除了以上接口外，还提供了其它丰富的接口（如：支持 HTTP 断点续传的 Range 相关的方法），如果您觉得这些接口依然不能满足要求，不妨通过 \"http_request::get_client\" 获得 acl::http_client 类对象（该类对象是 acl 有关 http 协议处理中比较基础的 HTTP 通信类），然后再在 acl::http_client 类中查找您所希望的功能接口。\n\n## 三、示例\n下面用一个简单的例子来说明上面一些方法的使用过程：\n\n```c++\n// http_servlet.cpp : 定义控制台应用程序的入口点。\n//\n#include <assert.h>\n#include <getopt.h>\n#include \"acl_cpp/lib_acl.hpp\"\n\nusing namespace acl;\n\n//////////////////////////////////////////////////////////////////////////\n\nclass http_request_test\n{\npublic:\n\thttp_request_test(const char* server_addr, const char* file,\n\t\tconst char* stype, const char* charset)\n\t{\n\t\tserver_addr_= server_addr;\n\t\tfile_ = file;\n\t\tstype_ = stype;\n\t\tcharset_ = charset;\n\t\tto_charset_ = \"gb2312\";\n\t}\n\n\t~http_request_test() {}\n\n\tbool run(void)\n\t{\n\t\tstring body;\n\t\tif (ifstream::load(file_, &body) == false)\n\t\t{\n\t\t\tlogger_error(\"load %s error\", file_.c_str());\n\t\t\treturn false;\n\t\t}\n\n\t\thttp_request req(server_addr_);\n\n\t\t// 添加 HTTP 请求头字段\n\n\t\tstring ctype(\"text/\");\n\t\tctype << stype_ << \"; charset=\" << charset_;\n\n\t\thttp_header& hdr = req.request_header();  // 请求头对象的引用\n\t\thdr.set_url(\"/\");\n\t\thdr.set_content_type(ctype);\n\t\thdr.add_param(\"name1\", \"value1\");\n\t\thdr.add_param(\"name2\", \"value2\");\n\t\t// 发送 HTTP 请求数据\n\t\tif (req.request(body.c_str(), body.length()) == false)\n\t\t{\n\t\t\tlogger_error(\"send http request to %s error\",\n\t\t\t\tserver_addr_.c_str());\n\t\t\treturn false;\n\t\t}\n\n\t\t// 取出 HTTP 响应头的 Content-Type 字段\n\n\t\tconst char* p = req.header_value(\"Content-Type\");\n\t\tif (p == NULL || *p == 0)\n\t\t{\n\t\t\tlogger_error(\"no Content-Type\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// 分析 HTTP 响应头的数据类型\n\t\thttp_ctype content_type;\n\t\tcontent_type.parse(p);\n\n\t\t// 响应头数据类型的子类型\n\t\tconst char* stype = content_type.get_stype();\n\n\t\tbool ret;\n\t\tif (stype == NULL)\n\t\t\tret = do_plain(req);\n\t\telse if (strcasecmp(stype, \"xml\") == 0)\n\t\t\tret = do_xml(req);\n\t\telse if (strcasecmp(stype, \"json\") == 0)\n\t\t\tret = do_json(req);\n\t\telse\n\t\t\tret = do_plain(req);\n\t\tif (ret == true)\n\t\t\tlogger(\"read ok!\\r\\n\");\n\t\treturn ret;\n\t}\n\nprivate:\n\t// 处理 text/plain 类型数据\n\tbool do_plain(http_request& req)\n\t{\n\t\tstring body;\n\t\tif (req.get_body(body, to_charset_) == false)\n\t\t{\n\t\t\tlogger_error(\"get http body error\");\n\t\t\treturn false;\n\t\t}\n\t\tprintf(\"body:\\r\\n(%s)\\r\\n\", body.c_str());\n\t\treturn true;\n\t}\n\n\t// 处理 text/xml 类型数据\n\tbool do_xml(http_request& req)\n\t{\n\t\txml body;\n\t\tif (req.get_body(body, to_charset_) == false)\n\t\t{\n\t\t\tlogger_error(\"get http body error\");\n\t\t\treturn false;\n\t\t}\n\t\txml_node* node = body.first_node();\n\t\twhile (node)\n\t\t{\n\t\t\tconst char* tag = node->tag_name();\n\t\t\tconst char* name = node->attr_value(\"name\");\n\t\t\tconst char* pass = node->attr_value(\"pass\");\n\t\t\tprintf(\">>tag: %s, name: %s, pass: %s\\r\\n\",\n\t\t\t\ttag ? tag : \"null\",\n\t\t\t\tname ? name : \"null\",\n\t\t\t\tpass ? pass : \"null\");\n\t\t\tnode = body.next_node();\n\t\t}\n\t\treturn true;\n\t}\n\n\t// 处理 text/json 类型数据\n\tbool do_json(http_request& req)\n\t{\n\t\tjson body;\n\t\tif (req.get_body(body, to_charset_) == false)\n\t\t{\n\t\t\tlogger_error(\"get http body error\");\n\t\t\treturn false;\n\t\t}\n\n\t\tjson_node* node = body.first_node();\n\t\twhile (node)\n\t\t{\n\t\t\tif (node->tag_name())\n\t\t\t{\n\t\t\t\tprintf(\"tag: %s\", node->tag_name());\n\t\t\t\tif (node->get_text())\n\t\t\t\t\tprintf(\", value: %s\\r\\n\", node->get_text());\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\r\\n\");\n\t\t\t}\n\t\t\tnode = body.next_node();\n\t\t}\n\t\treturn true;\n\t}\n\nprivate:\n\tstring server_addr_;\t// web 服务器地址\n\tstring file_;\t\t// 本地请求的数据文件\n\tstring stype_;\t\t// 请求数据的子数据类型\n\tstring charset_;\t// 本地请求数据文件的字符集\n\tstring to_charset_;\t// 将服务器响应数据转为本地字符集\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nstatic void usage(const char* procname)\n{\n\tprintf(\"usage: %s -h[help]\\r\\n\", procname);\n\tprintf(\"options:\\r\\n\");\n\tprintf(\"\\t-f request file\\r\\n\");\n\tprintf(\"\\t-t request stype[xml/json/plain]\\r\\n\");\n\tprintf(\"\\t-c request file's charset[gb2312/utf-8]\\r\\n\");\n}\n\nint main(int argc, char* argv[])\n{\n\tint   ch;\n\tstring server_addr(\"127.0.0.1:8888\"), file(\"./xml.txt\");\n\tstring stype(\"xml\"), charset(\"gb2312\");\n\n\twhile ((ch = getopt(argc, argv, \"hs:f:t:c:\")) > 0)\n\t{\n\t\tswitch (ch)\n\t\t{\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\treturn 0;\n\t\tcase 'f':\n\t\t\tfile = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tstype = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcharset = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tlog::stdout_open(true);   // 允许日志输出至屏幕上\n\thttp_request_test test(server_addr, file, stype, charset);\n\ttest.run();  // 开始运行\n\n\treturn 0;\n} \n```\n\n上面的例子来自于 lib_acl_cpp/samples/http_request。\n\n如果查看 http_request::request 源码实现，会发现 try_open()、reuse_conn、need_retry_ 等方法或变量来表示 HTTP 客户端连接的重试过程，这是因为 http_request 类的设计是支持长连接及可重用的，对于 HTTP 客户端连接池来说这些功能非常重要，在下一节介绍使用 acl 的 http 客户端连接池功能类时将会用到 http 请求客户端连接的重连及重试机制。\n\n## 四、参考\n\nhttp_request 类的头文件位置：lib_acl_cpp/include/acl_cpp/http/http_request.hpp\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","source":"_posts/http_request.md","raw":"---\ntitle: 使用 acl_cpp 库中的 http_request 类实现一个 HTTP 客户端请求的例子\ndate: 2014-06-02 20:06:24\ntags: http\ncategories: http开发\n---\n\n之前写过几篇如何使用 acl 库来实现 HTTP 客户端的例子都是基于 C 语言(使用 acl 较为底层的 HTTP 协议库写 HTTP 下载客户端举例, 使用 acl 库开发一个 HTTP 下载客户端)，其实在 acl 的 C++ 库(lib_acl_cpp) 中 HTTP 类功能更为强大，本节将介绍如何使用 acl::http_request 类来写一些简单的 HTTP 客户端示例。\n\n##  一、 acl::http_request 类的一些常用接口\n该 HTTP 请求类有两个构造函数，如下 ：\n\n```c++\n\t/**\n\t * 构造函数：通过该构造函数传入的 socket_stream 流对象并\n\t * 不会被关闭，需要调用者自己关闭\n\t * @param client {socket_stream*} 数据连接流，非空，\n\t *  在本类对象被销毁时该流对象并不会被销毁，所以用户需自行释放\n\t * @param conn_timeout {int} 如果传入的流关闭，则内部会\n\t *  自动重试，此时需要该值表示连接服务器的超时时间(秒)，\n\t *  至于重连流的 IO 读写超时时间是从 输入的流中继承的\n\t * @param unzip {bool} 是否对服务器响应的数据自动进行解压\n\t * 注：当该类实例被多次使用时，用户应该在每次调用前调用\n\t * request_header::http_header::reset()\n\t */\n\thttp_request(socket_stream* client, int conn_timeout = 60,\n\t\tbool unzip = true);\n\n\t/**\n\t * 构造函数：该构造函数内部创建的 socket_stream 流会自行关闭\n\t * @param addr {const char*} WEB 服务器地址\n\t * @param conn_timeout {int} 远程连接服务器超时时间(秒)\n\t * @param rw_timeout {int} IO 读写超时时间(秒)\n\t * @param unzip {bool} 是否对服务器响应的数据自动进行解压\n\t */\n\thttp_request(const char* addr, int conn_timeout = 60,\n\t\tint rw_timeout = 60, bool unzip = true);\n```\n第一个是以已经连接成功的套接字流为参数的构造函数，该构造函数把连接 HTTP 服务器的工作交给用户来完成；第二个是以 HTTP 服务器地址为参数的构造函数，使用该构造函数，则该类对象内部会自动连接 HTTP 服务器。\n\n下面的几个函数接口与 HTTP 发送相关：\n\n```c++\n\t/**\n\t * 获得 HTTP 请求头对象，然后在返回的 HTTP 请求头对象中添加\n\t * 自己的请求头字段或 http_header::reset()重置请求头状态，\n\t * 参考：http_header 类\n\t * @return {http_header&}\n\t */\n\thttp_header& request_header(void);\n\n\t/**\n\t * 向 HTTP 服务器发送 HTTP 请求头及 HTTP 请求体，同时从\n\t * HTTP 服务器读取 HTTP 响应头，对于长连接，当连接中断时\n\t * 会再重试一次，在调用下面的几个 get_body 函数前必须先\n\t * 调用本函数(或调用 write_head/write_body)；\n\t * 正常情况下，该函数在发送完请求数据后会读 HTTP 响应头，\n\t * 所以用户在本函数返回 true 后可以调用：get_body() 或\n\t * http_request::get_clinet()->read_body(char*, size_t)\n\t * 继续读 HTTP 响应的数据体\n\t * @param data {const void*} 发送的数据体地址，非空时自动按\n\t *  POST 方法发送，否则按 GET 方法发送\n\t * @param len {size_} data 非空时指定 data 数据长度\n\t * @return {bool} 发送请求数据及读 HTTP 响应头数据是否成功\n\t */\n\tbool request(const void* data, size_t len);\n\n\t/**\n\t * 当采用流式写数据时，需要首先调用本函数发送 HTTP 请求头\n\t * @return {bool} 是否成功，如果成功才可以继续调用 write_body\n\t */\n\tbool write_head();\n\n\t/**\n\t * 当采用流式写数据时，在调用 write_head 后，可以循环调用本函数\n\t * 发送 HTTP 请求体数据；当输入的两个参数为空值时则表示数据写完；\n\t * 当发送完数据后，该函数内部会自动读取 HTTP 响应头数据，用户可\n\t * 继续调用 get_body/read_body 获取 HTTP 响应体数据\n\t * @param data {const void*} 数据地址指针，当该值为空指针时表示\n\t *  数据发送完毕\n\t * @param len {size_t} data 非空指针时表示数据长度\n\t * @return {bool} 发送数据体是否成功\n\t *  注：当应用发送完数据后，必须再调用一次本函数，同时将两个参数都赋空\n\t */\n\tbool write_body(const void* data, size_t len);\n```\n\n构建及发送 HTTP 请求的过程如下：\n\n- 1、使用两个构造函数之一创建 acl::http_request 请求对象\n- 2、调用 http_request::request_header 获得 HTTP 请求头对象的引用（http_header&），然后对该 HTTP 请求头设置 HTTP 请求的参数\n- 3、http_request 类提供了两种 HTTP 请求调用 方式：\n  - 3.1、当 HTTP 请求方法为 HTTP GET 方法或为 HTTP POST 但数据体可以一次性写入时，可以使用 http_request::request 方法，在调用 http_request::request 时会将 HTTP 请求头及请求体一次性发给 HTTP 服务器；\n  - 3.2   如果为 HTTP POST 请求方法，且 HTTP 数据体内容是流式的（即每次只是要发送部分数据），则应该使用 http_request::write_head 和 http_request::write_body 两个函数，即使用流式方式发送数据时，应首先调用 http_request::write_head 发送 HTTP 请求头，当该函数返回成功后，可以循环调用 http_request::write_body 来发送 HTTP 请求数据体，为了表示 HTTP 请求体数据完毕，必须最后调用一次 http_request::write_body 且两个参数为 0 时以表示数据体发送完毕。\n\n在调用以上 3.1 或 3.2 过程成功发送完 HTTP 请求数据后，这两个过程内部会自动读取 HTTP 服务器发来的 HTTP 响应头。\n\n在上面的步骤 2 获得 HTTP 请求头对象（http_header）后，应该先调用下面的方法设置 HTTP 请求头中的参数：\n\n```c++\n\t/**\n\t * 设置请求的 URL，url 格式示例如下：\n\t * 1、http://www.test.com/\n\t * 2、/cgi-bin/test.cgi\n\t * 3、http://www.test.com/cgi-bin/test.cgi\n\t * 3、http://www.test.com/cgi-bin/test.cgi?name=value\n\t * 4、/cgi-bin/test.cgi?name=value\n\t * 5、http://www.test.com\n\t * 如果该 url 中有主机字段，则内部自动添加主机；\n\t * 如果该 url 中有参数字段，则内部自动进行处理并调用 add_param 方法；\n\t * 调用该函数后用户仍可以调用 add_param 等函数添加其它参数；\n\t * 当参数字段只有参数名没有参数值时，该参数将会被忽略，所以如果想\n\t * 单独添加参数名，应该调用 add_param 方法来添加\n\t * @param url {const char*} 请求的 url，非空指针\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_url(const char* url);\n\n\t/**\n\t * 设置 HTTP 请求头的 HOST 字段\n\t * @param value {const char*} 请求头的 HOST 字段值\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_host(const char* value);\n\n\t/**\n\t * 向请求的 URL 中添加参数对，当只有参数名没有参数值时则：\n\t * 1、参数名非空串，但参数值为空指针，则 URL 参数中只有：{name}\n\t * 2、参数名非空串，但参数值为空串，则 URL参数中为：{name}=\n\t * @param name {const char*} 参数名，不能为空指针\n\t * @param value {const char*} 参数值，当为空指针时，仅添加参数名，\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& add_param(const char* name, const char* value);\n\thttp_header& add_int(const char* name, short value);\n\thttp_header& add_int(const char* name, int value);\n\thttp_header& add_int(const char* name, long value);\n\thttp_header& add_int(const char* name, unsigned short value);\n\thttp_header& add_int(const char* name, unsigned int value);\n\thttp_header& add_int(const char* name, unsigned long value);\n\thttp_header& add_format(const char* name, const char* fmt, ...)\n\t\tACL_CPP_PRINTF(3, 4);\n\n\t/**\n\t * 向 HTTP 头中添加 cookie\n\t * @param name {const char*} cookie 名\n\t * @param value {const char*} cookie 值\n\t * @param domain {const char*} 所属域\n\t * @param path {const char*} 存储路径\n\t * @param expires {time_t} 过期时间，当该值为 0 时表示不过期，\n\t *  > 0 时，则从现在起再增加 expires 即为过期时间，单位为秒\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& add_cookie(const char* name, const char* value,\n\t\tconst char* domain = NULL, const char* path = NULL,\n\t\ttime_t expires = 0);\n\n\t/**\n\t * 设置 HTTP 头中的 Connection 字段，是否保持长连接\n\t * 不过，目前并未真正支持长连接，即使设置了该标志位，\n\t * 则得到响应数据后也会主动关闭连接\n\t * @param on {bool} 是否保持长连接\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_keep_alive(bool on);\n\n\t/**\n\t * 设置 HTTP 头中的 Content-Length 字段\n\t * @param n {long long int} 设置值\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_content_length(long long int n);\n\n\t/**\n\t * 设置 HTTP 头中的 Content-Type 字段\n\t * @param value {const char*} 设置值\n\t * @return {http_header&} 返回本对象的引用，便于用户连续操作\n\t */\n\thttp_header& set_content_type(const char* value);\n```\n\n以上仅列出了 http_header 类设置 HTTP 请求参数的一些常用方法，其它的方法请参考 http_header.hpp 头文件中的说明。\n\n## 二、acl::http_request 类获得 HTTP 服务器响应数据的常用方法\n上面介绍了使用 acl::http_request 构建 HTTP 请求头及发送请求的接口方法，下面介绍使用 acl::http_request 类中的方法来接收 HTTP 服务器响应过程，在调用 http_request 类中的 request 或 write_body 成功发送完请求数据后，该类对象在这两个方法内部会首先自动接收 HTTP 服务器的响应头数据，若接收过程失败，这两个方法也会返回 false 表示失败，若返回成功，则可以调用 http_request 类对象的 http_status 方法获得 HTTP 服务器的响应状态码（2xx, 3xx, 4xx, 5xx），还可调用 body_length 方法获得 HTTP 响应数据体的长度（当 HTTP 服务器返回的数据格式为 HTTP 块传输时，该函数会返回 -1，所以一般不用显示调用该方法）。下面介绍了主要的与 HTTP 响应相关的方法：\n\n首先是与 HTTP 响应头相关的接口函数，如下：\n\n```c++\n\t/**\n\t * 当发送完请求数据后，内部会自动调用读 HTTP 响应头过程，可以通过此函数获得服务端\n\t * 响应的 HTTP 状态字(2xx, 3xx, 4xx, 5xx)；\n\t * 其实该函数内部只是调用了 http_client::response_status 方法\n\t * @return {int}\n\t */\n\tint http_status() const;\n\n\t/**\n\t * 获得 HTTP 响应的数据体长度\n\t * @return {int64) 返回值若为 -1 则表明 HTTP 头不存在或没有长度字段\n\t */\n#ifdef WIN32\n\t__int64 body_length(void) const;\n#else\n\tlong long int body_length(void) const;\n#endif\n\t/**\n\t * HTTP 数据流(响应流是否允许保持长连接)\n\t * @return {bool}\n\t */\n\tbool keep_alive(void) const;\n\n\t/**\n\t * 获得 HTTP 响应头中某个字段名的字段值\n\t * @param name {const char*} 字段名\n\t * @return {const char*} 字段值，为空时表示不存在\n\t */\n\tconst char* header_value(const char* name) const;\n\n\t/**\n\t * 获得服务器返回的 Set-Cookie 设置的某个 cookie 对象\n\t * @param name {const char*} cookie 名\n\t * @param case_insensitive {bool} 是否区分大小写，true 表示\n\t *  不区分大小写\n\t * @return {const HttpCookie*} 返回 NULL 表示不存在\n\t */\n\tconst HttpCookie* get_cookie(const char* name,\n\t\tbool case_insensitive = true) const;\n```\n\n然后是与读 HTTP 响应数据体相关的接口函数：\n\n```c++\n\t/**\n\t * 是否读完了数据体\n\t * @return {bool}\n\t */\n\tbool body_finish() const;\n\n\t/**\n\t * 当调用 request 成功后调用本函数，读取服务器响应体数据\n\t * 并将结果存储于规定的 xml 对象中\n\t * @param out {xml&} HTTP 响应体数据存储于该 xml 对象中\n\t * @param to_charset {const char*} 当该项非空，内部自动\n\t *  将数据转成该字符集存储于 xml 对象中\n\t * @return {bool} 读数据是否成功\n\t * 注：当响应数据体特别大时不应用此函数，以免内存耗光\n\t */\n\tbool get_body(xml& out, const char* to_charset = NULL);\n\n\t/**\n\t * 当调用 request 成功后调用本函数，读取服务器响应体数据\n\t * 并将结果存储于规定的 json 对象中\n\t * @param out {json&} HTTP 响应体数据存储于该 json 对象中\n\t * @param to_charset {const char*} 当该项非空，内部自动\n\t *  将数据转成该字符集存储于 json 对象中\n\t * @return {bool} 读数据是否成功\n\t * 注：当响应数据体特别大时不应用此函数，以免内存耗光\n\t */\n\tbool get_body(json& out, const char* to_charset = NULL);\n\n\t/*\n\t * 当调用 request 成功后调用本函数，读取服务器全部响应数据\n\t * 存储于输入的缓冲区中\n\t * @param out {string&} 存储响应数据体\n\t * @param to_charset {const char*} 当该项非空，内部自动\n\t *  将数据转成该字符集存储于 out 对象中\n\t * 注：当响应数据体特别大时不应用此函数，以免内存耗光\n\t */\n\tbool get_body(string& out, const char* to_charset = NULL);\n\n\t/*\n\t * 当调用 request 成功后调用本函数，读取服务器响应数据并\n\t * 存储于输入的缓冲区中，可以循环调用本函数，直至数据读完了，\n\t * @param buf {char*} 存储部分响应数据体\n\t * @param size {size_t} buf 缓冲区大小\n\t * @return {int} 返回值 == 0 表示正常读完毕，< 0 表示服务器\n\t *  关闭连接，> 0 表示已经读到的数据，用户应该一直读数据直到\n\t *  返回值 <= 0 为止\n\t *  注：该函数读到的是原始 HTTP 数据体数据，不做解压和字符集\n\t *  解码，用户自己根据需要进行处理\n\t */\n\tint read_body(char* buf, size_t size);\n\n\t/**\n\t * 当调用 request 成功后调用本函数读 HTTP 响应数据体，可以循环调用\n\t * 本函数，本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用\n\t * set_charset 设置了本地字符集，则还同时对数据进行字符集转码操作\n\t * @param out {string&} 存储结果数据\n\t * @param clean {bool} 每次调用本函数时，是否要求先自动将缓冲区 out\n\t *  的数据清空\n\t * @param real_size {int*} 当该指针非空时，存储解压前读到的真正数据\n\t *  长度，如果在构造函数中指定了非自动解压模式且读到的数据 > 0，则该\n\t *  值存储的长度值应该与本函数返回值相同；当读出错或未读到任何数据时，\n\t *  该值存储的长度值为 0\n\t * @return {int} == 0 表示读完毕，可能连接并未关闭；>0 表示本次读操作\n\t *  读到的数据长度(当为解压后的数据时，则表示为解压之后的数据长度，\n\t *  与真实读到的数据不同，真实读到的数据长度应该通过参数 real_size 来\n\t *  获得); < 0 表示数据流关闭，此时若 real_size 非空，则 real_size 存\n\t *  储的值应该为 0\n\t */\n\tint read_body(string& out, bool clean = false, int* real_size = NULL);\n\n\t/**\n\t * 当调用 request 成功后调用本函数来从 HTTP 服务端读一行数据，可以循环调用\n\t * 本函数，直到返回 false 或 body_finish() 返回 true 为止；\n\t * 本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用 set_charset 设置了\n\t * 本地字符集，则还同时对数据进行字符集转码操作\n\t * @param out {string&} 存储结果数据\n\t * @param nonl {bool} 读到的一行数据是否自动去掉尾部的 \"\\r\\n\" 或 \"\\n\"\n\t * @param size {size_t*} 该指针非空时存放读到的数据长度\n\t * @return {bool} 是否读到了一行数据：当返回 true 时表示读到了一行数据，可以\n\t *  通过 body_finish() 是否为 true 来判断是否读数据体已经结束，当读到一个空行\n\t *  且 nonl = true 时，则 *size = 0；当返回 false 时表示未读完整行且读完毕，\n\t *  *size 中存放着读到的数据长度\n\t */\n\tbool body_gets(string& out, bool nonl = true, size_t* size = NULL);\n```\n\n虽然上面提供了多个读 HTTP 响应体数据的方法，但可以分为两大类：1、一次性读所有的数据体；2、以流式方式循环读数据体。 其中，对于“一次性读取所有数据体”的读方法，适合于响应数据体比较小的情形，当响应数据为 xml 或 json 格式时，还提供了直接将响应数据体转为 xml 或 json 对象的读方法；如果响应数据体非常大（如几兆甚至几十兆以上）则应该采用流式方法循环读数据体。\n\n有一点需要注意，除了 \" int read_body(char* buf, size_t size);\" 可以直接读原生的响应数据体外，其它的读方法会将读到数据体自动进行解压、字符集转换操作后将最终结果返回调用者。\n\n此外，为了方便一些文本类应用，在 http_request 类中还提供了 body_gets 方法，用来以行为单位读取 HTTP 响应数据体（当服务器也是以行为单位发送响应数据时才可使用 body_gets 方法）。\n\nacl::http_request 类除了以上接口外，还提供了其它丰富的接口（如：支持 HTTP 断点续传的 Range 相关的方法），如果您觉得这些接口依然不能满足要求，不妨通过 \"http_request::get_client\" 获得 acl::http_client 类对象（该类对象是 acl 有关 http 协议处理中比较基础的 HTTP 通信类），然后再在 acl::http_client 类中查找您所希望的功能接口。\n\n## 三、示例\n下面用一个简单的例子来说明上面一些方法的使用过程：\n\n```c++\n// http_servlet.cpp : 定义控制台应用程序的入口点。\n//\n#include <assert.h>\n#include <getopt.h>\n#include \"acl_cpp/lib_acl.hpp\"\n\nusing namespace acl;\n\n//////////////////////////////////////////////////////////////////////////\n\nclass http_request_test\n{\npublic:\n\thttp_request_test(const char* server_addr, const char* file,\n\t\tconst char* stype, const char* charset)\n\t{\n\t\tserver_addr_= server_addr;\n\t\tfile_ = file;\n\t\tstype_ = stype;\n\t\tcharset_ = charset;\n\t\tto_charset_ = \"gb2312\";\n\t}\n\n\t~http_request_test() {}\n\n\tbool run(void)\n\t{\n\t\tstring body;\n\t\tif (ifstream::load(file_, &body) == false)\n\t\t{\n\t\t\tlogger_error(\"load %s error\", file_.c_str());\n\t\t\treturn false;\n\t\t}\n\n\t\thttp_request req(server_addr_);\n\n\t\t// 添加 HTTP 请求头字段\n\n\t\tstring ctype(\"text/\");\n\t\tctype << stype_ << \"; charset=\" << charset_;\n\n\t\thttp_header& hdr = req.request_header();  // 请求头对象的引用\n\t\thdr.set_url(\"/\");\n\t\thdr.set_content_type(ctype);\n\t\thdr.add_param(\"name1\", \"value1\");\n\t\thdr.add_param(\"name2\", \"value2\");\n\t\t// 发送 HTTP 请求数据\n\t\tif (req.request(body.c_str(), body.length()) == false)\n\t\t{\n\t\t\tlogger_error(\"send http request to %s error\",\n\t\t\t\tserver_addr_.c_str());\n\t\t\treturn false;\n\t\t}\n\n\t\t// 取出 HTTP 响应头的 Content-Type 字段\n\n\t\tconst char* p = req.header_value(\"Content-Type\");\n\t\tif (p == NULL || *p == 0)\n\t\t{\n\t\t\tlogger_error(\"no Content-Type\");\n\t\t\treturn false;\n\t\t}\n\n\t\t// 分析 HTTP 响应头的数据类型\n\t\thttp_ctype content_type;\n\t\tcontent_type.parse(p);\n\n\t\t// 响应头数据类型的子类型\n\t\tconst char* stype = content_type.get_stype();\n\n\t\tbool ret;\n\t\tif (stype == NULL)\n\t\t\tret = do_plain(req);\n\t\telse if (strcasecmp(stype, \"xml\") == 0)\n\t\t\tret = do_xml(req);\n\t\telse if (strcasecmp(stype, \"json\") == 0)\n\t\t\tret = do_json(req);\n\t\telse\n\t\t\tret = do_plain(req);\n\t\tif (ret == true)\n\t\t\tlogger(\"read ok!\\r\\n\");\n\t\treturn ret;\n\t}\n\nprivate:\n\t// 处理 text/plain 类型数据\n\tbool do_plain(http_request& req)\n\t{\n\t\tstring body;\n\t\tif (req.get_body(body, to_charset_) == false)\n\t\t{\n\t\t\tlogger_error(\"get http body error\");\n\t\t\treturn false;\n\t\t}\n\t\tprintf(\"body:\\r\\n(%s)\\r\\n\", body.c_str());\n\t\treturn true;\n\t}\n\n\t// 处理 text/xml 类型数据\n\tbool do_xml(http_request& req)\n\t{\n\t\txml body;\n\t\tif (req.get_body(body, to_charset_) == false)\n\t\t{\n\t\t\tlogger_error(\"get http body error\");\n\t\t\treturn false;\n\t\t}\n\t\txml_node* node = body.first_node();\n\t\twhile (node)\n\t\t{\n\t\t\tconst char* tag = node->tag_name();\n\t\t\tconst char* name = node->attr_value(\"name\");\n\t\t\tconst char* pass = node->attr_value(\"pass\");\n\t\t\tprintf(\">>tag: %s, name: %s, pass: %s\\r\\n\",\n\t\t\t\ttag ? tag : \"null\",\n\t\t\t\tname ? name : \"null\",\n\t\t\t\tpass ? pass : \"null\");\n\t\t\tnode = body.next_node();\n\t\t}\n\t\treturn true;\n\t}\n\n\t// 处理 text/json 类型数据\n\tbool do_json(http_request& req)\n\t{\n\t\tjson body;\n\t\tif (req.get_body(body, to_charset_) == false)\n\t\t{\n\t\t\tlogger_error(\"get http body error\");\n\t\t\treturn false;\n\t\t}\n\n\t\tjson_node* node = body.first_node();\n\t\twhile (node)\n\t\t{\n\t\t\tif (node->tag_name())\n\t\t\t{\n\t\t\t\tprintf(\"tag: %s\", node->tag_name());\n\t\t\t\tif (node->get_text())\n\t\t\t\t\tprintf(\", value: %s\\r\\n\", node->get_text());\n\t\t\t\telse\n\t\t\t\t\tprintf(\"\\r\\n\");\n\t\t\t}\n\t\t\tnode = body.next_node();\n\t\t}\n\t\treturn true;\n\t}\n\nprivate:\n\tstring server_addr_;\t// web 服务器地址\n\tstring file_;\t\t// 本地请求的数据文件\n\tstring stype_;\t\t// 请求数据的子数据类型\n\tstring charset_;\t// 本地请求数据文件的字符集\n\tstring to_charset_;\t// 将服务器响应数据转为本地字符集\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nstatic void usage(const char* procname)\n{\n\tprintf(\"usage: %s -h[help]\\r\\n\", procname);\n\tprintf(\"options:\\r\\n\");\n\tprintf(\"\\t-f request file\\r\\n\");\n\tprintf(\"\\t-t request stype[xml/json/plain]\\r\\n\");\n\tprintf(\"\\t-c request file's charset[gb2312/utf-8]\\r\\n\");\n}\n\nint main(int argc, char* argv[])\n{\n\tint   ch;\n\tstring server_addr(\"127.0.0.1:8888\"), file(\"./xml.txt\");\n\tstring stype(\"xml\"), charset(\"gb2312\");\n\n\twhile ((ch = getopt(argc, argv, \"hs:f:t:c:\")) > 0)\n\t{\n\t\tswitch (ch)\n\t\t{\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\treturn 0;\n\t\tcase 'f':\n\t\t\tfile = optarg;\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tstype = optarg;\n\t\t\tbreak;\n\t\tcase 'c':\n\t\t\tcharset = optarg;\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tusage(argv[0]);\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\tlog::stdout_open(true);   // 允许日志输出至屏幕上\n\thttp_request_test test(server_addr, file, stype, charset);\n\ttest.run();  // 开始运行\n\n\treturn 0;\n} \n```\n\n上面的例子来自于 lib_acl_cpp/samples/http_request。\n\n如果查看 http_request::request 源码实现，会发现 try_open()、reuse_conn、need_retry_ 等方法或变量来表示 HTTP 客户端连接的重试过程，这是因为 http_request 类的设计是支持长连接及可重用的，对于 HTTP 客户端连接池来说这些功能非常重要，在下一节介绍使用 acl 的 http 客户端连接池功能类时将会用到 http 请求客户端连接的重连及重试机制。\n\n## 四、参考\n\nhttp_request 类的头文件位置：lib_acl_cpp/include/acl_cpp/http/http_request.hpp\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","slug":"http_request","published":1,"updated":"2023-01-24T02:48:51.541Z","_id":"cld9n1es000001xfyf246a2cd","comments":1,"layout":"post","photos":[],"link":"","content":"<p>之前写过几篇如何使用 acl 库来实现 HTTP 客户端的例子都是基于 C 语言(使用 acl 较为底层的 HTTP 协议库写 HTTP 下载客户端举例, 使用 acl 库开发一个 HTTP 下载客户端)，其实在 acl 的 C++ 库(lib_acl_cpp) 中 HTTP 类功能更为强大，本节将介绍如何使用 acl::http_request 类来写一些简单的 HTTP 客户端示例。</p>\n<h2 id=\"一、-acl-http-request-类的一些常用接口\"><a href=\"#一、-acl-http-request-类的一些常用接口\" class=\"headerlink\" title=\"一、 acl::http_request 类的一些常用接口\"></a>一、 acl::http_request 类的一些常用接口</h2><p>该 HTTP 请求类有两个构造函数，如下 ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构造函数：通过该构造函数传入的 socket_stream 流对象并</span><br><span class=\"hljs-comment\"> * 不会被关闭，需要调用者自己关闭</span><br><span class=\"hljs-comment\"> * @param client &#123;socket_stream*&#125; 数据连接流，非空，</span><br><span class=\"hljs-comment\"> *  在本类对象被销毁时该流对象并不会被销毁，所以用户需自行释放</span><br><span class=\"hljs-comment\"> * @param conn_timeout &#123;int&#125; 如果传入的流关闭，则内部会</span><br><span class=\"hljs-comment\"> *  自动重试，此时需要该值表示连接服务器的超时时间(秒)，</span><br><span class=\"hljs-comment\"> *  至于重连流的 IO 读写超时时间是从 输入的流中继承的</span><br><span class=\"hljs-comment\"> * @param unzip &#123;bool&#125; 是否对服务器响应的数据自动进行解压</span><br><span class=\"hljs-comment\"> * 注：当该类实例被多次使用时，用户应该在每次调用前调用</span><br><span class=\"hljs-comment\"> * request_header::http_header::reset()</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">http_request</span>(socket_stream* client, <span class=\"hljs-type\">int</span> conn_timeout = <span class=\"hljs-number\">60</span>,<br>\t<span class=\"hljs-type\">bool</span> unzip = <span class=\"hljs-literal\">true</span>);<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构造函数：该构造函数内部创建的 socket_stream 流会自行关闭</span><br><span class=\"hljs-comment\"> * @param addr &#123;const char*&#125; WEB 服务器地址</span><br><span class=\"hljs-comment\"> * @param conn_timeout &#123;int&#125; 远程连接服务器超时时间(秒)</span><br><span class=\"hljs-comment\"> * @param rw_timeout &#123;int&#125; IO 读写超时时间(秒)</span><br><span class=\"hljs-comment\"> * @param unzip &#123;bool&#125; 是否对服务器响应的数据自动进行解压</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">http_request</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">int</span> conn_timeout = <span class=\"hljs-number\">60</span>,<br>\t<span class=\"hljs-type\">int</span> rw_timeout = <span class=\"hljs-number\">60</span>, <span class=\"hljs-type\">bool</span> unzip = <span class=\"hljs-literal\">true</span>);<br></code></pre></td></tr></table></figure>\n<p>第一个是以已经连接成功的套接字流为参数的构造函数，该构造函数把连接 HTTP 服务器的工作交给用户来完成；第二个是以 HTTP 服务器地址为参数的构造函数，使用该构造函数，则该类对象内部会自动连接 HTTP 服务器。</p>\n<p>下面的几个函数接口与 HTTP 发送相关：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得 HTTP 请求头对象，然后在返回的 HTTP 请求头对象中添加</span><br><span class=\"hljs-comment\"> * 自己的请求头字段或 http_header::reset()重置请求头状态，</span><br><span class=\"hljs-comment\"> * 参考：http_header 类</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">request_header</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 向 HTTP 服务器发送 HTTP 请求头及 HTTP 请求体，同时从</span><br><span class=\"hljs-comment\"> * HTTP 服务器读取 HTTP 响应头，对于长连接，当连接中断时</span><br><span class=\"hljs-comment\"> * 会再重试一次，在调用下面的几个 get_body 函数前必须先</span><br><span class=\"hljs-comment\"> * 调用本函数(或调用 write_head/write_body)；</span><br><span class=\"hljs-comment\"> * 正常情况下，该函数在发送完请求数据后会读 HTTP 响应头，</span><br><span class=\"hljs-comment\"> * 所以用户在本函数返回 true 后可以调用：get_body() 或</span><br><span class=\"hljs-comment\"> * http_request::get_clinet()-&gt;read_body(char*, size_t)</span><br><span class=\"hljs-comment\"> * 继续读 HTTP 响应的数据体</span><br><span class=\"hljs-comment\"> * @param data &#123;const void*&#125; 发送的数据体地址，非空时自动按</span><br><span class=\"hljs-comment\"> *  POST 方法发送，否则按 GET 方法发送</span><br><span class=\"hljs-comment\"> * @param len &#123;size_&#125; data 非空时指定 data 数据长度</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 发送请求数据及读 HTTP 响应头数据是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">request</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* data, <span class=\"hljs-type\">size_t</span> len)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当采用流式写数据时，需要首先调用本函数发送 HTTP 请求头</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 是否成功，如果成功才可以继续调用 write_body</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_head</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当采用流式写数据时，在调用 write_head 后，可以循环调用本函数</span><br><span class=\"hljs-comment\"> * 发送 HTTP 请求体数据；当输入的两个参数为空值时则表示数据写完；</span><br><span class=\"hljs-comment\"> * 当发送完数据后，该函数内部会自动读取 HTTP 响应头数据，用户可</span><br><span class=\"hljs-comment\"> * 继续调用 get_body/read_body 获取 HTTP 响应体数据</span><br><span class=\"hljs-comment\"> * @param data &#123;const void*&#125; 数据地址指针，当该值为空指针时表示</span><br><span class=\"hljs-comment\"> *  数据发送完毕</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125; data 非空指针时表示数据长度</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 发送数据体是否成功</span><br><span class=\"hljs-comment\"> *  注：当应用发送完数据后，必须再调用一次本函数，同时将两个参数都赋空</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_body</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* data, <span class=\"hljs-type\">size_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>构建及发送 HTTP 请求的过程如下：</p>\n<ul>\n<li>1、使用两个构造函数之一创建 acl::http_request 请求对象</li>\n<li>2、调用 http_request::request_header 获得 HTTP 请求头对象的引用（http_header&amp;），然后对该 HTTP 请求头设置 HTTP 请求的参数</li>\n<li>3、http_request 类提供了两种 HTTP 请求调用 方式：<ul>\n<li>3.1、当 HTTP 请求方法为 HTTP GET 方法或为 HTTP POST 但数据体可以一次性写入时，可以使用 http_request::request 方法，在调用 http_request::request 时会将 HTTP 请求头及请求体一次性发给 HTTP 服务器；</li>\n<li>3.2   如果为 HTTP POST 请求方法，且 HTTP 数据体内容是流式的（即每次只是要发送部分数据），则应该使用 http_request::write_head 和 http_request::write_body 两个函数，即使用流式方式发送数据时，应首先调用 http_request::write_head 发送 HTTP 请求头，当该函数返回成功后，可以循环调用 http_request::write_body 来发送 HTTP 请求数据体，为了表示 HTTP 请求体数据完毕，必须最后调用一次 http_request::write_body 且两个参数为 0 时以表示数据体发送完毕。</li>\n</ul>\n</li>\n</ul>\n<p>在调用以上 3.1 或 3.2 过程成功发送完 HTTP 请求数据后，这两个过程内部会自动读取 HTTP 服务器发来的 HTTP 响应头。</p>\n<p>在上面的步骤 2 获得 HTTP 请求头对象（http_header）后，应该先调用下面的方法设置 HTTP 请求头中的参数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置请求的 URL，url 格式示例如下：</span><br><span class=\"hljs-comment\"> * 1、http://www.test.com/</span><br><span class=\"hljs-comment\"> * 2、/cgi-bin/test.cgi</span><br><span class=\"hljs-comment\"> * 3、http://www.test.com/cgi-bin/test.cgi</span><br><span class=\"hljs-comment\"> * 3、http://www.test.com/cgi-bin/test.cgi?name=value</span><br><span class=\"hljs-comment\"> * 4、/cgi-bin/test.cgi?name=value</span><br><span class=\"hljs-comment\"> * 5、http://www.test.com</span><br><span class=\"hljs-comment\"> * 如果该 url 中有主机字段，则内部自动添加主机；</span><br><span class=\"hljs-comment\"> * 如果该 url 中有参数字段，则内部自动进行处理并调用 add_param 方法；</span><br><span class=\"hljs-comment\"> * 调用该函数后用户仍可以调用 add_param 等函数添加其它参数；</span><br><span class=\"hljs-comment\"> * 当参数字段只有参数名没有参数值时，该参数将会被忽略，所以如果想</span><br><span class=\"hljs-comment\"> * 单独添加参数名，应该调用 add_param 方法来添加</span><br><span class=\"hljs-comment\"> * @param url &#123;const char*&#125; 请求的 url，非空指针</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_url</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* url)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 请求头的 HOST 字段</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; 请求头的 HOST 字段值</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_host</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 向请求的 URL 中添加参数对，当只有参数名没有参数值时则：</span><br><span class=\"hljs-comment\"> * 1、参数名非空串，但参数值为空指针，则 URL 参数中只有：&#123;name&#125;</span><br><span class=\"hljs-comment\"> * 2、参数名非空串，但参数值为空串，则 URL参数中为：&#123;name&#125;=</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; 参数名，不能为空指针</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; 参数值，当为空指针时，仅添加参数名，</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_param</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">short</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">int</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">long</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">short</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_format</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* fmt, ...)</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-title\">ACL_CPP_PRINTF</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 向 HTTP 头中添加 cookie</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; cookie 名</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; cookie 值</span><br><span class=\"hljs-comment\"> * @param domain &#123;const char*&#125; 所属域</span><br><span class=\"hljs-comment\"> * @param path &#123;const char*&#125; 存储路径</span><br><span class=\"hljs-comment\"> * @param expires &#123;time_t&#125; 过期时间，当该值为 0 时表示不过期，</span><br><span class=\"hljs-comment\"> *  &gt; 0 时，则从现在起再增加 expires 即为过期时间，单位为秒</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_cookie</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* domain = <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* path = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">time_t</span> expires = <span class=\"hljs-number\">0</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 头中的 Connection 字段，是否保持长连接</span><br><span class=\"hljs-comment\"> * 不过，目前并未真正支持长连接，即使设置了该标志位，</span><br><span class=\"hljs-comment\"> * 则得到响应数据后也会主动关闭连接</span><br><span class=\"hljs-comment\"> * @param on &#123;bool&#125; 是否保持长连接</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_keep_alive</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> on)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 头中的 Content-Length 字段</span><br><span class=\"hljs-comment\"> * @param n &#123;long long int&#125; 设置值</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_content_length</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> n)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 头中的 Content-Type 字段</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; 设置值</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_content_type</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>以上仅列出了 http_header 类设置 HTTP 请求参数的一些常用方法，其它的方法请参考 http_header.hpp 头文件中的说明。</p>\n<h2 id=\"二、acl-http-request-类获得-HTTP-服务器响应数据的常用方法\"><a href=\"#二、acl-http-request-类获得-HTTP-服务器响应数据的常用方法\" class=\"headerlink\" title=\"二、acl::http_request 类获得 HTTP 服务器响应数据的常用方法\"></a>二、acl::http_request 类获得 HTTP 服务器响应数据的常用方法</h2><p>上面介绍了使用 acl::http_request 构建 HTTP 请求头及发送请求的接口方法，下面介绍使用 acl::http_request 类中的方法来接收 HTTP 服务器响应过程，在调用 http_request 类中的 request 或 write_body 成功发送完请求数据后，该类对象在这两个方法内部会首先自动接收 HTTP 服务器的响应头数据，若接收过程失败，这两个方法也会返回 false 表示失败，若返回成功，则可以调用 http_request 类对象的 http_status 方法获得 HTTP 服务器的响应状态码（2xx, 3xx, 4xx, 5xx），还可调用 body_length 方法获得 HTTP 响应数据体的长度（当 HTTP 服务器返回的数据格式为 HTTP 块传输时，该函数会返回 -1，所以一般不用显示调用该方法）。下面介绍了主要的与 HTTP 响应相关的方法：</p>\n<p>首先是与 HTTP 响应头相关的接口函数，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 当发送完请求数据后，内部会自动调用读 HTTP 响应头过程，可以通过此函数获得服务端</span><br><span class=\"hljs-comment\">\t * 响应的 HTTP 状态字(2xx, 3xx, 4xx, 5xx)；</span><br><span class=\"hljs-comment\">\t * 其实该函数内部只是调用了 http_client::response_status 方法</span><br><span class=\"hljs-comment\">\t * @return &#123;int&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_status</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 响应的数据体长度</span><br><span class=\"hljs-comment\">\t * @return &#123;int64) 返回值若为 -1 则表明 HTTP 头不存在或没有长度字段</span><br><span class=\"hljs-comment\">\t */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t<span class=\"hljs-function\">__int64 <span class=\"hljs-title\">body_length</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">body_length</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * HTTP 数据流(响应流是否允许保持长连接)</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">keep_alive</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 响应头中某个字段名的字段值</span><br><span class=\"hljs-comment\">\t * @param name &#123;const char*&#125; 字段名</span><br><span class=\"hljs-comment\">\t * @return &#123;const char*&#125; 字段值，为空时表示不存在</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">header_value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得服务器返回的 Set-Cookie 设置的某个 cookie 对象</span><br><span class=\"hljs-comment\">\t * @param name &#123;const char*&#125; cookie 名</span><br><span class=\"hljs-comment\">\t * @param case_insensitive &#123;bool&#125; 是否区分大小写，true 表示</span><br><span class=\"hljs-comment\">\t *  不区分大小写</span><br><span class=\"hljs-comment\">\t * @return &#123;const HttpCookie*&#125; 返回 NULL 表示不存在</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">const</span> HttpCookie* <span class=\"hljs-title\">get_cookie</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">bool</span> case_insensitive = <span class=\"hljs-literal\">true</span>)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>然后是与读 HTTP 响应数据体相关的接口函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 是否读完了数据体</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">body_finish</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数，读取服务器响应体数据</span><br><span class=\"hljs-comment\"> * 并将结果存储于规定的 xml 对象中</span><br><span class=\"hljs-comment\"> * @param out &#123;xml&amp;&#125; HTTP 响应体数据存储于该 xml 对象中</span><br><span class=\"hljs-comment\"> * @param to_charset &#123;const char*&#125; 当该项非空，内部自动</span><br><span class=\"hljs-comment\"> *  将数据转成该字符集存储于 xml 对象中</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 读数据是否成功</span><br><span class=\"hljs-comment\"> * 注：当响应数据体特别大时不应用此函数，以免内存耗光</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">get_body</span><span class=\"hljs-params\">(xml&amp; out, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* to_charset = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数，读取服务器响应体数据</span><br><span class=\"hljs-comment\"> * 并将结果存储于规定的 json 对象中</span><br><span class=\"hljs-comment\"> * @param out &#123;json&amp;&#125; HTTP 响应体数据存储于该 json 对象中</span><br><span class=\"hljs-comment\"> * @param to_charset &#123;const char*&#125; 当该项非空，内部自动</span><br><span class=\"hljs-comment\"> *  将数据转成该字符集存储于 json 对象中</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 读数据是否成功</span><br><span class=\"hljs-comment\"> * 注：当响应数据体特别大时不应用此函数，以免内存耗光</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">get_body</span><span class=\"hljs-params\">(json&amp; out, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* to_charset = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数，读取服务器全部响应数据</span><br><span class=\"hljs-comment\"> * 存储于输入的缓冲区中</span><br><span class=\"hljs-comment\"> * @param out &#123;string&amp;&#125; 存储响应数据体</span><br><span class=\"hljs-comment\"> * @param to_charset &#123;const char*&#125; 当该项非空，内部自动</span><br><span class=\"hljs-comment\"> *  将数据转成该字符集存储于 out 对象中</span><br><span class=\"hljs-comment\"> * 注：当响应数据体特别大时不应用此函数，以免内存耗光</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">get_body</span><span class=\"hljs-params\">(string&amp; out, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* to_charset = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数，读取服务器响应数据并</span><br><span class=\"hljs-comment\"> * 存储于输入的缓冲区中，可以循环调用本函数，直至数据读完了，</span><br><span class=\"hljs-comment\"> * @param buf &#123;char*&#125; 存储部分响应数据体</span><br><span class=\"hljs-comment\"> * @param size &#123;size_t&#125; buf 缓冲区大小</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 返回值 == 0 表示正常读完毕，&lt; 0 表示服务器</span><br><span class=\"hljs-comment\"> *  关闭连接，&gt; 0 表示已经读到的数据，用户应该一直读数据直到</span><br><span class=\"hljs-comment\"> *  返回值 &lt;= 0 为止</span><br><span class=\"hljs-comment\"> *  注：该函数读到的是原始 HTTP 数据体数据，不做解压和字符集</span><br><span class=\"hljs-comment\"> *  解码，用户自己根据需要进行处理</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">read_body</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* buf, <span class=\"hljs-type\">size_t</span> size)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数读 HTTP 响应数据体，可以循环调用</span><br><span class=\"hljs-comment\"> * 本函数，本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用</span><br><span class=\"hljs-comment\"> * set_charset 设置了本地字符集，则还同时对数据进行字符集转码操作</span><br><span class=\"hljs-comment\"> * @param out &#123;string&amp;&#125; 存储结果数据</span><br><span class=\"hljs-comment\"> * @param clean &#123;bool&#125; 每次调用本函数时，是否要求先自动将缓冲区 out</span><br><span class=\"hljs-comment\"> *  的数据清空</span><br><span class=\"hljs-comment\"> * @param real_size &#123;int*&#125; 当该指针非空时，存储解压前读到的真正数据</span><br><span class=\"hljs-comment\"> *  长度，如果在构造函数中指定了非自动解压模式且读到的数据 &gt; 0，则该</span><br><span class=\"hljs-comment\"> *  值存储的长度值应该与本函数返回值相同；当读出错或未读到任何数据时，</span><br><span class=\"hljs-comment\"> *  该值存储的长度值为 0</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; == 0 表示读完毕，可能连接并未关闭；&gt;0 表示本次读操作</span><br><span class=\"hljs-comment\"> *  读到的数据长度(当为解压后的数据时，则表示为解压之后的数据长度，</span><br><span class=\"hljs-comment\"> *  与真实读到的数据不同，真实读到的数据长度应该通过参数 real_size 来</span><br><span class=\"hljs-comment\"> *  获得); &lt; 0 表示数据流关闭，此时若 real_size 非空，则 real_size 存</span><br><span class=\"hljs-comment\"> *  储的值应该为 0</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">read_body</span><span class=\"hljs-params\">(string&amp; out, <span class=\"hljs-type\">bool</span> clean = <span class=\"hljs-literal\">false</span>, <span class=\"hljs-type\">int</span>* real_size = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数来从 HTTP 服务端读一行数据，可以循环调用</span><br><span class=\"hljs-comment\"> * 本函数，直到返回 false 或 body_finish() 返回 true 为止；</span><br><span class=\"hljs-comment\"> * 本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用 set_charset 设置了</span><br><span class=\"hljs-comment\"> * 本地字符集，则还同时对数据进行字符集转码操作</span><br><span class=\"hljs-comment\"> * @param out &#123;string&amp;&#125; 存储结果数据</span><br><span class=\"hljs-comment\"> * @param nonl &#123;bool&#125; 读到的一行数据是否自动去掉尾部的 &quot;\\r\\n&quot; 或 &quot;\\n&quot;</span><br><span class=\"hljs-comment\"> * @param size &#123;size_t*&#125; 该指针非空时存放读到的数据长度</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 是否读到了一行数据：当返回 true 时表示读到了一行数据，可以</span><br><span class=\"hljs-comment\"> *  通过 body_finish() 是否为 true 来判断是否读数据体已经结束，当读到一个空行</span><br><span class=\"hljs-comment\"> *  且 nonl = true 时，则 *size = 0；当返回 false 时表示未读完整行且读完毕，</span><br><span class=\"hljs-comment\"> *  *size 中存放着读到的数据长度</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">body_gets</span><span class=\"hljs-params\">(string&amp; out, <span class=\"hljs-type\">bool</span> nonl = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">size_t</span>* size = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>虽然上面提供了多个读 HTTP 响应体数据的方法，但可以分为两大类：1、一次性读所有的数据体；2、以流式方式循环读数据体。 其中，对于“一次性读取所有数据体”的读方法，适合于响应数据体比较小的情形，当响应数据为 xml 或 json 格式时，还提供了直接将响应数据体转为 xml 或 json 对象的读方法；如果响应数据体非常大（如几兆甚至几十兆以上）则应该采用流式方法循环读数据体。</p>\n<p>有一点需要注意，除了 “ int read_body(char* buf, size_t size);” 可以直接读原生的响应数据体外，其它的读方法会将读到数据体自动进行解压、字符集转换操作后将最终结果返回调用者。</p>\n<p>此外，为了方便一些文本类应用，在 http_request 类中还提供了 body_gets 方法，用来以行为单位读取 HTTP 响应数据体（当服务器也是以行为单位发送响应数据时才可使用 body_gets 方法）。</p>\n<p>acl::http_request 类除了以上接口外，还提供了其它丰富的接口（如：支持 HTTP 断点续传的 Range 相关的方法），如果您觉得这些接口依然不能满足要求，不妨通过 “http_request::get_client” 获得 acl::http_client 类对象（该类对象是 acl 有关 http 协议处理中比较基础的 HTTP 通信类），然后再在 acl::http_client 类中查找您所希望的功能接口。</p>\n<h2 id=\"三、示例\"><a href=\"#三、示例\" class=\"headerlink\" title=\"三、示例\"></a>三、示例</h2><p>下面用一个简单的例子来说明上面一些方法的使用过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// http_servlet.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;getopt.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_request_test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_request_test</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* server_addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* file,<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* stype, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* charset)<br>\t&#123;<br>\t\tserver_addr_= server_addr;<br>\t\tfile_ = file;<br>\t\tstype_ = stype;<br>\t\tcharset_ = charset;<br>\t\tto_charset_ = <span class=\"hljs-string\">&quot;gb2312&quot;</span>;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">http_request_test</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstring body;<br>\t\t<span class=\"hljs-keyword\">if</span> (ifstream::<span class=\"hljs-built_in\">load</span>(file_, &amp;body) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;load %s error&quot;</span>, file_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-function\">http_request <span class=\"hljs-title\">req</span><span class=\"hljs-params\">(server_addr_)</span></span>;<br><br>\t\t<span class=\"hljs-comment\">// 添加 HTTP 请求头字段</span><br><br>\t\t<span class=\"hljs-function\">string <span class=\"hljs-title\">ctype</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;text/&quot;</span>)</span></span>;<br>\t\tctype &lt;&lt; stype_ &lt;&lt; <span class=\"hljs-string\">&quot;; charset=&quot;</span> &lt;&lt; charset_;<br><br>\t\thttp_header&amp; hdr = req.<span class=\"hljs-built_in\">request_header</span>();  <span class=\"hljs-comment\">// 请求头对象的引用</span><br>\t\thdr.<span class=\"hljs-built_in\">set_url</span>(<span class=\"hljs-string\">&quot;/&quot;</span>);<br>\t\thdr.<span class=\"hljs-built_in\">set_content_type</span>(ctype);<br>\t\thdr.<span class=\"hljs-built_in\">add_param</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>, <span class=\"hljs-string\">&quot;value1&quot;</span>);<br>\t\thdr.<span class=\"hljs-built_in\">add_param</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>, <span class=\"hljs-string\">&quot;value2&quot;</span>);<br>\t\t<span class=\"hljs-comment\">// 发送 HTTP 请求数据</span><br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">request</span>(body.<span class=\"hljs-built_in\">c_str</span>(), body.<span class=\"hljs-built_in\">length</span>()) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;send http request to %s error&quot;</span>,<br>\t\t\t\tserver_addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 取出 HTTP 响应头的 Content-Type 字段</span><br><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* p = req.<span class=\"hljs-built_in\">header_value</span>(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">NULL</span> || *p == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;no Content-Type&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 分析 HTTP 响应头的数据类型</span><br>\t\thttp_ctype content_type;<br>\t\tcontent_type.<span class=\"hljs-built_in\">parse</span>(p);<br><br>\t\t<span class=\"hljs-comment\">// 响应头数据类型的子类型</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* stype = content_type.<span class=\"hljs-built_in\">get_stype</span>();<br><br>\t\t<span class=\"hljs-type\">bool</span> ret;<br>\t\t<span class=\"hljs-keyword\">if</span> (stype == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\tret = <span class=\"hljs-built_in\">do_plain</span>(req);<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcasecmp</span>(stype, <span class=\"hljs-string\">&quot;xml&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\tret = <span class=\"hljs-built_in\">do_xml</span>(req);<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcasecmp</span>(stype, <span class=\"hljs-string\">&quot;json&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\tret = <span class=\"hljs-built_in\">do_json</span>(req);<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\tret = <span class=\"hljs-built_in\">do_plain</span>(req);<br>\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-literal\">true</span>)<br>\t\t\t<span class=\"hljs-built_in\">logger</span>(<span class=\"hljs-string\">&quot;read ok!\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> ret;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 处理 text/plain 类型数据</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">do_plain</span><span class=\"hljs-params\">(http_request&amp; req)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstring body;<br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">get_body</span>(body, to_charset_) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;get http body error&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;body:\\r\\n(%s)\\r\\n&quot;</span>, body.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 处理 text/xml 类型数据</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">do_xml</span><span class=\"hljs-params\">(http_request&amp; req)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\txml body;<br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">get_body</span>(body, to_charset_) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;get http body error&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\txml_node* node = body.<span class=\"hljs-built_in\">first_node</span>();<br>\t\t<span class=\"hljs-keyword\">while</span> (node)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* tag = node-&gt;<span class=\"hljs-built_in\">tag_name</span>();<br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name = node-&gt;<span class=\"hljs-built_in\">attr_value</span>(<span class=\"hljs-string\">&quot;name&quot;</span>);<br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* pass = node-&gt;<span class=\"hljs-built_in\">attr_value</span>(<span class=\"hljs-string\">&quot;pass&quot;</span>);<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;tag: %s, name: %s, pass: %s\\r\\n&quot;</span>,<br>\t\t\t\ttag ? tag : <span class=\"hljs-string\">&quot;null&quot;</span>,<br>\t\t\t\tname ? name : <span class=\"hljs-string\">&quot;null&quot;</span>,<br>\t\t\t\tpass ? pass : <span class=\"hljs-string\">&quot;null&quot;</span>);<br>\t\t\tnode = body.<span class=\"hljs-built_in\">next_node</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 处理 text/json 类型数据</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">do_json</span><span class=\"hljs-params\">(http_request&amp; req)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tjson body;<br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">get_body</span>(body, to_charset_) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;get http body error&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\tjson_node* node = body.<span class=\"hljs-built_in\">first_node</span>();<br>\t\t<span class=\"hljs-keyword\">while</span> (node)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">tag_name</span>())<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;tag: %s&quot;</span>, node-&gt;<span class=\"hljs-built_in\">tag_name</span>());<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">get_text</span>())<br>\t\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;, value: %s\\r\\n&quot;</span>, node-&gt;<span class=\"hljs-built_in\">get_text</span>());<br>\t\t\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>\t\t\t&#125;<br>\t\t\tnode = body.<span class=\"hljs-built_in\">next_node</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tstring server_addr_;\t<span class=\"hljs-comment\">// web 服务器地址</span><br>\tstring file_;\t\t<span class=\"hljs-comment\">// 本地请求的数据文件</span><br>\tstring stype_;\t\t<span class=\"hljs-comment\">// 请求数据的子数据类型</span><br>\tstring charset_;\t<span class=\"hljs-comment\">// 本地请求数据文件的字符集</span><br>\tstring to_charset_;\t<span class=\"hljs-comment\">// 将服务器响应数据转为本地字符集</span><br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* procname)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h[help]\\r\\n&quot;</span>, procname);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;options:\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\t-f request file\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\t-t request stype[xml/json/plain]\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\t-c request file&#x27;s charset[gb2312/utf-8]\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span>   ch;<br>\t<span class=\"hljs-function\">string <span class=\"hljs-title\">server_addr</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>)</span>, <span class=\"hljs-title\">file</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;./xml.txt&quot;</span>)</span></span>;<br>\t<span class=\"hljs-function\">string <span class=\"hljs-title\">stype</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;xml&quot;</span>)</span>, <span class=\"hljs-title\">charset</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;gb2312&quot;</span>)</span></span>;<br><br>\t<span class=\"hljs-keyword\">while</span> ((ch = <span class=\"hljs-built_in\">getopt</span>(argc, argv, <span class=\"hljs-string\">&quot;hs:f:t:c:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> (ch)<br>\t\t&#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;f&#x27;</span>:<br>\t\t\tfile = optarg;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;t&#x27;</span>:<br>\t\t\tstype = optarg;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;c&#x27;</span>:<br>\t\t\tcharset = optarg;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\tlog::<span class=\"hljs-built_in\">stdout_open</span>(<span class=\"hljs-literal\">true</span>);   <span class=\"hljs-comment\">// 允许日志输出至屏幕上</span><br>\t<span class=\"hljs-function\">http_request_test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(server_addr, file, stype, charset)</span></span>;<br>\ttest.<span class=\"hljs-built_in\">run</span>();  <span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>\n\n<p>上面的例子来自于 lib_acl_cpp&#x2F;samples&#x2F;http_request。</p>\n<p>如果查看 http_request::request 源码实现，会发现 try_open()、reuse_conn、need_retry_ 等方法或变量来表示 HTTP 客户端连接的重试过程，这是因为 http_request 类的设计是支持长连接及可重用的，对于 HTTP 客户端连接池来说这些功能非常重要，在下一节介绍使用 acl 的 http 客户端连接池功能类时将会用到 http 请求客户端连接的重连及重试机制。</p>\n<h2 id=\"四、参考\"><a href=\"#四、参考\" class=\"headerlink\" title=\"四、参考\"></a>四、参考</h2><p>http_request 类的头文件位置：lib_acl_cpp&#x2F;include&#x2F;acl_cpp&#x2F;http&#x2F;http_request.hpp<br>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>之前写过几篇如何使用 acl 库来实现 HTTP 客户端的例子都是基于 C 语言(使用 acl 较为底层的 HTTP 协议库写 HTTP 下载客户端举例, 使用 acl 库开发一个 HTTP 下载客户端)，其实在 acl 的 C++ 库(lib_acl_cpp) 中 HTTP 类功能更为强大，本节将介绍如何使用 acl::http_request 类来写一些简单的 HTTP 客户端示例。</p>\n<h2 id=\"一、-acl-http-request-类的一些常用接口\"><a href=\"#一、-acl-http-request-类的一些常用接口\" class=\"headerlink\" title=\"一、 acl::http_request 类的一些常用接口\"></a>一、 acl::http_request 类的一些常用接口</h2><p>该 HTTP 请求类有两个构造函数，如下 ：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构造函数：通过该构造函数传入的 socket_stream 流对象并</span><br><span class=\"hljs-comment\"> * 不会被关闭，需要调用者自己关闭</span><br><span class=\"hljs-comment\"> * @param client &#123;socket_stream*&#125; 数据连接流，非空，</span><br><span class=\"hljs-comment\"> *  在本类对象被销毁时该流对象并不会被销毁，所以用户需自行释放</span><br><span class=\"hljs-comment\"> * @param conn_timeout &#123;int&#125; 如果传入的流关闭，则内部会</span><br><span class=\"hljs-comment\"> *  自动重试，此时需要该值表示连接服务器的超时时间(秒)，</span><br><span class=\"hljs-comment\"> *  至于重连流的 IO 读写超时时间是从 输入的流中继承的</span><br><span class=\"hljs-comment\"> * @param unzip &#123;bool&#125; 是否对服务器响应的数据自动进行解压</span><br><span class=\"hljs-comment\"> * 注：当该类实例被多次使用时，用户应该在每次调用前调用</span><br><span class=\"hljs-comment\"> * request_header::http_header::reset()</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">http_request</span>(socket_stream* client, <span class=\"hljs-type\">int</span> conn_timeout = <span class=\"hljs-number\">60</span>,<br>\t<span class=\"hljs-type\">bool</span> unzip = <span class=\"hljs-literal\">true</span>);<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构造函数：该构造函数内部创建的 socket_stream 流会自行关闭</span><br><span class=\"hljs-comment\"> * @param addr &#123;const char*&#125; WEB 服务器地址</span><br><span class=\"hljs-comment\"> * @param conn_timeout &#123;int&#125; 远程连接服务器超时时间(秒)</span><br><span class=\"hljs-comment\"> * @param rw_timeout &#123;int&#125; IO 读写超时时间(秒)</span><br><span class=\"hljs-comment\"> * @param unzip &#123;bool&#125; 是否对服务器响应的数据自动进行解压</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">http_request</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">int</span> conn_timeout = <span class=\"hljs-number\">60</span>,<br>\t<span class=\"hljs-type\">int</span> rw_timeout = <span class=\"hljs-number\">60</span>, <span class=\"hljs-type\">bool</span> unzip = <span class=\"hljs-literal\">true</span>);<br></code></pre></td></tr></table></figure>\n<p>第一个是以已经连接成功的套接字流为参数的构造函数，该构造函数把连接 HTTP 服务器的工作交给用户来完成；第二个是以 HTTP 服务器地址为参数的构造函数，使用该构造函数，则该类对象内部会自动连接 HTTP 服务器。</p>\n<p>下面的几个函数接口与 HTTP 发送相关：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得 HTTP 请求头对象，然后在返回的 HTTP 请求头对象中添加</span><br><span class=\"hljs-comment\"> * 自己的请求头字段或 http_header::reset()重置请求头状态，</span><br><span class=\"hljs-comment\"> * 参考：http_header 类</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">request_header</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 向 HTTP 服务器发送 HTTP 请求头及 HTTP 请求体，同时从</span><br><span class=\"hljs-comment\"> * HTTP 服务器读取 HTTP 响应头，对于长连接，当连接中断时</span><br><span class=\"hljs-comment\"> * 会再重试一次，在调用下面的几个 get_body 函数前必须先</span><br><span class=\"hljs-comment\"> * 调用本函数(或调用 write_head/write_body)；</span><br><span class=\"hljs-comment\"> * 正常情况下，该函数在发送完请求数据后会读 HTTP 响应头，</span><br><span class=\"hljs-comment\"> * 所以用户在本函数返回 true 后可以调用：get_body() 或</span><br><span class=\"hljs-comment\"> * http_request::get_clinet()-&gt;read_body(char*, size_t)</span><br><span class=\"hljs-comment\"> * 继续读 HTTP 响应的数据体</span><br><span class=\"hljs-comment\"> * @param data &#123;const void*&#125; 发送的数据体地址，非空时自动按</span><br><span class=\"hljs-comment\"> *  POST 方法发送，否则按 GET 方法发送</span><br><span class=\"hljs-comment\"> * @param len &#123;size_&#125; data 非空时指定 data 数据长度</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 发送请求数据及读 HTTP 响应头数据是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">request</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* data, <span class=\"hljs-type\">size_t</span> len)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当采用流式写数据时，需要首先调用本函数发送 HTTP 请求头</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 是否成功，如果成功才可以继续调用 write_body</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_head</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当采用流式写数据时，在调用 write_head 后，可以循环调用本函数</span><br><span class=\"hljs-comment\"> * 发送 HTTP 请求体数据；当输入的两个参数为空值时则表示数据写完；</span><br><span class=\"hljs-comment\"> * 当发送完数据后，该函数内部会自动读取 HTTP 响应头数据，用户可</span><br><span class=\"hljs-comment\"> * 继续调用 get_body/read_body 获取 HTTP 响应体数据</span><br><span class=\"hljs-comment\"> * @param data &#123;const void*&#125; 数据地址指针，当该值为空指针时表示</span><br><span class=\"hljs-comment\"> *  数据发送完毕</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125; data 非空指针时表示数据长度</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 发送数据体是否成功</span><br><span class=\"hljs-comment\"> *  注：当应用发送完数据后，必须再调用一次本函数，同时将两个参数都赋空</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_body</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* data, <span class=\"hljs-type\">size_t</span> len)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>构建及发送 HTTP 请求的过程如下：</p>\n<ul>\n<li>1、使用两个构造函数之一创建 acl::http_request 请求对象</li>\n<li>2、调用 http_request::request_header 获得 HTTP 请求头对象的引用（http_header&amp;），然后对该 HTTP 请求头设置 HTTP 请求的参数</li>\n<li>3、http_request 类提供了两种 HTTP 请求调用 方式：<ul>\n<li>3.1、当 HTTP 请求方法为 HTTP GET 方法或为 HTTP POST 但数据体可以一次性写入时，可以使用 http_request::request 方法，在调用 http_request::request 时会将 HTTP 请求头及请求体一次性发给 HTTP 服务器；</li>\n<li>3.2   如果为 HTTP POST 请求方法，且 HTTP 数据体内容是流式的（即每次只是要发送部分数据），则应该使用 http_request::write_head 和 http_request::write_body 两个函数，即使用流式方式发送数据时，应首先调用 http_request::write_head 发送 HTTP 请求头，当该函数返回成功后，可以循环调用 http_request::write_body 来发送 HTTP 请求数据体，为了表示 HTTP 请求体数据完毕，必须最后调用一次 http_request::write_body 且两个参数为 0 时以表示数据体发送完毕。</li>\n</ul>\n</li>\n</ul>\n<p>在调用以上 3.1 或 3.2 过程成功发送完 HTTP 请求数据后，这两个过程内部会自动读取 HTTP 服务器发来的 HTTP 响应头。</p>\n<p>在上面的步骤 2 获得 HTTP 请求头对象（http_header）后，应该先调用下面的方法设置 HTTP 请求头中的参数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置请求的 URL，url 格式示例如下：</span><br><span class=\"hljs-comment\"> * 1、http://www.test.com/</span><br><span class=\"hljs-comment\"> * 2、/cgi-bin/test.cgi</span><br><span class=\"hljs-comment\"> * 3、http://www.test.com/cgi-bin/test.cgi</span><br><span class=\"hljs-comment\"> * 3、http://www.test.com/cgi-bin/test.cgi?name=value</span><br><span class=\"hljs-comment\"> * 4、/cgi-bin/test.cgi?name=value</span><br><span class=\"hljs-comment\"> * 5、http://www.test.com</span><br><span class=\"hljs-comment\"> * 如果该 url 中有主机字段，则内部自动添加主机；</span><br><span class=\"hljs-comment\"> * 如果该 url 中有参数字段，则内部自动进行处理并调用 add_param 方法；</span><br><span class=\"hljs-comment\"> * 调用该函数后用户仍可以调用 add_param 等函数添加其它参数；</span><br><span class=\"hljs-comment\"> * 当参数字段只有参数名没有参数值时，该参数将会被忽略，所以如果想</span><br><span class=\"hljs-comment\"> * 单独添加参数名，应该调用 add_param 方法来添加</span><br><span class=\"hljs-comment\"> * @param url &#123;const char*&#125; 请求的 url，非空指针</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_url</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* url)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 请求头的 HOST 字段</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; 请求头的 HOST 字段值</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_host</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 向请求的 URL 中添加参数对，当只有参数名没有参数值时则：</span><br><span class=\"hljs-comment\"> * 1、参数名非空串，但参数值为空指针，则 URL 参数中只有：&#123;name&#125;</span><br><span class=\"hljs-comment\"> * 2、参数名非空串，但参数值为空串，则 URL参数中为：&#123;name&#125;=</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; 参数名，不能为空指针</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; 参数值，当为空指针时，仅添加参数名，</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_param</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">short</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">int</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">long</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">short</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_int</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> value)</span></span>;<br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_format</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* fmt, ...)</span></span><br><span class=\"hljs-function\">\t<span class=\"hljs-title\">ACL_CPP_PRINTF</span><span class=\"hljs-params\">(<span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 向 HTTP 头中添加 cookie</span><br><span class=\"hljs-comment\"> * @param name &#123;const char*&#125; cookie 名</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; cookie 值</span><br><span class=\"hljs-comment\"> * @param domain &#123;const char*&#125; 所属域</span><br><span class=\"hljs-comment\"> * @param path &#123;const char*&#125; 存储路径</span><br><span class=\"hljs-comment\"> * @param expires &#123;time_t&#125; 过期时间，当该值为 0 时表示不过期，</span><br><span class=\"hljs-comment\"> *  &gt; 0 时，则从现在起再增加 expires 即为过期时间，单位为秒</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">add_cookie</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* domain = <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* path = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">time_t</span> expires = <span class=\"hljs-number\">0</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 头中的 Connection 字段，是否保持长连接</span><br><span class=\"hljs-comment\"> * 不过，目前并未真正支持长连接，即使设置了该标志位，</span><br><span class=\"hljs-comment\"> * 则得到响应数据后也会主动关闭连接</span><br><span class=\"hljs-comment\"> * @param on &#123;bool&#125; 是否保持长连接</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_keep_alive</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> on)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 头中的 Content-Length 字段</span><br><span class=\"hljs-comment\"> * @param n &#123;long long int&#125; 设置值</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_content_length</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> n)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 头中的 Content-Type 字段</span><br><span class=\"hljs-comment\"> * @param value &#123;const char*&#125; 设置值</span><br><span class=\"hljs-comment\"> * @return &#123;http_header&amp;&#125; 返回本对象的引用，便于用户连续操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">http_header&amp; <span class=\"hljs-title\">set_content_type</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>以上仅列出了 http_header 类设置 HTTP 请求参数的一些常用方法，其它的方法请参考 http_header.hpp 头文件中的说明。</p>\n<h2 id=\"二、acl-http-request-类获得-HTTP-服务器响应数据的常用方法\"><a href=\"#二、acl-http-request-类获得-HTTP-服务器响应数据的常用方法\" class=\"headerlink\" title=\"二、acl::http_request 类获得 HTTP 服务器响应数据的常用方法\"></a>二、acl::http_request 类获得 HTTP 服务器响应数据的常用方法</h2><p>上面介绍了使用 acl::http_request 构建 HTTP 请求头及发送请求的接口方法，下面介绍使用 acl::http_request 类中的方法来接收 HTTP 服务器响应过程，在调用 http_request 类中的 request 或 write_body 成功发送完请求数据后，该类对象在这两个方法内部会首先自动接收 HTTP 服务器的响应头数据，若接收过程失败，这两个方法也会返回 false 表示失败，若返回成功，则可以调用 http_request 类对象的 http_status 方法获得 HTTP 服务器的响应状态码（2xx, 3xx, 4xx, 5xx），还可调用 body_length 方法获得 HTTP 响应数据体的长度（当 HTTP 服务器返回的数据格式为 HTTP 块传输时，该函数会返回 -1，所以一般不用显示调用该方法）。下面介绍了主要的与 HTTP 响应相关的方法：</p>\n<p>首先是与 HTTP 响应头相关的接口函数，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 当发送完请求数据后，内部会自动调用读 HTTP 响应头过程，可以通过此函数获得服务端</span><br><span class=\"hljs-comment\">\t * 响应的 HTTP 状态字(2xx, 3xx, 4xx, 5xx)；</span><br><span class=\"hljs-comment\">\t * 其实该函数内部只是调用了 http_client::response_status 方法</span><br><span class=\"hljs-comment\">\t * @return &#123;int&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_status</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 响应的数据体长度</span><br><span class=\"hljs-comment\">\t * @return &#123;int64) 返回值若为 -1 则表明 HTTP 头不存在或没有长度字段</span><br><span class=\"hljs-comment\">\t */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t<span class=\"hljs-function\">__int64 <span class=\"hljs-title\">body_length</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">body_length</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * HTTP 数据流(响应流是否允许保持长连接)</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">keep_alive</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得 HTTP 响应头中某个字段名的字段值</span><br><span class=\"hljs-comment\">\t * @param name &#123;const char*&#125; 字段名</span><br><span class=\"hljs-comment\">\t * @return &#123;const char*&#125; 字段值，为空时表示不存在</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">header_value</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name)</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 获得服务器返回的 Set-Cookie 设置的某个 cookie 对象</span><br><span class=\"hljs-comment\">\t * @param name &#123;const char*&#125; cookie 名</span><br><span class=\"hljs-comment\">\t * @param case_insensitive &#123;bool&#125; 是否区分大小写，true 表示</span><br><span class=\"hljs-comment\">\t *  不区分大小写</span><br><span class=\"hljs-comment\">\t * @return &#123;const HttpCookie*&#125; 返回 NULL 表示不存在</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">const</span> HttpCookie* <span class=\"hljs-title\">get_cookie</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">bool</span> case_insensitive = <span class=\"hljs-literal\">true</span>)</span> <span class=\"hljs-type\">const</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>然后是与读 HTTP 响应数据体相关的接口函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 是否读完了数据体</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">body_finish</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数，读取服务器响应体数据</span><br><span class=\"hljs-comment\"> * 并将结果存储于规定的 xml 对象中</span><br><span class=\"hljs-comment\"> * @param out &#123;xml&amp;&#125; HTTP 响应体数据存储于该 xml 对象中</span><br><span class=\"hljs-comment\"> * @param to_charset &#123;const char*&#125; 当该项非空，内部自动</span><br><span class=\"hljs-comment\"> *  将数据转成该字符集存储于 xml 对象中</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 读数据是否成功</span><br><span class=\"hljs-comment\"> * 注：当响应数据体特别大时不应用此函数，以免内存耗光</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">get_body</span><span class=\"hljs-params\">(xml&amp; out, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* to_charset = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数，读取服务器响应体数据</span><br><span class=\"hljs-comment\"> * 并将结果存储于规定的 json 对象中</span><br><span class=\"hljs-comment\"> * @param out &#123;json&amp;&#125; HTTP 响应体数据存储于该 json 对象中</span><br><span class=\"hljs-comment\"> * @param to_charset &#123;const char*&#125; 当该项非空，内部自动</span><br><span class=\"hljs-comment\"> *  将数据转成该字符集存储于 json 对象中</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 读数据是否成功</span><br><span class=\"hljs-comment\"> * 注：当响应数据体特别大时不应用此函数，以免内存耗光</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">get_body</span><span class=\"hljs-params\">(json&amp; out, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* to_charset = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数，读取服务器全部响应数据</span><br><span class=\"hljs-comment\"> * 存储于输入的缓冲区中</span><br><span class=\"hljs-comment\"> * @param out &#123;string&amp;&#125; 存储响应数据体</span><br><span class=\"hljs-comment\"> * @param to_charset &#123;const char*&#125; 当该项非空，内部自动</span><br><span class=\"hljs-comment\"> *  将数据转成该字符集存储于 out 对象中</span><br><span class=\"hljs-comment\"> * 注：当响应数据体特别大时不应用此函数，以免内存耗光</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">get_body</span><span class=\"hljs-params\">(string&amp; out, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* to_charset = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br><span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数，读取服务器响应数据并</span><br><span class=\"hljs-comment\"> * 存储于输入的缓冲区中，可以循环调用本函数，直至数据读完了，</span><br><span class=\"hljs-comment\"> * @param buf &#123;char*&#125; 存储部分响应数据体</span><br><span class=\"hljs-comment\"> * @param size &#123;size_t&#125; buf 缓冲区大小</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 返回值 == 0 表示正常读完毕，&lt; 0 表示服务器</span><br><span class=\"hljs-comment\"> *  关闭连接，&gt; 0 表示已经读到的数据，用户应该一直读数据直到</span><br><span class=\"hljs-comment\"> *  返回值 &lt;= 0 为止</span><br><span class=\"hljs-comment\"> *  注：该函数读到的是原始 HTTP 数据体数据，不做解压和字符集</span><br><span class=\"hljs-comment\"> *  解码，用户自己根据需要进行处理</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">read_body</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* buf, <span class=\"hljs-type\">size_t</span> size)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数读 HTTP 响应数据体，可以循环调用</span><br><span class=\"hljs-comment\"> * 本函数，本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用</span><br><span class=\"hljs-comment\"> * set_charset 设置了本地字符集，则还同时对数据进行字符集转码操作</span><br><span class=\"hljs-comment\"> * @param out &#123;string&amp;&#125; 存储结果数据</span><br><span class=\"hljs-comment\"> * @param clean &#123;bool&#125; 每次调用本函数时，是否要求先自动将缓冲区 out</span><br><span class=\"hljs-comment\"> *  的数据清空</span><br><span class=\"hljs-comment\"> * @param real_size &#123;int*&#125; 当该指针非空时，存储解压前读到的真正数据</span><br><span class=\"hljs-comment\"> *  长度，如果在构造函数中指定了非自动解压模式且读到的数据 &gt; 0，则该</span><br><span class=\"hljs-comment\"> *  值存储的长度值应该与本函数返回值相同；当读出错或未读到任何数据时，</span><br><span class=\"hljs-comment\"> *  该值存储的长度值为 0</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; == 0 表示读完毕，可能连接并未关闭；&gt;0 表示本次读操作</span><br><span class=\"hljs-comment\"> *  读到的数据长度(当为解压后的数据时，则表示为解压之后的数据长度，</span><br><span class=\"hljs-comment\"> *  与真实读到的数据不同，真实读到的数据长度应该通过参数 real_size 来</span><br><span class=\"hljs-comment\"> *  获得); &lt; 0 表示数据流关闭，此时若 real_size 非空，则 real_size 存</span><br><span class=\"hljs-comment\"> *  储的值应该为 0</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">read_body</span><span class=\"hljs-params\">(string&amp; out, <span class=\"hljs-type\">bool</span> clean = <span class=\"hljs-literal\">false</span>, <span class=\"hljs-type\">int</span>* real_size = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当调用 request 成功后调用本函数来从 HTTP 服务端读一行数据，可以循环调用</span><br><span class=\"hljs-comment\"> * 本函数，直到返回 false 或 body_finish() 返回 true 为止；</span><br><span class=\"hljs-comment\"> * 本函数内部自动对压缩数据进行解压，如果在调用本函数之前调用 set_charset 设置了</span><br><span class=\"hljs-comment\"> * 本地字符集，则还同时对数据进行字符集转码操作</span><br><span class=\"hljs-comment\"> * @param out &#123;string&amp;&#125; 存储结果数据</span><br><span class=\"hljs-comment\"> * @param nonl &#123;bool&#125; 读到的一行数据是否自动去掉尾部的 &quot;\\r\\n&quot; 或 &quot;\\n&quot;</span><br><span class=\"hljs-comment\"> * @param size &#123;size_t*&#125; 该指针非空时存放读到的数据长度</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 是否读到了一行数据：当返回 true 时表示读到了一行数据，可以</span><br><span class=\"hljs-comment\"> *  通过 body_finish() 是否为 true 来判断是否读数据体已经结束，当读到一个空行</span><br><span class=\"hljs-comment\"> *  且 nonl = true 时，则 *size = 0；当返回 false 时表示未读完整行且读完毕，</span><br><span class=\"hljs-comment\"> *  *size 中存放着读到的数据长度</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">body_gets</span><span class=\"hljs-params\">(string&amp; out, <span class=\"hljs-type\">bool</span> nonl = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">size_t</span>* size = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>虽然上面提供了多个读 HTTP 响应体数据的方法，但可以分为两大类：1、一次性读所有的数据体；2、以流式方式循环读数据体。 其中，对于“一次性读取所有数据体”的读方法，适合于响应数据体比较小的情形，当响应数据为 xml 或 json 格式时，还提供了直接将响应数据体转为 xml 或 json 对象的读方法；如果响应数据体非常大（如几兆甚至几十兆以上）则应该采用流式方法循环读数据体。</p>\n<p>有一点需要注意，除了 “ int read_body(char* buf, size_t size);” 可以直接读原生的响应数据体外，其它的读方法会将读到数据体自动进行解压、字符集转换操作后将最终结果返回调用者。</p>\n<p>此外，为了方便一些文本类应用，在 http_request 类中还提供了 body_gets 方法，用来以行为单位读取 HTTP 响应数据体（当服务器也是以行为单位发送响应数据时才可使用 body_gets 方法）。</p>\n<p>acl::http_request 类除了以上接口外，还提供了其它丰富的接口（如：支持 HTTP 断点续传的 Range 相关的方法），如果您觉得这些接口依然不能满足要求，不妨通过 “http_request::get_client” 获得 acl::http_client 类对象（该类对象是 acl 有关 http 协议处理中比较基础的 HTTP 通信类），然后再在 acl::http_client 类中查找您所希望的功能接口。</p>\n<h2 id=\"三、示例\"><a href=\"#三、示例\" class=\"headerlink\" title=\"三、示例\"></a>三、示例</h2><p>下面用一个简单的例子来说明上面一些方法的使用过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// http_servlet.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;getopt.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_request_test</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_request_test</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* server_addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* file,<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* stype, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* charset)<br>\t&#123;<br>\t\tserver_addr_= server_addr;<br>\t\tfile_ = file;<br>\t\tstype_ = stype;<br>\t\tcharset_ = charset;<br>\t\tto_charset_ = <span class=\"hljs-string\">&quot;gb2312&quot;</span>;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">http_request_test</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstring body;<br>\t\t<span class=\"hljs-keyword\">if</span> (ifstream::<span class=\"hljs-built_in\">load</span>(file_, &amp;body) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;load %s error&quot;</span>, file_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-function\">http_request <span class=\"hljs-title\">req</span><span class=\"hljs-params\">(server_addr_)</span></span>;<br><br>\t\t<span class=\"hljs-comment\">// 添加 HTTP 请求头字段</span><br><br>\t\t<span class=\"hljs-function\">string <span class=\"hljs-title\">ctype</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;text/&quot;</span>)</span></span>;<br>\t\tctype &lt;&lt; stype_ &lt;&lt; <span class=\"hljs-string\">&quot;; charset=&quot;</span> &lt;&lt; charset_;<br><br>\t\thttp_header&amp; hdr = req.<span class=\"hljs-built_in\">request_header</span>();  <span class=\"hljs-comment\">// 请求头对象的引用</span><br>\t\thdr.<span class=\"hljs-built_in\">set_url</span>(<span class=\"hljs-string\">&quot;/&quot;</span>);<br>\t\thdr.<span class=\"hljs-built_in\">set_content_type</span>(ctype);<br>\t\thdr.<span class=\"hljs-built_in\">add_param</span>(<span class=\"hljs-string\">&quot;name1&quot;</span>, <span class=\"hljs-string\">&quot;value1&quot;</span>);<br>\t\thdr.<span class=\"hljs-built_in\">add_param</span>(<span class=\"hljs-string\">&quot;name2&quot;</span>, <span class=\"hljs-string\">&quot;value2&quot;</span>);<br>\t\t<span class=\"hljs-comment\">// 发送 HTTP 请求数据</span><br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">request</span>(body.<span class=\"hljs-built_in\">c_str</span>(), body.<span class=\"hljs-built_in\">length</span>()) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;send http request to %s error&quot;</span>,<br>\t\t\t\tserver_addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 取出 HTTP 响应头的 Content-Type 字段</span><br><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* p = req.<span class=\"hljs-built_in\">header_value</span>(<span class=\"hljs-string\">&quot;Content-Type&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (p == <span class=\"hljs-literal\">NULL</span> || *p == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;no Content-Type&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 分析 HTTP 响应头的数据类型</span><br>\t\thttp_ctype content_type;<br>\t\tcontent_type.<span class=\"hljs-built_in\">parse</span>(p);<br><br>\t\t<span class=\"hljs-comment\">// 响应头数据类型的子类型</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* stype = content_type.<span class=\"hljs-built_in\">get_stype</span>();<br><br>\t\t<span class=\"hljs-type\">bool</span> ret;<br>\t\t<span class=\"hljs-keyword\">if</span> (stype == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\tret = <span class=\"hljs-built_in\">do_plain</span>(req);<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcasecmp</span>(stype, <span class=\"hljs-string\">&quot;xml&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\tret = <span class=\"hljs-built_in\">do_xml</span>(req);<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strcasecmp</span>(stype, <span class=\"hljs-string\">&quot;json&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t\tret = <span class=\"hljs-built_in\">do_json</span>(req);<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\tret = <span class=\"hljs-built_in\">do_plain</span>(req);<br>\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-literal\">true</span>)<br>\t\t\t<span class=\"hljs-built_in\">logger</span>(<span class=\"hljs-string\">&quot;read ok!\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> ret;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-comment\">// 处理 text/plain 类型数据</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">do_plain</span><span class=\"hljs-params\">(http_request&amp; req)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstring body;<br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">get_body</span>(body, to_charset_) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;get http body error&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;body:\\r\\n(%s)\\r\\n&quot;</span>, body.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 处理 text/xml 类型数据</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">do_xml</span><span class=\"hljs-params\">(http_request&amp; req)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\txml body;<br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">get_body</span>(body, to_charset_) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;get http body error&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\txml_node* node = body.<span class=\"hljs-built_in\">first_node</span>();<br>\t\t<span class=\"hljs-keyword\">while</span> (node)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* tag = node-&gt;<span class=\"hljs-built_in\">tag_name</span>();<br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* name = node-&gt;<span class=\"hljs-built_in\">attr_value</span>(<span class=\"hljs-string\">&quot;name&quot;</span>);<br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* pass = node-&gt;<span class=\"hljs-built_in\">attr_value</span>(<span class=\"hljs-string\">&quot;pass&quot;</span>);<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;tag: %s, name: %s, pass: %s\\r\\n&quot;</span>,<br>\t\t\t\ttag ? tag : <span class=\"hljs-string\">&quot;null&quot;</span>,<br>\t\t\t\tname ? name : <span class=\"hljs-string\">&quot;null&quot;</span>,<br>\t\t\t\tpass ? pass : <span class=\"hljs-string\">&quot;null&quot;</span>);<br>\t\t\tnode = body.<span class=\"hljs-built_in\">next_node</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 处理 text/json 类型数据</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">do_json</span><span class=\"hljs-params\">(http_request&amp; req)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tjson body;<br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">get_body</span>(body, to_charset_) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;get http body error&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\tjson_node* node = body.<span class=\"hljs-built_in\">first_node</span>();<br>\t\t<span class=\"hljs-keyword\">while</span> (node)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">tag_name</span>())<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;tag: %s&quot;</span>, node-&gt;<span class=\"hljs-built_in\">tag_name</span>());<br>\t\t\t\t<span class=\"hljs-keyword\">if</span> (node-&gt;<span class=\"hljs-built_in\">get_text</span>())<br>\t\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;, value: %s\\r\\n&quot;</span>, node-&gt;<span class=\"hljs-built_in\">get_text</span>());<br>\t\t\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>\t\t\t&#125;<br>\t\t\tnode = body.<span class=\"hljs-built_in\">next_node</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tstring server_addr_;\t<span class=\"hljs-comment\">// web 服务器地址</span><br>\tstring file_;\t\t<span class=\"hljs-comment\">// 本地请求的数据文件</span><br>\tstring stype_;\t\t<span class=\"hljs-comment\">// 请求数据的子数据类型</span><br>\tstring charset_;\t<span class=\"hljs-comment\">// 本地请求数据文件的字符集</span><br>\tstring to_charset_;\t<span class=\"hljs-comment\">// 将服务器响应数据转为本地字符集</span><br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* procname)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h[help]\\r\\n&quot;</span>, procname);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;options:\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\t-f request file\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\t-t request stype[xml/json/plain]\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\t-c request file&#x27;s charset[gb2312/utf-8]\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span>   ch;<br>\t<span class=\"hljs-function\">string <span class=\"hljs-title\">server_addr</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>)</span>, <span class=\"hljs-title\">file</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;./xml.txt&quot;</span>)</span></span>;<br>\t<span class=\"hljs-function\">string <span class=\"hljs-title\">stype</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;xml&quot;</span>)</span>, <span class=\"hljs-title\">charset</span><span class=\"hljs-params\">(<span class=\"hljs-string\">&quot;gb2312&quot;</span>)</span></span>;<br><br>\t<span class=\"hljs-keyword\">while</span> ((ch = <span class=\"hljs-built_in\">getopt</span>(argc, argv, <span class=\"hljs-string\">&quot;hs:f:t:c:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> (ch)<br>\t\t&#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;f&#x27;</span>:<br>\t\t\tfile = optarg;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;t&#x27;</span>:<br>\t\t\tstype = optarg;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;c&#x27;</span>:<br>\t\t\tcharset = optarg;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\tlog::<span class=\"hljs-built_in\">stdout_open</span>(<span class=\"hljs-literal\">true</span>);   <span class=\"hljs-comment\">// 允许日志输出至屏幕上</span><br>\t<span class=\"hljs-function\">http_request_test <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(server_addr, file, stype, charset)</span></span>;<br>\ttest.<span class=\"hljs-built_in\">run</span>();  <span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125; <br></code></pre></td></tr></table></figure>\n\n<p>上面的例子来自于 lib_acl_cpp&#x2F;samples&#x2F;http_request。</p>\n<p>如果查看 http_request::request 源码实现，会发现 try_open()、reuse_conn、need_retry_ 等方法或变量来表示 HTTP 客户端连接的重试过程，这是因为 http_request 类的设计是支持长连接及可重用的，对于 HTTP 客户端连接池来说这些功能非常重要，在下一节介绍使用 acl 的 http 客户端连接池功能类时将会用到 http 请求客户端连接的重连及重试机制。</p>\n<h2 id=\"四、参考\"><a href=\"#四、参考\" class=\"headerlink\" title=\"四、参考\"></a>四、参考</h2><p>http_request 类的头文件位置：lib_acl_cpp&#x2F;include&#x2F;acl_cpp&#x2F;http&#x2F;http_request.hpp<br>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"使用 acl 库开发一个 HTTP 下载客户端","date":"2010-01-11T10:08:24.000Z","_content":"\n在 acl 的协议库(lib_protocol) 中有专门针对 HTTP 协议和 ICMP 协议的，本文主要介绍如何使用 lib_protocol 协议库来开发一个简单的 http 客户端。下面首先介绍一下几个本文用到的函数接口。\n\n```c++\n/**\n * 创建一个 HTTP_UTIL 请求对象\n * @param url {const char*} 完整的请求 url\n * @param method {const char*} 请求方法，有效的请求方法有：GET, POST, HEAD, CONNECT\n * @return {HTTP_UTIL*}\n */\nHTTP_API HTTP_UTIL *http_util_req_new(const char *url, const char *method);\n\n/**\n * 设置 HTTP 代理服务器地址\n * @param http_util {HTTP_UTIL*}\n * @param proxy {const char*} 代理服务器地址，有效格式为: IP:PORT, DOMAIN:PORT,\n *  如: 192.168.0.1:80, 192.168.0.2:8088, www.g.cn:80\n */\nHTTP_API void http_util_set_req_proxy(HTTP_UTIL *http_util, const char *proxy);\n\n/**\n * 设置 HTTP 响应体的转储文件，设置后 HTTP 响应体数据便会转储于该文件\n * @param http_util {HTTP_UTIL*}\n * @param filename {const char*} 转储文件名\n * @return {int} 如果返回值 < 0 则表示无法打开该文件, 否则表示打开文件成功\n */\nHTTP_API int http_util_set_dump_file(HTTP_UTIL *http_util, const char *filename);\n\n/**\n * 打开远程 HTTP 服务器或代理服务器连接，同时构建 HTTP 请求头数据并且将该数据\n * 发给新建立的网络连接\n * @param http_util {HTTP_UTIL*}\n * @return {int} 0: 成功; -1: 无法打开连接或发送请求头数据失败\n */\nHTTP_API int http_util_req_open(HTTP_UTIL *http_util);\n\n/**\n * 发送完请求数据后调用此函数从 HTTP 服务器读取完整的 HTTP 响应头\n * @param http_util {HTTP_UTIL*}\n * @return {int} 0: 成功; -1: 失败\n */\nHTTP_API int http_util_get_res_hdr(HTTP_UTIL *http_util);\n\n/**\n * 读完 HTTP 响应头后调用此函数从 HTTP 服务器读取 HTTP 数据体数据，需要连续调用\n * 此函数，直至返回值 <= 0, 如果之前设置了转储文件或转储则在读取数据过程中同时会\n * 拷贝一份数据给转储文件或转储流\n * @param http_util {HTTP_UTIL*}\n * @param buf {char *} 存储 HTTP 响应体的缓冲区\n * @param size {size_t} buf 的空间大小\n * @return {int} <= 0: 表示读结束; > 0: 表示本次读到的数据长度\n */\nHTTP_API int http_util_get_res_body(HTTP_UTIL *http_util, char *buf, size_t size);\n```\n\n以上仅是 lib_http_util.h 函数接口中的一部分，下面就写一个简单的例子：\n\n```c++\n#include \"lib_acl.h\"\n#include \"lib_protocol.h\"\n\nstatic void get_url(const char *method, const char *url,\n\tconst char *proxy, const char *dump, int out)\n{\n\t/* 创建 HTTP_UTIL 请求对象 */\n\tHTTP_UTIL *http = http_util_req_new(url, method);\n\tint   ret;\n\n\t/* 如果设定代理服务器，则连接代理服务器地址，\n\t * 否则使用 HTTP 请求头里指定的地址\n\t */\n\n\tif (proxy && *proxy)\n\t\thttp_util_set_req_proxy(http, proxy);\n\n\t/* 设置转储文件 */\n\tif (dump && *dump)\n\t\thttp_util_set_dump_file(http, dump);\n\n\t/* 输出 HTTP 请求头内容 */\n\n\thttp_hdr_print(&http->hdr_req->hdr, \"---request hdr---\");\n\n\t/* 连接远程 http 服务器 */\n\n\tif (http_util_req_open(http) < 0) {\n\t\tprintf(\"open connection(%s) error\\n\", http->server_addr);\n\t\thttp_util_free(http);\n\t\treturn;\n\t}\n\n\t/* 读取 HTTP 服务器响应头*/\n\n\tret = http_util_get_res_hdr(http);\n\tif (ret < 0) {\n\t\tprintf(\"get reply http header error\\n\");\n\t\thttp_util_free(http);\n\t\treturn;\n\t}\n\n\t/* 输出 HTTP 响应头 */\n\n\thttp_hdr_print(&http->hdr_res->hdr, \"--- reply http header ---\");\n\n\t/* 如果有数据体则开始读取 HTTP 响应数据体部分 */\n\twhile (1) {\n\t\tchar  buf[4096];\n\t\t\n\t\tret = http_util_get_res_body(http, buf, sizeof(buf) - 1);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tbuf[ret] = 0;\n\t\tif (out)\n\t\t\tprintf(\"%s\", buf);\n\t}\n\thttp_util_free(http);\n}\n\nstatic void usage(const char *procname)\n{\n\tprintf(\"usage: %s -h[help] -t method -r url -f dump_file -o[output] -X proxy_addr\\n\"\n\t\t\"example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\\n\",\n\t\tprocname, procname);\n}\n\nint main(int argc, char *argv[])\n{\n\tint   ch, out = 0;\n\tchar  url[256], dump[256], proxy[256], method[32];\n\n\tacl_init();  /* 初始化 acl 库 */\n\n\tACL_SAFE_STRNCPY(method, \"GET\", sizeof(method));\n\turl[0] = 0;\n\tdump[0] = 0;\n\tproxy[0] = 0;\n\twhile ((ch = getopt(argc, argv, \"hor:t:f:X:\")) > 0) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\treturn (0);\n\t\tcase 'o':\n\t\t\tout = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tACL_SAFE_STRNCPY(url, optarg, sizeof(url));\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tACL_SAFE_STRNCPY(method, optarg, sizeof(method));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tACL_SAFE_STRNCPY(dump, optarg, sizeof(dump));\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tACL_SAFE_STRNCPY(proxy, optarg, sizeof(proxy));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (url[0] == 0) {\n\t\tusage(argv[0]);\n\t\treturn (0);\n\t}\n\n\tget_url(method, url, proxy, dump, out);\n\treturn (0);\n}\n```\n\n编译成功后，运行 ./url_get -h 会给出如下提示：\n```\nusage: ./url_get -h[help] -t method -r url -f dump_file -o[output] -X proxy_addr\nexample: ./url_get -t GET -r http://www.sina.com.cn/ -f url_dump.txt\n```\n\n输入: ./url_get -t GET -r http://www.sina.com -o， 该命令是获取 www.sina.com 页面并输出至标准输出，得到的结果为：\n```\nHTTP/1.0 301 Moved Permanently\nDate: Tue, 12 Jan 2010 01:54:39 GMT\nServer: Apache\nLocation: http://www.sina.com.cn/\nCache-Control: max-age=3600\nExpires: Tue, 12 Jan 2010 02:54:39 GMT\nVary: Accept-Encoding\nContent-Length: 231\nContent-Type: text/html; charset=iso-8859-1\nAge: 265\nX-Cache: HIT from tj175-135.sina.com.cn\nConnection: close\n--------------- end -----------------\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>301 Moved Permanently</title>\n</head><body>\n<h1>Moved Permanently</h1>\n<p>The document has moved <a href=\"http://www.sina.com.cn/\">here</a>.</p>\n</body></html>\n```\n\n如果想把页面转存至文件中，可以输入：./url_get -t GET -r http://www.sina.com -f dump.txt, 这样就会把新浪的首页下载并存储于 dump.txt 文件中。\n\n这个例子非常简单，其实如果查看 http_util.c 源码，会看到这个文件是对 lib_http.h 里一些更为底层 API 的封装。\n\n如果仅是下载一个页面至某个文件中，其实还有更为简单的方法，只需要调用接口：\n\n```c++\n/**\n * 将某个 url 的响应体数据转储至某个文件中\n * @param url {const char*} 完整请求 url, 如: http://www.g.cn\n * @param dump {const char*} 转储文件名\n * @param {int} 读到的响应体数据长度, >=0: 表示成功, -1: 表示失败\n */\nHTTP_API int http_util_dump_url(const char *url, const char *dump);\n```\n\n这一个函数便可以达到与上一个例子相同的效果。","source":"_posts/http_dowload.md","raw":"---\ntitle: 使用 acl 库开发一个 HTTP 下载客户端\ndate: 2010-01-11 18:08:24\ntags: http\ncategories: http开发\n---\n\n在 acl 的协议库(lib_protocol) 中有专门针对 HTTP 协议和 ICMP 协议的，本文主要介绍如何使用 lib_protocol 协议库来开发一个简单的 http 客户端。下面首先介绍一下几个本文用到的函数接口。\n\n```c++\n/**\n * 创建一个 HTTP_UTIL 请求对象\n * @param url {const char*} 完整的请求 url\n * @param method {const char*} 请求方法，有效的请求方法有：GET, POST, HEAD, CONNECT\n * @return {HTTP_UTIL*}\n */\nHTTP_API HTTP_UTIL *http_util_req_new(const char *url, const char *method);\n\n/**\n * 设置 HTTP 代理服务器地址\n * @param http_util {HTTP_UTIL*}\n * @param proxy {const char*} 代理服务器地址，有效格式为: IP:PORT, DOMAIN:PORT,\n *  如: 192.168.0.1:80, 192.168.0.2:8088, www.g.cn:80\n */\nHTTP_API void http_util_set_req_proxy(HTTP_UTIL *http_util, const char *proxy);\n\n/**\n * 设置 HTTP 响应体的转储文件，设置后 HTTP 响应体数据便会转储于该文件\n * @param http_util {HTTP_UTIL*}\n * @param filename {const char*} 转储文件名\n * @return {int} 如果返回值 < 0 则表示无法打开该文件, 否则表示打开文件成功\n */\nHTTP_API int http_util_set_dump_file(HTTP_UTIL *http_util, const char *filename);\n\n/**\n * 打开远程 HTTP 服务器或代理服务器连接，同时构建 HTTP 请求头数据并且将该数据\n * 发给新建立的网络连接\n * @param http_util {HTTP_UTIL*}\n * @return {int} 0: 成功; -1: 无法打开连接或发送请求头数据失败\n */\nHTTP_API int http_util_req_open(HTTP_UTIL *http_util);\n\n/**\n * 发送完请求数据后调用此函数从 HTTP 服务器读取完整的 HTTP 响应头\n * @param http_util {HTTP_UTIL*}\n * @return {int} 0: 成功; -1: 失败\n */\nHTTP_API int http_util_get_res_hdr(HTTP_UTIL *http_util);\n\n/**\n * 读完 HTTP 响应头后调用此函数从 HTTP 服务器读取 HTTP 数据体数据，需要连续调用\n * 此函数，直至返回值 <= 0, 如果之前设置了转储文件或转储则在读取数据过程中同时会\n * 拷贝一份数据给转储文件或转储流\n * @param http_util {HTTP_UTIL*}\n * @param buf {char *} 存储 HTTP 响应体的缓冲区\n * @param size {size_t} buf 的空间大小\n * @return {int} <= 0: 表示读结束; > 0: 表示本次读到的数据长度\n */\nHTTP_API int http_util_get_res_body(HTTP_UTIL *http_util, char *buf, size_t size);\n```\n\n以上仅是 lib_http_util.h 函数接口中的一部分，下面就写一个简单的例子：\n\n```c++\n#include \"lib_acl.h\"\n#include \"lib_protocol.h\"\n\nstatic void get_url(const char *method, const char *url,\n\tconst char *proxy, const char *dump, int out)\n{\n\t/* 创建 HTTP_UTIL 请求对象 */\n\tHTTP_UTIL *http = http_util_req_new(url, method);\n\tint   ret;\n\n\t/* 如果设定代理服务器，则连接代理服务器地址，\n\t * 否则使用 HTTP 请求头里指定的地址\n\t */\n\n\tif (proxy && *proxy)\n\t\thttp_util_set_req_proxy(http, proxy);\n\n\t/* 设置转储文件 */\n\tif (dump && *dump)\n\t\thttp_util_set_dump_file(http, dump);\n\n\t/* 输出 HTTP 请求头内容 */\n\n\thttp_hdr_print(&http->hdr_req->hdr, \"---request hdr---\");\n\n\t/* 连接远程 http 服务器 */\n\n\tif (http_util_req_open(http) < 0) {\n\t\tprintf(\"open connection(%s) error\\n\", http->server_addr);\n\t\thttp_util_free(http);\n\t\treturn;\n\t}\n\n\t/* 读取 HTTP 服务器响应头*/\n\n\tret = http_util_get_res_hdr(http);\n\tif (ret < 0) {\n\t\tprintf(\"get reply http header error\\n\");\n\t\thttp_util_free(http);\n\t\treturn;\n\t}\n\n\t/* 输出 HTTP 响应头 */\n\n\thttp_hdr_print(&http->hdr_res->hdr, \"--- reply http header ---\");\n\n\t/* 如果有数据体则开始读取 HTTP 响应数据体部分 */\n\twhile (1) {\n\t\tchar  buf[4096];\n\t\t\n\t\tret = http_util_get_res_body(http, buf, sizeof(buf) - 1);\n\t\tif (ret <= 0)\n\t\t\tbreak;\n\t\tbuf[ret] = 0;\n\t\tif (out)\n\t\t\tprintf(\"%s\", buf);\n\t}\n\thttp_util_free(http);\n}\n\nstatic void usage(const char *procname)\n{\n\tprintf(\"usage: %s -h[help] -t method -r url -f dump_file -o[output] -X proxy_addr\\n\"\n\t\t\"example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\\n\",\n\t\tprocname, procname);\n}\n\nint main(int argc, char *argv[])\n{\n\tint   ch, out = 0;\n\tchar  url[256], dump[256], proxy[256], method[32];\n\n\tacl_init();  /* 初始化 acl 库 */\n\n\tACL_SAFE_STRNCPY(method, \"GET\", sizeof(method));\n\turl[0] = 0;\n\tdump[0] = 0;\n\tproxy[0] = 0;\n\twhile ((ch = getopt(argc, argv, \"hor:t:f:X:\")) > 0) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\treturn (0);\n\t\tcase 'o':\n\t\t\tout = 1;\n\t\t\tbreak;\n\t\tcase 'r':\n\t\t\tACL_SAFE_STRNCPY(url, optarg, sizeof(url));\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tACL_SAFE_STRNCPY(method, optarg, sizeof(method));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tACL_SAFE_STRNCPY(dump, optarg, sizeof(dump));\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tACL_SAFE_STRNCPY(proxy, optarg, sizeof(proxy));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (url[0] == 0) {\n\t\tusage(argv[0]);\n\t\treturn (0);\n\t}\n\n\tget_url(method, url, proxy, dump, out);\n\treturn (0);\n}\n```\n\n编译成功后，运行 ./url_get -h 会给出如下提示：\n```\nusage: ./url_get -h[help] -t method -r url -f dump_file -o[output] -X proxy_addr\nexample: ./url_get -t GET -r http://www.sina.com.cn/ -f url_dump.txt\n```\n\n输入: ./url_get -t GET -r http://www.sina.com -o， 该命令是获取 www.sina.com 页面并输出至标准输出，得到的结果为：\n```\nHTTP/1.0 301 Moved Permanently\nDate: Tue, 12 Jan 2010 01:54:39 GMT\nServer: Apache\nLocation: http://www.sina.com.cn/\nCache-Control: max-age=3600\nExpires: Tue, 12 Jan 2010 02:54:39 GMT\nVary: Accept-Encoding\nContent-Length: 231\nContent-Type: text/html; charset=iso-8859-1\nAge: 265\nX-Cache: HIT from tj175-135.sina.com.cn\nConnection: close\n--------------- end -----------------\n<!DOCTYPE HTML PUBLIC \"-//IETF//DTD HTML 2.0//EN\">\n<html><head>\n<title>301 Moved Permanently</title>\n</head><body>\n<h1>Moved Permanently</h1>\n<p>The document has moved <a href=\"http://www.sina.com.cn/\">here</a>.</p>\n</body></html>\n```\n\n如果想把页面转存至文件中，可以输入：./url_get -t GET -r http://www.sina.com -f dump.txt, 这样就会把新浪的首页下载并存储于 dump.txt 文件中。\n\n这个例子非常简单，其实如果查看 http_util.c 源码，会看到这个文件是对 lib_http.h 里一些更为底层 API 的封装。\n\n如果仅是下载一个页面至某个文件中，其实还有更为简单的方法，只需要调用接口：\n\n```c++\n/**\n * 将某个 url 的响应体数据转储至某个文件中\n * @param url {const char*} 完整请求 url, 如: http://www.g.cn\n * @param dump {const char*} 转储文件名\n * @param {int} 读到的响应体数据长度, >=0: 表示成功, -1: 表示失败\n */\nHTTP_API int http_util_dump_url(const char *url, const char *dump);\n```\n\n这一个函数便可以达到与上一个例子相同的效果。","slug":"http_dowload","published":1,"updated":"2023-01-24T02:58:12.034Z","_id":"cld9naynq000029fydnfx5hdh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在 acl 的协议库(lib_protocol) 中有专门针对 HTTP 协议和 ICMP 协议的，本文主要介绍如何使用 lib_protocol 协议库来开发一个简单的 http 客户端。下面首先介绍一下几个本文用到的函数接口。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 创建一个 HTTP_UTIL 请求对象</span><br><span class=\"hljs-comment\"> * @param url &#123;const char*&#125; 完整的请求 url</span><br><span class=\"hljs-comment\"> * @param method &#123;const char*&#125; 请求方法，有效的请求方法有：GET, POST, HEAD, CONNECT</span><br><span class=\"hljs-comment\"> * @return &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API HTTP_UTIL *<span class=\"hljs-title\">http_util_req_new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *url, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *method)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 代理服务器地址</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @param proxy &#123;const char*&#125; 代理服务器地址，有效格式为: IP:PORT, DOMAIN:PORT,</span><br><span class=\"hljs-comment\"> *  如: 192.168.0.1:80, 192.168.0.2:8088, www.g.cn:80</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_util_set_req_proxy</span><span class=\"hljs-params\">(HTTP_UTIL *http_util, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *proxy)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 响应体的转储文件，设置后 HTTP 响应体数据便会转储于该文件</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @param filename &#123;const char*&#125; 转储文件名</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 如果返回值 &lt; 0 则表示无法打开该文件, 否则表示打开文件成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_set_dump_file</span><span class=\"hljs-params\">(HTTP_UTIL *http_util, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *filename)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打开远程 HTTP 服务器或代理服务器连接，同时构建 HTTP 请求头数据并且将该数据</span><br><span class=\"hljs-comment\"> * 发给新建立的网络连接</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: 成功; -1: 无法打开连接或发送请求头数据失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_req_open</span><span class=\"hljs-params\">(HTTP_UTIL *http_util)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 发送完请求数据后调用此函数从 HTTP 服务器读取完整的 HTTP 响应头</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: 成功; -1: 失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_get_res_hdr</span><span class=\"hljs-params\">(HTTP_UTIL *http_util)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 读完 HTTP 响应头后调用此函数从 HTTP 服务器读取 HTTP 数据体数据，需要连续调用</span><br><span class=\"hljs-comment\"> * 此函数，直至返回值 &lt;= 0, 如果之前设置了转储文件或转储则在读取数据过程中同时会</span><br><span class=\"hljs-comment\"> * 拷贝一份数据给转储文件或转储流</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @param buf &#123;char *&#125; 存储 HTTP 响应体的缓冲区</span><br><span class=\"hljs-comment\"> * @param size &#123;size_t&#125; buf 的空间大小</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; &lt;= 0: 表示读结束; &gt; 0: 表示本次读到的数据长度</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_get_res_body</span><span class=\"hljs-params\">(HTTP_UTIL *http_util, <span class=\"hljs-type\">char</span> *buf, <span class=\"hljs-type\">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>以上仅是 lib_http_util.h 函数接口中的一部分，下面就写一个简单的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_protocol.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">get_url</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *method, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *url,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *proxy, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *dump, <span class=\"hljs-type\">int</span> out)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">/* 创建 HTTP_UTIL 请求对象 */</span><br>\tHTTP_UTIL *http = <span class=\"hljs-built_in\">http_util_req_new</span>(url, method);<br>\t<span class=\"hljs-type\">int</span>   ret;<br><br>\t<span class=\"hljs-comment\">/* 如果设定代理服务器，则连接代理服务器地址，</span><br><span class=\"hljs-comment\">\t * 否则使用 HTTP 请求头里指定的地址</span><br><span class=\"hljs-comment\">\t */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (proxy &amp;&amp; *proxy)<br>\t\t<span class=\"hljs-built_in\">http_util_set_req_proxy</span>(http, proxy);<br><br>\t<span class=\"hljs-comment\">/* 设置转储文件 */</span><br>\t<span class=\"hljs-keyword\">if</span> (dump &amp;&amp; *dump)<br>\t\t<span class=\"hljs-built_in\">http_util_set_dump_file</span>(http, dump);<br><br>\t<span class=\"hljs-comment\">/* 输出 HTTP 请求头内容 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;http-&gt;hdr_req-&gt;hdr, <span class=\"hljs-string\">&quot;---request hdr---&quot;</span>);<br><br>\t<span class=\"hljs-comment\">/* 连接远程 http 服务器 */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">http_util_req_open</span>(http) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open connection(%s) error\\n&quot;</span>, http-&gt;server_addr);<br>\t\t<span class=\"hljs-built_in\">http_util_free</span>(http);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 读取 HTTP 服务器响应头*/</span><br><br>\tret = <span class=\"hljs-built_in\">http_util_get_res_hdr</span>(http);<br>\t<span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get reply http header error\\n&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">http_util_free</span>(http);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 输出 HTTP 响应头 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;http-&gt;hdr_res-&gt;hdr, <span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br><br>\t<span class=\"hljs-comment\">/* 如果有数据体则开始读取 HTTP 响应数据体部分 */</span><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\t<span class=\"hljs-type\">char</span>  buf[<span class=\"hljs-number\">4096</span>];<br>\t\t<br>\t\tret = <span class=\"hljs-built_in\">http_util_get_res_body</span>(http, buf, <span class=\"hljs-built_in\">sizeof</span>(buf) - <span class=\"hljs-number\">1</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (ret &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\tbuf[ret] = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (out)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>, buf);<br>\t&#125;<br>\t<span class=\"hljs-built_in\">http_util_free</span>(http);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *procname)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h[help] -t method -r url -f dump_file -o[output] -X proxy_addr\\n&quot;</span><br>\t\t<span class=\"hljs-string\">&quot;example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\\n&quot;</span>,<br>\t\tprocname, procname);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span>   ch, out = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">char</span>  url[<span class=\"hljs-number\">256</span>], dump[<span class=\"hljs-number\">256</span>], proxy[<span class=\"hljs-number\">256</span>], method[<span class=\"hljs-number\">32</span>];<br><br>\t<span class=\"hljs-built_in\">acl_init</span>();  <span class=\"hljs-comment\">/* 初始化 acl 库 */</span><br><br>\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(method, <span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-built_in\">sizeof</span>(method));<br>\turl[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tdump[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tproxy[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> ((ch = <span class=\"hljs-built_in\">getopt</span>(argc, argv, <span class=\"hljs-string\">&quot;hor:t:f:X:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> (ch) &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;o&#x27;</span>:<br>\t\t\tout = <span class=\"hljs-number\">1</span>;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;r&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(url, optarg, <span class=\"hljs-built_in\">sizeof</span>(url));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;t&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(method, optarg, <span class=\"hljs-built_in\">sizeof</span>(method));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;f&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(dump, optarg, <span class=\"hljs-built_in\">sizeof</span>(dump));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;X&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(proxy, optarg, <span class=\"hljs-built_in\">sizeof</span>(proxy));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (url[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">get_url</span>(method, url, proxy, dump, out);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编译成功后，运行 .&#x2F;url_get -h 会给出如下提示：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\">usage: ./url_get -h[help] -t <span class=\"hljs-keyword\">method</span> -<span class=\"hljs-title function_\">r</span> <span class=\"hljs-title function_\">url</span> -<span class=\"hljs-title function_\">f</span> <span class=\"hljs-title function_\">dump_file</span> -<span class=\"hljs-title function_\">o</span>[<span class=\"hljs-title function_\">output</span>] -<span class=\"hljs-title function_\">X</span> <span class=\"hljs-title function_\">proxy_addr</span><br><span class=\"hljs-title function_\">example</span>: ./url_get -t GET -r http:<span class=\"hljs-comment\">//www.sina.com.cn/ -f url_dump.txt</span><br></code></pre></td></tr></table></figure>\n\n<p>输入: .&#x2F;url_get -t GET -r <a href=\"http://www.sina.com/\">http://www.sina.com</a> -o， 该命令是获取 <a href=\"http://www.sina.com/\">www.sina.com</a> 页面并输出至标准输出，得到的结果为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">HTTP/1.0 301 Moved Permanently<br>Date: Tue, 12 Jan 2010 01:54:39 GMT<br>Server: Apache<br>Location: http://www.sina.com.cn/<br>Cache-Control: max-age=3600<br>Expires: Tue, 12 Jan 2010 02:54:39 GMT<br>Vary: Accept-Encoding<br>Content-Length: 231<br>Content-Type: text/html; charset=iso-8859-1<br>Age: 265<br>X-Cache: HIT from tj175-135.sina.com.cn<br>Connection: close<br>--------------- end -----------------<br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">HTML</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//IETF//DTD HTML 2.0//EN&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>301 Moved Permanently<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Moved Permanently<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>The document has moved <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;http://www.sina.com.cn/&quot;</span>&gt;</span>here<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果想把页面转存至文件中，可以输入：.&#x2F;url_get -t GET -r <a href=\"http://www.sina.com/\">http://www.sina.com</a> -f dump.txt, 这样就会把新浪的首页下载并存储于 dump.txt 文件中。</p>\n<p>这个例子非常简单，其实如果查看 http_util.c 源码，会看到这个文件是对 lib_http.h 里一些更为底层 API 的封装。</p>\n<p>如果仅是下载一个页面至某个文件中，其实还有更为简单的方法，只需要调用接口：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 将某个 url 的响应体数据转储至某个文件中</span><br><span class=\"hljs-comment\"> * @param url &#123;const char*&#125; 完整请求 url, 如: http://www.g.cn</span><br><span class=\"hljs-comment\"> * @param dump &#123;const char*&#125; 转储文件名</span><br><span class=\"hljs-comment\"> * @param &#123;int&#125; 读到的响应体数据长度, &gt;=0: 表示成功, -1: 表示失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_dump_url</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *url, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *dump)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>这一个函数便可以达到与上一个例子相同的效果。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 acl 的协议库(lib_protocol) 中有专门针对 HTTP 协议和 ICMP 协议的，本文主要介绍如何使用 lib_protocol 协议库来开发一个简单的 http 客户端。下面首先介绍一下几个本文用到的函数接口。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 创建一个 HTTP_UTIL 请求对象</span><br><span class=\"hljs-comment\"> * @param url &#123;const char*&#125; 完整的请求 url</span><br><span class=\"hljs-comment\"> * @param method &#123;const char*&#125; 请求方法，有效的请求方法有：GET, POST, HEAD, CONNECT</span><br><span class=\"hljs-comment\"> * @return &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API HTTP_UTIL *<span class=\"hljs-title\">http_util_req_new</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *url, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *method)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 代理服务器地址</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @param proxy &#123;const char*&#125; 代理服务器地址，有效格式为: IP:PORT, DOMAIN:PORT,</span><br><span class=\"hljs-comment\"> *  如: 192.168.0.1:80, 192.168.0.2:8088, www.g.cn:80</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_util_set_req_proxy</span><span class=\"hljs-params\">(HTTP_UTIL *http_util, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *proxy)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 HTTP 响应体的转储文件，设置后 HTTP 响应体数据便会转储于该文件</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @param filename &#123;const char*&#125; 转储文件名</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 如果返回值 &lt; 0 则表示无法打开该文件, 否则表示打开文件成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_set_dump_file</span><span class=\"hljs-params\">(HTTP_UTIL *http_util, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *filename)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打开远程 HTTP 服务器或代理服务器连接，同时构建 HTTP 请求头数据并且将该数据</span><br><span class=\"hljs-comment\"> * 发给新建立的网络连接</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: 成功; -1: 无法打开连接或发送请求头数据失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_req_open</span><span class=\"hljs-params\">(HTTP_UTIL *http_util)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 发送完请求数据后调用此函数从 HTTP 服务器读取完整的 HTTP 响应头</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: 成功; -1: 失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_get_res_hdr</span><span class=\"hljs-params\">(HTTP_UTIL *http_util)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 读完 HTTP 响应头后调用此函数从 HTTP 服务器读取 HTTP 数据体数据，需要连续调用</span><br><span class=\"hljs-comment\"> * 此函数，直至返回值 &lt;= 0, 如果之前设置了转储文件或转储则在读取数据过程中同时会</span><br><span class=\"hljs-comment\"> * 拷贝一份数据给转储文件或转储流</span><br><span class=\"hljs-comment\"> * @param http_util &#123;HTTP_UTIL*&#125;</span><br><span class=\"hljs-comment\"> * @param buf &#123;char *&#125; 存储 HTTP 响应体的缓冲区</span><br><span class=\"hljs-comment\"> * @param size &#123;size_t&#125; buf 的空间大小</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; &lt;= 0: 表示读结束; &gt; 0: 表示本次读到的数据长度</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_get_res_body</span><span class=\"hljs-params\">(HTTP_UTIL *http_util, <span class=\"hljs-type\">char</span> *buf, <span class=\"hljs-type\">size_t</span> size)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>以上仅是 lib_http_util.h 函数接口中的一部分，下面就写一个简单的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_protocol.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">get_url</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *method, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *url,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *proxy, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *dump, <span class=\"hljs-type\">int</span> out)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">/* 创建 HTTP_UTIL 请求对象 */</span><br>\tHTTP_UTIL *http = <span class=\"hljs-built_in\">http_util_req_new</span>(url, method);<br>\t<span class=\"hljs-type\">int</span>   ret;<br><br>\t<span class=\"hljs-comment\">/* 如果设定代理服务器，则连接代理服务器地址，</span><br><span class=\"hljs-comment\">\t * 否则使用 HTTP 请求头里指定的地址</span><br><span class=\"hljs-comment\">\t */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (proxy &amp;&amp; *proxy)<br>\t\t<span class=\"hljs-built_in\">http_util_set_req_proxy</span>(http, proxy);<br><br>\t<span class=\"hljs-comment\">/* 设置转储文件 */</span><br>\t<span class=\"hljs-keyword\">if</span> (dump &amp;&amp; *dump)<br>\t\t<span class=\"hljs-built_in\">http_util_set_dump_file</span>(http, dump);<br><br>\t<span class=\"hljs-comment\">/* 输出 HTTP 请求头内容 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;http-&gt;hdr_req-&gt;hdr, <span class=\"hljs-string\">&quot;---request hdr---&quot;</span>);<br><br>\t<span class=\"hljs-comment\">/* 连接远程 http 服务器 */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">http_util_req_open</span>(http) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open connection(%s) error\\n&quot;</span>, http-&gt;server_addr);<br>\t\t<span class=\"hljs-built_in\">http_util_free</span>(http);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 读取 HTTP 服务器响应头*/</span><br><br>\tret = <span class=\"hljs-built_in\">http_util_get_res_hdr</span>(http);<br>\t<span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get reply http header error\\n&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">http_util_free</span>(http);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 输出 HTTP 响应头 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;http-&gt;hdr_res-&gt;hdr, <span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br><br>\t<span class=\"hljs-comment\">/* 如果有数据体则开始读取 HTTP 响应数据体部分 */</span><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\t<span class=\"hljs-type\">char</span>  buf[<span class=\"hljs-number\">4096</span>];<br>\t\t<br>\t\tret = <span class=\"hljs-built_in\">http_util_get_res_body</span>(http, buf, <span class=\"hljs-built_in\">sizeof</span>(buf) - <span class=\"hljs-number\">1</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (ret &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\tbuf[ret] = <span class=\"hljs-number\">0</span>;<br>\t\t<span class=\"hljs-keyword\">if</span> (out)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>, buf);<br>\t&#125;<br>\t<span class=\"hljs-built_in\">http_util_free</span>(http);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *procname)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h[help] -t method -r url -f dump_file -o[output] -X proxy_addr\\n&quot;</span><br>\t\t<span class=\"hljs-string\">&quot;example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\\n&quot;</span>,<br>\t\tprocname, procname);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span>   ch, out = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-type\">char</span>  url[<span class=\"hljs-number\">256</span>], dump[<span class=\"hljs-number\">256</span>], proxy[<span class=\"hljs-number\">256</span>], method[<span class=\"hljs-number\">32</span>];<br><br>\t<span class=\"hljs-built_in\">acl_init</span>();  <span class=\"hljs-comment\">/* 初始化 acl 库 */</span><br><br>\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(method, <span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-built_in\">sizeof</span>(method));<br>\turl[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tdump[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tproxy[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> ((ch = <span class=\"hljs-built_in\">getopt</span>(argc, argv, <span class=\"hljs-string\">&quot;hor:t:f:X:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> (ch) &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;o&#x27;</span>:<br>\t\t\tout = <span class=\"hljs-number\">1</span>;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;r&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(url, optarg, <span class=\"hljs-built_in\">sizeof</span>(url));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;t&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(method, optarg, <span class=\"hljs-built_in\">sizeof</span>(method));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;f&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(dump, optarg, <span class=\"hljs-built_in\">sizeof</span>(dump));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;X&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(proxy, optarg, <span class=\"hljs-built_in\">sizeof</span>(proxy));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (url[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">get_url</span>(method, url, proxy, dump, out);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编译成功后，运行 .&#x2F;url_get -h 会给出如下提示：</p>\n<figure class=\"highlight oxygene\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs oxygene\">usage: ./url_get -h[help] -t <span class=\"hljs-keyword\">method</span> -<span class=\"hljs-title function_\">r</span> <span class=\"hljs-title function_\">url</span> -<span class=\"hljs-title function_\">f</span> <span class=\"hljs-title function_\">dump_file</span> -<span class=\"hljs-title function_\">o</span>[<span class=\"hljs-title function_\">output</span>] -<span class=\"hljs-title function_\">X</span> <span class=\"hljs-title function_\">proxy_addr</span><br><span class=\"hljs-title function_\">example</span>: ./url_get -t GET -r http:<span class=\"hljs-comment\">//www.sina.com.cn/ -f url_dump.txt</span><br></code></pre></td></tr></table></figure>\n\n<p>输入: .&#x2F;url_get -t GET -r <a href=\"http://www.sina.com/\">http://www.sina.com</a> -o， 该命令是获取 <a href=\"http://www.sina.com/\">www.sina.com</a> 页面并输出至标准输出，得到的结果为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\">HTTP/1.0 301 Moved Permanently<br>Date: Tue, 12 Jan 2010 01:54:39 GMT<br>Server: Apache<br>Location: http://www.sina.com.cn/<br>Cache-Control: max-age=3600<br>Expires: Tue, 12 Jan 2010 02:54:39 GMT<br>Vary: Accept-Encoding<br>Content-Length: 231<br>Content-Type: text/html; charset=iso-8859-1<br>Age: 265<br>X-Cache: HIT from tj175-135.sina.com.cn<br>Connection: close<br>--------------- end -----------------<br><span class=\"hljs-meta\">&lt;!DOCTYPE <span class=\"hljs-keyword\">HTML</span> <span class=\"hljs-keyword\">PUBLIC</span> <span class=\"hljs-string\">&quot;-//IETF//DTD HTML 2.0//EN&quot;</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">html</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">head</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">title</span>&gt;</span>301 Moved Permanently<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">title</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">head</span>&gt;</span><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">body</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">h1</span>&gt;</span>Moved Permanently<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">h1</span>&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">p</span>&gt;</span>The document has moved <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">a</span> <span class=\"hljs-attr\">href</span>=<span class=\"hljs-string\">&quot;http://www.sina.com.cn/&quot;</span>&gt;</span>here<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">a</span>&gt;</span>.<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">p</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">body</span>&gt;</span><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">html</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>如果想把页面转存至文件中，可以输入：.&#x2F;url_get -t GET -r <a href=\"http://www.sina.com/\">http://www.sina.com</a> -f dump.txt, 这样就会把新浪的首页下载并存储于 dump.txt 文件中。</p>\n<p>这个例子非常简单，其实如果查看 http_util.c 源码，会看到这个文件是对 lib_http.h 里一些更为底层 API 的封装。</p>\n<p>如果仅是下载一个页面至某个文件中，其实还有更为简单的方法，只需要调用接口：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 将某个 url 的响应体数据转储至某个文件中</span><br><span class=\"hljs-comment\"> * @param url &#123;const char*&#125; 完整请求 url, 如: http://www.g.cn</span><br><span class=\"hljs-comment\"> * @param dump &#123;const char*&#125; 转储文件名</span><br><span class=\"hljs-comment\"> * @param &#123;int&#125; 读到的响应体数据长度, &gt;=0: 表示成功, -1: 表示失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">HTTP_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">http_util_dump_url</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *url, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *dump)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>这一个函数便可以达到与上一个例子相同的效果。</p>\n"},{"title":"使用 acl 较为底层的 HTTP 协议库写 HTTP 下载客户端举例","date":"2010-01-13T05:08:24.000Z","_content":"\n在《使用 acl 库开发一个 HTTP 下载客户端》文章中介绍利用ACL库中的 HTTP 高级API函数编写HTTP下载客户端的简单的例子，本文介绍一下如何使用稍微底层的API来编写同样功能的例子。在这个例子中，可以看到那些高级API是如何封装底层API的。\n\n请先看一个例子如下：\n\n```c++\n#include \"lib_acl.h\"\n#include \"lib_protocol.h\"\n\nstatic void get_url(const char *method, const char *url,\n\tconst char *proxy, const char *dump)\n{\n\t/* 创建 HTTP 请求头 */\n\tHTTP_HDR_REQ *hdr_req = http_hdr_req_create(url, method, \"HTTP/1.1\");\n\tACL_VSTREAM *stream;  /* 网络连接流 */\n\tACL_VSTRING *buf = acl_vstring_alloc(256);  /* 分配内存缓冲区 */\n\tHTTP_HDR_RES *hdr_res;  /* HTTP 响应头 */\n\tHTTP_RES *res;  /* HTTP响应体 */\n\tACL_FILE *fp = NULL;  /* 转储文件句柄 */\n\tconst char *ptr;\n\tint   ret;\n\n\t/* 输出 HTTP 请求头内容 */\n\n\thttp_hdr_print(&hdr_req->hdr, \"---request hdr---\");\n\n\t/* 如果设定代理服务器，则连接代理服务器地址，\n\t * 否则使用 HTTP 请求头里指定的地址\n\t */\n\n\tif (*proxy)\n\t\tacl_vstring_strcpy(buf, proxy);\n\telse\n\t\tacl_vstring_strcpy(buf, http_hdr_req_host(hdr_req));\n\n\t/* 获得远程 HTTP 服务器的连接地址 */\n\n\tptr = acl_vstring_memchr(buf, ':');\n\tif (ptr == NULL)\n\t\tacl_vstring_strcat(buf, \":80\");\n\telse {\n\t\tint   port;\n\t\tptr++;\n\t\tport = atoi(ptr);\n\t\tif (port <= 0 || port >= 65535) {\n\t\t\tprintf(\"http server's addr(%s) invalid\\n\", acl_vstring_str(buf));\n\t\t\tacl_vstring_free(buf);\n\t\t\thttp_hdr_req_free(hdr_req);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* 连接远程 http 服务器 */\n\n\tstream = acl_vstream_connect(acl_vstring_str(buf) /* 服务器地址 */,\n\t\t\tACL_BLOCKING /* 采用阻塞方式 */,\n\t\t\t10 /* 连接超时时间为 10 秒 */,\n\t\t\t10 /* 网络 IO 操作超时时间为 10 秒 */,\n\t\t\t4096 /* stream 流缓冲区大小为 4096 字节 */);\n\tif (stream == NULL) {\n\t\t/* 连接服务器失败 */\n\n\t\tprintf(\"connect addr(%s) error(%s)\\n\",\n\t\t\tacl_vstring_str(buf), acl_last_serror());\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 构建 HTTP 请求头数据 */\n\n\thttp_hdr_build_request(hdr_req, buf);\n\n\t/* 向 HTTP 服务器发送请求 */\n\n\tret = acl_vstream_writen(stream, acl_vstring_str(buf), ACL_VSTRING_LEN(buf));\n\tif (ret == ACL_VSTREAM_EOF) {\n\t\tprintf(\"write to server error(%s)\\n\", acl_last_serror());\n\t\tacl_vstream_close(stream);\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 创建一个 HTTP 响应头对象 */\n\n\thdr_res = http_hdr_res_new();\n\n\t/* 读取 HTTP 服务器响应头*/\n\n\tret = http_hdr_res_get_sync(hdr_res, stream, 10 /* IO 超时时间为 10 秒 */);\n\tif (ret < 0) {\n\t\tprintf(\"get http reply header error(%s)\\n\", acl_last_serror());\n\t\thttp_hdr_res_free(hdr_res);\n\t\tacl_vstream_close(stream);\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 分析HTTP服务器响应头 */\n\n\tif (http_hdr_res_parse(hdr_res) < 0) {\n\t\tprintf(\"parse http reply header error\\n\");\n\t\thttp_hdr_print(&hdr_res->hdr, \"--- reply http header ---\");\n\t\thttp_hdr_res_free(hdr_res);\n\t\tacl_vstream_close(stream);\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 如果需要转储至磁盘则需要先打开文件 */\n\n\tif (dump != NULL) {\n\t\tfp = acl_fopen(dump, \"w+\");\n\t\tif (fp == NULL)\n\t\t\tprintf(\"open file(%s) error(%s)\\n\",\n\t\t\t\tdump, acl_last_serror());\n\t}\n\n\t/* 如果 HTTP 响应没有数据体则仅输出 HTTP 响应头即可 */\n\n\tif (hdr_res->hdr.content_length == 0\n\t\t|| (hdr_res->hdr.content_length == -1\n\t\t\t&& !hdr_res->hdr.chunked\n\t\t\t&& hdr_res->reply_status > 300\n\t\t\t&& hdr_res->reply_status < 400))\n\t{\n\t\tif (fp)\n\t\t\thttp_hdr_fprint(ACL_FSTREAM(fp), &hdr_res->hdr,\n\t\t\t\t\"--- reply http header ---\");\n\t\telse\n\t\t\thttp_hdr_fprint(ACL_VSTREAM_OUT, &hdr_res->hdr,\n\t\t\t\t\"--- reply http header ---\");\n\t\thttp_hdr_res_free(hdr_res);\n\t\tacl_vstream_close(stream);\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 输出 HTTP 响应头 */\n\n\thttp_hdr_print(&hdr_res->hdr, \"--- reply http header ---\");\n\n\t/* 创建 HTTP 响应体对象 */\n\n\tres = http_res_new(hdr_res);\n\n\t/* 如果有数据体则开始读取 HTTP 响应数据体部分 */\n\n\twhile (1) {\n\t\thttp_off_t  n;\n\t\tchar  buf2[4096];\n\t\t\n\t\t/* 以同步方式读取HTTP响应数据 */\n\n\t\tn = http_res_body_get_sync(res, stream, buf2, sizeof(buf2) - 1);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\n\t\tif (fp) {\n\t\t\t/* 转储至文件中 */\n\n\t\t\tif (acl_fwrite(buf2, (size_t) n, 1, fp) == (size_t) EOF) {\n\t\t\t\tprintf(\"write to dump file(%s) error(%s)\\n\",\n\t\t\t\t\tdump, acl_last_serror());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbuf2[n] = 0;\n\t\t\tprintf(\"%s\", buf2);\n\t\t}\n\t}\n\n\tif (fp)\n\t\tacl_fclose(fp);  /* 关闭转储文件句柄 */\n\thttp_res_free(res);  /* 释放 HTTP 响应对象, hdr_res 会在此函数内部自动被释放 */\n\tacl_vstream_close(stream);  /* 关闭网络流 */\n\tacl_vstring_free(buf);  /* 释放内存区 */\n\thttp_hdr_req_free(hdr_req);  /* 释放 HTTP 请求头对象 */\n}\n\nstatic void usage(const char *procname)\n{\n\tprintf(\"usage: %s -h[help] -t method -r url -f dump_file -X proxy_addr\\n\"\n\t\t\"example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\\n\",\n\t\tprocname, procname);\n}\n\nint main(int argc, char *argv[])\n{\n\tint   ch;\n\tchar  url[256], dump[256], proxy[256], method[32];\n\n\tacl_init();  /* 初始化 acl 库 */\n\n\tACL_SAFE_STRNCPY(method, \"GET\", sizeof(method));\n\turl[0] = 0;\n\tdump[0] = 0;\n\tproxy[0] = 0;\n\twhile ((ch = getopt(argc, argv, \"hr:t:f:X:\")) > 0) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\treturn (0);\n\t\tcase 'r':\n\t\t\tACL_SAFE_STRNCPY(url, optarg, sizeof(url));\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tACL_SAFE_STRNCPY(method, optarg, sizeof(method));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tACL_SAFE_STRNCPY(dump, optarg, sizeof(dump));\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tACL_SAFE_STRNCPY(proxy, optarg, sizeof(proxy));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (url[0] == 0) {\n\t\tusage(argv[0]);\n\t\treturn (0);\n\t}\n\n\tget_url(method, url, proxy, dump);\n\treturn (0);\n}\n```\n\n可以明显地看出，该例子的实现代码量要比 使用 acl 库开发一个 HTTP 下载客户端 麻烦许多，但它却比较清晰地展示了 HTTP 协议的请求与响应过程。该例子可以在 acl_project/samples/http/get_url1/ 目录下找到。","source":"_posts/http_dowload2.md","raw":"---\ntitle: 使用 acl 较为底层的 HTTP 协议库写 HTTP 下载客户端举例\ndate: 2010-01-13 13:08:24\ntags: http\ncategories: http开发\n---\n\n在《使用 acl 库开发一个 HTTP 下载客户端》文章中介绍利用ACL库中的 HTTP 高级API函数编写HTTP下载客户端的简单的例子，本文介绍一下如何使用稍微底层的API来编写同样功能的例子。在这个例子中，可以看到那些高级API是如何封装底层API的。\n\n请先看一个例子如下：\n\n```c++\n#include \"lib_acl.h\"\n#include \"lib_protocol.h\"\n\nstatic void get_url(const char *method, const char *url,\n\tconst char *proxy, const char *dump)\n{\n\t/* 创建 HTTP 请求头 */\n\tHTTP_HDR_REQ *hdr_req = http_hdr_req_create(url, method, \"HTTP/1.1\");\n\tACL_VSTREAM *stream;  /* 网络连接流 */\n\tACL_VSTRING *buf = acl_vstring_alloc(256);  /* 分配内存缓冲区 */\n\tHTTP_HDR_RES *hdr_res;  /* HTTP 响应头 */\n\tHTTP_RES *res;  /* HTTP响应体 */\n\tACL_FILE *fp = NULL;  /* 转储文件句柄 */\n\tconst char *ptr;\n\tint   ret;\n\n\t/* 输出 HTTP 请求头内容 */\n\n\thttp_hdr_print(&hdr_req->hdr, \"---request hdr---\");\n\n\t/* 如果设定代理服务器，则连接代理服务器地址，\n\t * 否则使用 HTTP 请求头里指定的地址\n\t */\n\n\tif (*proxy)\n\t\tacl_vstring_strcpy(buf, proxy);\n\telse\n\t\tacl_vstring_strcpy(buf, http_hdr_req_host(hdr_req));\n\n\t/* 获得远程 HTTP 服务器的连接地址 */\n\n\tptr = acl_vstring_memchr(buf, ':');\n\tif (ptr == NULL)\n\t\tacl_vstring_strcat(buf, \":80\");\n\telse {\n\t\tint   port;\n\t\tptr++;\n\t\tport = atoi(ptr);\n\t\tif (port <= 0 || port >= 65535) {\n\t\t\tprintf(\"http server's addr(%s) invalid\\n\", acl_vstring_str(buf));\n\t\t\tacl_vstring_free(buf);\n\t\t\thttp_hdr_req_free(hdr_req);\n\t\t\treturn;\n\t\t}\n\t}\n\n\t/* 连接远程 http 服务器 */\n\n\tstream = acl_vstream_connect(acl_vstring_str(buf) /* 服务器地址 */,\n\t\t\tACL_BLOCKING /* 采用阻塞方式 */,\n\t\t\t10 /* 连接超时时间为 10 秒 */,\n\t\t\t10 /* 网络 IO 操作超时时间为 10 秒 */,\n\t\t\t4096 /* stream 流缓冲区大小为 4096 字节 */);\n\tif (stream == NULL) {\n\t\t/* 连接服务器失败 */\n\n\t\tprintf(\"connect addr(%s) error(%s)\\n\",\n\t\t\tacl_vstring_str(buf), acl_last_serror());\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 构建 HTTP 请求头数据 */\n\n\thttp_hdr_build_request(hdr_req, buf);\n\n\t/* 向 HTTP 服务器发送请求 */\n\n\tret = acl_vstream_writen(stream, acl_vstring_str(buf), ACL_VSTRING_LEN(buf));\n\tif (ret == ACL_VSTREAM_EOF) {\n\t\tprintf(\"write to server error(%s)\\n\", acl_last_serror());\n\t\tacl_vstream_close(stream);\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 创建一个 HTTP 响应头对象 */\n\n\thdr_res = http_hdr_res_new();\n\n\t/* 读取 HTTP 服务器响应头*/\n\n\tret = http_hdr_res_get_sync(hdr_res, stream, 10 /* IO 超时时间为 10 秒 */);\n\tif (ret < 0) {\n\t\tprintf(\"get http reply header error(%s)\\n\", acl_last_serror());\n\t\thttp_hdr_res_free(hdr_res);\n\t\tacl_vstream_close(stream);\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 分析HTTP服务器响应头 */\n\n\tif (http_hdr_res_parse(hdr_res) < 0) {\n\t\tprintf(\"parse http reply header error\\n\");\n\t\thttp_hdr_print(&hdr_res->hdr, \"--- reply http header ---\");\n\t\thttp_hdr_res_free(hdr_res);\n\t\tacl_vstream_close(stream);\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 如果需要转储至磁盘则需要先打开文件 */\n\n\tif (dump != NULL) {\n\t\tfp = acl_fopen(dump, \"w+\");\n\t\tif (fp == NULL)\n\t\t\tprintf(\"open file(%s) error(%s)\\n\",\n\t\t\t\tdump, acl_last_serror());\n\t}\n\n\t/* 如果 HTTP 响应没有数据体则仅输出 HTTP 响应头即可 */\n\n\tif (hdr_res->hdr.content_length == 0\n\t\t|| (hdr_res->hdr.content_length == -1\n\t\t\t&& !hdr_res->hdr.chunked\n\t\t\t&& hdr_res->reply_status > 300\n\t\t\t&& hdr_res->reply_status < 400))\n\t{\n\t\tif (fp)\n\t\t\thttp_hdr_fprint(ACL_FSTREAM(fp), &hdr_res->hdr,\n\t\t\t\t\"--- reply http header ---\");\n\t\telse\n\t\t\thttp_hdr_fprint(ACL_VSTREAM_OUT, &hdr_res->hdr,\n\t\t\t\t\"--- reply http header ---\");\n\t\thttp_hdr_res_free(hdr_res);\n\t\tacl_vstream_close(stream);\n\t\tacl_vstring_free(buf);\n\t\thttp_hdr_req_free(hdr_req);\n\t\treturn;\n\t}\n\n\t/* 输出 HTTP 响应头 */\n\n\thttp_hdr_print(&hdr_res->hdr, \"--- reply http header ---\");\n\n\t/* 创建 HTTP 响应体对象 */\n\n\tres = http_res_new(hdr_res);\n\n\t/* 如果有数据体则开始读取 HTTP 响应数据体部分 */\n\n\twhile (1) {\n\t\thttp_off_t  n;\n\t\tchar  buf2[4096];\n\t\t\n\t\t/* 以同步方式读取HTTP响应数据 */\n\n\t\tn = http_res_body_get_sync(res, stream, buf2, sizeof(buf2) - 1);\n\t\tif (n <= 0)\n\t\t\tbreak;\n\n\t\tif (fp) {\n\t\t\t/* 转储至文件中 */\n\n\t\t\tif (acl_fwrite(buf2, (size_t) n, 1, fp) == (size_t) EOF) {\n\t\t\t\tprintf(\"write to dump file(%s) error(%s)\\n\",\n\t\t\t\t\tdump, acl_last_serror());\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tbuf2[n] = 0;\n\t\t\tprintf(\"%s\", buf2);\n\t\t}\n\t}\n\n\tif (fp)\n\t\tacl_fclose(fp);  /* 关闭转储文件句柄 */\n\thttp_res_free(res);  /* 释放 HTTP 响应对象, hdr_res 会在此函数内部自动被释放 */\n\tacl_vstream_close(stream);  /* 关闭网络流 */\n\tacl_vstring_free(buf);  /* 释放内存区 */\n\thttp_hdr_req_free(hdr_req);  /* 释放 HTTP 请求头对象 */\n}\n\nstatic void usage(const char *procname)\n{\n\tprintf(\"usage: %s -h[help] -t method -r url -f dump_file -X proxy_addr\\n\"\n\t\t\"example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\\n\",\n\t\tprocname, procname);\n}\n\nint main(int argc, char *argv[])\n{\n\tint   ch;\n\tchar  url[256], dump[256], proxy[256], method[32];\n\n\tacl_init();  /* 初始化 acl 库 */\n\n\tACL_SAFE_STRNCPY(method, \"GET\", sizeof(method));\n\turl[0] = 0;\n\tdump[0] = 0;\n\tproxy[0] = 0;\n\twhile ((ch = getopt(argc, argv, \"hr:t:f:X:\")) > 0) {\n\t\tswitch (ch) {\n\t\tcase 'h':\n\t\t\tusage(argv[0]);\n\t\t\treturn (0);\n\t\tcase 'r':\n\t\t\tACL_SAFE_STRNCPY(url, optarg, sizeof(url));\n\t\t\tbreak;\n\t\tcase 't':\n\t\t\tACL_SAFE_STRNCPY(method, optarg, sizeof(method));\n\t\t\tbreak;\n\t\tcase 'f':\n\t\t\tACL_SAFE_STRNCPY(dump, optarg, sizeof(dump));\n\t\t\tbreak;\n\t\tcase 'X':\n\t\t\tACL_SAFE_STRNCPY(proxy, optarg, sizeof(proxy));\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tbreak;\n\t\t}\n\t}\n\n\tif (url[0] == 0) {\n\t\tusage(argv[0]);\n\t\treturn (0);\n\t}\n\n\tget_url(method, url, proxy, dump);\n\treturn (0);\n}\n```\n\n可以明显地看出，该例子的实现代码量要比 使用 acl 库开发一个 HTTP 下载客户端 麻烦许多，但它却比较清晰地展示了 HTTP 协议的请求与响应过程。该例子可以在 acl_project/samples/http/get_url1/ 目录下找到。","slug":"http_dowload2","published":1,"updated":"2023-01-24T03:02:29.335Z","_id":"cld9nhaj8000329fyaomnc9d9","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在《使用 acl 库开发一个 HTTP 下载客户端》文章中介绍利用ACL库中的 HTTP 高级API函数编写HTTP下载客户端的简单的例子，本文介绍一下如何使用稍微底层的API来编写同样功能的例子。在这个例子中，可以看到那些高级API是如何封装底层API的。</p>\n<p>请先看一个例子如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_protocol.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">get_url</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *method, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *url,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *proxy, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *dump)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">/* 创建 HTTP 请求头 */</span><br>\tHTTP_HDR_REQ *hdr_req = <span class=\"hljs-built_in\">http_hdr_req_create</span>(url, method, <span class=\"hljs-string\">&quot;HTTP/1.1&quot;</span>);<br>\tACL_VSTREAM *stream;  <span class=\"hljs-comment\">/* 网络连接流 */</span><br>\tACL_VSTRING *buf = <span class=\"hljs-built_in\">acl_vstring_alloc</span>(<span class=\"hljs-number\">256</span>);  <span class=\"hljs-comment\">/* 分配内存缓冲区 */</span><br>\tHTTP_HDR_RES *hdr_res;  <span class=\"hljs-comment\">/* HTTP 响应头 */</span><br>\tHTTP_RES *res;  <span class=\"hljs-comment\">/* HTTP响应体 */</span><br>\tACL_FILE *fp = <span class=\"hljs-literal\">NULL</span>;  <span class=\"hljs-comment\">/* 转储文件句柄 */</span><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *ptr;<br>\t<span class=\"hljs-type\">int</span>   ret;<br><br>\t<span class=\"hljs-comment\">/* 输出 HTTP 请求头内容 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;hdr_req-&gt;hdr, <span class=\"hljs-string\">&quot;---request hdr---&quot;</span>);<br><br>\t<span class=\"hljs-comment\">/* 如果设定代理服务器，则连接代理服务器地址，</span><br><span class=\"hljs-comment\">\t * 否则使用 HTTP 请求头里指定的地址</span><br><span class=\"hljs-comment\">\t */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (*proxy)<br>\t\t<span class=\"hljs-built_in\">acl_vstring_strcpy</span>(buf, proxy);<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">acl_vstring_strcpy</span>(buf, <span class=\"hljs-built_in\">http_hdr_req_host</span>(hdr_req));<br><br>\t<span class=\"hljs-comment\">/* 获得远程 HTTP 服务器的连接地址 */</span><br><br>\tptr = <span class=\"hljs-built_in\">acl_vstring_memchr</span>(buf, <span class=\"hljs-string\">&#x27;:&#x27;</span>);<br>\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">acl_vstring_strcat</span>(buf, <span class=\"hljs-string\">&quot;:80&quot;</span>);<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-type\">int</span>   port;<br>\t\tptr++;<br>\t\tport = <span class=\"hljs-built_in\">atoi</span>(ptr);<br>\t\t<span class=\"hljs-keyword\">if</span> (port &lt;= <span class=\"hljs-number\">0</span> || port &gt;= <span class=\"hljs-number\">65535</span>) &#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;http server&#x27;s addr(%s) invalid\\n&quot;</span>, <span class=\"hljs-built_in\">acl_vstring_str</span>(buf));<br>\t\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 连接远程 http 服务器 */</span><br><br>\tstream = <span class=\"hljs-built_in\">acl_vstream_connect</span>(<span class=\"hljs-built_in\">acl_vstring_str</span>(buf) <span class=\"hljs-comment\">/* 服务器地址 */</span>,<br>\t\t\tACL_BLOCKING <span class=\"hljs-comment\">/* 采用阻塞方式 */</span>,<br>\t\t\t<span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* 连接超时时间为 10 秒 */</span>,<br>\t\t\t<span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* 网络 IO 操作超时时间为 10 秒 */</span>,<br>\t\t\t<span class=\"hljs-number\">4096</span> <span class=\"hljs-comment\">/* stream 流缓冲区大小为 4096 字节 */</span>);<br>\t<span class=\"hljs-keyword\">if</span> (stream == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t<span class=\"hljs-comment\">/* 连接服务器失败 */</span><br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;connect addr(%s) error(%s)\\n&quot;</span>,<br>\t\t\t<span class=\"hljs-built_in\">acl_vstring_str</span>(buf), <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 构建 HTTP 请求头数据 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_build_request</span>(hdr_req, buf);<br><br>\t<span class=\"hljs-comment\">/* 向 HTTP 服务器发送请求 */</span><br><br>\tret = <span class=\"hljs-built_in\">acl_vstream_writen</span>(stream, <span class=\"hljs-built_in\">acl_vstring_str</span>(buf), <span class=\"hljs-built_in\">ACL_VSTRING_LEN</span>(buf));<br>\t<span class=\"hljs-keyword\">if</span> (ret == ACL_VSTREAM_EOF) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;write to server error(%s)\\n&quot;</span>, <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 创建一个 HTTP 响应头对象 */</span><br><br>\thdr_res = <span class=\"hljs-built_in\">http_hdr_res_new</span>();<br><br>\t<span class=\"hljs-comment\">/* 读取 HTTP 服务器响应头*/</span><br><br>\tret = <span class=\"hljs-built_in\">http_hdr_res_get_sync</span>(hdr_res, stream, <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* IO 超时时间为 10 秒 */</span>);<br>\t<span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get http reply header error(%s)\\n&quot;</span>, <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t\t<span class=\"hljs-built_in\">http_hdr_res_free</span>(hdr_res);<br>\t\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 分析HTTP服务器响应头 */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">http_hdr_res_parse</span>(hdr_res) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;parse http reply header error\\n&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;hdr_res-&gt;hdr, <span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">http_hdr_res_free</span>(hdr_res);<br>\t\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 如果需要转储至磁盘则需要先打开文件 */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (dump != <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\tfp = <span class=\"hljs-built_in\">acl_fopen</span>(dump, <span class=\"hljs-string\">&quot;w+&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (fp == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open file(%s) error(%s)\\n&quot;</span>,<br>\t\t\t\tdump, <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 如果 HTTP 响应没有数据体则仅输出 HTTP 响应头即可 */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (hdr_res-&gt;hdr.content_length == <span class=\"hljs-number\">0</span><br>\t\t|| (hdr_res-&gt;hdr.content_length == <span class=\"hljs-number\">-1</span><br>\t\t\t&amp;&amp; !hdr_res-&gt;hdr.chunked<br>\t\t\t&amp;&amp; hdr_res-&gt;reply_status &gt; <span class=\"hljs-number\">300</span><br>\t\t\t&amp;&amp; hdr_res-&gt;reply_status &lt; <span class=\"hljs-number\">400</span>))<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (fp)<br>\t\t\t<span class=\"hljs-built_in\">http_hdr_fprint</span>(<span class=\"hljs-built_in\">ACL_FSTREAM</span>(fp), &amp;hdr_res-&gt;hdr,<br>\t\t\t\t<span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\t<span class=\"hljs-built_in\">http_hdr_fprint</span>(ACL_VSTREAM_OUT, &amp;hdr_res-&gt;hdr,<br>\t\t\t\t<span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">http_hdr_res_free</span>(hdr_res);<br>\t\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 输出 HTTP 响应头 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;hdr_res-&gt;hdr, <span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br><br>\t<span class=\"hljs-comment\">/* 创建 HTTP 响应体对象 */</span><br><br>\tres = <span class=\"hljs-built_in\">http_res_new</span>(hdr_res);<br><br>\t<span class=\"hljs-comment\">/* 如果有数据体则开始读取 HTTP 响应数据体部分 */</span><br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\t<span class=\"hljs-type\">http_off_t</span>  n;<br>\t\t<span class=\"hljs-type\">char</span>  buf2[<span class=\"hljs-number\">4096</span>];<br>\t\t<br>\t\t<span class=\"hljs-comment\">/* 以同步方式读取HTTP响应数据 */</span><br><br>\t\tn = <span class=\"hljs-built_in\">http_res_body_get_sync</span>(res, stream, buf2, <span class=\"hljs-built_in\">sizeof</span>(buf2) - <span class=\"hljs-number\">1</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (fp) &#123;<br>\t\t\t<span class=\"hljs-comment\">/* 转储至文件中 */</span><br><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">acl_fwrite</span>(buf2, (<span class=\"hljs-type\">size_t</span>) n, <span class=\"hljs-number\">1</span>, fp) == (<span class=\"hljs-type\">size_t</span>) EOF) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;write to dump file(%s) error(%s)\\n&quot;</span>,<br>\t\t\t\t\tdump, <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tbuf2[n] = <span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>, buf2);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (fp)<br>\t\t<span class=\"hljs-built_in\">acl_fclose</span>(fp);  <span class=\"hljs-comment\">/* 关闭转储文件句柄 */</span><br>\t<span class=\"hljs-built_in\">http_res_free</span>(res);  <span class=\"hljs-comment\">/* 释放 HTTP 响应对象, hdr_res 会在此函数内部自动被释放 */</span><br>\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);  <span class=\"hljs-comment\">/* 关闭网络流 */</span><br>\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);  <span class=\"hljs-comment\">/* 释放内存区 */</span><br>\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);  <span class=\"hljs-comment\">/* 释放 HTTP 请求头对象 */</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *procname)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h[help] -t method -r url -f dump_file -X proxy_addr\\n&quot;</span><br>\t\t<span class=\"hljs-string\">&quot;example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\\n&quot;</span>,<br>\t\tprocname, procname);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span>   ch;<br>\t<span class=\"hljs-type\">char</span>  url[<span class=\"hljs-number\">256</span>], dump[<span class=\"hljs-number\">256</span>], proxy[<span class=\"hljs-number\">256</span>], method[<span class=\"hljs-number\">32</span>];<br><br>\t<span class=\"hljs-built_in\">acl_init</span>();  <span class=\"hljs-comment\">/* 初始化 acl 库 */</span><br><br>\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(method, <span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-built_in\">sizeof</span>(method));<br>\turl[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tdump[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tproxy[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> ((ch = <span class=\"hljs-built_in\">getopt</span>(argc, argv, <span class=\"hljs-string\">&quot;hr:t:f:X:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> (ch) &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;r&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(url, optarg, <span class=\"hljs-built_in\">sizeof</span>(url));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;t&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(method, optarg, <span class=\"hljs-built_in\">sizeof</span>(method));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;f&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(dump, optarg, <span class=\"hljs-built_in\">sizeof</span>(dump));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;X&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(proxy, optarg, <span class=\"hljs-built_in\">sizeof</span>(proxy));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (url[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">get_url</span>(method, url, proxy, dump);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以明显地看出，该例子的实现代码量要比 使用 acl 库开发一个 HTTP 下载客户端 麻烦许多，但它却比较清晰地展示了 HTTP 协议的请求与响应过程。该例子可以在 acl_project&#x2F;samples&#x2F;http&#x2F;get_url1&#x2F; 目录下找到。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在《使用 acl 库开发一个 HTTP 下载客户端》文章中介绍利用ACL库中的 HTTP 高级API函数编写HTTP下载客户端的简单的例子，本文介绍一下如何使用稍微底层的API来编写同样功能的例子。在这个例子中，可以看到那些高级API是如何封装底层API的。</p>\n<p>请先看一个例子如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_protocol.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">get_url</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *method, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *url,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *proxy, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *dump)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">/* 创建 HTTP 请求头 */</span><br>\tHTTP_HDR_REQ *hdr_req = <span class=\"hljs-built_in\">http_hdr_req_create</span>(url, method, <span class=\"hljs-string\">&quot;HTTP/1.1&quot;</span>);<br>\tACL_VSTREAM *stream;  <span class=\"hljs-comment\">/* 网络连接流 */</span><br>\tACL_VSTRING *buf = <span class=\"hljs-built_in\">acl_vstring_alloc</span>(<span class=\"hljs-number\">256</span>);  <span class=\"hljs-comment\">/* 分配内存缓冲区 */</span><br>\tHTTP_HDR_RES *hdr_res;  <span class=\"hljs-comment\">/* HTTP 响应头 */</span><br>\tHTTP_RES *res;  <span class=\"hljs-comment\">/* HTTP响应体 */</span><br>\tACL_FILE *fp = <span class=\"hljs-literal\">NULL</span>;  <span class=\"hljs-comment\">/* 转储文件句柄 */</span><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *ptr;<br>\t<span class=\"hljs-type\">int</span>   ret;<br><br>\t<span class=\"hljs-comment\">/* 输出 HTTP 请求头内容 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;hdr_req-&gt;hdr, <span class=\"hljs-string\">&quot;---request hdr---&quot;</span>);<br><br>\t<span class=\"hljs-comment\">/* 如果设定代理服务器，则连接代理服务器地址，</span><br><span class=\"hljs-comment\">\t * 否则使用 HTTP 请求头里指定的地址</span><br><span class=\"hljs-comment\">\t */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (*proxy)<br>\t\t<span class=\"hljs-built_in\">acl_vstring_strcpy</span>(buf, proxy);<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">acl_vstring_strcpy</span>(buf, <span class=\"hljs-built_in\">http_hdr_req_host</span>(hdr_req));<br><br>\t<span class=\"hljs-comment\">/* 获得远程 HTTP 服务器的连接地址 */</span><br><br>\tptr = <span class=\"hljs-built_in\">acl_vstring_memchr</span>(buf, <span class=\"hljs-string\">&#x27;:&#x27;</span>);<br>\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t<span class=\"hljs-built_in\">acl_vstring_strcat</span>(buf, <span class=\"hljs-string\">&quot;:80&quot;</span>);<br>\t<span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-type\">int</span>   port;<br>\t\tptr++;<br>\t\tport = <span class=\"hljs-built_in\">atoi</span>(ptr);<br>\t\t<span class=\"hljs-keyword\">if</span> (port &lt;= <span class=\"hljs-number\">0</span> || port &gt;= <span class=\"hljs-number\">65535</span>) &#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;http server&#x27;s addr(%s) invalid\\n&quot;</span>, <span class=\"hljs-built_in\">acl_vstring_str</span>(buf));<br>\t\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 连接远程 http 服务器 */</span><br><br>\tstream = <span class=\"hljs-built_in\">acl_vstream_connect</span>(<span class=\"hljs-built_in\">acl_vstring_str</span>(buf) <span class=\"hljs-comment\">/* 服务器地址 */</span>,<br>\t\t\tACL_BLOCKING <span class=\"hljs-comment\">/* 采用阻塞方式 */</span>,<br>\t\t\t<span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* 连接超时时间为 10 秒 */</span>,<br>\t\t\t<span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* 网络 IO 操作超时时间为 10 秒 */</span>,<br>\t\t\t<span class=\"hljs-number\">4096</span> <span class=\"hljs-comment\">/* stream 流缓冲区大小为 4096 字节 */</span>);<br>\t<span class=\"hljs-keyword\">if</span> (stream == <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t<span class=\"hljs-comment\">/* 连接服务器失败 */</span><br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;connect addr(%s) error(%s)\\n&quot;</span>,<br>\t\t\t<span class=\"hljs-built_in\">acl_vstring_str</span>(buf), <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 构建 HTTP 请求头数据 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_build_request</span>(hdr_req, buf);<br><br>\t<span class=\"hljs-comment\">/* 向 HTTP 服务器发送请求 */</span><br><br>\tret = <span class=\"hljs-built_in\">acl_vstream_writen</span>(stream, <span class=\"hljs-built_in\">acl_vstring_str</span>(buf), <span class=\"hljs-built_in\">ACL_VSTRING_LEN</span>(buf));<br>\t<span class=\"hljs-keyword\">if</span> (ret == ACL_VSTREAM_EOF) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;write to server error(%s)\\n&quot;</span>, <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 创建一个 HTTP 响应头对象 */</span><br><br>\thdr_res = <span class=\"hljs-built_in\">http_hdr_res_new</span>();<br><br>\t<span class=\"hljs-comment\">/* 读取 HTTP 服务器响应头*/</span><br><br>\tret = <span class=\"hljs-built_in\">http_hdr_res_get_sync</span>(hdr_res, stream, <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* IO 超时时间为 10 秒 */</span>);<br>\t<span class=\"hljs-keyword\">if</span> (ret &lt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get http reply header error(%s)\\n&quot;</span>, <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t\t<span class=\"hljs-built_in\">http_hdr_res_free</span>(hdr_res);<br>\t\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 分析HTTP服务器响应头 */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">http_hdr_res_parse</span>(hdr_res) &lt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;parse http reply header error\\n&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;hdr_res-&gt;hdr, <span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">http_hdr_res_free</span>(hdr_res);<br>\t\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 如果需要转储至磁盘则需要先打开文件 */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (dump != <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\tfp = <span class=\"hljs-built_in\">acl_fopen</span>(dump, <span class=\"hljs-string\">&quot;w+&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (fp == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open file(%s) error(%s)\\n&quot;</span>,<br>\t\t\t\tdump, <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 如果 HTTP 响应没有数据体则仅输出 HTTP 响应头即可 */</span><br><br>\t<span class=\"hljs-keyword\">if</span> (hdr_res-&gt;hdr.content_length == <span class=\"hljs-number\">0</span><br>\t\t|| (hdr_res-&gt;hdr.content_length == <span class=\"hljs-number\">-1</span><br>\t\t\t&amp;&amp; !hdr_res-&gt;hdr.chunked<br>\t\t\t&amp;&amp; hdr_res-&gt;reply_status &gt; <span class=\"hljs-number\">300</span><br>\t\t\t&amp;&amp; hdr_res-&gt;reply_status &lt; <span class=\"hljs-number\">400</span>))<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (fp)<br>\t\t\t<span class=\"hljs-built_in\">http_hdr_fprint</span>(<span class=\"hljs-built_in\">ACL_FSTREAM</span>(fp), &amp;hdr_res-&gt;hdr,<br>\t\t\t\t<span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\t<span class=\"hljs-built_in\">http_hdr_fprint</span>(ACL_VSTREAM_OUT, &amp;hdr_res-&gt;hdr,<br>\t\t\t\t<span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">http_hdr_res_free</span>(hdr_res);<br>\t\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);<br>\t\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);<br>\t\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 输出 HTTP 响应头 */</span><br><br>\t<span class=\"hljs-built_in\">http_hdr_print</span>(&amp;hdr_res-&gt;hdr, <span class=\"hljs-string\">&quot;--- reply http header ---&quot;</span>);<br><br>\t<span class=\"hljs-comment\">/* 创建 HTTP 响应体对象 */</span><br><br>\tres = <span class=\"hljs-built_in\">http_res_new</span>(hdr_res);<br><br>\t<span class=\"hljs-comment\">/* 如果有数据体则开始读取 HTTP 响应数据体部分 */</span><br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\t<span class=\"hljs-type\">http_off_t</span>  n;<br>\t\t<span class=\"hljs-type\">char</span>  buf2[<span class=\"hljs-number\">4096</span>];<br>\t\t<br>\t\t<span class=\"hljs-comment\">/* 以同步方式读取HTTP响应数据 */</span><br><br>\t\tn = <span class=\"hljs-built_in\">http_res_body_get_sync</span>(res, stream, buf2, <span class=\"hljs-built_in\">sizeof</span>(buf2) - <span class=\"hljs-number\">1</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (n &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (fp) &#123;<br>\t\t\t<span class=\"hljs-comment\">/* 转储至文件中 */</span><br><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">acl_fwrite</span>(buf2, (<span class=\"hljs-type\">size_t</span>) n, <span class=\"hljs-number\">1</span>, fp) == (<span class=\"hljs-type\">size_t</span>) EOF) &#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;write to dump file(%s) error(%s)\\n&quot;</span>,<br>\t\t\t\t\tdump, <span class=\"hljs-built_in\">acl_last_serror</span>());<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tbuf2[n] = <span class=\"hljs-number\">0</span>;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s&quot;</span>, buf2);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (fp)<br>\t\t<span class=\"hljs-built_in\">acl_fclose</span>(fp);  <span class=\"hljs-comment\">/* 关闭转储文件句柄 */</span><br>\t<span class=\"hljs-built_in\">http_res_free</span>(res);  <span class=\"hljs-comment\">/* 释放 HTTP 响应对象, hdr_res 会在此函数内部自动被释放 */</span><br>\t<span class=\"hljs-built_in\">acl_vstream_close</span>(stream);  <span class=\"hljs-comment\">/* 关闭网络流 */</span><br>\t<span class=\"hljs-built_in\">acl_vstring_free</span>(buf);  <span class=\"hljs-comment\">/* 释放内存区 */</span><br>\t<span class=\"hljs-built_in\">http_hdr_req_free</span>(hdr_req);  <span class=\"hljs-comment\">/* 释放 HTTP 请求头对象 */</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *procname)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h[help] -t method -r url -f dump_file -X proxy_addr\\n&quot;</span><br>\t\t<span class=\"hljs-string\">&quot;example: %s -t GET -r http://www.sina.com.cn/ -f url_dump.txt\\n&quot;</span>,<br>\t\tprocname, procname);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">int</span>   ch;<br>\t<span class=\"hljs-type\">char</span>  url[<span class=\"hljs-number\">256</span>], dump[<span class=\"hljs-number\">256</span>], proxy[<span class=\"hljs-number\">256</span>], method[<span class=\"hljs-number\">32</span>];<br><br>\t<span class=\"hljs-built_in\">acl_init</span>();  <span class=\"hljs-comment\">/* 初始化 acl 库 */</span><br><br>\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(method, <span class=\"hljs-string\">&quot;GET&quot;</span>, <span class=\"hljs-built_in\">sizeof</span>(method));<br>\turl[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tdump[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tproxy[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> ((ch = <span class=\"hljs-built_in\">getopt</span>(argc, argv, <span class=\"hljs-string\">&quot;hr:t:f:X:&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">switch</span> (ch) &#123;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;r&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(url, optarg, <span class=\"hljs-built_in\">sizeof</span>(url));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;t&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(method, optarg, <span class=\"hljs-built_in\">sizeof</span>(method));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;f&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(dump, optarg, <span class=\"hljs-built_in\">sizeof</span>(dump));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;X&#x27;</span>:<br>\t\t\t<span class=\"hljs-built_in\">ACL_SAFE_STRNCPY</span>(proxy, optarg, <span class=\"hljs-built_in\">sizeof</span>(proxy));<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (url[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">usage</span>(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">get_url</span>(method, url, proxy, dump);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>可以明显地看出，该例子的实现代码量要比 使用 acl 库开发一个 HTTP 下载客户端 麻烦许多，但它却比较清晰地展示了 HTTP 协议的请求与响应过程。该例子可以在 acl_project&#x2F;samples&#x2F;http&#x2F;get_url1&#x2F; 目录下找到。</p>\n"},{"title":"ACL编程之父子进程机制，父进程守护子进程以防止子进程异常退出","date":"2009-06-07T05:45:00.000Z","_content":"\n在WIN32平台进行编程时，经常会遇到工作进程因为程序内部BUG而异常退出的现象，当然为了解决此类问题最好还是找到问题所在并解决它，但如果这类导致程序崩溃的BUG并不是经常出现，只有当某种条件发生时才会有，在我们解决BUG的时间里，为了尽最大可能地为用户提供服务可以采用一种父进程守护机制：当子进程异常退出时，守护父进程可以截获这一消息，并立即重启子进程，这样用户就可以继续使用我们的程序了，当然如果子进程的问题比较严重频繁地 DOWN掉，而父进程却不停地重启子进程的话，势必造成用户机系统资源的大量耗费，那我们的程序就如病毒一样，很快耗尽了用户机资源，所以需要父进程能够智能地控制重启子进程的时间间隔。\n本文将给出一个具体的例子（利用ACL库），介绍父、子进程的编程方法。\n\n## 一、接口介绍\n### 1.1 以守护进程方式运行的接口\n创建守护进程的方式非常简单，只需要调用 acl_proctl_deamon_init, acl_proctl_daemon_loop 两个函数即可\n接口说明如下：\n\n```c\n/**\n * 初始化进程控制框架（仅 acl_proctl_start 需要）\n * @param progname {const char*} 控制进程进程名\n */\nACL_API void acl_proctl_deamon_init(const char *progname);\n\n/**\n * 控制进程作为后台服务进程运行，监视所有子进程的运行状态，\n * 如果子进程异常退出则会重启该子进程\n */\nACL_API void acl_proctl_daemon_loop(void);\n```\n\n### 1.2 以命令方式来控制守护进程（守护进程即控制进程的意思）\n守护进程启动后，可以以命令方式控制守护进程来启动、停止子进程，或查询显示当前正在运行的子进程。\n启动子进程：acl_proctl_start_one\n停止子进程：acl_proctl_stop_one\n停止所有子进程：acl_proctl_stop_all\n查询子进程是否在运行：acl_proctl_probe\n查询当前所有在运行的子进程：acl_proctl_list\n通过守护进程停止所有子进程且守护进程自身退出：acl_proctl_quit\n\n接口说明如下：\n\n```c\n/**\n * 以命令方式启动某个子进程\n * @param progname {const char*} 控制进程进程名\n * @param progchild {const char*} 子进程进程名\n * @param argc {int} argv 数组的长度\n * @param argv {char* []} 传递给子进程的参数\n */\nACL_API void acl_proctl_start_one(const char *progname,\n    const char *progchild, int argc, char *argv[]);\n\n/**\n * 以命令方式停止某个子进程\n * @param progname {const char*} 控制进程进程名\n * @param progchild {const char*} 子进程进程名\n * @param argc {int} argv 数组的长度\n * @param argv {char* []} 传递给子进程的参数\n */\nACL_API void acl_proctl_stop_one(const char *progname,\n    const char *progchild, int argc, char *argv[]);\n\n/**\n * 以命令方式停止所有的子进程\n * @param progname {const char*} 控制进程进程名\n */\nACL_API void acl_proctl_stop_all(const char *progname);\n\n/**\n * 探测某个服务进程是否在运行\n * @param progname {const char*} 控制进程进程名\n * @param progchild {const char*} 子进程进程名\n */\nACL_API void acl_proctl_probe(const char *progname, const char *progchild);\n\n/**\n * 列出当前所有正在运行的服务进程\n * @param progname {const char*} 控制进程进程名\n */\nACL_API void acl_proctl_list(const char *progname);\n\n/**\n * 以命令方式通知控制进程停止所有的子进程，并在子进程退出后控制进程也自动退出\n * @param progname {const char*} 控制进程进程名\n */\nACL_API void acl_proctl_quit(const char *progname);\n```\n\n### 1.3、子进程编写\n子进程编程也比较容易，只需在程序初始化时调用　acl_proctl_child　即可，这样子进程就会在硬盘创建自己的信息并与父进程（即守护进程）建立联系。\n接口说明：\n\n```c\n/**\n * 子进程调用接口，通过此接口与父进程之间建立控制/被控制关系\n * @param progname {const char*} 子进程进程名\n * @param onexit_fn {void (*)(void*)} 如果非空则当子进程退出时调用的回调函数\n * @param arg {void*} onexit_fn 参数之一\n */\nACL_API void acl_proctl_child(const char *progname, void (*onexit_fn)(void *), void *arg);\n```\n\n## 二、例子\n### 2.1、父进程\n程序名：acl_project\\samples\\proctl\\proctld.cpp\n\n```c\n// proctld.cpp : 定义控制台应用程序的入口点。\n//\n#pragma comment(lib,\"ws2_32\")\n#include \"lib_acl.h\"\n#include <assert.h>\n\nstatic void init(void)\n{\n\tacl_init();  // 初始化ACL库  \n}\n\nstatic void usage(const char *progname)\n{\n\tprintf(\"usage: %s -h [help] -d [START|STOP|QUIT|LIST|PROBE] -f filepath -a args\\r\\n\",\n\t\t\tprogname);\n\tgetchar();\n}\n\nint main(int argc, char *argv[])\n{\n\tchar  ch, filepath[256], cmd[256];\n\tchar **child_argv = NULL;\n\tint   child_argc = 0, i;\n\tACL_ARGV *argv_tmp;\n\n\tfilepath[0] = 0;\n\tcmd[0] = 0;\n\n\tinit();\n\n\twhile ((ch = getopt(argc, argv, \"d:f:a:h\")) > 0) {\n\t\tswitch(ch) {\n\t\t\tcase 'd':\n\t\t\t\tACL_SAFE_STRNCPY(cmd, optarg, sizeof(cmd));\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tACL_SAFE_STRNCPY(filepath, optarg, sizeof(filepath));\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\targv_tmp = acl_argv_split(optarg, \"|\");\n\t\t\t\tassert(argv_tmp);\n\t\t\t\tchild_argc = argv_tmp->argc;\n\t\t\t\tchild_argv = (char**) acl_mycalloc(child_argc + 1, sizeof(char*));\n\t\t\t\tfor (i = 0; i < child_argc; i++) {\n\t\t\t\t\tchild_argv[i] = acl_mystrdup(argv_tmp->argv[i]);\n\t\t\t\t}\n\t\t\t\tchild_argv[i] = NULL;\n\n\t\t\t\tacl_argv_free(argv_tmp);\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tusage(argv[0]);\n\t\t\t\treturn (0);\n\t\t\tdefault:\n\t\t\t\tusage(argv[0]);\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\n\tif (strcasecmp(cmd, \"STOP\") == 0) {\n\t\t// 向守护进程发送消息命令，停止某个子进程或所有的子进程\n\t\tif (filepath[0])\n\t\t\tacl_proctl_stop_one(argv[0], filepath, child_argc, child_argv);\n\t\telse\n\t\t\tacl_proctl_stop_all(argv[0]);\n\t} else if (strcasecmp(cmd, \"START\") == 0) {\n\t\tif (filepath[0] == 0) {\n\t\t\tusage(argv[0]);\n\t\t\treturn (0);\n\t\t}\n\t\t// 向守护进程发送消息命令，启动某个子进程\n\t\tacl_proctl_start_one(argv[0], filepath, child_argc, child_argv);\n\t} else if (strcasecmp(cmd, \"QUIT\") == 0) {\n\t\t// 向守护进程发送消息命令，停止所有的子进程同时守护父进程也退出\n\t\tacl_proctl_quit(argv[0]);\n\t} else if (strcasecmp(cmd, \"LIST\") == 0) {\n\t\t// 向守护进程发送消息命令，列出由守护进程管理的正在运行的所有子进程\n\t\tacl_proctl_list(argv[0]);\n\t} else if (strcasecmp(cmd, \"PROBE\") == 0) {\n\t\tif (filepath[0] == 0) {\n\t\t\tusage(argv[0]);\n\t\t\treturn (0);\n\t\t}\n\t\t// 向守护进程发送消息命令，探测某个子进程是否在运行\n\t\tacl_proctl_probe(argv[0], filepath);\n\t} else {\n\t\t// 父进程以守护进程方式启动\n\t\tchar  buf[MAX_PATH], logfile[MAX_PATH], *ptr;\n\n\t\t// 获得父进程执行程序所在的磁盘路径\n\t\tacl_proctl_daemon_path(buf, sizeof(buf));\n\t\tptr = strrchr(argv[0], '\\\\');\n\t\tif (ptr == NULL)\n\t\t\tptr = strrchr(argv[0], '/');\n\n\t\tif (ptr == NULL)\n\t\t\tptr = argv[0];\n\t\telse\n\t\t\tptr++;\n\n\t\tsnprintf(logfile, sizeof(logfile), \"%s/%s.log\", buf, ptr);\n\t\t// 打开日志文件\n\t\tacl_msg_open(logfile, \"daemon\");\n\t\t// 打开调试信息\n\t\tacl_debug_init(\"all:2\");\n\n\t\t// 以服务器模式启动监控进程\n\t\tacl_proctl_deamon_init(argv[0]);\n\t\t// 父进程作为守护进程启动\n\t\tacl_proctl_daemon_loop();\n\t}\n\n\tif (child_argv) {\n\t\tfor (i = 0; child_argv[i] != NULL; i++) {\n\t\t\tacl_myfree(child_argv[i]);\n\t\t}\n\t\tacl_myfree(child_argv);\n\t}\n\treturn (0);\n}\n```\n\n### 2.2、子进程\nacl_project\\samples\\proctl\\proctlc.cpp\n\n```c\n// proctlc.cpp : 定义控制台应用程序的入口点。\n//\n#pragma comment(lib,\"ws2_32\")\n#include \"lib_acl.h\"\n\nstatic void onexit_fn(void *arg acl_unused)\n{\n\tprintf(\"child exit now\\r\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n\tint   i;\n\n\tacl_socket_init();\n\tacl_msg_open(\"debug.txt\", \"proctlc\");\n\tacl_msg_info(\">>> in child progname(%s), argc=%d\\r\\n\", argv[0], argc);\n\tif (argc > 1)\n\t\tacl_msg_info(\">>> in child progname, argv[1]=(%s)\\r\\n\", argv[1]);\n\n\t// 子进程启动，同时注册自身信息\n\tacl_proctl_child(argv[0], onexit_fn, NULL);\n\n\tfor (i = 0; i < argc; i++) {\n\t\tacl_msg_info(\">>>argv[%d]:%s\\r\\n\", i, argv[i]);\n\t}\n\n\ti = 0;\n\twhile (1) {\n\t\tacl_msg_info(\"i = %d\\r\\n\", i++);\n\t\tif (i == 5)\n\t\t\tbreak;\n\t\telse\n\t\t\tsleep(1);\n\t}\n\treturn (-1);  // 返回 -1 是为了让父进程继续启动\n}\n```\n\n### 2.3、编译、运行\n可以打开 acl_project\\win32_build\\vc\\samples\\samples_vc2003.sln，编译其中的 proctlc, proctld 两个工程，便会生成两个可执行文件：proctlc.exe(子进程程序），proctld.exe(父进程程序）。\n先让父进程以守护进程模式启动 proctld.exe，然后运行 proctld.exe -d START {path}/proctlc.exe 通知父进程启动子进程；可以运行 proctld.exe -d LIST 列出当前正在运行的子进程，运行 proctld.exe -d PROBE {path}/proctld.exe 判断子进程是否在运行，运行 proctld.exe -d STOP {path}/proctld.exe 让守护父进程停止子进程，运行 proctld.exe -d QUID 使守护进程停止所有子进程并自动退出。\n另外，从子进程的程序可以看出，每隔5秒子进程就会异常退出，则守护进程便会立即重启该子进程，如果子进程死的过于频繁，则守护进程会延迟重启子进程，以防止太过耗费系统资源。\n\n## 三、小结\n因为有守护进程保护，就不必担心子进程（即你的工作进程）异常崩溃了，这种父子进程模型可以应用于大多数工作子进程偶尔异常崩溃的情形，如果你的程序 BUG太多，每一会儿就崩溃好多次，建议你还是先把主要问题解决后再使用父子进程，毕竟如果你的程序太过脆弱，虽然父进程能不断地重启你的程序，但你还是不能为用户提供正常服务。这种模型适用于在WIN32平台下，你的程序可能写得比较复杂，程序基本上是比较健壮的，只是会因偶尔某些原因而异常退出的情况。\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","source":"_posts/process_control.md","raw":"---\ntitle: ACL编程之父子进程机制，父进程守护子进程以防止子进程异常退出\ndate: 2009-06-07 13:45\ncategories: 进程控制\n---\n\n在WIN32平台进行编程时，经常会遇到工作进程因为程序内部BUG而异常退出的现象，当然为了解决此类问题最好还是找到问题所在并解决它，但如果这类导致程序崩溃的BUG并不是经常出现，只有当某种条件发生时才会有，在我们解决BUG的时间里，为了尽最大可能地为用户提供服务可以采用一种父进程守护机制：当子进程异常退出时，守护父进程可以截获这一消息，并立即重启子进程，这样用户就可以继续使用我们的程序了，当然如果子进程的问题比较严重频繁地 DOWN掉，而父进程却不停地重启子进程的话，势必造成用户机系统资源的大量耗费，那我们的程序就如病毒一样，很快耗尽了用户机资源，所以需要父进程能够智能地控制重启子进程的时间间隔。\n本文将给出一个具体的例子（利用ACL库），介绍父、子进程的编程方法。\n\n## 一、接口介绍\n### 1.1 以守护进程方式运行的接口\n创建守护进程的方式非常简单，只需要调用 acl_proctl_deamon_init, acl_proctl_daemon_loop 两个函数即可\n接口说明如下：\n\n```c\n/**\n * 初始化进程控制框架（仅 acl_proctl_start 需要）\n * @param progname {const char*} 控制进程进程名\n */\nACL_API void acl_proctl_deamon_init(const char *progname);\n\n/**\n * 控制进程作为后台服务进程运行，监视所有子进程的运行状态，\n * 如果子进程异常退出则会重启该子进程\n */\nACL_API void acl_proctl_daemon_loop(void);\n```\n\n### 1.2 以命令方式来控制守护进程（守护进程即控制进程的意思）\n守护进程启动后，可以以命令方式控制守护进程来启动、停止子进程，或查询显示当前正在运行的子进程。\n启动子进程：acl_proctl_start_one\n停止子进程：acl_proctl_stop_one\n停止所有子进程：acl_proctl_stop_all\n查询子进程是否在运行：acl_proctl_probe\n查询当前所有在运行的子进程：acl_proctl_list\n通过守护进程停止所有子进程且守护进程自身退出：acl_proctl_quit\n\n接口说明如下：\n\n```c\n/**\n * 以命令方式启动某个子进程\n * @param progname {const char*} 控制进程进程名\n * @param progchild {const char*} 子进程进程名\n * @param argc {int} argv 数组的长度\n * @param argv {char* []} 传递给子进程的参数\n */\nACL_API void acl_proctl_start_one(const char *progname,\n    const char *progchild, int argc, char *argv[]);\n\n/**\n * 以命令方式停止某个子进程\n * @param progname {const char*} 控制进程进程名\n * @param progchild {const char*} 子进程进程名\n * @param argc {int} argv 数组的长度\n * @param argv {char* []} 传递给子进程的参数\n */\nACL_API void acl_proctl_stop_one(const char *progname,\n    const char *progchild, int argc, char *argv[]);\n\n/**\n * 以命令方式停止所有的子进程\n * @param progname {const char*} 控制进程进程名\n */\nACL_API void acl_proctl_stop_all(const char *progname);\n\n/**\n * 探测某个服务进程是否在运行\n * @param progname {const char*} 控制进程进程名\n * @param progchild {const char*} 子进程进程名\n */\nACL_API void acl_proctl_probe(const char *progname, const char *progchild);\n\n/**\n * 列出当前所有正在运行的服务进程\n * @param progname {const char*} 控制进程进程名\n */\nACL_API void acl_proctl_list(const char *progname);\n\n/**\n * 以命令方式通知控制进程停止所有的子进程，并在子进程退出后控制进程也自动退出\n * @param progname {const char*} 控制进程进程名\n */\nACL_API void acl_proctl_quit(const char *progname);\n```\n\n### 1.3、子进程编写\n子进程编程也比较容易，只需在程序初始化时调用　acl_proctl_child　即可，这样子进程就会在硬盘创建自己的信息并与父进程（即守护进程）建立联系。\n接口说明：\n\n```c\n/**\n * 子进程调用接口，通过此接口与父进程之间建立控制/被控制关系\n * @param progname {const char*} 子进程进程名\n * @param onexit_fn {void (*)(void*)} 如果非空则当子进程退出时调用的回调函数\n * @param arg {void*} onexit_fn 参数之一\n */\nACL_API void acl_proctl_child(const char *progname, void (*onexit_fn)(void *), void *arg);\n```\n\n## 二、例子\n### 2.1、父进程\n程序名：acl_project\\samples\\proctl\\proctld.cpp\n\n```c\n// proctld.cpp : 定义控制台应用程序的入口点。\n//\n#pragma comment(lib,\"ws2_32\")\n#include \"lib_acl.h\"\n#include <assert.h>\n\nstatic void init(void)\n{\n\tacl_init();  // 初始化ACL库  \n}\n\nstatic void usage(const char *progname)\n{\n\tprintf(\"usage: %s -h [help] -d [START|STOP|QUIT|LIST|PROBE] -f filepath -a args\\r\\n\",\n\t\t\tprogname);\n\tgetchar();\n}\n\nint main(int argc, char *argv[])\n{\n\tchar  ch, filepath[256], cmd[256];\n\tchar **child_argv = NULL;\n\tint   child_argc = 0, i;\n\tACL_ARGV *argv_tmp;\n\n\tfilepath[0] = 0;\n\tcmd[0] = 0;\n\n\tinit();\n\n\twhile ((ch = getopt(argc, argv, \"d:f:a:h\")) > 0) {\n\t\tswitch(ch) {\n\t\t\tcase 'd':\n\t\t\t\tACL_SAFE_STRNCPY(cmd, optarg, sizeof(cmd));\n\t\t\t\tbreak;\n\t\t\tcase 'f':\n\t\t\t\tACL_SAFE_STRNCPY(filepath, optarg, sizeof(filepath));\n\t\t\t\tbreak;\n\t\t\tcase 'a':\n\t\t\t\targv_tmp = acl_argv_split(optarg, \"|\");\n\t\t\t\tassert(argv_tmp);\n\t\t\t\tchild_argc = argv_tmp->argc;\n\t\t\t\tchild_argv = (char**) acl_mycalloc(child_argc + 1, sizeof(char*));\n\t\t\t\tfor (i = 0; i < child_argc; i++) {\n\t\t\t\t\tchild_argv[i] = acl_mystrdup(argv_tmp->argv[i]);\n\t\t\t\t}\n\t\t\t\tchild_argv[i] = NULL;\n\n\t\t\t\tacl_argv_free(argv_tmp);\n\t\t\t\tbreak;\n\t\t\tcase 'h':\n\t\t\t\tusage(argv[0]);\n\t\t\t\treturn (0);\n\t\t\tdefault:\n\t\t\t\tusage(argv[0]);\n\t\t\t\treturn (0);\n\t\t}\n\t}\n\n\tif (strcasecmp(cmd, \"STOP\") == 0) {\n\t\t// 向守护进程发送消息命令，停止某个子进程或所有的子进程\n\t\tif (filepath[0])\n\t\t\tacl_proctl_stop_one(argv[0], filepath, child_argc, child_argv);\n\t\telse\n\t\t\tacl_proctl_stop_all(argv[0]);\n\t} else if (strcasecmp(cmd, \"START\") == 0) {\n\t\tif (filepath[0] == 0) {\n\t\t\tusage(argv[0]);\n\t\t\treturn (0);\n\t\t}\n\t\t// 向守护进程发送消息命令，启动某个子进程\n\t\tacl_proctl_start_one(argv[0], filepath, child_argc, child_argv);\n\t} else if (strcasecmp(cmd, \"QUIT\") == 0) {\n\t\t// 向守护进程发送消息命令，停止所有的子进程同时守护父进程也退出\n\t\tacl_proctl_quit(argv[0]);\n\t} else if (strcasecmp(cmd, \"LIST\") == 0) {\n\t\t// 向守护进程发送消息命令，列出由守护进程管理的正在运行的所有子进程\n\t\tacl_proctl_list(argv[0]);\n\t} else if (strcasecmp(cmd, \"PROBE\") == 0) {\n\t\tif (filepath[0] == 0) {\n\t\t\tusage(argv[0]);\n\t\t\treturn (0);\n\t\t}\n\t\t// 向守护进程发送消息命令，探测某个子进程是否在运行\n\t\tacl_proctl_probe(argv[0], filepath);\n\t} else {\n\t\t// 父进程以守护进程方式启动\n\t\tchar  buf[MAX_PATH], logfile[MAX_PATH], *ptr;\n\n\t\t// 获得父进程执行程序所在的磁盘路径\n\t\tacl_proctl_daemon_path(buf, sizeof(buf));\n\t\tptr = strrchr(argv[0], '\\\\');\n\t\tif (ptr == NULL)\n\t\t\tptr = strrchr(argv[0], '/');\n\n\t\tif (ptr == NULL)\n\t\t\tptr = argv[0];\n\t\telse\n\t\t\tptr++;\n\n\t\tsnprintf(logfile, sizeof(logfile), \"%s/%s.log\", buf, ptr);\n\t\t// 打开日志文件\n\t\tacl_msg_open(logfile, \"daemon\");\n\t\t// 打开调试信息\n\t\tacl_debug_init(\"all:2\");\n\n\t\t// 以服务器模式启动监控进程\n\t\tacl_proctl_deamon_init(argv[0]);\n\t\t// 父进程作为守护进程启动\n\t\tacl_proctl_daemon_loop();\n\t}\n\n\tif (child_argv) {\n\t\tfor (i = 0; child_argv[i] != NULL; i++) {\n\t\t\tacl_myfree(child_argv[i]);\n\t\t}\n\t\tacl_myfree(child_argv);\n\t}\n\treturn (0);\n}\n```\n\n### 2.2、子进程\nacl_project\\samples\\proctl\\proctlc.cpp\n\n```c\n// proctlc.cpp : 定义控制台应用程序的入口点。\n//\n#pragma comment(lib,\"ws2_32\")\n#include \"lib_acl.h\"\n\nstatic void onexit_fn(void *arg acl_unused)\n{\n\tprintf(\"child exit now\\r\\n\");\n}\n\nint main(int argc, char *argv[])\n{\n\tint   i;\n\n\tacl_socket_init();\n\tacl_msg_open(\"debug.txt\", \"proctlc\");\n\tacl_msg_info(\">>> in child progname(%s), argc=%d\\r\\n\", argv[0], argc);\n\tif (argc > 1)\n\t\tacl_msg_info(\">>> in child progname, argv[1]=(%s)\\r\\n\", argv[1]);\n\n\t// 子进程启动，同时注册自身信息\n\tacl_proctl_child(argv[0], onexit_fn, NULL);\n\n\tfor (i = 0; i < argc; i++) {\n\t\tacl_msg_info(\">>>argv[%d]:%s\\r\\n\", i, argv[i]);\n\t}\n\n\ti = 0;\n\twhile (1) {\n\t\tacl_msg_info(\"i = %d\\r\\n\", i++);\n\t\tif (i == 5)\n\t\t\tbreak;\n\t\telse\n\t\t\tsleep(1);\n\t}\n\treturn (-1);  // 返回 -1 是为了让父进程继续启动\n}\n```\n\n### 2.3、编译、运行\n可以打开 acl_project\\win32_build\\vc\\samples\\samples_vc2003.sln，编译其中的 proctlc, proctld 两个工程，便会生成两个可执行文件：proctlc.exe(子进程程序），proctld.exe(父进程程序）。\n先让父进程以守护进程模式启动 proctld.exe，然后运行 proctld.exe -d START {path}/proctlc.exe 通知父进程启动子进程；可以运行 proctld.exe -d LIST 列出当前正在运行的子进程，运行 proctld.exe -d PROBE {path}/proctld.exe 判断子进程是否在运行，运行 proctld.exe -d STOP {path}/proctld.exe 让守护父进程停止子进程，运行 proctld.exe -d QUID 使守护进程停止所有子进程并自动退出。\n另外，从子进程的程序可以看出，每隔5秒子进程就会异常退出，则守护进程便会立即重启该子进程，如果子进程死的过于频繁，则守护进程会延迟重启子进程，以防止太过耗费系统资源。\n\n## 三、小结\n因为有守护进程保护，就不必担心子进程（即你的工作进程）异常崩溃了，这种父子进程模型可以应用于大多数工作子进程偶尔异常崩溃的情形，如果你的程序 BUG太多，每一会儿就崩溃好多次，建议你还是先把主要问题解决后再使用父子进程，毕竟如果你的程序太过脆弱，虽然父进程能不断地重启你的程序，但你还是不能为用户提供正常服务。这种模型适用于在WIN32平台下，你的程序可能写得比较复杂，程序基本上是比较健壮的，只是会因偶尔某些原因而异常退出的情况。\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","slug":"process_control","published":1,"updated":"2023-01-24T03:10:59.805Z","_id":"cld9no3at000629fy3luv70vy","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在WIN32平台进行编程时，经常会遇到工作进程因为程序内部BUG而异常退出的现象，当然为了解决此类问题最好还是找到问题所在并解决它，但如果这类导致程序崩溃的BUG并不是经常出现，只有当某种条件发生时才会有，在我们解决BUG的时间里，为了尽最大可能地为用户提供服务可以采用一种父进程守护机制：当子进程异常退出时，守护父进程可以截获这一消息，并立即重启子进程，这样用户就可以继续使用我们的程序了，当然如果子进程的问题比较严重频繁地 DOWN掉，而父进程却不停地重启子进程的话，势必造成用户机系统资源的大量耗费，那我们的程序就如病毒一样，很快耗尽了用户机资源，所以需要父进程能够智能地控制重启子进程的时间间隔。<br>本文将给出一个具体的例子（利用ACL库），介绍父、子进程的编程方法。</p>\n<h2 id=\"一、接口介绍\"><a href=\"#一、接口介绍\" class=\"headerlink\" title=\"一、接口介绍\"></a>一、接口介绍</h2><h3 id=\"1-1-以守护进程方式运行的接口\"><a href=\"#1-1-以守护进程方式运行的接口\" class=\"headerlink\" title=\"1.1 以守护进程方式运行的接口\"></a>1.1 以守护进程方式运行的接口</h3><p>创建守护进程的方式非常简单，只需要调用 acl_proctl_deamon_init, acl_proctl_daemon_loop 两个函数即可<br>接口说明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 初始化进程控制框架（仅 acl_proctl_start 需要）</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_deamon_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 控制进程作为后台服务进程运行，监视所有子进程的运行状态，</span><br><span class=\"hljs-comment\"> * 如果子进程异常退出则会重启该子进程</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_daemon_loop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-以命令方式来控制守护进程（守护进程即控制进程的意思）\"><a href=\"#1-2-以命令方式来控制守护进程（守护进程即控制进程的意思）\" class=\"headerlink\" title=\"1.2 以命令方式来控制守护进程（守护进程即控制进程的意思）\"></a>1.2 以命令方式来控制守护进程（守护进程即控制进程的意思）</h3><p>守护进程启动后，可以以命令方式控制守护进程来启动、停止子进程，或查询显示当前正在运行的子进程。<br>启动子进程：acl_proctl_start_one<br>停止子进程：acl_proctl_stop_one<br>停止所有子进程：acl_proctl_stop_all<br>查询子进程是否在运行：acl_proctl_probe<br>查询当前所有在运行的子进程：acl_proctl_list<br>通过守护进程停止所有子进程且守护进程自身退出：acl_proctl_quit</p>\n<p>接口说明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 以命令方式启动某个子进程</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> * @param progchild &#123;const char*&#125; 子进程进程名</span><br><span class=\"hljs-comment\"> * @param argc &#123;int&#125; argv 数组的长度</span><br><span class=\"hljs-comment\"> * @param argv &#123;char* []&#125; 传递给子进程的参数</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_start_one</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname,</span><br><span class=\"hljs-params\">    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progchild, <span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 以命令方式停止某个子进程</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> * @param progchild &#123;const char*&#125; 子进程进程名</span><br><span class=\"hljs-comment\"> * @param argc &#123;int&#125; argv 数组的长度</span><br><span class=\"hljs-comment\"> * @param argv &#123;char* []&#125; 传递给子进程的参数</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_stop_one</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname,</span><br><span class=\"hljs-params\">    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progchild, <span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 以命令方式停止所有的子进程</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_stop_all</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 探测某个服务进程是否在运行</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> * @param progchild &#123;const char*&#125; 子进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_probe</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progchild)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 列出当前所有正在运行的服务进程</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_list</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 以命令方式通知控制进程停止所有的子进程，并在子进程退出后控制进程也自动退出</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_quit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-3、子进程编写\"><a href=\"#1-3、子进程编写\" class=\"headerlink\" title=\"1.3、子进程编写\"></a>1.3、子进程编写</h3><p>子进程编程也比较容易，只需在程序初始化时调用　acl_proctl_child　即可，这样子进程就会在硬盘创建自己的信息并与父进程（即守护进程）建立联系。<br>接口说明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 子进程调用接口，通过此接口与父进程之间建立控制/被控制关系</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 子进程进程名</span><br><span class=\"hljs-comment\"> * @param onexit_fn &#123;void (*)(void*)&#125; 如果非空则当子进程退出时调用的回调函数</span><br><span class=\"hljs-comment\"> * @param arg &#123;void*&#125; onexit_fn 参数之一</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_child</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname, <span class=\"hljs-type\">void</span> (*onexit_fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、例子\"><a href=\"#二、例子\" class=\"headerlink\" title=\"二、例子\"></a>二、例子</h2><h3 id=\"2-1、父进程\"><a href=\"#2-1、父进程\" class=\"headerlink\" title=\"2.1、父进程\"></a>2.1、父进程</h3><p>程序名：acl_project\\samples\\proctl\\proctld.cpp</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// proctld.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> comment(lib,<span class=\"hljs-string\">&quot;ws2_32&quot;</span>)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tacl_init();  <span class=\"hljs-comment\">// 初始化ACL库  </span><br>&#125;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span><br>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h [help] -d [START|STOP|QUIT|LIST|PROBE] -f filepath -a args\\r\\n&quot;</span>,<br>\t\t\tprogname);<br>\tgetchar();<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span>  ch, filepath[<span class=\"hljs-number\">256</span>], cmd[<span class=\"hljs-number\">256</span>];<br>\t<span class=\"hljs-type\">char</span> **child_argv = <span class=\"hljs-literal\">NULL</span>;<br>\t<span class=\"hljs-type\">int</span>   child_argc = <span class=\"hljs-number\">0</span>, i;<br>\tACL_ARGV *argv_tmp;<br><br>\tfilepath[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tcmd[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br><br>\tinit();<br><br>\t<span class=\"hljs-keyword\">while</span> ((ch = getopt(argc, argv, <span class=\"hljs-string\">&quot;d:f:a:h&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">switch</span>(ch) &#123;<br>\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;d&#x27;</span>:<br>\t\t\t\tACL_SAFE_STRNCPY(cmd, optarg, <span class=\"hljs-keyword\">sizeof</span>(cmd));<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;f&#x27;</span>:<br>\t\t\t\tACL_SAFE_STRNCPY(filepath, optarg, <span class=\"hljs-keyword\">sizeof</span>(filepath));<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;a&#x27;</span>:<br>\t\t\t\targv_tmp = acl_argv_split(optarg, <span class=\"hljs-string\">&quot;|&quot;</span>);<br>\t\t\t\tassert(argv_tmp);<br>\t\t\t\tchild_argc = argv_tmp-&gt;argc;<br>\t\t\t\tchild_argv = (<span class=\"hljs-type\">char</span>**) acl_mycalloc(child_argc + <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">char</span>*));<br>\t\t\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; child_argc; i++) &#123;<br>\t\t\t\t\tchild_argv[i] = acl_mystrdup(argv_tmp-&gt;argv[i]);<br>\t\t\t\t&#125;<br>\t\t\t\tchild_argv[i] = <span class=\"hljs-literal\">NULL</span>;<br><br>\t\t\t\tacl_argv_free(argv_tmp);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t\tusage(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t\tusage(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;STOP&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，停止某个子进程或所有的子进程</span><br>\t\t<span class=\"hljs-keyword\">if</span> (filepath[<span class=\"hljs-number\">0</span>])<br>\t\t\tacl_proctl_stop_one(argv[<span class=\"hljs-number\">0</span>], filepath, child_argc, child_argv);<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\tacl_proctl_stop_all(argv[<span class=\"hljs-number\">0</span>]);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;START&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (filepath[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tusage(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，启动某个子进程</span><br>\t\tacl_proctl_start_one(argv[<span class=\"hljs-number\">0</span>], filepath, child_argc, child_argv);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;QUIT&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，停止所有的子进程同时守护父进程也退出</span><br>\t\tacl_proctl_quit(argv[<span class=\"hljs-number\">0</span>]);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;LIST&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，列出由守护进程管理的正在运行的所有子进程</span><br>\t\tacl_proctl_list(argv[<span class=\"hljs-number\">0</span>]);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;PROBE&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (filepath[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tusage(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，探测某个子进程是否在运行</span><br>\t\tacl_proctl_probe(argv[<span class=\"hljs-number\">0</span>], filepath);<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-comment\">// 父进程以守护进程方式启动</span><br>\t\t<span class=\"hljs-type\">char</span>  buf[MAX_PATH], logfile[MAX_PATH], *ptr;<br><br>\t\t<span class=\"hljs-comment\">// 获得父进程执行程序所在的磁盘路径</span><br>\t\tacl_proctl_daemon_path(buf, <span class=\"hljs-keyword\">sizeof</span>(buf));<br>\t\tptr = <span class=\"hljs-built_in\">strrchr</span>(argv[<span class=\"hljs-number\">0</span>], <span class=\"hljs-string\">&#x27;\\\\&#x27;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\tptr = <span class=\"hljs-built_in\">strrchr</span>(argv[<span class=\"hljs-number\">0</span>], <span class=\"hljs-string\">&#x27;/&#x27;</span>);<br><br>\t\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\tptr = argv[<span class=\"hljs-number\">0</span>];<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\tptr++;<br><br>\t\t<span class=\"hljs-built_in\">snprintf</span>(logfile, <span class=\"hljs-keyword\">sizeof</span>(logfile), <span class=\"hljs-string\">&quot;%s/%s.log&quot;</span>, buf, ptr);<br>\t\t<span class=\"hljs-comment\">// 打开日志文件</span><br>\t\tacl_msg_open(logfile, <span class=\"hljs-string\">&quot;daemon&quot;</span>);<br>\t\t<span class=\"hljs-comment\">// 打开调试信息</span><br>\t\tacl_debug_init(<span class=\"hljs-string\">&quot;all:2&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 以服务器模式启动监控进程</span><br>\t\tacl_proctl_deamon_init(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t<span class=\"hljs-comment\">// 父进程作为守护进程启动</span><br>\t\tacl_proctl_daemon_loop();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (child_argv) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; child_argv[i] != <span class=\"hljs-literal\">NULL</span>; i++) &#123;<br>\t\t\tacl_myfree(child_argv[i]);<br>\t\t&#125;<br>\t\tacl_myfree(child_argv);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2、子进程\"><a href=\"#2-2、子进程\" class=\"headerlink\" title=\"2.2、子进程\"></a>2.2、子进程</h3><p>acl_project\\samples\\proctl\\proctlc.cpp</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// proctlc.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> comment(lib,<span class=\"hljs-string\">&quot;ws2_32&quot;</span>)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">onexit_fn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg acl_unused)</span><br>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;child exit now\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span>   i;<br><br>\tacl_socket_init();<br>\tacl_msg_open(<span class=\"hljs-string\">&quot;debug.txt&quot;</span>, <span class=\"hljs-string\">&quot;proctlc&quot;</span>);<br>\tacl_msg_info(<span class=\"hljs-string\">&quot;&gt;&gt;&gt; in child progname(%s), argc=%d\\r\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>], argc);<br>\t<span class=\"hljs-keyword\">if</span> (argc &gt; <span class=\"hljs-number\">1</span>)<br>\t\tacl_msg_info(<span class=\"hljs-string\">&quot;&gt;&gt;&gt; in child progname, argv[1]=(%s)\\r\\n&quot;</span>, argv[<span class=\"hljs-number\">1</span>]);<br><br>\t<span class=\"hljs-comment\">// 子进程启动，同时注册自身信息</span><br>\tacl_proctl_child(argv[<span class=\"hljs-number\">0</span>], onexit_fn, <span class=\"hljs-literal\">NULL</span>);<br><br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; argc; i++) &#123;<br>\t\tacl_msg_info(<span class=\"hljs-string\">&quot;&gt;&gt;&gt;argv[%d]:%s\\r\\n&quot;</span>, i, argv[i]);<br>\t&#125;<br><br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\tacl_msg_info(<span class=\"hljs-string\">&quot;i = %d\\r\\n&quot;</span>, i++);<br>\t\t<span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">5</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\tsleep(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">-1</span>);  <span class=\"hljs-comment\">// 返回 -1 是为了让父进程继续启动</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3、编译、运行\"><a href=\"#2-3、编译、运行\" class=\"headerlink\" title=\"2.3、编译、运行\"></a>2.3、编译、运行</h3><p>可以打开 acl_project\\win32_build\\vc\\samples\\samples_vc2003.sln，编译其中的 proctlc, proctld 两个工程，便会生成两个可执行文件：proctlc.exe(子进程程序），proctld.exe(父进程程序）。<br>先让父进程以守护进程模式启动 proctld.exe，然后运行 proctld.exe -d START {path}&#x2F;proctlc.exe 通知父进程启动子进程；可以运行 proctld.exe -d LIST 列出当前正在运行的子进程，运行 proctld.exe -d PROBE {path}&#x2F;proctld.exe 判断子进程是否在运行，运行 proctld.exe -d STOP {path}&#x2F;proctld.exe 让守护父进程停止子进程，运行 proctld.exe -d QUID 使守护进程停止所有子进程并自动退出。<br>另外，从子进程的程序可以看出，每隔5秒子进程就会异常退出，则守护进程便会立即重启该子进程，如果子进程死的过于频繁，则守护进程会延迟重启子进程，以防止太过耗费系统资源。</p>\n<h2 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h2><p>因为有守护进程保护，就不必担心子进程（即你的工作进程）异常崩溃了，这种父子进程模型可以应用于大多数工作子进程偶尔异常崩溃的情形，如果你的程序 BUG太多，每一会儿就崩溃好多次，建议你还是先把主要问题解决后再使用父子进程，毕竟如果你的程序太过脆弱，虽然父进程能不断地重启你的程序，但你还是不能为用户提供正常服务。这种模型适用于在WIN32平台下，你的程序可能写得比较复杂，程序基本上是比较健壮的，只是会因偶尔某些原因而异常退出的情况。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在WIN32平台进行编程时，经常会遇到工作进程因为程序内部BUG而异常退出的现象，当然为了解决此类问题最好还是找到问题所在并解决它，但如果这类导致程序崩溃的BUG并不是经常出现，只有当某种条件发生时才会有，在我们解决BUG的时间里，为了尽最大可能地为用户提供服务可以采用一种父进程守护机制：当子进程异常退出时，守护父进程可以截获这一消息，并立即重启子进程，这样用户就可以继续使用我们的程序了，当然如果子进程的问题比较严重频繁地 DOWN掉，而父进程却不停地重启子进程的话，势必造成用户机系统资源的大量耗费，那我们的程序就如病毒一样，很快耗尽了用户机资源，所以需要父进程能够智能地控制重启子进程的时间间隔。<br>本文将给出一个具体的例子（利用ACL库），介绍父、子进程的编程方法。</p>\n<h2 id=\"一、接口介绍\"><a href=\"#一、接口介绍\" class=\"headerlink\" title=\"一、接口介绍\"></a>一、接口介绍</h2><h3 id=\"1-1-以守护进程方式运行的接口\"><a href=\"#1-1-以守护进程方式运行的接口\" class=\"headerlink\" title=\"1.1 以守护进程方式运行的接口\"></a>1.1 以守护进程方式运行的接口</h3><p>创建守护进程的方式非常简单，只需要调用 acl_proctl_deamon_init, acl_proctl_daemon_loop 两个函数即可<br>接口说明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 初始化进程控制框架（仅 acl_proctl_start 需要）</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_deamon_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 控制进程作为后台服务进程运行，监视所有子进程的运行状态，</span><br><span class=\"hljs-comment\"> * 如果子进程异常退出则会重启该子进程</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_daemon_loop</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-2-以命令方式来控制守护进程（守护进程即控制进程的意思）\"><a href=\"#1-2-以命令方式来控制守护进程（守护进程即控制进程的意思）\" class=\"headerlink\" title=\"1.2 以命令方式来控制守护进程（守护进程即控制进程的意思）\"></a>1.2 以命令方式来控制守护进程（守护进程即控制进程的意思）</h3><p>守护进程启动后，可以以命令方式控制守护进程来启动、停止子进程，或查询显示当前正在运行的子进程。<br>启动子进程：acl_proctl_start_one<br>停止子进程：acl_proctl_stop_one<br>停止所有子进程：acl_proctl_stop_all<br>查询子进程是否在运行：acl_proctl_probe<br>查询当前所有在运行的子进程：acl_proctl_list<br>通过守护进程停止所有子进程且守护进程自身退出：acl_proctl_quit</p>\n<p>接口说明如下：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 以命令方式启动某个子进程</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> * @param progchild &#123;const char*&#125; 子进程进程名</span><br><span class=\"hljs-comment\"> * @param argc &#123;int&#125; argv 数组的长度</span><br><span class=\"hljs-comment\"> * @param argv &#123;char* []&#125; 传递给子进程的参数</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_start_one</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname,</span><br><span class=\"hljs-params\">    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progchild, <span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 以命令方式停止某个子进程</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> * @param progchild &#123;const char*&#125; 子进程进程名</span><br><span class=\"hljs-comment\"> * @param argc &#123;int&#125; argv 数组的长度</span><br><span class=\"hljs-comment\"> * @param argv &#123;char* []&#125; 传递给子进程的参数</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_stop_one</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname,</span><br><span class=\"hljs-params\">    <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progchild, <span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 以命令方式停止所有的子进程</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_stop_all</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 探测某个服务进程是否在运行</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> * @param progchild &#123;const char*&#125; 子进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_probe</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progchild)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 列出当前所有正在运行的服务进程</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_list</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 以命令方式通知控制进程停止所有的子进程，并在子进程退出后控制进程也自动退出</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 控制进程进程名</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_quit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"1-3、子进程编写\"><a href=\"#1-3、子进程编写\" class=\"headerlink\" title=\"1.3、子进程编写\"></a>1.3、子进程编写</h3><p>子进程编程也比较容易，只需在程序初始化时调用　acl_proctl_child　即可，这样子进程就会在硬盘创建自己的信息并与父进程（即守护进程）建立联系。<br>接口说明：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 子进程调用接口，通过此接口与父进程之间建立控制/被控制关系</span><br><span class=\"hljs-comment\"> * @param progname &#123;const char*&#125; 子进程进程名</span><br><span class=\"hljs-comment\"> * @param onexit_fn &#123;void (*)(void*)&#125; 如果非空则当子进程退出时调用的回调函数</span><br><span class=\"hljs-comment\"> * @param arg &#123;void*&#125; onexit_fn 参数之一</span><br><span class=\"hljs-comment\"> */</span><br>ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">acl_proctl_child</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname, <span class=\"hljs-type\">void</span> (*onexit_fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *arg)</span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、例子\"><a href=\"#二、例子\" class=\"headerlink\" title=\"二、例子\"></a>二、例子</h2><h3 id=\"2-1、父进程\"><a href=\"#2-1、父进程\" class=\"headerlink\" title=\"2.1、父进程\"></a>2.1、父进程</h3><p>程序名：acl_project\\samples\\proctl\\proctld.cpp</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// proctld.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> comment(lib,<span class=\"hljs-string\">&quot;ws2_32&quot;</span>)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\tacl_init();  <span class=\"hljs-comment\">// 初始化ACL库  </span><br>&#125;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">usage</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *progname)</span><br>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;usage: %s -h [help] -d [START|STOP|QUIT|LIST|PROBE] -f filepath -a args\\r\\n&quot;</span>,<br>\t\t\tprogname);<br>\tgetchar();<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span>  ch, filepath[<span class=\"hljs-number\">256</span>], cmd[<span class=\"hljs-number\">256</span>];<br>\t<span class=\"hljs-type\">char</span> **child_argv = <span class=\"hljs-literal\">NULL</span>;<br>\t<span class=\"hljs-type\">int</span>   child_argc = <span class=\"hljs-number\">0</span>, i;<br>\tACL_ARGV *argv_tmp;<br><br>\tfilepath[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br>\tcmd[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">0</span>;<br><br>\tinit();<br><br>\t<span class=\"hljs-keyword\">while</span> ((ch = getopt(argc, argv, <span class=\"hljs-string\">&quot;d:f:a:h&quot;</span>)) &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">switch</span>(ch) &#123;<br>\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;d&#x27;</span>:<br>\t\t\t\tACL_SAFE_STRNCPY(cmd, optarg, <span class=\"hljs-keyword\">sizeof</span>(cmd));<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;f&#x27;</span>:<br>\t\t\t\tACL_SAFE_STRNCPY(filepath, optarg, <span class=\"hljs-keyword\">sizeof</span>(filepath));<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;a&#x27;</span>:<br>\t\t\t\targv_tmp = acl_argv_split(optarg, <span class=\"hljs-string\">&quot;|&quot;</span>);<br>\t\t\t\tassert(argv_tmp);<br>\t\t\t\tchild_argc = argv_tmp-&gt;argc;<br>\t\t\t\tchild_argv = (<span class=\"hljs-type\">char</span>**) acl_mycalloc(child_argc + <span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(<span class=\"hljs-type\">char</span>*));<br>\t\t\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; child_argc; i++) &#123;<br>\t\t\t\t\tchild_argv[i] = acl_mystrdup(argv_tmp-&gt;argv[i]);<br>\t\t\t\t&#125;<br>\t\t\t\tchild_argv[i] = <span class=\"hljs-literal\">NULL</span>;<br><br>\t\t\t\tacl_argv_free(argv_tmp);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-string\">&#x27;h&#x27;</span>:<br>\t\t\t\tusage(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t\tusage(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;STOP&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，停止某个子进程或所有的子进程</span><br>\t\t<span class=\"hljs-keyword\">if</span> (filepath[<span class=\"hljs-number\">0</span>])<br>\t\t\tacl_proctl_stop_one(argv[<span class=\"hljs-number\">0</span>], filepath, child_argc, child_argv);<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\tacl_proctl_stop_all(argv[<span class=\"hljs-number\">0</span>]);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;START&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (filepath[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tusage(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，启动某个子进程</span><br>\t\tacl_proctl_start_one(argv[<span class=\"hljs-number\">0</span>], filepath, child_argc, child_argv);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;QUIT&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，停止所有的子进程同时守护父进程也退出</span><br>\t\tacl_proctl_quit(argv[<span class=\"hljs-number\">0</span>]);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;LIST&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，列出由守护进程管理的正在运行的所有子进程</span><br>\t\tacl_proctl_list(argv[<span class=\"hljs-number\">0</span>]);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (strcasecmp(cmd, <span class=\"hljs-string\">&quot;PROBE&quot;</span>) == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (filepath[<span class=\"hljs-number\">0</span>] == <span class=\"hljs-number\">0</span>) &#123;<br>\t\t\tusage(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">// 向守护进程发送消息命令，探测某个子进程是否在运行</span><br>\t\tacl_proctl_probe(argv[<span class=\"hljs-number\">0</span>], filepath);<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-comment\">// 父进程以守护进程方式启动</span><br>\t\t<span class=\"hljs-type\">char</span>  buf[MAX_PATH], logfile[MAX_PATH], *ptr;<br><br>\t\t<span class=\"hljs-comment\">// 获得父进程执行程序所在的磁盘路径</span><br>\t\tacl_proctl_daemon_path(buf, <span class=\"hljs-keyword\">sizeof</span>(buf));<br>\t\tptr = <span class=\"hljs-built_in\">strrchr</span>(argv[<span class=\"hljs-number\">0</span>], <span class=\"hljs-string\">&#x27;\\\\&#x27;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\tptr = <span class=\"hljs-built_in\">strrchr</span>(argv[<span class=\"hljs-number\">0</span>], <span class=\"hljs-string\">&#x27;/&#x27;</span>);<br><br>\t\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\tptr = argv[<span class=\"hljs-number\">0</span>];<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\tptr++;<br><br>\t\t<span class=\"hljs-built_in\">snprintf</span>(logfile, <span class=\"hljs-keyword\">sizeof</span>(logfile), <span class=\"hljs-string\">&quot;%s/%s.log&quot;</span>, buf, ptr);<br>\t\t<span class=\"hljs-comment\">// 打开日志文件</span><br>\t\tacl_msg_open(logfile, <span class=\"hljs-string\">&quot;daemon&quot;</span>);<br>\t\t<span class=\"hljs-comment\">// 打开调试信息</span><br>\t\tacl_debug_init(<span class=\"hljs-string\">&quot;all:2&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 以服务器模式启动监控进程</span><br>\t\tacl_proctl_deamon_init(argv[<span class=\"hljs-number\">0</span>]);<br>\t\t<span class=\"hljs-comment\">// 父进程作为守护进程启动</span><br>\t\tacl_proctl_daemon_loop();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">if</span> (child_argv) &#123;<br>\t\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; child_argv[i] != <span class=\"hljs-literal\">NULL</span>; i++) &#123;<br>\t\t\tacl_myfree(child_argv[i]);<br>\t\t&#125;<br>\t\tacl_myfree(child_argv);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2、子进程\"><a href=\"#2-2、子进程\" class=\"headerlink\" title=\"2.2、子进程\"></a>2.2、子进程</h3><p>acl_project\\samples\\proctl\\proctlc.cpp</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// proctlc.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> comment(lib,<span class=\"hljs-string\">&quot;ws2_32&quot;</span>)</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">onexit_fn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg acl_unused)</span><br>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;child exit now\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-type\">int</span> <span class=\"hljs-title function_\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span> *argv[])</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span>   i;<br><br>\tacl_socket_init();<br>\tacl_msg_open(<span class=\"hljs-string\">&quot;debug.txt&quot;</span>, <span class=\"hljs-string\">&quot;proctlc&quot;</span>);<br>\tacl_msg_info(<span class=\"hljs-string\">&quot;&gt;&gt;&gt; in child progname(%s), argc=%d\\r\\n&quot;</span>, argv[<span class=\"hljs-number\">0</span>], argc);<br>\t<span class=\"hljs-keyword\">if</span> (argc &gt; <span class=\"hljs-number\">1</span>)<br>\t\tacl_msg_info(<span class=\"hljs-string\">&quot;&gt;&gt;&gt; in child progname, argv[1]=(%s)\\r\\n&quot;</span>, argv[<span class=\"hljs-number\">1</span>]);<br><br>\t<span class=\"hljs-comment\">// 子进程启动，同时注册自身信息</span><br>\tacl_proctl_child(argv[<span class=\"hljs-number\">0</span>], onexit_fn, <span class=\"hljs-literal\">NULL</span>);<br><br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; argc; i++) &#123;<br>\t\tacl_msg_info(<span class=\"hljs-string\">&quot;&gt;&gt;&gt;argv[%d]:%s\\r\\n&quot;</span>, i, argv[i]);<br>\t&#125;<br><br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\tacl_msg_info(<span class=\"hljs-string\">&quot;i = %d\\r\\n&quot;</span>, i++);<br>\t\t<span class=\"hljs-keyword\">if</span> (i == <span class=\"hljs-number\">5</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t\tsleep(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">-1</span>);  <span class=\"hljs-comment\">// 返回 -1 是为了让父进程继续启动</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3、编译、运行\"><a href=\"#2-3、编译、运行\" class=\"headerlink\" title=\"2.3、编译、运行\"></a>2.3、编译、运行</h3><p>可以打开 acl_project\\win32_build\\vc\\samples\\samples_vc2003.sln，编译其中的 proctlc, proctld 两个工程，便会生成两个可执行文件：proctlc.exe(子进程程序），proctld.exe(父进程程序）。<br>先让父进程以守护进程模式启动 proctld.exe，然后运行 proctld.exe -d START {path}&#x2F;proctlc.exe 通知父进程启动子进程；可以运行 proctld.exe -d LIST 列出当前正在运行的子进程，运行 proctld.exe -d PROBE {path}&#x2F;proctld.exe 判断子进程是否在运行，运行 proctld.exe -d STOP {path}&#x2F;proctld.exe 让守护父进程停止子进程，运行 proctld.exe -d QUID 使守护进程停止所有子进程并自动退出。<br>另外，从子进程的程序可以看出，每隔5秒子进程就会异常退出，则守护进程便会立即重启该子进程，如果子进程死的过于频繁，则守护进程会延迟重启子进程，以防止太过耗费系统资源。</p>\n<h2 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h2><p>因为有守护进程保护，就不必担心子进程（即你的工作进程）异常崩溃了，这种父子进程模型可以应用于大多数工作子进程偶尔异常崩溃的情形，如果你的程序 BUG太多，每一会儿就崩溃好多次，建议你还是先把主要问题解决后再使用父子进程，毕竟如果你的程序太过脆弱，虽然父进程能不断地重启你的程序，但你还是不能为用户提供正常服务。这种模型适用于在WIN32平台下，你的程序可能写得比较复杂，程序基本上是比较健壮的，只是会因偶尔某些原因而异常退出的情况。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"配置文件的读取","date":"2009-11-03T04:43:00.000Z","_content":"\n配置文件的读取是程序中必要部分，虽然不算复杂，但如果每次都写配置文件的分析提取代码也是件烦人的事。现在流行的配置文件格式有：ini，xml ，简单name-value对等格式，ACL库中实现了最简单的 name-value对格式的配置文件，该文件格式有点类似于 xinetd.conf 的格式，文件格式如下：\n\n\ntest.cf:\n\n```\nservice myapp {\n\n    my_addr = 127.0.0.1\n\n    my_port = 80\n\n    my_list = www.test1.com, www.test2.com, www.test3.com, \\\n\n                   www.test4.com, www.test5.com, www.test6.com\n\n    ...\n\n}\n```\n \n\n其中的 \"\\\"  是连接符，可以把折行的数据连接起来。\n\n下面的例子读取该配置文件并进行解析：\n\n```c\nstatic int var_cfg_my_port;\n\nstatic ACL_CFG_INT_TABLE __conf_int_tab[] = {\n  /* 配置项名称, 配置项缺省值, 存储配置项值的地址, 保留字, 保留字 */\n  { \"my_port\", 8080, &var_cfg_my_port, 0, 0 },\n  { 0, 0 , 0, 0, 0 }\n};\n\nstatic char *var_cfg_my_addr;\nstatic char *var_cfg_my_list;\n\nstatic ACL_CFG_STR_TABLE __conf_str_tab[] = {\n  /* 配置项名称, 配置项缺省值, 存储配置项值的地址 */\n  { \"my_addr\", \"192.168.0.1\", &var_cfg_my_addr },\n  { \"my_list\", \"www.test.com\", &var_cfg_my_list },\n  { 0, 0, 0 }\n};\n\nstatic int var_cfg_my_check;\n\nstatic ACL_CFG_BOOL_TABLE __conf_bool_tab[] = {\n  /* 配置项名称, 配置项缺省值, 存储配置项值的地址 */\n  { \"my_check\", 0, &var_cfg_my_check },\n  { 0, 0, 0 }\n};\n\nvoid test(void)\n{\n  ACL_XINETD_CFG_PARSER *cfg;  // 配置解析对象\n\n  cfg = acl_xinetd_cfg_load(\"test.cf\");  // 读取并解析配置文件\n  acl_xinetd_params_int_table(cfg, __conf_int_tab);  // 读取所有 int 类型的配置项\n  acl_xinetd_params_str_table(cfg, __conf_str_tab);  // 读取所有字符串类型的配置项\n  acl_xinetd_params_bool_table(cfg, __conf_bool_tab);  // 读取所有 bool 型的配置项\n\n  acl_xinetd_cfg_free(cfg);  // 释放内存\n}\n```\n通过调用 acl_xinetd_params_xxx_table() 函数，直接将配置项的值赋给变量，这样省去了很多麻烦。","source":"_posts/configure.md","raw":"---\ntitle: 配置文件的读取\ndate: 2009-11-03 12:43\ncategories: 配置文件\n---\n\n配置文件的读取是程序中必要部分，虽然不算复杂，但如果每次都写配置文件的分析提取代码也是件烦人的事。现在流行的配置文件格式有：ini，xml ，简单name-value对等格式，ACL库中实现了最简单的 name-value对格式的配置文件，该文件格式有点类似于 xinetd.conf 的格式，文件格式如下：\n\n\ntest.cf:\n\n```\nservice myapp {\n\n    my_addr = 127.0.0.1\n\n    my_port = 80\n\n    my_list = www.test1.com, www.test2.com, www.test3.com, \\\n\n                   www.test4.com, www.test5.com, www.test6.com\n\n    ...\n\n}\n```\n \n\n其中的 \"\\\"  是连接符，可以把折行的数据连接起来。\n\n下面的例子读取该配置文件并进行解析：\n\n```c\nstatic int var_cfg_my_port;\n\nstatic ACL_CFG_INT_TABLE __conf_int_tab[] = {\n  /* 配置项名称, 配置项缺省值, 存储配置项值的地址, 保留字, 保留字 */\n  { \"my_port\", 8080, &var_cfg_my_port, 0, 0 },\n  { 0, 0 , 0, 0, 0 }\n};\n\nstatic char *var_cfg_my_addr;\nstatic char *var_cfg_my_list;\n\nstatic ACL_CFG_STR_TABLE __conf_str_tab[] = {\n  /* 配置项名称, 配置项缺省值, 存储配置项值的地址 */\n  { \"my_addr\", \"192.168.0.1\", &var_cfg_my_addr },\n  { \"my_list\", \"www.test.com\", &var_cfg_my_list },\n  { 0, 0, 0 }\n};\n\nstatic int var_cfg_my_check;\n\nstatic ACL_CFG_BOOL_TABLE __conf_bool_tab[] = {\n  /* 配置项名称, 配置项缺省值, 存储配置项值的地址 */\n  { \"my_check\", 0, &var_cfg_my_check },\n  { 0, 0, 0 }\n};\n\nvoid test(void)\n{\n  ACL_XINETD_CFG_PARSER *cfg;  // 配置解析对象\n\n  cfg = acl_xinetd_cfg_load(\"test.cf\");  // 读取并解析配置文件\n  acl_xinetd_params_int_table(cfg, __conf_int_tab);  // 读取所有 int 类型的配置项\n  acl_xinetd_params_str_table(cfg, __conf_str_tab);  // 读取所有字符串类型的配置项\n  acl_xinetd_params_bool_table(cfg, __conf_bool_tab);  // 读取所有 bool 型的配置项\n\n  acl_xinetd_cfg_free(cfg);  // 释放内存\n}\n```\n通过调用 acl_xinetd_params_xxx_table() 函数，直接将配置项的值赋给变量，这样省去了很多麻烦。","slug":"configure","published":1,"updated":"2023-01-24T05:10:34.103Z","_id":"cld9s2kme000929fy27ah3g38","comments":1,"layout":"post","photos":[],"link":"","content":"<p>配置文件的读取是程序中必要部分，虽然不算复杂，但如果每次都写配置文件的分析提取代码也是件烦人的事。现在流行的配置文件格式有：ini，xml ，简单name-value对等格式，ACL库中实现了最简单的 name-value对格式的配置文件，该文件格式有点类似于 xinetd.conf 的格式，文件格式如下：</p>\n<p>test.cf:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">service myapp &#123;<br><br>    my_addr = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br><br>    my_port = <span class=\"hljs-number\">80</span><br><br>    my_list = www<span class=\"hljs-selector-class\">.test1</span><span class=\"hljs-selector-class\">.com</span>, www<span class=\"hljs-selector-class\">.test2</span><span class=\"hljs-selector-class\">.com</span>, www<span class=\"hljs-selector-class\">.test3</span><span class=\"hljs-selector-class\">.com</span>, \\<br><br>                   www<span class=\"hljs-selector-class\">.test4</span><span class=\"hljs-selector-class\">.com</span>, www<span class=\"hljs-selector-class\">.test5</span><span class=\"hljs-selector-class\">.com</span>, www<span class=\"hljs-selector-class\">.test6</span><span class=\"hljs-selector-class\">.com</span><br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其中的 “&quot;  是连接符，可以把折行的数据连接起来。</p>\n<p>下面的例子读取该配置文件并进行解析：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> var_cfg_my_port;<br><br><span class=\"hljs-type\">static</span> ACL_CFG_INT_TABLE __conf_int_tab[] = &#123;<br>  <span class=\"hljs-comment\">/* 配置项名称, 配置项缺省值, 存储配置项值的地址, 保留字, 保留字 */</span><br>  &#123; <span class=\"hljs-string\">&quot;my_port&quot;</span>, <span class=\"hljs-number\">8080</span>, &amp;var_cfg_my_port, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;,<br>  &#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_my_addr;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_my_list;<br><br><span class=\"hljs-type\">static</span> ACL_CFG_STR_TABLE __conf_str_tab[] = &#123;<br>  <span class=\"hljs-comment\">/* 配置项名称, 配置项缺省值, 存储配置项值的地址 */</span><br>  &#123; <span class=\"hljs-string\">&quot;my_addr&quot;</span>, <span class=\"hljs-string\">&quot;192.168.0.1&quot;</span>, &amp;var_cfg_my_addr &#125;,<br>  &#123; <span class=\"hljs-string\">&quot;my_list&quot;</span>, <span class=\"hljs-string\">&quot;www.test.com&quot;</span>, &amp;var_cfg_my_list &#125;,<br>  &#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> var_cfg_my_check;<br><br><span class=\"hljs-type\">static</span> ACL_CFG_BOOL_TABLE __conf_bool_tab[] = &#123;<br>  <span class=\"hljs-comment\">/* 配置项名称, 配置项缺省值, 存储配置项值的地址 */</span><br>  &#123; <span class=\"hljs-string\">&quot;my_check&quot;</span>, <span class=\"hljs-number\">0</span>, &amp;var_cfg_my_check &#125;,<br>  &#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>  ACL_XINETD_CFG_PARSER *cfg;  <span class=\"hljs-comment\">// 配置解析对象</span><br><br>  cfg = acl_xinetd_cfg_load(<span class=\"hljs-string\">&quot;test.cf&quot;</span>);  <span class=\"hljs-comment\">// 读取并解析配置文件</span><br>  acl_xinetd_params_int_table(cfg, __conf_int_tab);  <span class=\"hljs-comment\">// 读取所有 int 类型的配置项</span><br>  acl_xinetd_params_str_table(cfg, __conf_str_tab);  <span class=\"hljs-comment\">// 读取所有字符串类型的配置项</span><br>  acl_xinetd_params_bool_table(cfg, __conf_bool_tab);  <span class=\"hljs-comment\">// 读取所有 bool 型的配置项</span><br><br>  acl_xinetd_cfg_free(cfg);  <span class=\"hljs-comment\">// 释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通过调用 acl_xinetd_params_xxx_table() 函数，直接将配置项的值赋给变量，这样省去了很多麻烦。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>配置文件的读取是程序中必要部分，虽然不算复杂，但如果每次都写配置文件的分析提取代码也是件烦人的事。现在流行的配置文件格式有：ini，xml ，简单name-value对等格式，ACL库中实现了最简单的 name-value对格式的配置文件，该文件格式有点类似于 xinetd.conf 的格式，文件格式如下：</p>\n<p>test.cf:</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">service myapp &#123;<br><br>    my_addr = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br><br>    my_port = <span class=\"hljs-number\">80</span><br><br>    my_list = www<span class=\"hljs-selector-class\">.test1</span><span class=\"hljs-selector-class\">.com</span>, www<span class=\"hljs-selector-class\">.test2</span><span class=\"hljs-selector-class\">.com</span>, www<span class=\"hljs-selector-class\">.test3</span><span class=\"hljs-selector-class\">.com</span>, \\<br><br>                   www<span class=\"hljs-selector-class\">.test4</span><span class=\"hljs-selector-class\">.com</span>, www<span class=\"hljs-selector-class\">.test5</span><span class=\"hljs-selector-class\">.com</span>, www<span class=\"hljs-selector-class\">.test6</span><span class=\"hljs-selector-class\">.com</span><br><br>    ...<br><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>其中的 “&quot;  是连接符，可以把折行的数据连接起来。</p>\n<p>下面的例子读取该配置文件并进行解析：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> var_cfg_my_port;<br><br><span class=\"hljs-type\">static</span> ACL_CFG_INT_TABLE __conf_int_tab[] = &#123;<br>  <span class=\"hljs-comment\">/* 配置项名称, 配置项缺省值, 存储配置项值的地址, 保留字, 保留字 */</span><br>  &#123; <span class=\"hljs-string\">&quot;my_port&quot;</span>, <span class=\"hljs-number\">8080</span>, &amp;var_cfg_my_port, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;,<br>  &#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_my_addr;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_my_list;<br><br><span class=\"hljs-type\">static</span> ACL_CFG_STR_TABLE __conf_str_tab[] = &#123;<br>  <span class=\"hljs-comment\">/* 配置项名称, 配置项缺省值, 存储配置项值的地址 */</span><br>  &#123; <span class=\"hljs-string\">&quot;my_addr&quot;</span>, <span class=\"hljs-string\">&quot;192.168.0.1&quot;</span>, &amp;var_cfg_my_addr &#125;,<br>  &#123; <span class=\"hljs-string\">&quot;my_list&quot;</span>, <span class=\"hljs-string\">&quot;www.test.com&quot;</span>, &amp;var_cfg_my_list &#125;,<br>  &#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> var_cfg_my_check;<br><br><span class=\"hljs-type\">static</span> ACL_CFG_BOOL_TABLE __conf_bool_tab[] = &#123;<br>  <span class=\"hljs-comment\">/* 配置项名称, 配置项缺省值, 存储配置项值的地址 */</span><br>  &#123; <span class=\"hljs-string\">&quot;my_check&quot;</span>, <span class=\"hljs-number\">0</span>, &amp;var_cfg_my_check &#125;,<br>  &#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>  ACL_XINETD_CFG_PARSER *cfg;  <span class=\"hljs-comment\">// 配置解析对象</span><br><br>  cfg = acl_xinetd_cfg_load(<span class=\"hljs-string\">&quot;test.cf&quot;</span>);  <span class=\"hljs-comment\">// 读取并解析配置文件</span><br>  acl_xinetd_params_int_table(cfg, __conf_int_tab);  <span class=\"hljs-comment\">// 读取所有 int 类型的配置项</span><br>  acl_xinetd_params_str_table(cfg, __conf_str_tab);  <span class=\"hljs-comment\">// 读取所有字符串类型的配置项</span><br>  acl_xinetd_params_bool_table(cfg, __conf_bool_tab);  <span class=\"hljs-comment\">// 读取所有 bool 型的配置项</span><br><br>  acl_xinetd_cfg_free(cfg);  <span class=\"hljs-comment\">// 释放内存</span><br>&#125;<br></code></pre></td></tr></table></figure>\n<p>通过调用 acl_xinetd_params_xxx_table() 函数，直接将配置项的值赋给变量，这样省去了很多麻烦。</p>\n"},{"title":"使用 acl 服务器框架编写负载均衡的应用服务","date":"2014-09-20T14:33:00.000Z","_content":"\nacl 服务器框架的几种服务器模型（进程模型，多线程模型，非阻塞模型，协程模型，触发器模型，UDP通信模型）中，使用比较多的是多线程模型、协程模块及非阻塞模型，这三种模型可以配置成启动多个进程实例（即成为：多进程多线程、多进程多协程及多进程非阻塞），但在实际应用中因为系统 TCP 连接分配的不均匀性，会导致每个进程实例的 TCP 连接数极不均匀甚至相差很大的问题（便出现了有的进程“撑死”，有的进程“饿死“的现象），acl 服务器框架提供了一个 TCP 连接分配器，该分配器负责接收外来 TCP 连接，然后将该 TCP 连接的文件句柄通过 UNIX 域套接字”平均传递给“后端的每一个子进程，从而保证了应用服务器进程池中的每个进程实例都能获得相等数量的 TCP 连接，从而达到负载均衡的目的。\n![server_loadbalance](/img/loadbalance.png)\n如上图所示，整个网络连接处理过程如下：\n\n- 在 acl_master 服务器框架下启动两个服务：TCP连接分配器和应用服务进程\n- TCP 连接分配器监听两个地址：一个是网络地址（如：192.168.188.1:80)和一个本机的 UNIX 域套接字（如：/opt/acl/var/private/dispatch.sock）\n\n  注：acl 服务器框架支持同时监听多个网络地址或 UNIX 域套口地址，参见：使用 acl 服务器框架编写监听多个地址的服务器程序\n- 应用服务的每个进程通过该 UNIX 域套接口连接 TCP 连接分配器：\n  - 通过该连接向TCP连接分配器报告自己当前的 TCP 连接数\n  - 在该UNIX套接口接收TCP连接分配器发送的客户端TCP连接的套接字句柄\n\n- 客户端通过网络连接 TCP 连接分配器监听的网络地址\n- TCP 连接分配器从后端进程池中选取一个连接数最少的进程，并通过与该进程的 UNIX 套接字将客户端的 TCP 连接句柄传递给该进程\n- 后端获得 TCP 连接分配器传递来的 TCP 连接句柄，从而与前端客户端建立联系，开始处理客户端的请求。\n\n通过以上处理流程，就可以保证客户端连接可以均匀地分配给后端服务进程池中的每一个进程实例，这样，每个进程实例占用的系统资源（如：CPU、内存、IO 等）就相对比较均匀。\n\n在 UNIX/LINUX 平台下，通过 UNIX 域套接字传递描述字过程是由内核完成的，应用层只需负责相关的系统 API 调用即可，如何使用系统 API 传递描述字可以参考 acl 库中的 lib_acl/src/stdlib/sys/unix/acl_transfer_fd.c 源文件。\n\n另外，上面所提的 TCP 连接分配器是使用 acl 服务器框架中的非阻塞服务模型编写的一个服务器程序，具体实现在 app/master_dispatch/server 目录下；应用服务器程序可以使用 acl 服务器框架中的线程池模型或非阻塞模型编写。\n\n在部署时，需要将 TCP 连接分配器(app/master_dispatch/server/master_dispatch) 及用户自己写的服务器程序拷贝到执行目录下，在应用自己的服务器程序中需要将配置文件中的域接口连接地址打开（对于线程池模型需要打开 ioctl_dispatch_addr 配置项，对于非阻塞模型需要打开 aio_dispatch_addr 配置项）","source":"_posts/server_loadbalance.md","raw":"---\ntitle: 使用 acl 服务器框架编写负载均衡的应用服务\ndate: 2014-09-20 22:33\ncategories: 服务编程\n---\n\nacl 服务器框架的几种服务器模型（进程模型，多线程模型，非阻塞模型，协程模型，触发器模型，UDP通信模型）中，使用比较多的是多线程模型、协程模块及非阻塞模型，这三种模型可以配置成启动多个进程实例（即成为：多进程多线程、多进程多协程及多进程非阻塞），但在实际应用中因为系统 TCP 连接分配的不均匀性，会导致每个进程实例的 TCP 连接数极不均匀甚至相差很大的问题（便出现了有的进程“撑死”，有的进程“饿死“的现象），acl 服务器框架提供了一个 TCP 连接分配器，该分配器负责接收外来 TCP 连接，然后将该 TCP 连接的文件句柄通过 UNIX 域套接字”平均传递给“后端的每一个子进程，从而保证了应用服务器进程池中的每个进程实例都能获得相等数量的 TCP 连接，从而达到负载均衡的目的。\n![server_loadbalance](/img/loadbalance.png)\n如上图所示，整个网络连接处理过程如下：\n\n- 在 acl_master 服务器框架下启动两个服务：TCP连接分配器和应用服务进程\n- TCP 连接分配器监听两个地址：一个是网络地址（如：192.168.188.1:80)和一个本机的 UNIX 域套接字（如：/opt/acl/var/private/dispatch.sock）\n\n  注：acl 服务器框架支持同时监听多个网络地址或 UNIX 域套口地址，参见：使用 acl 服务器框架编写监听多个地址的服务器程序\n- 应用服务的每个进程通过该 UNIX 域套接口连接 TCP 连接分配器：\n  - 通过该连接向TCP连接分配器报告自己当前的 TCP 连接数\n  - 在该UNIX套接口接收TCP连接分配器发送的客户端TCP连接的套接字句柄\n\n- 客户端通过网络连接 TCP 连接分配器监听的网络地址\n- TCP 连接分配器从后端进程池中选取一个连接数最少的进程，并通过与该进程的 UNIX 套接字将客户端的 TCP 连接句柄传递给该进程\n- 后端获得 TCP 连接分配器传递来的 TCP 连接句柄，从而与前端客户端建立联系，开始处理客户端的请求。\n\n通过以上处理流程，就可以保证客户端连接可以均匀地分配给后端服务进程池中的每一个进程实例，这样，每个进程实例占用的系统资源（如：CPU、内存、IO 等）就相对比较均匀。\n\n在 UNIX/LINUX 平台下，通过 UNIX 域套接字传递描述字过程是由内核完成的，应用层只需负责相关的系统 API 调用即可，如何使用系统 API 传递描述字可以参考 acl 库中的 lib_acl/src/stdlib/sys/unix/acl_transfer_fd.c 源文件。\n\n另外，上面所提的 TCP 连接分配器是使用 acl 服务器框架中的非阻塞服务模型编写的一个服务器程序，具体实现在 app/master_dispatch/server 目录下；应用服务器程序可以使用 acl 服务器框架中的线程池模型或非阻塞模型编写。\n\n在部署时，需要将 TCP 连接分配器(app/master_dispatch/server/master_dispatch) 及用户自己写的服务器程序拷贝到执行目录下，在应用自己的服务器程序中需要将配置文件中的域接口连接地址打开（对于线程池模型需要打开 ioctl_dispatch_addr 配置项，对于非阻塞模型需要打开 aio_dispatch_addr 配置项）","slug":"server_loadbalance","published":1,"updated":"2023-01-24T06:10:42.187Z","_id":"cld9s983y000c29fy5dpxa2a5","comments":1,"layout":"post","photos":[],"link":"","content":"<p>acl 服务器框架的几种服务器模型（进程模型，多线程模型，非阻塞模型，协程模型，触发器模型，UDP通信模型）中，使用比较多的是多线程模型、协程模块及非阻塞模型，这三种模型可以配置成启动多个进程实例（即成为：多进程多线程、多进程多协程及多进程非阻塞），但在实际应用中因为系统 TCP 连接分配的不均匀性，会导致每个进程实例的 TCP 连接数极不均匀甚至相差很大的问题（便出现了有的进程“撑死”，有的进程“饿死“的现象），acl 服务器框架提供了一个 TCP 连接分配器，该分配器负责接收外来 TCP 连接，然后将该 TCP 连接的文件句柄通过 UNIX 域套接字”平均传递给“后端的每一个子进程，从而保证了应用服务器进程池中的每个进程实例都能获得相等数量的 TCP 连接，从而达到负载均衡的目的。<br><img src=\"/img/loadbalance.png\" alt=\"server_loadbalance\"><br>如上图所示，整个网络连接处理过程如下：</p>\n<ul>\n<li><p>在 acl_master 服务器框架下启动两个服务：TCP连接分配器和应用服务进程</p>\n</li>\n<li><p>TCP 连接分配器监听两个地址：一个是网络地址（如：192.168.188.1:80)和一个本机的 UNIX 域套接字（如：&#x2F;opt&#x2F;acl&#x2F;var&#x2F;private&#x2F;dispatch.sock）</p>\n<p>注：acl 服务器框架支持同时监听多个网络地址或 UNIX 域套口地址，参见：使用 acl 服务器框架编写监听多个地址的服务器程序</p>\n</li>\n<li><p>应用服务的每个进程通过该 UNIX 域套接口连接 TCP 连接分配器：</p>\n<ul>\n<li>通过该连接向TCP连接分配器报告自己当前的 TCP 连接数</li>\n<li>在该UNIX套接口接收TCP连接分配器发送的客户端TCP连接的套接字句柄</li>\n</ul>\n</li>\n<li><p>客户端通过网络连接 TCP 连接分配器监听的网络地址</p>\n</li>\n<li><p>TCP 连接分配器从后端进程池中选取一个连接数最少的进程，并通过与该进程的 UNIX 套接字将客户端的 TCP 连接句柄传递给该进程</p>\n</li>\n<li><p>后端获得 TCP 连接分配器传递来的 TCP 连接句柄，从而与前端客户端建立联系，开始处理客户端的请求。</p>\n</li>\n</ul>\n<p>通过以上处理流程，就可以保证客户端连接可以均匀地分配给后端服务进程池中的每一个进程实例，这样，每个进程实例占用的系统资源（如：CPU、内存、IO 等）就相对比较均匀。</p>\n<p>在 UNIX&#x2F;LINUX 平台下，通过 UNIX 域套接字传递描述字过程是由内核完成的，应用层只需负责相关的系统 API 调用即可，如何使用系统 API 传递描述字可以参考 acl 库中的 lib_acl&#x2F;src&#x2F;stdlib&#x2F;sys&#x2F;unix&#x2F;acl_transfer_fd.c 源文件。</p>\n<p>另外，上面所提的 TCP 连接分配器是使用 acl 服务器框架中的非阻塞服务模型编写的一个服务器程序，具体实现在 app&#x2F;master_dispatch&#x2F;server 目录下；应用服务器程序可以使用 acl 服务器框架中的线程池模型或非阻塞模型编写。</p>\n<p>在部署时，需要将 TCP 连接分配器(app&#x2F;master_dispatch&#x2F;server&#x2F;master_dispatch) 及用户自己写的服务器程序拷贝到执行目录下，在应用自己的服务器程序中需要将配置文件中的域接口连接地址打开（对于线程池模型需要打开 ioctl_dispatch_addr 配置项，对于非阻塞模型需要打开 aio_dispatch_addr 配置项）</p>\n","site":{"data":{}},"excerpt":"","more":"<p>acl 服务器框架的几种服务器模型（进程模型，多线程模型，非阻塞模型，协程模型，触发器模型，UDP通信模型）中，使用比较多的是多线程模型、协程模块及非阻塞模型，这三种模型可以配置成启动多个进程实例（即成为：多进程多线程、多进程多协程及多进程非阻塞），但在实际应用中因为系统 TCP 连接分配的不均匀性，会导致每个进程实例的 TCP 连接数极不均匀甚至相差很大的问题（便出现了有的进程“撑死”，有的进程“饿死“的现象），acl 服务器框架提供了一个 TCP 连接分配器，该分配器负责接收外来 TCP 连接，然后将该 TCP 连接的文件句柄通过 UNIX 域套接字”平均传递给“后端的每一个子进程，从而保证了应用服务器进程池中的每个进程实例都能获得相等数量的 TCP 连接，从而达到负载均衡的目的。<br><img src=\"/img/loadbalance.png\" alt=\"server_loadbalance\"><br>如上图所示，整个网络连接处理过程如下：</p>\n<ul>\n<li><p>在 acl_master 服务器框架下启动两个服务：TCP连接分配器和应用服务进程</p>\n</li>\n<li><p>TCP 连接分配器监听两个地址：一个是网络地址（如：192.168.188.1:80)和一个本机的 UNIX 域套接字（如：&#x2F;opt&#x2F;acl&#x2F;var&#x2F;private&#x2F;dispatch.sock）</p>\n<p>注：acl 服务器框架支持同时监听多个网络地址或 UNIX 域套口地址，参见：使用 acl 服务器框架编写监听多个地址的服务器程序</p>\n</li>\n<li><p>应用服务的每个进程通过该 UNIX 域套接口连接 TCP 连接分配器：</p>\n<ul>\n<li>通过该连接向TCP连接分配器报告自己当前的 TCP 连接数</li>\n<li>在该UNIX套接口接收TCP连接分配器发送的客户端TCP连接的套接字句柄</li>\n</ul>\n</li>\n<li><p>客户端通过网络连接 TCP 连接分配器监听的网络地址</p>\n</li>\n<li><p>TCP 连接分配器从后端进程池中选取一个连接数最少的进程，并通过与该进程的 UNIX 套接字将客户端的 TCP 连接句柄传递给该进程</p>\n</li>\n<li><p>后端获得 TCP 连接分配器传递来的 TCP 连接句柄，从而与前端客户端建立联系，开始处理客户端的请求。</p>\n</li>\n</ul>\n<p>通过以上处理流程，就可以保证客户端连接可以均匀地分配给后端服务进程池中的每一个进程实例，这样，每个进程实例占用的系统资源（如：CPU、内存、IO 等）就相对比较均匀。</p>\n<p>在 UNIX&#x2F;LINUX 平台下，通过 UNIX 域套接字传递描述字过程是由内核完成的，应用层只需负责相关的系统 API 调用即可，如何使用系统 API 传递描述字可以参考 acl 库中的 lib_acl&#x2F;src&#x2F;stdlib&#x2F;sys&#x2F;unix&#x2F;acl_transfer_fd.c 源文件。</p>\n<p>另外，上面所提的 TCP 连接分配器是使用 acl 服务器框架中的非阻塞服务模型编写的一个服务器程序，具体实现在 app&#x2F;master_dispatch&#x2F;server 目录下；应用服务器程序可以使用 acl 服务器框架中的线程池模型或非阻塞模型编写。</p>\n<p>在部署时，需要将 TCP 连接分配器(app&#x2F;master_dispatch&#x2F;server&#x2F;master_dispatch) 及用户自己写的服务器程序拷贝到执行目录下，在应用自己的服务器程序中需要将配置文件中的域接口连接地址打开（对于线程池模型需要打开 ioctl_dispatch_addr 配置项，对于非阻塞模型需要打开 aio_dispatch_addr 配置项）</p>\n"},{"title":"使用 acl 库开发简单的客户端与服务器程序","date":"2014-05-18T15:25:00.000Z","_content":"\nacl 的 C++ 库部分也提供了一些简单的服务器类，本文将介绍如何使用这些简单的类来实现一些服务器程序和网络客户端程序。\n\n首先介绍 acl 中的服务器类：server_socket。该类定义了如下几个简单方法：\n \n```c++\n\t/**\n\t * 开始监听给定服务端地址\n\t * @param addr {const char*} 服务器监听地址，格式为：\n\t *  ip:port；在 unix 环境下，还可以是域套接口，格式为：\n\t *   /path/xxx\n\t * @return {bool} 监听是否成功\n\t */\n\tbool open(const char* addr);\n\n\t/**\n\t * 关闭已经打开的监听套接口\n\t * @return {bool} 是否正常关闭\n\t */\n\tbool close();\n\n\t/**\n\t * 接收客户端连接并创建客户端连接流\n\t * @param timeout {int} 在阻塞模式下，当该值 > 0 时，采用超时\n\t *  方式接收客户端连接，若在指定时间内未获得客户端连接，则返回 NULL\n\t * @return {socket_stream*} 返回空表示接收失败\n\t */\n\tsocket_stream* accept(int timeout = 0);\n\n\t/**\n\t * 获得监听的地址\n\t * @return {const char*} 返回值非空指针\n\t */\n\tconst char* get_addr() const\n\t{\n\t\treturn addr_;\n\t}\n```\n\n使用上述网络服务类的步骤是：调用 open 监听本机的一个网络地址（如果是UNIX平台，还可以监听UNIX域套接口）------> 调用 accept 方法等待远程客户端连接本服务器 ------> 当服务器程序接收到客户端连接时 accept 方法返回客户端连接网络流(socket_stream) ------> 启动一个线程处理这个客户端连接。下面为一个简单的服务器程序：\n\n \n```c++\n#include \"acl_cpp/lib_acl.hpp\"\n\n// 处理客户端连接的线程类\nclass client_thread : public acl::thread\n{\npublic:\n\tclient_thread(acl::socket_stream* client)\n\t: client_(client)\n\t{\n\t}\n\n\t~client_thread()\n\t{\n\t\tdelete client_;\n\t}\n\nprotected:\n\t// 实现基类 acl::thread 中定义的纯虚方法\n\tvoid* run()\n\t{\n\t\tacl::string buf;\n\t\twhile (true)\n\t\t{\n\t\t\t// 从客户端连接读一行数据，第二个参数为 false 意思是希望\n\t\t\t// socket_stream 在读到一行数据时保留 \\r\\n\n\t\t\tif (client_->gets(buf, false) == false)\n\t\t\t\treturn NULL;\n\n\t\t\tprintf(\"gets one line: %s\", buf.c_str());\n\n\t\t\t// 回写所读到的一行数据\n\t\t\tif (client_->write(buf) == -1)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\nprivate:\n\tacl::socket_stream* client_;\n};\n\nint main(void)\n{\n\tconst char* addr = \"0.0.0.0:8080\";\n\tacl::socket_server server;\n\n\t// 监听本机网络地址\n\tif (server.open(addr) == false)\n\t{\n\t\tprintf(\"listen addr: %s error: %s\\r\\n\", addr, acl::last_serror());\n\t\treturn -1\n\t}\n\n\twhile (true)\n\t{\n\t\t// 等待客户端连接本服务器程序\n\t\tacl::socket_stream* client = server.accept();\n\t\tif (client == NULL)\n\t\t{\n\t\t\tprintf(\"accept error: %s\\r\\n\", acl::last_serror());\n\t\t\treturn -1;\n\t\t}\n\n\t\t// 创建一个子线程用来处理该客户端连接\n\t\tclient_thread* thread = new client_thread(client);\n\n\t\t// 将线程设为分离模式，这样当线程退出时会自行释放线程相关资源\n\t\tthread->set_detachable(true);\n\n\t\t// 启动该线程\n\t\tthread->start();\n\t}\n\n\treturn 0;\n}\n```\n\n上面例子非常简单，毋庸详述，关于如何使用 acl 编写多线程程序，请参照：使用 acl_cpp 库编写多线程程序。下面再给出一个简单的网络客户端例子：\n\n```c++\n#include \"acl_cpp/lib_acl.hpp\"\n\nint main(void)\n{\n\tconst char* server_addr = \"127.0.0.1:8080\";\n\tint   conn_timeout = 10 /* 连接服务器超时时间，单位：秒 */\n\tint   rw_timeout = 10 /* 网络 IO 超时时间，单位：秒 */;\n\tacl::socket_stream conn;\n\n\t// 连接远程服务器\n\tif (conn.open(server_addr, conn_timeout, rw_timeout) == false)\n\t{\n\t\tprintf(\"connect server: %s error: %s\\r\\n\",\n\t\t\tserver_addr, acl::last_serror());\n\t\treturn -1;\n\t}\n\n\tconst char* req = \"hello world!\\r\\n\";\n\n\tacl::string buf;\n\n\t// 向服务器写一行数据，同时从服务器读一行数据，循环 10 次\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\t// 向服务器发送一行数据\n\t\tif (conn.write(req, strlen(req)) == -1)\n\t\t{\n\t\t\tprintf(\"write request to server error: %s\\r\\n\",\n\t\t\t\tacl::last_serror());\n\t\t\treturn -1;\n\t\t}\n\n\t\t// 从服务器读一行数据，注：第二个参数为默认的 true，意思是获得\n\t\t// 一行数据后自动将尾部的 \\r\\n 去掉\n\t\tif (conn.gets(buf) == false)\n\t\t{\n\t\t\tprintf(\"gets one line from server error: %s\\r\\n\",\n\t\t\t\tacl::last_serror();\n\t\t\treturn -1;\n\t\t}\n\n\t\tprintf(\"response: %s\\r\\n\", buf.c_str());\n\t}\n\n\treturn 0;\n}\n``` \n","source":"_posts/network_simple.md","raw":"---\ntitle: 使用 acl 库开发简单的客户端与服务器程序\ndate: 2014-05-18 23:25\ncategories: 网络编程\n---\n\nacl 的 C++ 库部分也提供了一些简单的服务器类，本文将介绍如何使用这些简单的类来实现一些服务器程序和网络客户端程序。\n\n首先介绍 acl 中的服务器类：server_socket。该类定义了如下几个简单方法：\n \n```c++\n\t/**\n\t * 开始监听给定服务端地址\n\t * @param addr {const char*} 服务器监听地址，格式为：\n\t *  ip:port；在 unix 环境下，还可以是域套接口，格式为：\n\t *   /path/xxx\n\t * @return {bool} 监听是否成功\n\t */\n\tbool open(const char* addr);\n\n\t/**\n\t * 关闭已经打开的监听套接口\n\t * @return {bool} 是否正常关闭\n\t */\n\tbool close();\n\n\t/**\n\t * 接收客户端连接并创建客户端连接流\n\t * @param timeout {int} 在阻塞模式下，当该值 > 0 时，采用超时\n\t *  方式接收客户端连接，若在指定时间内未获得客户端连接，则返回 NULL\n\t * @return {socket_stream*} 返回空表示接收失败\n\t */\n\tsocket_stream* accept(int timeout = 0);\n\n\t/**\n\t * 获得监听的地址\n\t * @return {const char*} 返回值非空指针\n\t */\n\tconst char* get_addr() const\n\t{\n\t\treturn addr_;\n\t}\n```\n\n使用上述网络服务类的步骤是：调用 open 监听本机的一个网络地址（如果是UNIX平台，还可以监听UNIX域套接口）------> 调用 accept 方法等待远程客户端连接本服务器 ------> 当服务器程序接收到客户端连接时 accept 方法返回客户端连接网络流(socket_stream) ------> 启动一个线程处理这个客户端连接。下面为一个简单的服务器程序：\n\n \n```c++\n#include \"acl_cpp/lib_acl.hpp\"\n\n// 处理客户端连接的线程类\nclass client_thread : public acl::thread\n{\npublic:\n\tclient_thread(acl::socket_stream* client)\n\t: client_(client)\n\t{\n\t}\n\n\t~client_thread()\n\t{\n\t\tdelete client_;\n\t}\n\nprotected:\n\t// 实现基类 acl::thread 中定义的纯虚方法\n\tvoid* run()\n\t{\n\t\tacl::string buf;\n\t\twhile (true)\n\t\t{\n\t\t\t// 从客户端连接读一行数据，第二个参数为 false 意思是希望\n\t\t\t// socket_stream 在读到一行数据时保留 \\r\\n\n\t\t\tif (client_->gets(buf, false) == false)\n\t\t\t\treturn NULL;\n\n\t\t\tprintf(\"gets one line: %s\", buf.c_str());\n\n\t\t\t// 回写所读到的一行数据\n\t\t\tif (client_->write(buf) == -1)\n\t\t\t\treturn NULL;\n\t\t}\n\t}\n\nprivate:\n\tacl::socket_stream* client_;\n};\n\nint main(void)\n{\n\tconst char* addr = \"0.0.0.0:8080\";\n\tacl::socket_server server;\n\n\t// 监听本机网络地址\n\tif (server.open(addr) == false)\n\t{\n\t\tprintf(\"listen addr: %s error: %s\\r\\n\", addr, acl::last_serror());\n\t\treturn -1\n\t}\n\n\twhile (true)\n\t{\n\t\t// 等待客户端连接本服务器程序\n\t\tacl::socket_stream* client = server.accept();\n\t\tif (client == NULL)\n\t\t{\n\t\t\tprintf(\"accept error: %s\\r\\n\", acl::last_serror());\n\t\t\treturn -1;\n\t\t}\n\n\t\t// 创建一个子线程用来处理该客户端连接\n\t\tclient_thread* thread = new client_thread(client);\n\n\t\t// 将线程设为分离模式，这样当线程退出时会自行释放线程相关资源\n\t\tthread->set_detachable(true);\n\n\t\t// 启动该线程\n\t\tthread->start();\n\t}\n\n\treturn 0;\n}\n```\n\n上面例子非常简单，毋庸详述，关于如何使用 acl 编写多线程程序，请参照：使用 acl_cpp 库编写多线程程序。下面再给出一个简单的网络客户端例子：\n\n```c++\n#include \"acl_cpp/lib_acl.hpp\"\n\nint main(void)\n{\n\tconst char* server_addr = \"127.0.0.1:8080\";\n\tint   conn_timeout = 10 /* 连接服务器超时时间，单位：秒 */\n\tint   rw_timeout = 10 /* 网络 IO 超时时间，单位：秒 */;\n\tacl::socket_stream conn;\n\n\t// 连接远程服务器\n\tif (conn.open(server_addr, conn_timeout, rw_timeout) == false)\n\t{\n\t\tprintf(\"connect server: %s error: %s\\r\\n\",\n\t\t\tserver_addr, acl::last_serror());\n\t\treturn -1;\n\t}\n\n\tconst char* req = \"hello world!\\r\\n\";\n\n\tacl::string buf;\n\n\t// 向服务器写一行数据，同时从服务器读一行数据，循环 10 次\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\t// 向服务器发送一行数据\n\t\tif (conn.write(req, strlen(req)) == -1)\n\t\t{\n\t\t\tprintf(\"write request to server error: %s\\r\\n\",\n\t\t\t\tacl::last_serror());\n\t\t\treturn -1;\n\t\t}\n\n\t\t// 从服务器读一行数据，注：第二个参数为默认的 true，意思是获得\n\t\t// 一行数据后自动将尾部的 \\r\\n 去掉\n\t\tif (conn.gets(buf) == false)\n\t\t{\n\t\t\tprintf(\"gets one line from server error: %s\\r\\n\",\n\t\t\t\tacl::last_serror();\n\t\t\treturn -1;\n\t\t}\n\n\t\tprintf(\"response: %s\\r\\n\", buf.c_str());\n\t}\n\n\treturn 0;\n}\n``` \n","slug":"network_simple","published":1,"updated":"2023-01-24T06:19:42.414Z","_id":"cld9uizpo00057x9k4xoi3txp","comments":1,"layout":"post","photos":[],"link":"","content":"<p>acl 的 C++ 库部分也提供了一些简单的服务器类，本文将介绍如何使用这些简单的类来实现一些服务器程序和网络客户端程序。</p>\n<p>首先介绍 acl 中的服务器类：server_socket。该类定义了如下几个简单方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 开始监听给定服务端地址</span><br><span class=\"hljs-comment\"> * @param addr &#123;const char*&#125; 服务器监听地址，格式为：</span><br><span class=\"hljs-comment\"> *  ip:port；在 unix 环境下，还可以是域套接口，格式为：</span><br><span class=\"hljs-comment\"> *   /path/xxx</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 监听是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">open</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 关闭已经打开的监听套接口</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 是否正常关闭</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">close</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 接收客户端连接并创建客户端连接流</span><br><span class=\"hljs-comment\"> * @param timeout &#123;int&#125; 在阻塞模式下，当该值 &gt; 0 时，采用超时</span><br><span class=\"hljs-comment\"> *  方式接收客户端连接，若在指定时间内未获得客户端连接，则返回 NULL</span><br><span class=\"hljs-comment\"> * @return &#123;socket_stream*&#125; 返回空表示接收失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">socket_stream* <span class=\"hljs-title\">accept</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> timeout = <span class=\"hljs-number\">0</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得监听的地址</span><br><span class=\"hljs-comment\"> * @return &#123;const char*&#125; 返回值非空指针</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">get_addr</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> addr_;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用上述网络服务类的步骤是：调用 open 监听本机的一个网络地址（如果是UNIX平台，还可以监听UNIX域套接口）——&gt; 调用 accept 方法等待远程客户端连接本服务器 ——&gt; 当服务器程序接收到客户端连接时 accept 方法返回客户端连接网络流(socket_stream) ——&gt; 启动一个线程处理这个客户端连接。下面为一个简单的服务器程序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-comment\">// 处理客户端连接的线程类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">client_thread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">client_thread</span>(acl::socket_stream* client)<br>\t: <span class=\"hljs-built_in\">client_</span>(client)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">client_thread</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">delete</span> client_;<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 实现基类 acl::thread 中定义的纯虚方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tacl::string buf;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 从客户端连接读一行数据，第二个参数为 false 意思是希望</span><br>\t\t\t<span class=\"hljs-comment\">// socket_stream 在读到一行数据时保留 \\r\\n</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (client_-&gt;<span class=\"hljs-built_in\">gets</span>(buf, <span class=\"hljs-literal\">false</span>) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;gets one line: %s&quot;</span>, buf.<span class=\"hljs-built_in\">c_str</span>());<br><br>\t\t\t<span class=\"hljs-comment\">// 回写所读到的一行数据</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (client_-&gt;<span class=\"hljs-built_in\">write</span>(buf) == <span class=\"hljs-number\">-1</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t\t&#125;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tacl::socket_stream* client_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;0.0.0.0:8080&quot;</span>;<br>\tacl::socket_server server;<br><br>\t<span class=\"hljs-comment\">// 监听本机网络地址</span><br>\t<span class=\"hljs-keyword\">if</span> (server.<span class=\"hljs-built_in\">open</span>(addr) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen addr: %s error: %s\\r\\n&quot;</span>, addr, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 等待客户端连接本服务器程序</span><br>\t\tacl::socket_stream* client = server.<span class=\"hljs-built_in\">accept</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (client == <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept error: %s\\r\\n&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 创建一个子线程用来处理该客户端连接</span><br>\t\tclient_thread* thread = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">client_thread</span>(client);<br><br>\t\t<span class=\"hljs-comment\">// 将线程设为分离模式，这样当线程退出时会自行释放线程相关资源</span><br>\t\tthread-&gt;<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">true</span>);<br><br>\t\t<span class=\"hljs-comment\">// 启动该线程</span><br>\t\tthread-&gt;<span class=\"hljs-built_in\">start</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面例子非常简单，毋庸详述，关于如何使用 acl 编写多线程程序，请参照：使用 acl_cpp 库编写多线程程序。下面再给出一个简单的网络客户端例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* server_addr = <span class=\"hljs-string\">&quot;127.0.0.1:8080&quot;</span>;<br>\t<span class=\"hljs-type\">int</span>   conn_timeout = <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* 连接服务器超时时间，单位：秒 */</span><br>\t<span class=\"hljs-type\">int</span>   rw_timeout = <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* 网络 IO 超时时间，单位：秒 */</span>;<br>\tacl::socket_stream conn;<br><br>\t<span class=\"hljs-comment\">// 连接远程服务器</span><br>\t<span class=\"hljs-keyword\">if</span> (conn.<span class=\"hljs-built_in\">open</span>(server_addr, conn_timeout, rw_timeout) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;connect server: %s error: %s\\r\\n&quot;</span>,<br>\t\t\tserver_addr, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* req = <span class=\"hljs-string\">&quot;hello world!\\r\\n&quot;</span>;<br><br>\tacl::string buf;<br><br>\t<span class=\"hljs-comment\">// 向服务器写一行数据，同时从服务器读一行数据，循环 10 次</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 向服务器发送一行数据</span><br>\t\t<span class=\"hljs-keyword\">if</span> (conn.<span class=\"hljs-built_in\">write</span>(req, <span class=\"hljs-built_in\">strlen</span>(req)) == <span class=\"hljs-number\">-1</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;write request to server error: %s\\r\\n&quot;</span>,<br>\t\t\t\tacl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 从服务器读一行数据，注：第二个参数为默认的 true，意思是获得</span><br>\t\t<span class=\"hljs-comment\">// 一行数据后自动将尾部的 \\r\\n 去掉</span><br>\t\t<span class=\"hljs-keyword\">if</span> (conn.<span class=\"hljs-built_in\">gets</span>(buf) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;gets one line from server error: %s\\r\\n&quot;</span>,<br>\t\t\t\tacl::<span class=\"hljs-built_in\">last_serror</span>();<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;response: %s\\r\\n&quot;</span>, buf.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>acl 的 C++ 库部分也提供了一些简单的服务器类，本文将介绍如何使用这些简单的类来实现一些服务器程序和网络客户端程序。</p>\n<p>首先介绍 acl 中的服务器类：server_socket。该类定义了如下几个简单方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 开始监听给定服务端地址</span><br><span class=\"hljs-comment\"> * @param addr &#123;const char*&#125; 服务器监听地址，格式为：</span><br><span class=\"hljs-comment\"> *  ip:port；在 unix 环境下，还可以是域套接口，格式为：</span><br><span class=\"hljs-comment\"> *   /path/xxx</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 监听是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">open</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 关闭已经打开的监听套接口</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 是否正常关闭</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">close</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 接收客户端连接并创建客户端连接流</span><br><span class=\"hljs-comment\"> * @param timeout &#123;int&#125; 在阻塞模式下，当该值 &gt; 0 时，采用超时</span><br><span class=\"hljs-comment\"> *  方式接收客户端连接，若在指定时间内未获得客户端连接，则返回 NULL</span><br><span class=\"hljs-comment\"> * @return &#123;socket_stream*&#125; 返回空表示接收失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">socket_stream* <span class=\"hljs-title\">accept</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> timeout = <span class=\"hljs-number\">0</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得监听的地址</span><br><span class=\"hljs-comment\"> * @return &#123;const char*&#125; 返回值非空指针</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">get_addr</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> addr_;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>使用上述网络服务类的步骤是：调用 open 监听本机的一个网络地址（如果是UNIX平台，还可以监听UNIX域套接口）——&gt; 调用 accept 方法等待远程客户端连接本服务器 ——&gt; 当服务器程序接收到客户端连接时 accept 方法返回客户端连接网络流(socket_stream) ——&gt; 启动一个线程处理这个客户端连接。下面为一个简单的服务器程序：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-comment\">// 处理客户端连接的线程类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">client_thread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">client_thread</span>(acl::socket_stream* client)<br>\t: <span class=\"hljs-built_in\">client_</span>(client)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">client_thread</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">delete</span> client_;<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 实现基类 acl::thread 中定义的纯虚方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tacl::string buf;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 从客户端连接读一行数据，第二个参数为 false 意思是希望</span><br>\t\t\t<span class=\"hljs-comment\">// socket_stream 在读到一行数据时保留 \\r\\n</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (client_-&gt;<span class=\"hljs-built_in\">gets</span>(buf, <span class=\"hljs-literal\">false</span>) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br><br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;gets one line: %s&quot;</span>, buf.<span class=\"hljs-built_in\">c_str</span>());<br><br>\t\t\t<span class=\"hljs-comment\">// 回写所读到的一行数据</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (client_-&gt;<span class=\"hljs-built_in\">write</span>(buf) == <span class=\"hljs-number\">-1</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t\t&#125;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tacl::socket_stream* client_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;0.0.0.0:8080&quot;</span>;<br>\tacl::socket_server server;<br><br>\t<span class=\"hljs-comment\">// 监听本机网络地址</span><br>\t<span class=\"hljs-keyword\">if</span> (server.<span class=\"hljs-built_in\">open</span>(addr) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;listen addr: %s error: %s\\r\\n&quot;</span>, addr, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span><br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 等待客户端连接本服务器程序</span><br>\t\tacl::socket_stream* client = server.<span class=\"hljs-built_in\">accept</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (client == <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;accept error: %s\\r\\n&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 创建一个子线程用来处理该客户端连接</span><br>\t\tclient_thread* thread = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">client_thread</span>(client);<br><br>\t\t<span class=\"hljs-comment\">// 将线程设为分离模式，这样当线程退出时会自行释放线程相关资源</span><br>\t\tthread-&gt;<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">true</span>);<br><br>\t\t<span class=\"hljs-comment\">// 启动该线程</span><br>\t\tthread-&gt;<span class=\"hljs-built_in\">start</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面例子非常简单，毋庸详述，关于如何使用 acl 编写多线程程序，请参照：使用 acl_cpp 库编写多线程程序。下面再给出一个简单的网络客户端例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* server_addr = <span class=\"hljs-string\">&quot;127.0.0.1:8080&quot;</span>;<br>\t<span class=\"hljs-type\">int</span>   conn_timeout = <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* 连接服务器超时时间，单位：秒 */</span><br>\t<span class=\"hljs-type\">int</span>   rw_timeout = <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">/* 网络 IO 超时时间，单位：秒 */</span>;<br>\tacl::socket_stream conn;<br><br>\t<span class=\"hljs-comment\">// 连接远程服务器</span><br>\t<span class=\"hljs-keyword\">if</span> (conn.<span class=\"hljs-built_in\">open</span>(server_addr, conn_timeout, rw_timeout) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;connect server: %s error: %s\\r\\n&quot;</span>,<br>\t\t\tserver_addr, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* req = <span class=\"hljs-string\">&quot;hello world!\\r\\n&quot;</span>;<br><br>\tacl::string buf;<br><br>\t<span class=\"hljs-comment\">// 向服务器写一行数据，同时从服务器读一行数据，循环 10 次</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 向服务器发送一行数据</span><br>\t\t<span class=\"hljs-keyword\">if</span> (conn.<span class=\"hljs-built_in\">write</span>(req, <span class=\"hljs-built_in\">strlen</span>(req)) == <span class=\"hljs-number\">-1</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;write request to server error: %s\\r\\n&quot;</span>,<br>\t\t\t\tacl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 从服务器读一行数据，注：第二个参数为默认的 true，意思是获得</span><br>\t\t<span class=\"hljs-comment\">// 一行数据后自动将尾部的 \\r\\n 去掉</span><br>\t\t<span class=\"hljs-keyword\">if</span> (conn.<span class=\"hljs-built_in\">gets</span>(buf) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;gets one line from server error: %s\\r\\n&quot;</span>,<br>\t\t\t\tacl::<span class=\"hljs-built_in\">last_serror</span>();<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">-1</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;response: %s\\r\\n&quot;</span>, buf.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n"},{"title":"非阻塞网络编程实例讲解","date":"2012-04-04T15:22:00.000Z","_content":"\n## 一、概述    \nacl 库的 C 库(lib_acl) 的 aio 模块设计了完整的非阻塞异步 IO 通信过程，在 acl 的C++库(lib_acl_cpp) 中封装并增强了异步通信的功能，本文主要描述了 acl C++ 库之非阻塞IO库的设计及使用方法，该异步流的设计思路为：异步流类与异步流接口类，其中异步流类对象完成网络套接口监听、连接、读写的操作，异步流接口类对象定义了网络读写成功/超时回调、连接成功回调、接收客户端连接回调等接口；用户在进行异步编程时，首先必须实现接口类中定义的纯方法，然后将接口类对象在异步流对象中进行注册，这样当满足接口类对象的回调条件时 acl_cpp 的异步框架便自动调用用户定义的接口方法。\n\n在 acl_cpp 中异步流的类继续关系如下图所示：\n![异步流类继承关系图](/img/aio_inherit.png)\n\n由上图可以看出，基类 aio_stream 中定义了流关闭，注册/取消流关闭回调和流超时回调等基础方法；aio_istream 和 aio_ostream 分别定义了异步流读及写的基本方法，aio_istream 中包含添加/删除流读成功回调接口类对象的方法，aio_ostream 中包含添加/删除流写成功回调接口类对象的方法；aio_socket_stream 类对象为连接服务器成功后的客户端流，或服务器接收到客户端连接创建的客户端连接流，其中定义了做为连接流时远程连接的方法及添加连接成功回调接口的方法；aio_listen_stream 类为监听流类，其中定义了监听某个网络地址（或UNIX下的域套接口地址）方法，以及注册接收成功接口的方法。\n\nacl_cpp 异步流接口类继承关系图如下图：\n![异步流类继承关系图](/img/aio_callback.png)\n\n异步流接口类的设计中：aio_accept_callback 为监听流的回调接口类，用户应继承该类以获得外来客户端连接流，同时还需要定义继承于 aio_callback 的类，用于获得网络读写操作等结果信息；aio_open_callback 只有当客户端连接远程服务器时，用户需要实现其子类获得连接成功的结果。\n\n## 二、实例\n### 1、异步服务器\n\n```c++\n#include <iostream>\n#include <assert.h>\n#include \"aio_handle.hpp\"\n#include \"aio_istream.hpp\"\n#include \"aio_listen_stream.hpp\"\n#include \"aio_socket_stream.hpp\"\n\nusing namespace acl;\n\n/**\n * 异步客户端流的回调类的子类\n */\nclass io_callback : public aio_callback\n{\npublic:\n\tio_callback(aio_socket_stream* client)\n\t\t: client_(client)\n\t\t, i_(0)\n\t{\n\t}\n\n\t~io_callback()\n\t{\n\t\tstd::cout << \"delete io_callback now ...\" << std::endl;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的读成功回调过程\n\t * @param data {char*} 读到的数据地址\n\t * @param len {int} 读到的数据长度\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool read_callback(char* data, int len)\n\t{\n\t\ti_++;\n\t\tif (i_ < 10)\n\t\t\tstd::cout << \">>gets(i:\" << i_ << \"): \" << data;\n\n\t\t// 如果远程客户端希望退出，则关闭之\n\t\tif (strncasecmp(data, \"quit\", 4) == 0)\n\t\t{\n\t\t\tclient_->format(\"Bye!\\r\\n\");\n\t\t\tclient_->close();\n\t\t}\n\n\t\t// 如果远程客户端希望服务端也关闭，则中止异步事件过程\n\t\telse if (strncasecmp(data, \"stop\", 4) == 0)\n\t\t{\n\t\t\tclient_->format(\"Stop now!\\r\\n\");\n\t\t\tclient_->close();  // 关闭远程异步流\n\n\t\t\t// 通知异步引擎关闭循环过程\n\t\t\tclient_->get_handle().stop();\n\t\t}\n\n\t\t// 向远程客户端回写收到的数据\n\n\t\tclient_->write(data, len);\n\n\t\treturn (true);\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的写成功回调过程\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool write_callback()\n\t{\n\t\treturn (true);\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的超时回调过程\n\t */\n\tvoid close_callback()\n\t{\n\t\t// 必须在此处删除该动态分配的回调类对象以防止内存泄露\n\t\tdelete this;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的超时回调过程\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool timeout_callback()\n\t{\n\t\tstd::cout << \"Timeout ...\" << std::endl;\n\t\treturn (true);\n\t}\n\nprivate:\n\taio_socket_stream* client_;\n\tint   i_;\n};\n\n/**\n * 异步监听流的回调类的子类\n */\nclass io_accept_callback : public aio_accept_callback\n{\npublic:\n\tio_accept_callback() {}\n\t~io_accept_callback()\n\t{\n\t\tprintf(\">>io_accept_callback over!\\n\");\n\t}\n\n\t/**\n\t * 基类虚函数，当有新连接到达后调用此回调过程\n\t * @param client {aio_socket_stream*} 异步客户端流\n\t * @return {bool} 返回 true 以通知监听流继续监听\n\t */\n\tbool accept_callback(aio_socket_stream* client)\n\t{\n\t\t// 创建异步客户端流的回调对象并与该异步流进行绑定\n\t\tio_callback* callback = new io_callback(client);\n\n\t\t// 注册异步流的读回调过程\n\t\tclient->add_read_callback(callback);\n\n\t\t// 注册异步流的写回调过程\n\t\tclient->add_write_callback(callback);\n\n\t\t// 注册异步流的关闭回调过程\n\t\tclient->add_close_callback(callback);\n\n\t\t// 注册异步流的超时回调过程\n\t\tclient->add_timeout_callback(callback);\n\n\t\t// 从异步流读一行数据\n\t\tclient->gets(10, false);\n\t\treturn (true);\n\t}\n};\n\nint main(int argc, char* argv[])\n{\n\t// 初始化ACL库(尤其是在WIN32下一定要调用此函数，在UNIX平台下可不调用)\n\tacl_cpp_init();\n\n\t// 构建异步引擎类对象\n\taio_handle handle(ENGINE_KERNEL);\n\n\t// 创建监听异步流\n\taio_listen_stream* sstream = new aio_listen_stream(&handle);\n\tconst char* addr = \"127.0.0.1:9001\";\n\n\t// 监听指定的地址\n\tif (sstream->open(addr) == false)\n\t{\n\t\tstd::cout << \"open \" << addr << \" error!\" << std::endl;\n\t\tsstream->close();\n\t\t// XXX: 为了保证能关闭监听流，应在此处再 check 一下\n\t\thandle.check();\n\n\t\tgetchar();\n\t\treturn (1);\n\t}\n\n\t// 创建回调类对象，当有新连接到达时自动调用此类对象的回调过程\n\tio_accept_callback callback;\n\tsstream->add_accept_callback(&callback);\n\tstd::cout << \"Listen: \" << addr << \" ok!\" << std::endl;\n\n\twhile (true)\n\t{\n\t\t// 如果返回 false 则表示不再继续，需要退出\n\t\tif (handle.check() == false)\n\t\t{\n\t\t\tstd::cout << \"aio_server stop now ...\" << std::endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// 关闭监听流并释放流对象\n\tsstream->close();\n\n\t// XXX: 为了保证能关闭监听流，应在此处再 check 一下\n\thandle.check();\n\n\treturn (0);\n}\n```\n\n简要说明一下，上面代码的基本思路是：\n\n- 创建异步通信框架对象 aio_handle --> 创建异步监听流 aio_listen_stream 并注册回调类对象 io_accept_callback-->进入异步通信框架的事件循环中；\n- 当接收到客户端连接后，异步框架回调 io_accept_callback 类对象的 accept_callback 接口并将客户端异步流输入-->创建异步流接口类对象，并将该对象注册至客户端异步流对象中;\n- 当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 --> 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的close_callback --> 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。\n\n异步监听流的接口类的纯虚函数：virtual bool accept_callback(aio_socket_stream* client)  需要子类实现，子类在该函数中获得客户端连接异步流对象。\n\n客户端异步流接口类 aio_callback 有四个虚函数：\n- `virtual bool read_callback(char* data, int len)`  当客户端异步流读到数据时的回调虚函数；\n- `virtual bool write_callback()` 当客户端异步流写数据成功后的回调虚函数；\n- `virtual void close_callback()` 当异步流(客户端流或监听流)关闭时的回调虚函数；\n- `virtual bool timeout_callback()` 当异步流（客户端流在读写超时或监听流在监听超时）超时时的回调函数虚函数。\n\n### 2、异步客户端\n```c++\n#include <iostream>\n#include <assert.h>\n#include \"string.hpp\"\n#include \"util.hpp\"\n#include \"aio_handle.hpp\"\n#include \"acl_cpp_init.hpp\"\n#include \"aio_socket_stream.hpp\"\n\n#ifdef WIN32\n# ifndef snprintf\n#  define snprintf _snprintf\n# endif\n#endif\n\nusing namespace acl;\n\ntypedef struct\n{\n\tchar  addr[64];\n\taio_handle* handle;\n\tint   connect_timeout;\n\tint   read_timeout;\n\tint   nopen_limit;\n\tint   nopen_total;\n\tint   nwrite_limit;\n\tint   nwrite_total;\n\tint   nread_total;\n\tint   id_begin;\n\tbool  debug;\n} IO_CTX;\n\nstatic bool connect_server(IO_CTX* ctx, int id);\n\n/**\n * 客户端异步连接流回调函数类\n */\nclass client_io_callback : public aio_open_callback\n{\npublic:\n\t/**\n\t * 构造函数\n\t * @param ctx {IO_CTX*}\n\t * @param client {aio_socket_stream*} 异步连接流\n\t * @param id {int} 本流的ID号\n\t */\n\tclient_io_callback(IO_CTX* ctx, aio_socket_stream* client, int id)\n\t\t: client_(client)\n\t\t, ctx_(ctx)\n\t\t, nwrite_(0)\n\t\t, id_(id)\n\t{\n\t}\n\n\t~client_io_callback()\n\t{\n\t\tstd::cout << \">>>ID: \" << id_ << \", io_callback deleted now!\" << std::endl;\n\t}\n\n\t/**\n\t * 基类虚函数, 当异步流读到所要求的数据时调用此回调函数\n\t * @param data {char*} 读到的数据地址\n\t * @param len {int｝ 读到的数据长度\n\t * @return {bool} 返回给调用者 true 表示继续，否则表示需要关闭异步流\n\t */\n\tbool read_callback(char* data, int len)\n\t{\n\t\t(void) data;\n\t\t(void) len;\n\n\t\tctx_->nread_total++;\n\n\t\tif (ctx_->debug)\n\t\t{\n\t\t\tif (nwrite_ < 10)\n\t\t\t\tstd::cout << \"gets(\" << nwrite_ << \"): \" << data;\n\t\t\telse if (nwrite_ % 2000 == 0)\n\t\t\t\tstd::cout << \">>ID: \" << id_ << \", I: \"\n\t\t\t\t\t<< nwrite_ << \"; \"<<  data;\n\t\t}\n\n\t\t// 如果收到服务器的退出消息，则也应退出\n\t\tif (acl::strncasecmp_(data, \"quit\", 4) == 0)\n\t\t{\n\t\t\t// 向服务器发送数据\n\t\t\tclient_->format(\"Bye!\\r\\n\");\n\t\t\t// 关闭异步流连接\n\t\t\tclient_->close();\n\t\t\treturn (true);\n\t\t}\n\n\t\tif (nwrite_ >= ctx_->nwrite_limit)\n\t\t{\n\t\t\tif (ctx_->debug)\n\t\t\t\tstd::cout << \"ID: \" << id_\n\t\t\t\t\t<< \", nwrite: \" << nwrite_\n\t\t\t\t\t<< \", nwrite_limit: \" << ctx_->nwrite_limit\n\t\t\t\t\t<< \", quiting ...\" << std::endl;\n\n\t\t\t// 向服务器发送退出消息\n\t\t\tclient_->format(\"quit\\r\\n\");\n\t\t\tclient_->close();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar  buf[256];\n\t\t\tsnprintf(buf, sizeof(buf), \"hello world: %d\\n\", nwrite_);\n\t\t\tclient_->write(buf, (int) strlen(buf));\n\n\t\t\t// 向服务器发送数据\n\t\t\t//client_->format(\"hello world: %d\\n\", nwrite_);\n\t\t}\n\n\t\treturn (true);\n\t}\n\n\t/**\n\t * 基类虚函数, 当异步流写成功时调用此回调函数\n\t * @return {bool} 返回给调用者 true 表示继续，否则表示需要关闭异步流\n\t */\n\tbool write_callback()\n\t{\n\t\tctx_->nwrite_total++;\n\t\tnwrite_++;\n\n\t\t// 从服务器读一行数据\n\t\tclient_->gets(ctx_->read_timeout, false);\n\t\treturn (true);\n\t}\n\n\t/**\n\t * 基类虚函数, 当该异步流关闭时调用此回调函数\n\t */\n\tvoid close_callback()\n\t{\n\t\tif (client_->is_opened() == false)\n\t\t{\n\t\t\tstd::cout << \"Id: \" << id_ << \" connect \"\n\t\t\t\t<< ctx_->addr << \" error: \"\n\t\t\t\t<< acl::last_serror();\n\n\t\t\t// 如果是第一次连接就失败，则退出\n\t\t\tif (ctx_->nopen_total == 0)\n\t\t\t{\n\t\t\t\tstd::cout << \", first connect error, quit\";\n\t\t\t\t/* 获得异步引擎句柄，并设置为退出状态 */\n\t\t\t\tclient_->get_handle().stop();\n\t\t\t}\n\t\t\tstd::cout << std::endl;\n\t\t\tdelete this;\n\t\t\treturn;\n\t\t}\n\n\t\t/* 获得异步引擎中受监控的异步流个数 */\n\t\tint nleft = client_->get_handle().length();\n\t\tif (ctx_->nopen_total == ctx_->nopen_limit && nleft == 1)\n\t\t{\n\t\t\tstd::cout << \"Id: \" << id_ << \" stop now! nstream: \"\n\t\t\t\t<< nleft << std::endl;\n\t\t\t/* 获得异步引擎句柄，并设置为退出状态 */\n\t\t\tclient_->get_handle().stop();\n\t\t}\n\n\t\t// 必须在此处删除该动态分配的回调类对象以防止内存泄露\n\t\tdelete this;\n\t}\n\n\t/**\n\t * 基类虚函数，当异步流超时时调用此函数\n\t * @return {bool} 返回给调用者 true 表示继续，否则表示需要关闭异步流\n\t */\n\tbool timeout_callback()\n\t{\n\t\tstd::cout << \"Connect \" << ctx_->addr << \" Timeout ...\" << std::endl;\n\t\tclient_->close();\n\t\treturn (false);\n\t}\n\n\t/**\n\t * 基类虚函数, 当异步连接成功后调用此函数\n\t * @return {bool} 返回给调用者 true 表示继续，否则表示需要关闭异步流\n\t */\n\tbool open_callback()\n\t{\n\t\t// 连接成功，设置IO读写回调函数\n\t\tclient_->add_read_callback(this);\n\t\tclient_->add_write_callback(this);\n\t\tctx_->nopen_total++;\n\n\t\tacl::assert_(id_ > 0);\n\t\tif (ctx_->nopen_total < ctx_->nopen_limit)\n\t\t{\n\t\t\t// 开始进行下一个连接过程\n\t\t\tif (connect_server(ctx_, id_ + 1) == false)\n\t\t\t\tstd::cout << \"connect error!\" << std::endl;\n\t\t}\n\n\t\t// 异步向服务器发送数据\n\t\t//client_->format(\"hello world: %d\\n\", nwrite_);\n\t\tchar  buf[256];\n\t\tsnprintf(buf, sizeof(buf), \"hello world: %d\\n\", nwrite_);\n\t\tclient_->write(buf, (int) strlen(buf));\n\n\t\t// 异步从服务器读取一行数据\n\t\tclient_->gets(ctx_->read_timeout, false);\n\n\t\t// 表示继续异步过程\n\t\treturn (true);\n\t}\n\nprivate:\n\taio_socket_stream* client_;\n\tIO_CTX* ctx_;\n\tint   nwrite_;\n\tint   id_;\n};\n\nstatic bool connect_server(IO_CTX* ctx, int id)\n{\n\t// 开始异步连接远程服务器\n\taio_socket_stream* stream = aio_socket_stream::open(ctx->handle,\n\t\t\tctx->addr, ctx->connect_timeout);\n\tif (stream == NULL)\n\t{\n\t\tstd::cout << \"connect \" << ctx->addr << \" error!\" << std::endl;\n\t\tstd::cout << \"stoping ...\" << std::endl;\n\t\tif (id == 0)\n\t\t\tctx->handle->stop();\n\t\treturn (false);\n\t}\n\n\t// 创建连接后的回调函数类\n\tclient_io_callback* callback = new client_io_callback(ctx, stream, id);\n\n\t// 添加连接成功的回调函数类\n\tstream->add_open_callback(callback);\n\n\t// 添加连接失败后回调函数类\n\tstream->add_close_callback(callback);\n\n\t// 添加连接超时的回调函数类\n\tstream->add_timeout_callback(callback);\n\treturn (true);\n}\n\nint main(int argc, char* argv[])\n{\n\tbool use_kernel = false;\n\tint   ch;\n\tIO_CTX ctx;\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.connect_timeout = 5;\n\tctx.nopen_limit = 10;\n\tctx.id_begin = 1;\n\tctx.nwrite_limit = 10;\n\tctx.debug = false;\n\tsnprintf(ctx.addr, sizeof(ctx.addr), \"127.0.0.1:9001\");\n\n\tacl_cpp_init();\n\n\taio_handle handle(ENGINE_KERNEL);\n\tctx.handle = &handle;\n\n\tif (connect_server(&ctx, ctx.id_begin) == false)\n\t{\n\t\tstd::cout << \"enter any key to exit.\" << std::endl;\n\t\tgetchar();\n\t\treturn (1);\n\t}\n\n\tstd::cout << \"Connect \" << ctx.addr << \" ...\" << std::endl;\n\n\twhile (true)\n\t{\n\t\t// 如果返回 false 则表示不再继续，需要退出\n\t\tif (handle.check() == false)\n\t\t\tbreak;\n\t}\n\n\treturn (0);\n}\n```\n\n异步客户端的基本流程为：\n- 创建异步框架对象 aio_handle --> 异步连接远程服务器，创建连接成功/失败/超时的异步接口类对象并注册至异步连接流中 --> 异步框架进行事件循环中；\n- 连接成功后，异步接口类对象中的 open_callback 被调用，启动下一个异步连接过程（未达限制连接数前） --> 添加异步读及异步写的回调接口类  --> 异步写入数据，同时开始异步读数据过程；\n- 当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 --> 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的 close_callback --> 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。\n\n客户端异步连接流的接口类 aio_open_callback 的纯虚函数 virtual bool open_callback() 需要子类实现，在连接服务器成功后调用此函数，允许子类在该函数中做进一步操作，如：注册客户端流的异步读回调接口类对象及异步写回调类对象；如果连接超时或连接失败而导致的关闭，则基础接口类中的 timeout_callback() 或 close_callback() 将会被调用，以通知用户应用程序。\n\n## 三、小结\n以上的示例演示了基本的非阻塞异步流的监听、读写、连接等过程，类的设计中也提供了基本的操作方法，为了应对实践中的多样性及复杂性，acl_cpp 的异步流还设计了更多的接口和方法，如：延迟读写操作（这对于限流的服务器比较有用处）、定时器操作等。\n\n更多例子参见：lib_acl_cpp/samples/aio/ 目录\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","source":"_posts/aio.md","raw":"---\ntitle: 非阻塞网络编程实例讲解\ndate: 2012-04-04 23:22\ncategories: 非阻塞编程\n---\n\n## 一、概述    \nacl 库的 C 库(lib_acl) 的 aio 模块设计了完整的非阻塞异步 IO 通信过程，在 acl 的C++库(lib_acl_cpp) 中封装并增强了异步通信的功能，本文主要描述了 acl C++ 库之非阻塞IO库的设计及使用方法，该异步流的设计思路为：异步流类与异步流接口类，其中异步流类对象完成网络套接口监听、连接、读写的操作，异步流接口类对象定义了网络读写成功/超时回调、连接成功回调、接收客户端连接回调等接口；用户在进行异步编程时，首先必须实现接口类中定义的纯方法，然后将接口类对象在异步流对象中进行注册，这样当满足接口类对象的回调条件时 acl_cpp 的异步框架便自动调用用户定义的接口方法。\n\n在 acl_cpp 中异步流的类继续关系如下图所示：\n![异步流类继承关系图](/img/aio_inherit.png)\n\n由上图可以看出，基类 aio_stream 中定义了流关闭，注册/取消流关闭回调和流超时回调等基础方法；aio_istream 和 aio_ostream 分别定义了异步流读及写的基本方法，aio_istream 中包含添加/删除流读成功回调接口类对象的方法，aio_ostream 中包含添加/删除流写成功回调接口类对象的方法；aio_socket_stream 类对象为连接服务器成功后的客户端流，或服务器接收到客户端连接创建的客户端连接流，其中定义了做为连接流时远程连接的方法及添加连接成功回调接口的方法；aio_listen_stream 类为监听流类，其中定义了监听某个网络地址（或UNIX下的域套接口地址）方法，以及注册接收成功接口的方法。\n\nacl_cpp 异步流接口类继承关系图如下图：\n![异步流类继承关系图](/img/aio_callback.png)\n\n异步流接口类的设计中：aio_accept_callback 为监听流的回调接口类，用户应继承该类以获得外来客户端连接流，同时还需要定义继承于 aio_callback 的类，用于获得网络读写操作等结果信息；aio_open_callback 只有当客户端连接远程服务器时，用户需要实现其子类获得连接成功的结果。\n\n## 二、实例\n### 1、异步服务器\n\n```c++\n#include <iostream>\n#include <assert.h>\n#include \"aio_handle.hpp\"\n#include \"aio_istream.hpp\"\n#include \"aio_listen_stream.hpp\"\n#include \"aio_socket_stream.hpp\"\n\nusing namespace acl;\n\n/**\n * 异步客户端流的回调类的子类\n */\nclass io_callback : public aio_callback\n{\npublic:\n\tio_callback(aio_socket_stream* client)\n\t\t: client_(client)\n\t\t, i_(0)\n\t{\n\t}\n\n\t~io_callback()\n\t{\n\t\tstd::cout << \"delete io_callback now ...\" << std::endl;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的读成功回调过程\n\t * @param data {char*} 读到的数据地址\n\t * @param len {int} 读到的数据长度\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool read_callback(char* data, int len)\n\t{\n\t\ti_++;\n\t\tif (i_ < 10)\n\t\t\tstd::cout << \">>gets(i:\" << i_ << \"): \" << data;\n\n\t\t// 如果远程客户端希望退出，则关闭之\n\t\tif (strncasecmp(data, \"quit\", 4) == 0)\n\t\t{\n\t\t\tclient_->format(\"Bye!\\r\\n\");\n\t\t\tclient_->close();\n\t\t}\n\n\t\t// 如果远程客户端希望服务端也关闭，则中止异步事件过程\n\t\telse if (strncasecmp(data, \"stop\", 4) == 0)\n\t\t{\n\t\t\tclient_->format(\"Stop now!\\r\\n\");\n\t\t\tclient_->close();  // 关闭远程异步流\n\n\t\t\t// 通知异步引擎关闭循环过程\n\t\t\tclient_->get_handle().stop();\n\t\t}\n\n\t\t// 向远程客户端回写收到的数据\n\n\t\tclient_->write(data, len);\n\n\t\treturn (true);\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的写成功回调过程\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool write_callback()\n\t{\n\t\treturn (true);\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的超时回调过程\n\t */\n\tvoid close_callback()\n\t{\n\t\t// 必须在此处删除该动态分配的回调类对象以防止内存泄露\n\t\tdelete this;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的超时回调过程\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool timeout_callback()\n\t{\n\t\tstd::cout << \"Timeout ...\" << std::endl;\n\t\treturn (true);\n\t}\n\nprivate:\n\taio_socket_stream* client_;\n\tint   i_;\n};\n\n/**\n * 异步监听流的回调类的子类\n */\nclass io_accept_callback : public aio_accept_callback\n{\npublic:\n\tio_accept_callback() {}\n\t~io_accept_callback()\n\t{\n\t\tprintf(\">>io_accept_callback over!\\n\");\n\t}\n\n\t/**\n\t * 基类虚函数，当有新连接到达后调用此回调过程\n\t * @param client {aio_socket_stream*} 异步客户端流\n\t * @return {bool} 返回 true 以通知监听流继续监听\n\t */\n\tbool accept_callback(aio_socket_stream* client)\n\t{\n\t\t// 创建异步客户端流的回调对象并与该异步流进行绑定\n\t\tio_callback* callback = new io_callback(client);\n\n\t\t// 注册异步流的读回调过程\n\t\tclient->add_read_callback(callback);\n\n\t\t// 注册异步流的写回调过程\n\t\tclient->add_write_callback(callback);\n\n\t\t// 注册异步流的关闭回调过程\n\t\tclient->add_close_callback(callback);\n\n\t\t// 注册异步流的超时回调过程\n\t\tclient->add_timeout_callback(callback);\n\n\t\t// 从异步流读一行数据\n\t\tclient->gets(10, false);\n\t\treturn (true);\n\t}\n};\n\nint main(int argc, char* argv[])\n{\n\t// 初始化ACL库(尤其是在WIN32下一定要调用此函数，在UNIX平台下可不调用)\n\tacl_cpp_init();\n\n\t// 构建异步引擎类对象\n\taio_handle handle(ENGINE_KERNEL);\n\n\t// 创建监听异步流\n\taio_listen_stream* sstream = new aio_listen_stream(&handle);\n\tconst char* addr = \"127.0.0.1:9001\";\n\n\t// 监听指定的地址\n\tif (sstream->open(addr) == false)\n\t{\n\t\tstd::cout << \"open \" << addr << \" error!\" << std::endl;\n\t\tsstream->close();\n\t\t// XXX: 为了保证能关闭监听流，应在此处再 check 一下\n\t\thandle.check();\n\n\t\tgetchar();\n\t\treturn (1);\n\t}\n\n\t// 创建回调类对象，当有新连接到达时自动调用此类对象的回调过程\n\tio_accept_callback callback;\n\tsstream->add_accept_callback(&callback);\n\tstd::cout << \"Listen: \" << addr << \" ok!\" << std::endl;\n\n\twhile (true)\n\t{\n\t\t// 如果返回 false 则表示不再继续，需要退出\n\t\tif (handle.check() == false)\n\t\t{\n\t\t\tstd::cout << \"aio_server stop now ...\" << std::endl;\n\t\t\tbreak;\n\t\t}\n\t}\n\n\t// 关闭监听流并释放流对象\n\tsstream->close();\n\n\t// XXX: 为了保证能关闭监听流，应在此处再 check 一下\n\thandle.check();\n\n\treturn (0);\n}\n```\n\n简要说明一下，上面代码的基本思路是：\n\n- 创建异步通信框架对象 aio_handle --> 创建异步监听流 aio_listen_stream 并注册回调类对象 io_accept_callback-->进入异步通信框架的事件循环中；\n- 当接收到客户端连接后，异步框架回调 io_accept_callback 类对象的 accept_callback 接口并将客户端异步流输入-->创建异步流接口类对象，并将该对象注册至客户端异步流对象中;\n- 当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 --> 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的close_callback --> 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。\n\n异步监听流的接口类的纯虚函数：virtual bool accept_callback(aio_socket_stream* client)  需要子类实现，子类在该函数中获得客户端连接异步流对象。\n\n客户端异步流接口类 aio_callback 有四个虚函数：\n- `virtual bool read_callback(char* data, int len)`  当客户端异步流读到数据时的回调虚函数；\n- `virtual bool write_callback()` 当客户端异步流写数据成功后的回调虚函数；\n- `virtual void close_callback()` 当异步流(客户端流或监听流)关闭时的回调虚函数；\n- `virtual bool timeout_callback()` 当异步流（客户端流在读写超时或监听流在监听超时）超时时的回调函数虚函数。\n\n### 2、异步客户端\n```c++\n#include <iostream>\n#include <assert.h>\n#include \"string.hpp\"\n#include \"util.hpp\"\n#include \"aio_handle.hpp\"\n#include \"acl_cpp_init.hpp\"\n#include \"aio_socket_stream.hpp\"\n\n#ifdef WIN32\n# ifndef snprintf\n#  define snprintf _snprintf\n# endif\n#endif\n\nusing namespace acl;\n\ntypedef struct\n{\n\tchar  addr[64];\n\taio_handle* handle;\n\tint   connect_timeout;\n\tint   read_timeout;\n\tint   nopen_limit;\n\tint   nopen_total;\n\tint   nwrite_limit;\n\tint   nwrite_total;\n\tint   nread_total;\n\tint   id_begin;\n\tbool  debug;\n} IO_CTX;\n\nstatic bool connect_server(IO_CTX* ctx, int id);\n\n/**\n * 客户端异步连接流回调函数类\n */\nclass client_io_callback : public aio_open_callback\n{\npublic:\n\t/**\n\t * 构造函数\n\t * @param ctx {IO_CTX*}\n\t * @param client {aio_socket_stream*} 异步连接流\n\t * @param id {int} 本流的ID号\n\t */\n\tclient_io_callback(IO_CTX* ctx, aio_socket_stream* client, int id)\n\t\t: client_(client)\n\t\t, ctx_(ctx)\n\t\t, nwrite_(0)\n\t\t, id_(id)\n\t{\n\t}\n\n\t~client_io_callback()\n\t{\n\t\tstd::cout << \">>>ID: \" << id_ << \", io_callback deleted now!\" << std::endl;\n\t}\n\n\t/**\n\t * 基类虚函数, 当异步流读到所要求的数据时调用此回调函数\n\t * @param data {char*} 读到的数据地址\n\t * @param len {int｝ 读到的数据长度\n\t * @return {bool} 返回给调用者 true 表示继续，否则表示需要关闭异步流\n\t */\n\tbool read_callback(char* data, int len)\n\t{\n\t\t(void) data;\n\t\t(void) len;\n\n\t\tctx_->nread_total++;\n\n\t\tif (ctx_->debug)\n\t\t{\n\t\t\tif (nwrite_ < 10)\n\t\t\t\tstd::cout << \"gets(\" << nwrite_ << \"): \" << data;\n\t\t\telse if (nwrite_ % 2000 == 0)\n\t\t\t\tstd::cout << \">>ID: \" << id_ << \", I: \"\n\t\t\t\t\t<< nwrite_ << \"; \"<<  data;\n\t\t}\n\n\t\t// 如果收到服务器的退出消息，则也应退出\n\t\tif (acl::strncasecmp_(data, \"quit\", 4) == 0)\n\t\t{\n\t\t\t// 向服务器发送数据\n\t\t\tclient_->format(\"Bye!\\r\\n\");\n\t\t\t// 关闭异步流连接\n\t\t\tclient_->close();\n\t\t\treturn (true);\n\t\t}\n\n\t\tif (nwrite_ >= ctx_->nwrite_limit)\n\t\t{\n\t\t\tif (ctx_->debug)\n\t\t\t\tstd::cout << \"ID: \" << id_\n\t\t\t\t\t<< \", nwrite: \" << nwrite_\n\t\t\t\t\t<< \", nwrite_limit: \" << ctx_->nwrite_limit\n\t\t\t\t\t<< \", quiting ...\" << std::endl;\n\n\t\t\t// 向服务器发送退出消息\n\t\t\tclient_->format(\"quit\\r\\n\");\n\t\t\tclient_->close();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tchar  buf[256];\n\t\t\tsnprintf(buf, sizeof(buf), \"hello world: %d\\n\", nwrite_);\n\t\t\tclient_->write(buf, (int) strlen(buf));\n\n\t\t\t// 向服务器发送数据\n\t\t\t//client_->format(\"hello world: %d\\n\", nwrite_);\n\t\t}\n\n\t\treturn (true);\n\t}\n\n\t/**\n\t * 基类虚函数, 当异步流写成功时调用此回调函数\n\t * @return {bool} 返回给调用者 true 表示继续，否则表示需要关闭异步流\n\t */\n\tbool write_callback()\n\t{\n\t\tctx_->nwrite_total++;\n\t\tnwrite_++;\n\n\t\t// 从服务器读一行数据\n\t\tclient_->gets(ctx_->read_timeout, false);\n\t\treturn (true);\n\t}\n\n\t/**\n\t * 基类虚函数, 当该异步流关闭时调用此回调函数\n\t */\n\tvoid close_callback()\n\t{\n\t\tif (client_->is_opened() == false)\n\t\t{\n\t\t\tstd::cout << \"Id: \" << id_ << \" connect \"\n\t\t\t\t<< ctx_->addr << \" error: \"\n\t\t\t\t<< acl::last_serror();\n\n\t\t\t// 如果是第一次连接就失败，则退出\n\t\t\tif (ctx_->nopen_total == 0)\n\t\t\t{\n\t\t\t\tstd::cout << \", first connect error, quit\";\n\t\t\t\t/* 获得异步引擎句柄，并设置为退出状态 */\n\t\t\t\tclient_->get_handle().stop();\n\t\t\t}\n\t\t\tstd::cout << std::endl;\n\t\t\tdelete this;\n\t\t\treturn;\n\t\t}\n\n\t\t/* 获得异步引擎中受监控的异步流个数 */\n\t\tint nleft = client_->get_handle().length();\n\t\tif (ctx_->nopen_total == ctx_->nopen_limit && nleft == 1)\n\t\t{\n\t\t\tstd::cout << \"Id: \" << id_ << \" stop now! nstream: \"\n\t\t\t\t<< nleft << std::endl;\n\t\t\t/* 获得异步引擎句柄，并设置为退出状态 */\n\t\t\tclient_->get_handle().stop();\n\t\t}\n\n\t\t// 必须在此处删除该动态分配的回调类对象以防止内存泄露\n\t\tdelete this;\n\t}\n\n\t/**\n\t * 基类虚函数，当异步流超时时调用此函数\n\t * @return {bool} 返回给调用者 true 表示继续，否则表示需要关闭异步流\n\t */\n\tbool timeout_callback()\n\t{\n\t\tstd::cout << \"Connect \" << ctx_->addr << \" Timeout ...\" << std::endl;\n\t\tclient_->close();\n\t\treturn (false);\n\t}\n\n\t/**\n\t * 基类虚函数, 当异步连接成功后调用此函数\n\t * @return {bool} 返回给调用者 true 表示继续，否则表示需要关闭异步流\n\t */\n\tbool open_callback()\n\t{\n\t\t// 连接成功，设置IO读写回调函数\n\t\tclient_->add_read_callback(this);\n\t\tclient_->add_write_callback(this);\n\t\tctx_->nopen_total++;\n\n\t\tacl::assert_(id_ > 0);\n\t\tif (ctx_->nopen_total < ctx_->nopen_limit)\n\t\t{\n\t\t\t// 开始进行下一个连接过程\n\t\t\tif (connect_server(ctx_, id_ + 1) == false)\n\t\t\t\tstd::cout << \"connect error!\" << std::endl;\n\t\t}\n\n\t\t// 异步向服务器发送数据\n\t\t//client_->format(\"hello world: %d\\n\", nwrite_);\n\t\tchar  buf[256];\n\t\tsnprintf(buf, sizeof(buf), \"hello world: %d\\n\", nwrite_);\n\t\tclient_->write(buf, (int) strlen(buf));\n\n\t\t// 异步从服务器读取一行数据\n\t\tclient_->gets(ctx_->read_timeout, false);\n\n\t\t// 表示继续异步过程\n\t\treturn (true);\n\t}\n\nprivate:\n\taio_socket_stream* client_;\n\tIO_CTX* ctx_;\n\tint   nwrite_;\n\tint   id_;\n};\n\nstatic bool connect_server(IO_CTX* ctx, int id)\n{\n\t// 开始异步连接远程服务器\n\taio_socket_stream* stream = aio_socket_stream::open(ctx->handle,\n\t\t\tctx->addr, ctx->connect_timeout);\n\tif (stream == NULL)\n\t{\n\t\tstd::cout << \"connect \" << ctx->addr << \" error!\" << std::endl;\n\t\tstd::cout << \"stoping ...\" << std::endl;\n\t\tif (id == 0)\n\t\t\tctx->handle->stop();\n\t\treturn (false);\n\t}\n\n\t// 创建连接后的回调函数类\n\tclient_io_callback* callback = new client_io_callback(ctx, stream, id);\n\n\t// 添加连接成功的回调函数类\n\tstream->add_open_callback(callback);\n\n\t// 添加连接失败后回调函数类\n\tstream->add_close_callback(callback);\n\n\t// 添加连接超时的回调函数类\n\tstream->add_timeout_callback(callback);\n\treturn (true);\n}\n\nint main(int argc, char* argv[])\n{\n\tbool use_kernel = false;\n\tint   ch;\n\tIO_CTX ctx;\n\n\tmemset(&ctx, 0, sizeof(ctx));\n\tctx.connect_timeout = 5;\n\tctx.nopen_limit = 10;\n\tctx.id_begin = 1;\n\tctx.nwrite_limit = 10;\n\tctx.debug = false;\n\tsnprintf(ctx.addr, sizeof(ctx.addr), \"127.0.0.1:9001\");\n\n\tacl_cpp_init();\n\n\taio_handle handle(ENGINE_KERNEL);\n\tctx.handle = &handle;\n\n\tif (connect_server(&ctx, ctx.id_begin) == false)\n\t{\n\t\tstd::cout << \"enter any key to exit.\" << std::endl;\n\t\tgetchar();\n\t\treturn (1);\n\t}\n\n\tstd::cout << \"Connect \" << ctx.addr << \" ...\" << std::endl;\n\n\twhile (true)\n\t{\n\t\t// 如果返回 false 则表示不再继续，需要退出\n\t\tif (handle.check() == false)\n\t\t\tbreak;\n\t}\n\n\treturn (0);\n}\n```\n\n异步客户端的基本流程为：\n- 创建异步框架对象 aio_handle --> 异步连接远程服务器，创建连接成功/失败/超时的异步接口类对象并注册至异步连接流中 --> 异步框架进行事件循环中；\n- 连接成功后，异步接口类对象中的 open_callback 被调用，启动下一个异步连接过程（未达限制连接数前） --> 添加异步读及异步写的回调接口类  --> 异步写入数据，同时开始异步读数据过程；\n- 当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 --> 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的 close_callback --> 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。\n\n客户端异步连接流的接口类 aio_open_callback 的纯虚函数 virtual bool open_callback() 需要子类实现，在连接服务器成功后调用此函数，允许子类在该函数中做进一步操作，如：注册客户端流的异步读回调接口类对象及异步写回调类对象；如果连接超时或连接失败而导致的关闭，则基础接口类中的 timeout_callback() 或 close_callback() 将会被调用，以通知用户应用程序。\n\n## 三、小结\n以上的示例演示了基本的非阻塞异步流的监听、读写、连接等过程，类的设计中也提供了基本的操作方法，为了应对实践中的多样性及复杂性，acl_cpp 的异步流还设计了更多的接口和方法，如：延迟读写操作（这对于限流的服务器比较有用处）、定时器操作等。\n\n更多例子参见：lib_acl_cpp/samples/aio/ 目录\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","slug":"aio","published":1,"updated":"2023-01-24T07:45:18.978Z","_id":"cld9vmr0d00097x9k102077aw","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>acl 库的 C 库(lib_acl) 的 aio 模块设计了完整的非阻塞异步 IO 通信过程，在 acl 的C++库(lib_acl_cpp) 中封装并增强了异步通信的功能，本文主要描述了 acl C++ 库之非阻塞IO库的设计及使用方法，该异步流的设计思路为：异步流类与异步流接口类，其中异步流类对象完成网络套接口监听、连接、读写的操作，异步流接口类对象定义了网络读写成功&#x2F;超时回调、连接成功回调、接收客户端连接回调等接口；用户在进行异步编程时，首先必须实现接口类中定义的纯方法，然后将接口类对象在异步流对象中进行注册，这样当满足接口类对象的回调条件时 acl_cpp 的异步框架便自动调用用户定义的接口方法。</p>\n<p>在 acl_cpp 中异步流的类继续关系如下图所示：<br><img src=\"/img/aio_inherit.png\" alt=\"异步流类继承关系图\"></p>\n<p>由上图可以看出，基类 aio_stream 中定义了流关闭，注册&#x2F;取消流关闭回调和流超时回调等基础方法；aio_istream 和 aio_ostream 分别定义了异步流读及写的基本方法，aio_istream 中包含添加&#x2F;删除流读成功回调接口类对象的方法，aio_ostream 中包含添加&#x2F;删除流写成功回调接口类对象的方法；aio_socket_stream 类对象为连接服务器成功后的客户端流，或服务器接收到客户端连接创建的客户端连接流，其中定义了做为连接流时远程连接的方法及添加连接成功回调接口的方法；aio_listen_stream 类为监听流类，其中定义了监听某个网络地址（或UNIX下的域套接口地址）方法，以及注册接收成功接口的方法。</p>\n<p>acl_cpp 异步流接口类继承关系图如下图：<br><img src=\"/img/aio_callback.png\" alt=\"异步流类继承关系图\"></p>\n<p>异步流接口类的设计中：aio_accept_callback 为监听流的回调接口类，用户应继承该类以获得外来客户端连接流，同时还需要定义继承于 aio_callback 的类，用于获得网络读写操作等结果信息；aio_open_callback 只有当客户端连接远程服务器时，用户需要实现其子类获得连接成功的结果。</p>\n<h2 id=\"二、实例\"><a href=\"#二、实例\" class=\"headerlink\" title=\"二、实例\"></a>二、实例</h2><h3 id=\"1、异步服务器\"><a href=\"#1、异步服务器\" class=\"headerlink\" title=\"1、异步服务器\"></a>1、异步服务器</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_handle.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_istream.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_listen_stream.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_socket_stream.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 异步客户端流的回调类的子类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">io_callback</span> : <span class=\"hljs-keyword\">public</span> aio_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">io_callback</span>(aio_socket_stream* client)<br>\t\t: <span class=\"hljs-built_in\">client_</span>(client)<br>\t\t, <span class=\"hljs-built_in\">i_</span>(<span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">io_callback</span>()<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;delete io_callback now ...&quot;</span> &lt;&lt; std::endl;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的读成功回调过程</span><br><span class=\"hljs-comment\">\t * @param data &#123;char*&#125; 读到的数据地址</span><br><span class=\"hljs-comment\">\t * @param len &#123;int&#125; 读到的数据长度</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">read_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* data, <span class=\"hljs-type\">int</span> len)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\ti_++;<br>\t\t<span class=\"hljs-keyword\">if</span> (i_ &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;&gt;&gt;gets(i:&quot;</span> &lt;&lt; i_ &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; data;<br><br>\t\t<span class=\"hljs-comment\">// 如果远程客户端希望退出，则关闭之</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncasecmp</span>(data, <span class=\"hljs-string\">&quot;quit&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Bye!\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 如果远程客户端希望服务端也关闭，则中止异步事件过程</span><br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncasecmp</span>(data, <span class=\"hljs-string\">&quot;stop&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Stop now!\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();  <span class=\"hljs-comment\">// 关闭远程异步流</span><br><br>\t\t\t<span class=\"hljs-comment\">// 通知异步引擎关闭循环过程</span><br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">stop</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 向远程客户端回写收到的数据</span><br><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(data, len);<br><br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的写成功回调过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的超时回调过程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">close_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 必须在此处删除该动态分配的回调类对象以防止内存泄露</span><br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的超时回调过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">timeout_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Timeout ...&quot;</span> &lt;&lt; std::endl;<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\taio_socket_stream* client_;<br>\t<span class=\"hljs-type\">int</span>   i_;<br>&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 异步监听流的回调类的子类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">io_accept_callback</span> : <span class=\"hljs-keyword\">public</span> aio_accept_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">io_accept_callback</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">io_accept_callback</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;io_accept_callback over!\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数，当有新连接到达后调用此回调过程</span><br><span class=\"hljs-comment\">\t * @param client &#123;aio_socket_stream*&#125; 异步客户端流</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 以通知监听流继续监听</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">accept_callback</span><span class=\"hljs-params\">(aio_socket_stream* client)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 创建异步客户端流的回调对象并与该异步流进行绑定</span><br>\t\tio_callback* callback = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">io_callback</span>(client);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的读回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_read_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的写回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_write_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的关闭回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_close_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的超时回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_timeout_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 从异步流读一行数据</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">gets</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-literal\">false</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 初始化ACL库(尤其是在WIN32下一定要调用此函数，在UNIX平台下可不调用)</span><br>\t<span class=\"hljs-built_in\">acl_cpp_init</span>();<br><br>\t<span class=\"hljs-comment\">// 构建异步引擎类对象</span><br>\t<span class=\"hljs-function\">aio_handle <span class=\"hljs-title\">handle</span><span class=\"hljs-params\">(ENGINE_KERNEL)</span></span>;<br><br>\t<span class=\"hljs-comment\">// 创建监听异步流</span><br>\taio_listen_stream* sstream = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">aio_listen_stream</span>(&amp;handle);<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:9001&quot;</span>;<br><br>\t<span class=\"hljs-comment\">// 监听指定的地址</span><br>\t<span class=\"hljs-keyword\">if</span> (sstream-&gt;<span class=\"hljs-built_in\">open</span>(addr) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;open &quot;</span> &lt;&lt; addr &lt;&lt; <span class=\"hljs-string\">&quot; error!&quot;</span> &lt;&lt; std::endl;<br>\t\tsstream-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">XXX:</span> 为了保证能关闭监听流，应在此处再 check 一下</span><br>\t\thandle.<span class=\"hljs-built_in\">check</span>();<br><br>\t\t<span class=\"hljs-built_in\">getchar</span>();<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 创建回调类对象，当有新连接到达时自动调用此类对象的回调过程</span><br>\tio_accept_callback callback;<br>\tsstream-&gt;<span class=\"hljs-built_in\">add_accept_callback</span>(&amp;callback);<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Listen: &quot;</span> &lt;&lt; addr &lt;&lt; <span class=\"hljs-string\">&quot; ok!&quot;</span> &lt;&lt; std::endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 如果返回 false 则表示不再继续，需要退出</span><br>\t\t<span class=\"hljs-keyword\">if</span> (handle.<span class=\"hljs-built_in\">check</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;aio_server stop now ...&quot;</span> &lt;&lt; std::endl;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 关闭监听流并释放流对象</span><br>\tsstream-&gt;<span class=\"hljs-built_in\">close</span>();<br><br>\t<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">XXX:</span> 为了保证能关闭监听流，应在此处再 check 一下</span><br>\thandle.<span class=\"hljs-built_in\">check</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>简要说明一下，上面代码的基本思路是：</p>\n<ul>\n<li>创建异步通信框架对象 aio_handle –&gt; 创建异步监听流 aio_listen_stream 并注册回调类对象 io_accept_callback–&gt;进入异步通信框架的事件循环中；</li>\n<li>当接收到客户端连接后，异步框架回调 io_accept_callback 类对象的 accept_callback 接口并将客户端异步流输入–&gt;创建异步流接口类对象，并将该对象注册至客户端异步流对象中;</li>\n<li>当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 –&gt; 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的close_callback –&gt; 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。</li>\n</ul>\n<p>异步监听流的接口类的纯虚函数：virtual bool accept_callback(aio_socket_stream* client)  需要子类实现，子类在该函数中获得客户端连接异步流对象。</p>\n<p>客户端异步流接口类 aio_callback 有四个虚函数：</p>\n<ul>\n<li><code>virtual bool read_callback(char* data, int len)</code>  当客户端异步流读到数据时的回调虚函数；</li>\n<li><code>virtual bool write_callback()</code> 当客户端异步流写数据成功后的回调虚函数；</li>\n<li><code>virtual void close_callback()</code> 当异步流(客户端流或监听流)关闭时的回调虚函数；</li>\n<li><code>virtual bool timeout_callback()</code> 当异步流（客户端流在读写超时或监听流在监听超时）超时时的回调函数虚函数。</li>\n</ul>\n<h3 id=\"2、异步客户端\"><a href=\"#2、异步客户端\" class=\"headerlink\" title=\"2、异步客户端\"></a>2、异步客户端</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;string.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;util.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_handle.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp_init.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_socket_stream.hpp&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">ifndef</span> snprintf</span><br><span class=\"hljs-meta\">#  <span class=\"hljs-keyword\">define</span> snprintf _snprintf</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span>  addr[<span class=\"hljs-number\">64</span>];<br>\taio_handle* handle;<br>\t<span class=\"hljs-type\">int</span>   connect_timeout;<br>\t<span class=\"hljs-type\">int</span>   read_timeout;<br>\t<span class=\"hljs-type\">int</span>   nopen_limit;<br>\t<span class=\"hljs-type\">int</span>   nopen_total;<br>\t<span class=\"hljs-type\">int</span>   nwrite_limit;<br>\t<span class=\"hljs-type\">int</span>   nwrite_total;<br>\t<span class=\"hljs-type\">int</span>   nread_total;<br>\t<span class=\"hljs-type\">int</span>   id_begin;<br>\t<span class=\"hljs-type\">bool</span>  debug;<br>&#125; IO_CTX;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">connect_server</span><span class=\"hljs-params\">(IO_CTX* ctx, <span class=\"hljs-type\">int</span> id)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 客户端异步连接流回调函数类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">client_io_callback</span> : <span class=\"hljs-keyword\">public</span> aio_open_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 构造函数</span><br><span class=\"hljs-comment\">\t * @param ctx &#123;IO_CTX*&#125;</span><br><span class=\"hljs-comment\">\t * @param client &#123;aio_socket_stream*&#125; 异步连接流</span><br><span class=\"hljs-comment\">\t * @param id &#123;int&#125; 本流的ID号</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-built_in\">client_io_callback</span>(IO_CTX* ctx, aio_socket_stream* client, <span class=\"hljs-type\">int</span> id)<br>\t\t: <span class=\"hljs-built_in\">client_</span>(client)<br>\t\t, <span class=\"hljs-built_in\">ctx_</span>(ctx)<br>\t\t, <span class=\"hljs-built_in\">nwrite_</span>(<span class=\"hljs-number\">0</span>)<br>\t\t, <span class=\"hljs-built_in\">id_</span>(id)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">client_io_callback</span>()<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;&gt;&gt;&gt;ID: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot;, io_callback deleted now!&quot;</span> &lt;&lt; std::endl;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数, 当异步流读到所要求的数据时调用此回调函数</span><br><span class=\"hljs-comment\">\t * @param data &#123;char*&#125; 读到的数据地址</span><br><span class=\"hljs-comment\">\t * @param len &#123;int｝ 读到的数据长度</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">read_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* data, <span class=\"hljs-type\">int</span> len)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t(<span class=\"hljs-type\">void</span>) data;<br>\t\t(<span class=\"hljs-type\">void</span>) len;<br><br>\t\tctx_-&gt;nread_total++;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;debug)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (nwrite_ &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;gets(&quot;</span> &lt;&lt; nwrite_ &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; data;<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nwrite_ % <span class=\"hljs-number\">2000</span> == <span class=\"hljs-number\">0</span>)<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;&gt;&gt;ID: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot;, I: &quot;</span><br>\t\t\t\t\t&lt;&lt; nwrite_ &lt;&lt; <span class=\"hljs-string\">&quot;; &quot;</span>&lt;&lt;  data;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 如果收到服务器的退出消息，则也应退出</span><br>\t\t<span class=\"hljs-keyword\">if</span> (acl::<span class=\"hljs-built_in\">strncasecmp_</span>(data, <span class=\"hljs-string\">&quot;quit&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 向服务器发送数据</span><br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Bye!\\r\\n&quot;</span>);<br>\t\t\t<span class=\"hljs-comment\">// 关闭异步流连接</span><br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (nwrite_ &gt;= ctx_-&gt;nwrite_limit)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;debug)<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;ID: &quot;</span> &lt;&lt; id_<br>\t\t\t\t\t&lt;&lt; <span class=\"hljs-string\">&quot;, nwrite: &quot;</span> &lt;&lt; nwrite_<br>\t\t\t\t\t&lt;&lt; <span class=\"hljs-string\">&quot;, nwrite_limit: &quot;</span> &lt;&lt; ctx_-&gt;nwrite_limit<br>\t\t\t\t\t&lt;&lt; <span class=\"hljs-string\">&quot;, quiting ...&quot;</span> &lt;&lt; std::endl;<br><br>\t\t\t<span class=\"hljs-comment\">// 向服务器发送退出消息</span><br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;quit\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">char</span>  buf[<span class=\"hljs-number\">256</span>];<br>\t\t\t<span class=\"hljs-built_in\">snprintf</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf), <span class=\"hljs-string\">&quot;hello world: %d\\n&quot;</span>, nwrite_);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(buf, (<span class=\"hljs-type\">int</span>) <span class=\"hljs-built_in\">strlen</span>(buf));<br><br>\t\t\t<span class=\"hljs-comment\">// 向服务器发送数据</span><br>\t\t\t<span class=\"hljs-comment\">//client_-&gt;format(&quot;hello world: %d\\n&quot;, nwrite_);</span><br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数, 当异步流写成功时调用此回调函数</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tctx_-&gt;nwrite_total++;<br>\t\tnwrite_++;<br><br>\t\t<span class=\"hljs-comment\">// 从服务器读一行数据</span><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">gets</span>(ctx_-&gt;read_timeout, <span class=\"hljs-literal\">false</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数, 当该异步流关闭时调用此回调函数</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">close_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (client_-&gt;<span class=\"hljs-built_in\">is_opened</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Id: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot; connect &quot;</span><br>\t\t\t\t&lt;&lt; ctx_-&gt;addr &lt;&lt; <span class=\"hljs-string\">&quot; error: &quot;</span><br>\t\t\t\t&lt;&lt; acl::<span class=\"hljs-built_in\">last_serror</span>();<br><br>\t\t\t<span class=\"hljs-comment\">// 如果是第一次连接就失败，则退出</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;nopen_total == <span class=\"hljs-number\">0</span>)<br>\t\t\t&#123;<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;, first connect error, quit&quot;</span>;<br>\t\t\t\t<span class=\"hljs-comment\">/* 获得异步引擎句柄，并设置为退出状态 */</span><br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">stop</span>();<br>\t\t\t&#125;<br>\t\t\tstd::cout &lt;&lt; std::endl;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">/* 获得异步引擎中受监控的异步流个数 */</span><br>\t\t<span class=\"hljs-type\">int</span> nleft = client_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">length</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;nopen_total == ctx_-&gt;nopen_limit &amp;&amp; nleft == <span class=\"hljs-number\">1</span>)<br>\t\t&#123;<br>\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Id: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot; stop now! nstream: &quot;</span><br>\t\t\t\t&lt;&lt; nleft &lt;&lt; std::endl;<br>\t\t\t<span class=\"hljs-comment\">/* 获得异步引擎句柄，并设置为退出状态 */</span><br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">stop</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 必须在此处删除该动态分配的回调类对象以防止内存泄露</span><br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数，当异步流超时时调用此函数</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">timeout_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Connect &quot;</span> &lt;&lt; ctx_-&gt;addr &lt;&lt; <span class=\"hljs-string\">&quot; Timeout ...&quot;</span> &lt;&lt; std::endl;<br>\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">false</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数, 当异步连接成功后调用此函数</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">open_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 连接成功，设置IO读写回调函数</span><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">add_read_callback</span>(<span class=\"hljs-keyword\">this</span>);<br>\t\tclient_-&gt;<span class=\"hljs-built_in\">add_write_callback</span>(<span class=\"hljs-keyword\">this</span>);<br>\t\tctx_-&gt;nopen_total++;<br><br>\t\tacl::<span class=\"hljs-built_in\">assert_</span>(id_ &gt; <span class=\"hljs-number\">0</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;nopen_total &lt; ctx_-&gt;nopen_limit)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 开始进行下一个连接过程</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">connect_server</span>(ctx_, id_ + <span class=\"hljs-number\">1</span>) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;connect error!&quot;</span> &lt;&lt; std::endl;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 异步向服务器发送数据</span><br>\t\t<span class=\"hljs-comment\">//client_-&gt;format(&quot;hello world: %d\\n&quot;, nwrite_);</span><br>\t\t<span class=\"hljs-type\">char</span>  buf[<span class=\"hljs-number\">256</span>];<br>\t\t<span class=\"hljs-built_in\">snprintf</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf), <span class=\"hljs-string\">&quot;hello world: %d\\n&quot;</span>, nwrite_);<br>\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(buf, (<span class=\"hljs-type\">int</span>) <span class=\"hljs-built_in\">strlen</span>(buf));<br><br>\t\t<span class=\"hljs-comment\">// 异步从服务器读取一行数据</span><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">gets</span>(ctx_-&gt;read_timeout, <span class=\"hljs-literal\">false</span>);<br><br>\t\t<span class=\"hljs-comment\">// 表示继续异步过程</span><br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\taio_socket_stream* client_;<br>\tIO_CTX* ctx_;<br>\t<span class=\"hljs-type\">int</span>   nwrite_;<br>\t<span class=\"hljs-type\">int</span>   id_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">connect_server</span><span class=\"hljs-params\">(IO_CTX* ctx, <span class=\"hljs-type\">int</span> id)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 开始异步连接远程服务器</span><br>\taio_socket_stream* stream = aio_socket_stream::<span class=\"hljs-built_in\">open</span>(ctx-&gt;handle,<br>\t\t\tctx-&gt;addr, ctx-&gt;connect_timeout);<br>\t<span class=\"hljs-keyword\">if</span> (stream == <span class=\"hljs-literal\">NULL</span>)<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;connect &quot;</span> &lt;&lt; ctx-&gt;addr &lt;&lt; <span class=\"hljs-string\">&quot; error!&quot;</span> &lt;&lt; std::endl;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;stoping ...&quot;</span> &lt;&lt; std::endl;<br>\t\t<span class=\"hljs-keyword\">if</span> (id == <span class=\"hljs-number\">0</span>)<br>\t\t\tctx-&gt;handle-&gt;<span class=\"hljs-built_in\">stop</span>();<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">false</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 创建连接后的回调函数类</span><br>\tclient_io_callback* callback = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">client_io_callback</span>(ctx, stream, id);<br><br>\t<span class=\"hljs-comment\">// 添加连接成功的回调函数类</span><br>\tstream-&gt;<span class=\"hljs-built_in\">add_open_callback</span>(callback);<br><br>\t<span class=\"hljs-comment\">// 添加连接失败后回调函数类</span><br>\tstream-&gt;<span class=\"hljs-built_in\">add_close_callback</span>(callback);<br><br>\t<span class=\"hljs-comment\">// 添加连接超时的回调函数类</span><br>\tstream-&gt;<span class=\"hljs-built_in\">add_timeout_callback</span>(callback);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">bool</span> use_kernel = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-type\">int</span>   ch;<br>\tIO_CTX ctx;<br><br>\t<span class=\"hljs-built_in\">memset</span>(&amp;ctx, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(ctx));<br>\tctx.connect_timeout = <span class=\"hljs-number\">5</span>;<br>\tctx.nopen_limit = <span class=\"hljs-number\">10</span>;<br>\tctx.id_begin = <span class=\"hljs-number\">1</span>;<br>\tctx.nwrite_limit = <span class=\"hljs-number\">10</span>;<br>\tctx.debug = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-built_in\">snprintf</span>(ctx.addr, <span class=\"hljs-built_in\">sizeof</span>(ctx.addr), <span class=\"hljs-string\">&quot;127.0.0.1:9001&quot;</span>);<br><br>\t<span class=\"hljs-built_in\">acl_cpp_init</span>();<br><br>\t<span class=\"hljs-function\">aio_handle <span class=\"hljs-title\">handle</span><span class=\"hljs-params\">(ENGINE_KERNEL)</span></span>;<br>\tctx.handle = &amp;handle;<br><br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">connect_server</span>(&amp;ctx, ctx.id_begin) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;enter any key to exit.&quot;</span> &lt;&lt; std::endl;<br>\t\t<span class=\"hljs-built_in\">getchar</span>();<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Connect &quot;</span> &lt;&lt; ctx.addr &lt;&lt; <span class=\"hljs-string\">&quot; ...&quot;</span> &lt;&lt; std::endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 如果返回 false 则表示不再继续，需要退出</span><br>\t\t<span class=\"hljs-keyword\">if</span> (handle.<span class=\"hljs-built_in\">check</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>异步客户端的基本流程为：</p>\n<ul>\n<li>创建异步框架对象 aio_handle –&gt; 异步连接远程服务器，创建连接成功&#x2F;失败&#x2F;超时的异步接口类对象并注册至异步连接流中 –&gt; 异步框架进行事件循环中；</li>\n<li>连接成功后，异步接口类对象中的 open_callback 被调用，启动下一个异步连接过程（未达限制连接数前） –&gt; 添加异步读及异步写的回调接口类  –&gt; 异步写入数据，同时开始异步读数据过程；</li>\n<li>当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 –&gt; 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的 close_callback –&gt; 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。</li>\n</ul>\n<p>客户端异步连接流的接口类 aio_open_callback 的纯虚函数 virtual bool open_callback() 需要子类实现，在连接服务器成功后调用此函数，允许子类在该函数中做进一步操作，如：注册客户端流的异步读回调接口类对象及异步写回调类对象；如果连接超时或连接失败而导致的关闭，则基础接口类中的 timeout_callback() 或 close_callback() 将会被调用，以通知用户应用程序。</p>\n<h2 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h2><p>以上的示例演示了基本的非阻塞异步流的监听、读写、连接等过程，类的设计中也提供了基本的操作方法，为了应对实践中的多样性及复杂性，acl_cpp 的异步流还设计了更多的接口和方法，如：延迟读写操作（这对于限流的服务器比较有用处）、定时器操作等。</p>\n<p>更多例子参见：lib_acl_cpp&#x2F;samples&#x2F;aio&#x2F; 目录<br>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>acl 库的 C 库(lib_acl) 的 aio 模块设计了完整的非阻塞异步 IO 通信过程，在 acl 的C++库(lib_acl_cpp) 中封装并增强了异步通信的功能，本文主要描述了 acl C++ 库之非阻塞IO库的设计及使用方法，该异步流的设计思路为：异步流类与异步流接口类，其中异步流类对象完成网络套接口监听、连接、读写的操作，异步流接口类对象定义了网络读写成功&#x2F;超时回调、连接成功回调、接收客户端连接回调等接口；用户在进行异步编程时，首先必须实现接口类中定义的纯方法，然后将接口类对象在异步流对象中进行注册，这样当满足接口类对象的回调条件时 acl_cpp 的异步框架便自动调用用户定义的接口方法。</p>\n<p>在 acl_cpp 中异步流的类继续关系如下图所示：<br><img src=\"/img/aio_inherit.png\" alt=\"异步流类继承关系图\"></p>\n<p>由上图可以看出，基类 aio_stream 中定义了流关闭，注册&#x2F;取消流关闭回调和流超时回调等基础方法；aio_istream 和 aio_ostream 分别定义了异步流读及写的基本方法，aio_istream 中包含添加&#x2F;删除流读成功回调接口类对象的方法，aio_ostream 中包含添加&#x2F;删除流写成功回调接口类对象的方法；aio_socket_stream 类对象为连接服务器成功后的客户端流，或服务器接收到客户端连接创建的客户端连接流，其中定义了做为连接流时远程连接的方法及添加连接成功回调接口的方法；aio_listen_stream 类为监听流类，其中定义了监听某个网络地址（或UNIX下的域套接口地址）方法，以及注册接收成功接口的方法。</p>\n<p>acl_cpp 异步流接口类继承关系图如下图：<br><img src=\"/img/aio_callback.png\" alt=\"异步流类继承关系图\"></p>\n<p>异步流接口类的设计中：aio_accept_callback 为监听流的回调接口类，用户应继承该类以获得外来客户端连接流，同时还需要定义继承于 aio_callback 的类，用于获得网络读写操作等结果信息；aio_open_callback 只有当客户端连接远程服务器时，用户需要实现其子类获得连接成功的结果。</p>\n<h2 id=\"二、实例\"><a href=\"#二、实例\" class=\"headerlink\" title=\"二、实例\"></a>二、实例</h2><h3 id=\"1、异步服务器\"><a href=\"#1、异步服务器\" class=\"headerlink\" title=\"1、异步服务器\"></a>1、异步服务器</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_handle.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_istream.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_listen_stream.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_socket_stream.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 异步客户端流的回调类的子类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">io_callback</span> : <span class=\"hljs-keyword\">public</span> aio_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">io_callback</span>(aio_socket_stream* client)<br>\t\t: <span class=\"hljs-built_in\">client_</span>(client)<br>\t\t, <span class=\"hljs-built_in\">i_</span>(<span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">io_callback</span>()<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;delete io_callback now ...&quot;</span> &lt;&lt; std::endl;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的读成功回调过程</span><br><span class=\"hljs-comment\">\t * @param data &#123;char*&#125; 读到的数据地址</span><br><span class=\"hljs-comment\">\t * @param len &#123;int&#125; 读到的数据长度</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">read_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* data, <span class=\"hljs-type\">int</span> len)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\ti_++;<br>\t\t<span class=\"hljs-keyword\">if</span> (i_ &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;&gt;&gt;gets(i:&quot;</span> &lt;&lt; i_ &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; data;<br><br>\t\t<span class=\"hljs-comment\">// 如果远程客户端希望退出，则关闭之</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncasecmp</span>(data, <span class=\"hljs-string\">&quot;quit&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Bye!\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 如果远程客户端希望服务端也关闭，则中止异步事件过程</span><br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncasecmp</span>(data, <span class=\"hljs-string\">&quot;stop&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Stop now!\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();  <span class=\"hljs-comment\">// 关闭远程异步流</span><br><br>\t\t\t<span class=\"hljs-comment\">// 通知异步引擎关闭循环过程</span><br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">stop</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 向远程客户端回写收到的数据</span><br><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(data, len);<br><br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的写成功回调过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的超时回调过程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">close_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 必须在此处删除该动态分配的回调类对象以防止内存泄露</span><br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的超时回调过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">timeout_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Timeout ...&quot;</span> &lt;&lt; std::endl;<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\taio_socket_stream* client_;<br>\t<span class=\"hljs-type\">int</span>   i_;<br>&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 异步监听流的回调类的子类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">io_accept_callback</span> : <span class=\"hljs-keyword\">public</span> aio_accept_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">io_accept_callback</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">io_accept_callback</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;io_accept_callback over!\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数，当有新连接到达后调用此回调过程</span><br><span class=\"hljs-comment\">\t * @param client &#123;aio_socket_stream*&#125; 异步客户端流</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 以通知监听流继续监听</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">accept_callback</span><span class=\"hljs-params\">(aio_socket_stream* client)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 创建异步客户端流的回调对象并与该异步流进行绑定</span><br>\t\tio_callback* callback = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">io_callback</span>(client);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的读回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_read_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的写回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_write_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的关闭回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_close_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的超时回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_timeout_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 从异步流读一行数据</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">gets</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-literal\">false</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 初始化ACL库(尤其是在WIN32下一定要调用此函数，在UNIX平台下可不调用)</span><br>\t<span class=\"hljs-built_in\">acl_cpp_init</span>();<br><br>\t<span class=\"hljs-comment\">// 构建异步引擎类对象</span><br>\t<span class=\"hljs-function\">aio_handle <span class=\"hljs-title\">handle</span><span class=\"hljs-params\">(ENGINE_KERNEL)</span></span>;<br><br>\t<span class=\"hljs-comment\">// 创建监听异步流</span><br>\taio_listen_stream* sstream = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">aio_listen_stream</span>(&amp;handle);<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:9001&quot;</span>;<br><br>\t<span class=\"hljs-comment\">// 监听指定的地址</span><br>\t<span class=\"hljs-keyword\">if</span> (sstream-&gt;<span class=\"hljs-built_in\">open</span>(addr) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;open &quot;</span> &lt;&lt; addr &lt;&lt; <span class=\"hljs-string\">&quot; error!&quot;</span> &lt;&lt; std::endl;<br>\t\tsstream-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">XXX:</span> 为了保证能关闭监听流，应在此处再 check 一下</span><br>\t\thandle.<span class=\"hljs-built_in\">check</span>();<br><br>\t\t<span class=\"hljs-built_in\">getchar</span>();<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 创建回调类对象，当有新连接到达时自动调用此类对象的回调过程</span><br>\tio_accept_callback callback;<br>\tsstream-&gt;<span class=\"hljs-built_in\">add_accept_callback</span>(&amp;callback);<br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Listen: &quot;</span> &lt;&lt; addr &lt;&lt; <span class=\"hljs-string\">&quot; ok!&quot;</span> &lt;&lt; std::endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 如果返回 false 则表示不再继续，需要退出</span><br>\t\t<span class=\"hljs-keyword\">if</span> (handle.<span class=\"hljs-built_in\">check</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;aio_server stop now ...&quot;</span> &lt;&lt; std::endl;<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 关闭监听流并释放流对象</span><br>\tsstream-&gt;<span class=\"hljs-built_in\">close</span>();<br><br>\t<span class=\"hljs-comment\">// <span class=\"hljs-doctag\">XXX:</span> 为了保证能关闭监听流，应在此处再 check 一下</span><br>\thandle.<span class=\"hljs-built_in\">check</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>简要说明一下，上面代码的基本思路是：</p>\n<ul>\n<li>创建异步通信框架对象 aio_handle –&gt; 创建异步监听流 aio_listen_stream 并注册回调类对象 io_accept_callback–&gt;进入异步通信框架的事件循环中；</li>\n<li>当接收到客户端连接后，异步框架回调 io_accept_callback 类对象的 accept_callback 接口并将客户端异步流输入–&gt;创建异步流接口类对象，并将该对象注册至客户端异步流对象中;</li>\n<li>当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 –&gt; 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的close_callback –&gt; 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。</li>\n</ul>\n<p>异步监听流的接口类的纯虚函数：virtual bool accept_callback(aio_socket_stream* client)  需要子类实现，子类在该函数中获得客户端连接异步流对象。</p>\n<p>客户端异步流接口类 aio_callback 有四个虚函数：</p>\n<ul>\n<li><code>virtual bool read_callback(char* data, int len)</code>  当客户端异步流读到数据时的回调虚函数；</li>\n<li><code>virtual bool write_callback()</code> 当客户端异步流写数据成功后的回调虚函数；</li>\n<li><code>virtual void close_callback()</code> 当异步流(客户端流或监听流)关闭时的回调虚函数；</li>\n<li><code>virtual bool timeout_callback()</code> 当异步流（客户端流在读写超时或监听流在监听超时）超时时的回调函数虚函数。</li>\n</ul>\n<h3 id=\"2、异步客户端\"><a href=\"#2、异步客户端\" class=\"headerlink\" title=\"2、异步客户端\"></a>2、异步客户端</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;string.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;util.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_handle.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp_init.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;aio_socket_stream.hpp&quot;</span></span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">ifndef</span> snprintf</span><br><span class=\"hljs-meta\">#  <span class=\"hljs-keyword\">define</span> snprintf _snprintf</span><br><span class=\"hljs-meta\"># <span class=\"hljs-keyword\">endif</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span><br>&#123;<br>\t<span class=\"hljs-type\">char</span>  addr[<span class=\"hljs-number\">64</span>];<br>\taio_handle* handle;<br>\t<span class=\"hljs-type\">int</span>   connect_timeout;<br>\t<span class=\"hljs-type\">int</span>   read_timeout;<br>\t<span class=\"hljs-type\">int</span>   nopen_limit;<br>\t<span class=\"hljs-type\">int</span>   nopen_total;<br>\t<span class=\"hljs-type\">int</span>   nwrite_limit;<br>\t<span class=\"hljs-type\">int</span>   nwrite_total;<br>\t<span class=\"hljs-type\">int</span>   nread_total;<br>\t<span class=\"hljs-type\">int</span>   id_begin;<br>\t<span class=\"hljs-type\">bool</span>  debug;<br>&#125; IO_CTX;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">connect_server</span><span class=\"hljs-params\">(IO_CTX* ctx, <span class=\"hljs-type\">int</span> id)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 客户端异步连接流回调函数类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">client_io_callback</span> : <span class=\"hljs-keyword\">public</span> aio_open_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 构造函数</span><br><span class=\"hljs-comment\">\t * @param ctx &#123;IO_CTX*&#125;</span><br><span class=\"hljs-comment\">\t * @param client &#123;aio_socket_stream*&#125; 异步连接流</span><br><span class=\"hljs-comment\">\t * @param id &#123;int&#125; 本流的ID号</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-built_in\">client_io_callback</span>(IO_CTX* ctx, aio_socket_stream* client, <span class=\"hljs-type\">int</span> id)<br>\t\t: <span class=\"hljs-built_in\">client_</span>(client)<br>\t\t, <span class=\"hljs-built_in\">ctx_</span>(ctx)<br>\t\t, <span class=\"hljs-built_in\">nwrite_</span>(<span class=\"hljs-number\">0</span>)<br>\t\t, <span class=\"hljs-built_in\">id_</span>(id)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">client_io_callback</span>()<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;&gt;&gt;&gt;ID: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot;, io_callback deleted now!&quot;</span> &lt;&lt; std::endl;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数, 当异步流读到所要求的数据时调用此回调函数</span><br><span class=\"hljs-comment\">\t * @param data &#123;char*&#125; 读到的数据地址</span><br><span class=\"hljs-comment\">\t * @param len &#123;int｝ 读到的数据长度</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">read_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* data, <span class=\"hljs-type\">int</span> len)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t(<span class=\"hljs-type\">void</span>) data;<br>\t\t(<span class=\"hljs-type\">void</span>) len;<br><br>\t\tctx_-&gt;nread_total++;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;debug)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (nwrite_ &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;gets(&quot;</span> &lt;&lt; nwrite_ &lt;&lt; <span class=\"hljs-string\">&quot;): &quot;</span> &lt;&lt; data;<br>\t\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (nwrite_ % <span class=\"hljs-number\">2000</span> == <span class=\"hljs-number\">0</span>)<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;&gt;&gt;ID: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot;, I: &quot;</span><br>\t\t\t\t\t&lt;&lt; nwrite_ &lt;&lt; <span class=\"hljs-string\">&quot;; &quot;</span>&lt;&lt;  data;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 如果收到服务器的退出消息，则也应退出</span><br>\t\t<span class=\"hljs-keyword\">if</span> (acl::<span class=\"hljs-built_in\">strncasecmp_</span>(data, <span class=\"hljs-string\">&quot;quit&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 向服务器发送数据</span><br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Bye!\\r\\n&quot;</span>);<br>\t\t\t<span class=\"hljs-comment\">// 关闭异步流连接</span><br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (nwrite_ &gt;= ctx_-&gt;nwrite_limit)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;debug)<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;ID: &quot;</span> &lt;&lt; id_<br>\t\t\t\t\t&lt;&lt; <span class=\"hljs-string\">&quot;, nwrite: &quot;</span> &lt;&lt; nwrite_<br>\t\t\t\t\t&lt;&lt; <span class=\"hljs-string\">&quot;, nwrite_limit: &quot;</span> &lt;&lt; ctx_-&gt;nwrite_limit<br>\t\t\t\t\t&lt;&lt; <span class=\"hljs-string\">&quot;, quiting ...&quot;</span> &lt;&lt; std::endl;<br><br>\t\t\t<span class=\"hljs-comment\">// 向服务器发送退出消息</span><br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;quit\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span><br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">char</span>  buf[<span class=\"hljs-number\">256</span>];<br>\t\t\t<span class=\"hljs-built_in\">snprintf</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf), <span class=\"hljs-string\">&quot;hello world: %d\\n&quot;</span>, nwrite_);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(buf, (<span class=\"hljs-type\">int</span>) <span class=\"hljs-built_in\">strlen</span>(buf));<br><br>\t\t\t<span class=\"hljs-comment\">// 向服务器发送数据</span><br>\t\t\t<span class=\"hljs-comment\">//client_-&gt;format(&quot;hello world: %d\\n&quot;, nwrite_);</span><br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数, 当异步流写成功时调用此回调函数</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tctx_-&gt;nwrite_total++;<br>\t\tnwrite_++;<br><br>\t\t<span class=\"hljs-comment\">// 从服务器读一行数据</span><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">gets</span>(ctx_-&gt;read_timeout, <span class=\"hljs-literal\">false</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数, 当该异步流关闭时调用此回调函数</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">close_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (client_-&gt;<span class=\"hljs-built_in\">is_opened</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Id: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot; connect &quot;</span><br>\t\t\t\t&lt;&lt; ctx_-&gt;addr &lt;&lt; <span class=\"hljs-string\">&quot; error: &quot;</span><br>\t\t\t\t&lt;&lt; acl::<span class=\"hljs-built_in\">last_serror</span>();<br><br>\t\t\t<span class=\"hljs-comment\">// 如果是第一次连接就失败，则退出</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;nopen_total == <span class=\"hljs-number\">0</span>)<br>\t\t\t&#123;<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;, first connect error, quit&quot;</span>;<br>\t\t\t\t<span class=\"hljs-comment\">/* 获得异步引擎句柄，并设置为退出状态 */</span><br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">stop</span>();<br>\t\t\t&#125;<br>\t\t\tstd::cout &lt;&lt; std::endl;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">/* 获得异步引擎中受监控的异步流个数 */</span><br>\t\t<span class=\"hljs-type\">int</span> nleft = client_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">length</span>();<br>\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;nopen_total == ctx_-&gt;nopen_limit &amp;&amp; nleft == <span class=\"hljs-number\">1</span>)<br>\t\t&#123;<br>\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Id: &quot;</span> &lt;&lt; id_ &lt;&lt; <span class=\"hljs-string\">&quot; stop now! nstream: &quot;</span><br>\t\t\t\t&lt;&lt; nleft &lt;&lt; std::endl;<br>\t\t\t<span class=\"hljs-comment\">/* 获得异步引擎句柄，并设置为退出状态 */</span><br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">stop</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 必须在此处删除该动态分配的回调类对象以防止内存泄露</span><br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数，当异步流超时时调用此函数</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">timeout_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Connect &quot;</span> &lt;&lt; ctx_-&gt;addr &lt;&lt; <span class=\"hljs-string\">&quot; Timeout ...&quot;</span> &lt;&lt; std::endl;<br>\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">false</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 基类虚函数, 当异步连接成功后调用此函数</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回给调用者 true 表示继续，否则表示需要关闭异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">open_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 连接成功，设置IO读写回调函数</span><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">add_read_callback</span>(<span class=\"hljs-keyword\">this</span>);<br>\t\tclient_-&gt;<span class=\"hljs-built_in\">add_write_callback</span>(<span class=\"hljs-keyword\">this</span>);<br>\t\tctx_-&gt;nopen_total++;<br><br>\t\tacl::<span class=\"hljs-built_in\">assert_</span>(id_ &gt; <span class=\"hljs-number\">0</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (ctx_-&gt;nopen_total &lt; ctx_-&gt;nopen_limit)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 开始进行下一个连接过程</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">connect_server</span>(ctx_, id_ + <span class=\"hljs-number\">1</span>) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;connect error!&quot;</span> &lt;&lt; std::endl;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 异步向服务器发送数据</span><br>\t\t<span class=\"hljs-comment\">//client_-&gt;format(&quot;hello world: %d\\n&quot;, nwrite_);</span><br>\t\t<span class=\"hljs-type\">char</span>  buf[<span class=\"hljs-number\">256</span>];<br>\t\t<span class=\"hljs-built_in\">snprintf</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf), <span class=\"hljs-string\">&quot;hello world: %d\\n&quot;</span>, nwrite_);<br>\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(buf, (<span class=\"hljs-type\">int</span>) <span class=\"hljs-built_in\">strlen</span>(buf));<br><br>\t\t<span class=\"hljs-comment\">// 异步从服务器读取一行数据</span><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">gets</span>(ctx_-&gt;read_timeout, <span class=\"hljs-literal\">false</span>);<br><br>\t\t<span class=\"hljs-comment\">// 表示继续异步过程</span><br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\taio_socket_stream* client_;<br>\tIO_CTX* ctx_;<br>\t<span class=\"hljs-type\">int</span>   nwrite_;<br>\t<span class=\"hljs-type\">int</span>   id_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">connect_server</span><span class=\"hljs-params\">(IO_CTX* ctx, <span class=\"hljs-type\">int</span> id)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 开始异步连接远程服务器</span><br>\taio_socket_stream* stream = aio_socket_stream::<span class=\"hljs-built_in\">open</span>(ctx-&gt;handle,<br>\t\t\tctx-&gt;addr, ctx-&gt;connect_timeout);<br>\t<span class=\"hljs-keyword\">if</span> (stream == <span class=\"hljs-literal\">NULL</span>)<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;connect &quot;</span> &lt;&lt; ctx-&gt;addr &lt;&lt; <span class=\"hljs-string\">&quot; error!&quot;</span> &lt;&lt; std::endl;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;stoping ...&quot;</span> &lt;&lt; std::endl;<br>\t\t<span class=\"hljs-keyword\">if</span> (id == <span class=\"hljs-number\">0</span>)<br>\t\t\tctx-&gt;handle-&gt;<span class=\"hljs-built_in\">stop</span>();<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">false</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 创建连接后的回调函数类</span><br>\tclient_io_callback* callback = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">client_io_callback</span>(ctx, stream, id);<br><br>\t<span class=\"hljs-comment\">// 添加连接成功的回调函数类</span><br>\tstream-&gt;<span class=\"hljs-built_in\">add_open_callback</span>(callback);<br><br>\t<span class=\"hljs-comment\">// 添加连接失败后回调函数类</span><br>\tstream-&gt;<span class=\"hljs-built_in\">add_close_callback</span>(callback);<br><br>\t<span class=\"hljs-comment\">// 添加连接超时的回调函数类</span><br>\tstream-&gt;<span class=\"hljs-built_in\">add_timeout_callback</span>(callback);<br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-literal\">true</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">bool</span> use_kernel = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-type\">int</span>   ch;<br>\tIO_CTX ctx;<br><br>\t<span class=\"hljs-built_in\">memset</span>(&amp;ctx, <span class=\"hljs-number\">0</span>, <span class=\"hljs-built_in\">sizeof</span>(ctx));<br>\tctx.connect_timeout = <span class=\"hljs-number\">5</span>;<br>\tctx.nopen_limit = <span class=\"hljs-number\">10</span>;<br>\tctx.id_begin = <span class=\"hljs-number\">1</span>;<br>\tctx.nwrite_limit = <span class=\"hljs-number\">10</span>;<br>\tctx.debug = <span class=\"hljs-literal\">false</span>;<br>\t<span class=\"hljs-built_in\">snprintf</span>(ctx.addr, <span class=\"hljs-built_in\">sizeof</span>(ctx.addr), <span class=\"hljs-string\">&quot;127.0.0.1:9001&quot;</span>);<br><br>\t<span class=\"hljs-built_in\">acl_cpp_init</span>();<br><br>\t<span class=\"hljs-function\">aio_handle <span class=\"hljs-title\">handle</span><span class=\"hljs-params\">(ENGINE_KERNEL)</span></span>;<br>\tctx.handle = &amp;handle;<br><br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">connect_server</span>(&amp;ctx, ctx.id_begin) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;enter any key to exit.&quot;</span> &lt;&lt; std::endl;<br>\t\t<span class=\"hljs-built_in\">getchar</span>();<br>\t\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\tstd::cout &lt;&lt; <span class=\"hljs-string\">&quot;Connect &quot;</span> &lt;&lt; ctx.addr &lt;&lt; <span class=\"hljs-string\">&quot; ...&quot;</span> &lt;&lt; std::endl;<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 如果返回 false 则表示不再继续，需要退出</span><br>\t\t<span class=\"hljs-keyword\">if</span> (handle.<span class=\"hljs-built_in\">check</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>异步客户端的基本流程为：</p>\n<ul>\n<li>创建异步框架对象 aio_handle –&gt; 异步连接远程服务器，创建连接成功&#x2F;失败&#x2F;超时的异步接口类对象并注册至异步连接流中 –&gt; 异步框架进行事件循环中；</li>\n<li>连接成功后，异步接口类对象中的 open_callback 被调用，启动下一个异步连接过程（未达限制连接数前） –&gt; 添加异步读及异步写的回调接口类  –&gt; 异步写入数据，同时开始异步读数据过程；</li>\n<li>当客户端异步流收到数据时回调异步流接口中的 read_callback 方法 –&gt; 回写收到数据至客户端；当客户端流连接关闭时回调异步流接口中的 close_callback –&gt; 如果该接口类对象是动态创建的则需要手工 delete 掉；当接收客户端数据超时时会回调异步流接口中的 time_callback，该函数如果返回 true 则表示希望异步框架不关闭该客户端异步流，否则则关闭。</li>\n</ul>\n<p>客户端异步连接流的接口类 aio_open_callback 的纯虚函数 virtual bool open_callback() 需要子类实现，在连接服务器成功后调用此函数，允许子类在该函数中做进一步操作，如：注册客户端流的异步读回调接口类对象及异步写回调类对象；如果连接超时或连接失败而导致的关闭，则基础接口类中的 timeout_callback() 或 close_callback() 将会被调用，以通知用户应用程序。</p>\n<h2 id=\"三、小结\"><a href=\"#三、小结\" class=\"headerlink\" title=\"三、小结\"></a>三、小结</h2><p>以上的示例演示了基本的非阻塞异步流的监听、读写、连接等过程，类的设计中也提供了基本的操作方法，为了应对实践中的多样性及复杂性，acl_cpp 的异步流还设计了更多的接口和方法，如：延迟读写操作（这对于限流的服务器比较有用处）、定时器操作等。</p>\n<p>更多例子参见：lib_acl_cpp&#x2F;samples&#x2F;aio&#x2F; 目录<br>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"用 acl::master_aio 类编写高并发非阻塞服务器程序","date":"2012-05-30T14:15:00.000Z","_content":"\n在文章《使用 acl::master_threads 类编写多进程多线程服务器程序》讲述了如何编写 LINUX 平台下阻塞式服务器程序的多线程。虽然这种模式都可以处理并发任务，并且效率也不低，但是毕竟线程和进程资源是操作系统的宝贵资源，如果要支持非常高的并发请求，则会因为系统限制而不能创建更多的进程或线程。大家常见的 webserver Nginx 就是以支持高并发而闻名，Nginx 本身就是非阻塞设计的典型应用，当然还有很多其它服务器程序也是非阻塞的：ircd、Squid、Varnish、Bind 等。\n\n因为非阻塞程序编写有一定难度，所以现在有人在写非阻塞程序时不得不转向 Erlang、Nodejs 等一些脚本式语言，要想用 C/C++ 来实现非阻塞程序还是有些难度：系统级 API 过于底层、容易出错、难于调试。虽然也有一些 C++ 库（象ACE）提供了非阻塞库，但这些库的入门门槛还是挺高的。根据本人多年在非阻塞编程方面的经验，总结出一套比较实用的 C/C++ 非阻塞函数库，本文就讲述如果使用 acl_cpp 库中的 master_aio 类来编写非阻塞服务器程序（该服务器程序可以规定启动最大进程的个数，其中每个进程是一个独立的非阻塞进程）。在文章《非阻塞网络编程实例讲解》中给出了一个非阻塞网络程序的示例，您可以参考一下。\n\n## 一、类接口定义\nmaster_aio 是一个纯虚类，其中定义的接口需要子类实现，子类实例必须只能创建一个实例，接口如下：\n```c++\n\t/**\n\t * 纯虚函数：当接收到一个客户端连接时调用此函数\n\t * @param stream {aio_socket_stream*} 新接收到的客户端异步流对象\n\t * @return {bool} 该函数如果返回 false 则通知服务器框架不再接收\n\t *  远程客户端连接，否则继续接收客户端连接\n\t */\n\tvirtual bool on_accept(aio_socket_stream* stream) = 0;\n```\n\nmaster_aio 提供了四个外部方法，如下：\n```c++\n\t/**\n\t * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架\n\t * 控制之下运行，一般用于生产机状态\n\t * @param argc {int} 从 main 中传递的第一个参数，表示参数个数\n\t * @param argv {char**} 从 main 中传递的第二个参数\n\t */\n\tvoid run_daemon(int argc, char** argv);\n\n\t/**\n\t * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作\n\t * @param addr {const char*} 服务监听地址\n\t * @param conf {const char*} 配置文件全路径\n\t * @param ht {aio_handle_type} 事件引擎的类型\n\t * @return {bool} 监听是否成功\n\t */\n\tbool run_alone(const char* addr, const char* conf = NULL,\n\t\taio_handle_type ht = ENGINE_SELECT);\n\n\t/**\n\t * 获得异步IO的事件引擎句柄，通过此句柄，用户可以设置定时器等功能\n\t * @return {aio_handle*}\n\t */\n\taio_handle* get_handle() const;\n\n\t/**\n\t * 在 run_alone 模式下，通知服务器框架关闭引擎，退出程序\n\t */\n\tvoid stop();\n```\n\n从上面两个函数，可以看出 master_aio 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。\n\nmaster_aio 的基类 master_base 的几个虚接口如下：\n```c++ \n\t/**\n\t * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些\n\t * 用户身份为 root 的权限操作\n\t */\n\tvirtual void proc_pre_jail() {}\n\n\t/**\n\t * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程\n\t * 的权限为普通受限级别\n\t */\n\tvirtual void proc_on_init() {}\n\n\t/**\n\t * 当进程退出前调用的回调函数\n\t */\n\tvirtual void proc_on_exit() {}\n\n\t// 在 run_alone 状态下运行前，调用此函数初始化一些配置\n```\n\n基类的这几个虚函数用户可以根据需要调用。\n\n另外，基类 master_base 还提供了几个用来读配置选项的函数：\n```c++\n\t/**\n\t * 设置 bool 类型的配置项\n\t * @param table {master_bool_tbl*}\n\t */\n\tvoid set_cfg_bool(master_bool_tbl* table);\n\n\t/**\n\t * 设置 int 类型的配置项\n\t * @param table {master_int_tbl*}\n\t */\n\tvoid set_cfg_int(master_int_tbl* table);\n\n\t/**\n\t * 设置 int64 类型的配置项\n\t * @param table {master_int64_tbl*}\n\t */\n\tvoid set_cfg_int64(master_int64_tbl* table);\n\n\t/**\n\t * 设置 字符串 类型的配置项\n\t * @param table {master_str_tbl*}\n\t */\n\tvoid set_cfg_str(master_str_tbl* table);\n```\n\n## 二、示例源程序\n```c++\n// master_aio.cpp : 定义控制台应用程序的入口点。\n//\n\n#include \"stdafx.h\"\n#include \"lib_acl.hpp\"\n\nstatic char *var_cfg_debug_msg;\n\nstatic acl::master_str_tbl var_conf_str_tab[] = {\n\t{ \"debug_msg\", \"test_msg\", &var_cfg_debug_msg },\n\n\t{ 0, 0, 0 }\n};\n\nstatic int  var_cfg_debug_enable;\nstatic int  var_cfg_keep_alive;\nstatic int  var_cfg_send_banner;\n\nstatic acl::master_bool_tbl var_conf_bool_tab[] = {\n\t{ \"debug_enable\", 1, &var_cfg_debug_enable },\n\t{ \"keep_alive\", 1, &var_cfg_keep_alive },\n\t{ \"send_banner\", 1, &var_cfg_send_banner },\n\n\t{ 0, 0, 0 }\n};\n\nstatic int  var_cfg_io_timeout;\n\nstatic acl::master_int_tbl var_conf_int_tab[] = {\n\t{ \"io_timeout\", 120, &var_cfg_io_timeout, 0, 0 },\n\n\t{ 0, 0 , 0 , 0, 0 }\n};\n\nstatic void (*format)(const char*, ...) = acl::log::msg1;\n\nusing namespace acl;\n\n//////////////////////////////////////////////////////////////////////////\n/**\n * 延迟读回调处理类\n */\nclass timer_reader: public aio_timer_reader\n{\npublic:\n\ttimer_reader(int delay)\n\t{\n\t\tdelay_ = delay;\n\t\tformat(\"timer_reader init, delay: %d\\r\\n\", delay);\n\t}\n\n\t~timer_reader()\n\t{\n\t}\n\n\t// aio_timer_reader 的子类必须重载 destroy 方法\n\tvoid destroy()\n\t{\n\t\tformat(\"timer_reader delete, delay: %d\\r\\n\", delay_);\n\t\tdelete this;\n\t}\n\n\t// 重载基类回调方法\n\tvoid timer_callback(unsigned int id)\n\t{\n\t\tformat(\"timer_reader(%u): timer_callback, delay: %d\\r\\n\", id, delay_);\n\n\t\t// 调用基类的处理过程\n\t\taio_timer_reader::timer_callback(id);\n\t}\n\nprivate:\n\tint   delay_;\n};\n\n/**\n * 延迟写回调处理类\n */\nclass timer_writer: public aio_timer_writer\n{\npublic:\n\ttimer_writer(int delay)\n\t{\n\t\tdelay_ = delay;\n\t\tformat(\"timer_writer init, delay: %d\\r\\n\", delay);\n\t}\n\n\t~timer_writer()\n\t{\n\t}\n\n\t// aio_timer_reader 的子类必须重载 destroy 方法\n\tvoid destroy()\n\t{\n\t\tformat(\"timer_writer delete, delay: %d\\r\\n\", delay_);\n\t\tdelete this;\n\t}\n\n\t// 重载基类回调方法\n\tvoid timer_callback(unsigned int id)\n\t{\n\t\tformat(\"timer_writer(%u): timer_callback, delay: %u\\r\\n\", id, delay_);\n\n\t\t// 调用基类的处理过程\n\t\taio_timer_writer::timer_callback(id);\n\t}\n\nprivate:\n\tint   delay_;\n};\n\nclass timer_test : public aio_timer_callback\n{\npublic:\n\ttimer_test() {}\n\t~timer_test() {}\nprotected:\n\t// 基类纯虚函数\n\tvoid timer_callback(unsigned int id)\n\t{\n\t\tformat(\"id: %u\\r\\n\", id);\n\t}\n\n\tvoid destroy(void)\n\t{\n\t\tdelete this;\n\t\tformat(\"timer delete now\\r\\n\");\n\t}\n};\n\n/**\n * 异步客户端流的回调类的子类\n */\nclass io_callback : public aio_callback\n{\npublic:\n\tio_callback(aio_socket_stream* client)\n\t\t: client_(client)\n\t\t, i_(0)\n\t{\n\t}\n\n\t~io_callback()\n\t{\n\t\tformat(\"delete io_callback now ...\\r\\n\");\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的读成功回调过程\n\t * @param data {char*} 读到的数据地址\n\t * @param len {int} 读到的数据长度\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool read_callback(char* data, int len)\n\t{\n\t\tif (++i_ < 10)\n\t\t\tformat(\">>gets(i: %d): %s\\r\\n\", i_, data);\n\n\t\t// 如果远程客户端希望退出，则关闭之\n\t\tif (strncmp(data, \"quit\", 4) == 0)\n\t\t{\n\t\t\tclient_->format(\"Bye!\\r\\n\");\n\t\t\tclient_->close();\n\t\t}\n\n\t\t// 如果远程客户端希望服务端也关闭，则中止异步事件过程\n\t\telse if (strncmp(data, \"stop\", 4) == 0)\n\t\t{\n\t\t\tclient_->format(\"Stop now!\\r\\n\");\n\t\t\tclient_->close();  // 关闭远程异步流\n\n\t\t\t// 通知异步引擎关闭循环过程\n\t\t\tclient_->get_handle().stop();\n\t\t}\n\n\t\t// 向远程客户端回写收到的数据\n\n\t\tint   delay = 0;\n\n\t\tif (strncmp(data, \"write_delay\", strlen(\"write_delay\")) == 0)\n\t\t{\n\t\t\t// 延迟写过程\n\n\t\t\tconst char* ptr = data + strlen(\"write_delay\");\n\t\t\tdelay = atoi(ptr);\n\t\t\tif (delay > 0)\n\t\t\t{\n\t\t\t\tformat(\">> write delay %d second ...\\r\\n\", delay);\n\t\t\t\ttimer_writer* timer = new timer_writer(delay);\n\t\t\t\tclient_->write(data, len, delay * 1000000, timer);\n\t\t\t\tclient_->gets(10, false);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(data, \"read_delay\", strlen(\"read_delay\")) == 0)\n\t\t{\n\t\t\t// 延迟读过程\n\n\t\t\tconst char* ptr = data + strlen(\"read_delay\");\n\t\t\tdelay = atoi(ptr);\n\t\t\tif (delay > 0)\n\t\t\t{\n\t\t\t\tclient_->write(data, len);\n\t\t\t\tformat(\">> read delay %d second ...\\r\\n\", delay);\n\t\t\t\ttimer_reader* timer = new timer_reader(delay);\n\t\t\t\tclient_->gets(10, false, delay * 1000000, timer);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tclient_->write(data, len);\n\t\t//client_->gets(10, false);\n\t\treturn true;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的写成功回调过程\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool write_callback()\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的关闭回调过程\n\t */\n\tvoid close_callback()\n\t{\n\t\t// 必须在此处删除该动态分配的回调类对象以防止内存泄露\n\t\tdelete this;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的超时回调过程\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool timeout_callback()\n\t{\n\t\tformat(\"Timeout ...\\r\\n\");\n\t\treturn true;\n\t}\n\nprivate:\n\taio_socket_stream* client_;\n\tint   i_;\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nclass master_aio_test : public master_aio\n{\npublic:\n\tmaster_aio_test() { timer_test_ = new timer_test(); }\n\n\t~master_aio_test() { handle_->keep_timer(false); }\n\nprotected:\n\t// 基类纯虚函数：当接收到一个新的连接时调用此函数\n\tbool on_accept(aio_socket_stream* client)\n\t{\n\t\t// 创建异步客户端流的回调对象并与该异步流进行绑定\n\t\tio_callback* callback = new io_callback(client);\n\n\t\t// 注册异步流的读回调过程\n\t\tclient->add_read_callback(callback);\n\n\t\t// 注册异步流的写回调过程\n\t\tclient->add_write_callback(callback);\n\n\t\t// 注册异步流的关闭回调过程\n\t\tclient->add_close_callback(callback);\n\n\t\t// 注册异步流的超时回调过程\n\t\tclient->add_timeout_callback(callback);\n\n\t\t// 写欢迎信息\n\t\tif (var_cfg_send_banner)\n\t\t\tclient->format(\"hello, you're welcome\\r\\n\");\n\n\t\t// 从异步流读一行数据\n\t\tclient->gets(10, false);\n\t\t//client->read();\n\t\treturn true;\n\t}\n\n\t// 基类虚函数：服务进程切换用户身份前调用此函数\n\tvoid proc_pre_jail()\n\t{\n\t\tformat(\"proc_pre_jail\\r\\n\");\n\t\t// 只有当程序启动后才能获得异步引擎句柄\n\t\thandle_ = get_handle();\n\t\thandle_->keep_timer(true); // 允许定时器被重复触发\n\t\t// 设置第一个定时任务，每隔1秒触发一次，定时任务ID为0\n\t\thandle_->set_timer(timer_test_, 1000000, 0);\n\t}\n\n\t// 基类虚函数：服务进程切换用户身份后调用此函数\n\tvoid proc_on_init()\n\t{\n\t\tformat(\"proc init\\r\\n\");\n\t\t// 设置第二个定时任务，每隔2秒触发一次，定时任务ID为1\n\t\thandle_->set_timer(timer_test_, 2000000, 1);\n\t}\n\n\t// 基类虚函数：服务进程退出前调用此函数\n\tvoid proc_on_exit()\n\t{\n\t\tformat(\"proc exit\\r\\n\");\n\t}\nprivate:\n\ttimer_test* timer_test_;\n\taio_handle* handle_;\n};\n//////////////////////////////////////////////////////////////////////////\n\nint main(int argc, char* argv[])\n{\n\tmaster_aio_test ma;  // master_aio 要求只能起一个实例\n\n\t// 设置配置参数表\n\tma.set_cfg_int(var_conf_int_tab);\n\tma.set_cfg_int64(NULL);\n\tma.set_cfg_str(var_conf_str_tab);\n\tma.set_cfg_bool(var_conf_bool_tab);\n\n\t// 开始运行\n\n\tif (argc >= 2 && strcmp(argv[1], \"alone\") == 0)\n\t{\n\t\tconst char* addr = \"127.0.0.1:8888\";\n\n\t\tif (argc >= 3)\n\t\t\taddr = argv[2];\n\n\t\tformat = (void (*)(const char*, ...)) printf;\n\t\tformat(\"listen: %s now\\r\\n\", addr);\n\t\tma.run_alone(addr);  // 单独运行方式\n\t}\n\telse\n\t\tma.run_daemon(argc, argv);  // acl_master 控制模式运行\n\treturn 0;\n}\n```\n\n该示例主要实现几个功能：接收一行数据并回写该数据、延迟回写所读的数据、延迟读下一行数据、设置定时器的定时任务。因为 master_aio 类是按非阻塞模式设计的（其实，该类主要对 acl 库中的非阻塞框架库用 C++ 进行了封装），所以该例子可以支持非常大的并发请求。可以通过配置文件指定系统事件 API 选择采用 select/poll/epoll 中的一种、规定进程的空闲退出时间、预先启动子进程的数量等参数。该例子所在目录：acl_cpp/samples/master_aio。\n\n在这个例子中，当服务端接收到客户端连接后，非阻塞框架会通过虚函数  on_accept 回调子类处理过程，子类需要在这个虚函数中需要将一个处理 IO 过程的类实例与这个非阻塞连接流进行绑定（通过 add_xxx_callback 方式），其中处理 IO 过程的类的基类定义为：aio_callback，子类需要实现其中的虚方法。\n\n## 三、配置文件及程序安装\n打开 acl_cpp/samples/master_aio/aio_echo.cf 配置文件，就其中几个配置参数说明一下：\n\n```\n## 由 acl_master 用来控制服务进程池的配置项\n# 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程\nmaster_disable = no\n\n# 表示本服务器进程监听 127.0.0.1 的 8888 端口\nmaster_service = 127.0.0.1:8888\n\n# 表示是 TCP 套接口服务类型\nmaster_type = inet\n\n# 表示该服务进程池的最大进程数为 2\nmaster_maxproc = 2\n\n# 需要预先启动的进程数，该值不应大于 master_maxproc\nmaster_prefork = 2\n\n# 进程程序名\nmaster_command = aio_echo\n\n# 进程日志记录文件，其中 {install_path} 需要用实际的安装路径代替\nmaster_log = {install_path}/var/log/aio_echo.log\n \n# 用 select 进行循环时的时间间隔\n# 单位为秒\naio_delay_sec = 1\n# 单位为微秒\naio_delay_usec = 500\n# 采用事件循环的方式: select(default), poll, kernel(epoll/devpoll/kqueue)\naio_event_mode = select\n# 是否将 socket 接收与IO功能分开: yes/no, 如果为 yes 可以大大提高 accept() 速度\naio_accept_alone = yes\n# 线程池的最大线程数, 如果该值为0则表示采用单线程非阻塞模式.\naio_max_threads = 0\n# 每个线程的空闲时间.\naio_thread_idle_limit = 60\n# 允许访问的客户端IP地址范围\naio_access_allow = 10.0.0.1:255.255.255.255, 127.0.0.1:127.0.0.1\n# 当 acl_master 退出时，如果该值置1则该程序不等所有连接处理完毕便立即退出\naio_quick_abort = 1\n```\n\n例如当 acl_master 服务器框架程序的安装目录为：/opt/acl，则：\n\n- /opt/acl/libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；\n- /opt/acl/conf：该目录存放 acl_master 程序配置文件 main.cf；\n- /opt/acl/conf/service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；\n- /opt/acl/var/log：该目录存放日志文件；\n- /opt/acl/var/pid：该目录存放进程号文件。\n\n该程序编译通过后，需要把可执行程序放在 /opt/acl/libexec 目录下，把配置文件放在 /opt/acl/conf/service 目录下。\n\n在 /opt/acl/sh 下有启动/停止 acl_master 服务进程的控制脚本；运行脚本：./start.sh，然后请用下面方法检查服务是否已经启动：\n\nps -ef|grep acl_master # 查看服务器控制进程是否已经启动\n\nnetstat -nap|grep LISTEN|grep 5001 # 查看服务端口号是否已经被监听\n\n当然，您也可以查看 /opt/acl/var/log/acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。\n\n可以命令行如下测试：telnet 127.0.0.1 8888\n\ngithub: https://github.com/acl-dev/acl\ngitee: https://gitee.com/acl-dev/acl\n \n","source":"_posts/master_aio.md","raw":"---\ntitle: 用 acl::master_aio 类编写高并发非阻塞服务器程序\ndate: 2012-05-30 22:15\ncategories: 服务编程\n---\n\n在文章《使用 acl::master_threads 类编写多进程多线程服务器程序》讲述了如何编写 LINUX 平台下阻塞式服务器程序的多线程。虽然这种模式都可以处理并发任务，并且效率也不低，但是毕竟线程和进程资源是操作系统的宝贵资源，如果要支持非常高的并发请求，则会因为系统限制而不能创建更多的进程或线程。大家常见的 webserver Nginx 就是以支持高并发而闻名，Nginx 本身就是非阻塞设计的典型应用，当然还有很多其它服务器程序也是非阻塞的：ircd、Squid、Varnish、Bind 等。\n\n因为非阻塞程序编写有一定难度，所以现在有人在写非阻塞程序时不得不转向 Erlang、Nodejs 等一些脚本式语言，要想用 C/C++ 来实现非阻塞程序还是有些难度：系统级 API 过于底层、容易出错、难于调试。虽然也有一些 C++ 库（象ACE）提供了非阻塞库，但这些库的入门门槛还是挺高的。根据本人多年在非阻塞编程方面的经验，总结出一套比较实用的 C/C++ 非阻塞函数库，本文就讲述如果使用 acl_cpp 库中的 master_aio 类来编写非阻塞服务器程序（该服务器程序可以规定启动最大进程的个数，其中每个进程是一个独立的非阻塞进程）。在文章《非阻塞网络编程实例讲解》中给出了一个非阻塞网络程序的示例，您可以参考一下。\n\n## 一、类接口定义\nmaster_aio 是一个纯虚类，其中定义的接口需要子类实现，子类实例必须只能创建一个实例，接口如下：\n```c++\n\t/**\n\t * 纯虚函数：当接收到一个客户端连接时调用此函数\n\t * @param stream {aio_socket_stream*} 新接收到的客户端异步流对象\n\t * @return {bool} 该函数如果返回 false 则通知服务器框架不再接收\n\t *  远程客户端连接，否则继续接收客户端连接\n\t */\n\tvirtual bool on_accept(aio_socket_stream* stream) = 0;\n```\n\nmaster_aio 提供了四个外部方法，如下：\n```c++\n\t/**\n\t * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架\n\t * 控制之下运行，一般用于生产机状态\n\t * @param argc {int} 从 main 中传递的第一个参数，表示参数个数\n\t * @param argv {char**} 从 main 中传递的第二个参数\n\t */\n\tvoid run_daemon(int argc, char** argv);\n\n\t/**\n\t * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作\n\t * @param addr {const char*} 服务监听地址\n\t * @param conf {const char*} 配置文件全路径\n\t * @param ht {aio_handle_type} 事件引擎的类型\n\t * @return {bool} 监听是否成功\n\t */\n\tbool run_alone(const char* addr, const char* conf = NULL,\n\t\taio_handle_type ht = ENGINE_SELECT);\n\n\t/**\n\t * 获得异步IO的事件引擎句柄，通过此句柄，用户可以设置定时器等功能\n\t * @return {aio_handle*}\n\t */\n\taio_handle* get_handle() const;\n\n\t/**\n\t * 在 run_alone 模式下，通知服务器框架关闭引擎，退出程序\n\t */\n\tvoid stop();\n```\n\n从上面两个函数，可以看出 master_aio 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。\n\nmaster_aio 的基类 master_base 的几个虚接口如下：\n```c++ \n\t/**\n\t * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些\n\t * 用户身份为 root 的权限操作\n\t */\n\tvirtual void proc_pre_jail() {}\n\n\t/**\n\t * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程\n\t * 的权限为普通受限级别\n\t */\n\tvirtual void proc_on_init() {}\n\n\t/**\n\t * 当进程退出前调用的回调函数\n\t */\n\tvirtual void proc_on_exit() {}\n\n\t// 在 run_alone 状态下运行前，调用此函数初始化一些配置\n```\n\n基类的这几个虚函数用户可以根据需要调用。\n\n另外，基类 master_base 还提供了几个用来读配置选项的函数：\n```c++\n\t/**\n\t * 设置 bool 类型的配置项\n\t * @param table {master_bool_tbl*}\n\t */\n\tvoid set_cfg_bool(master_bool_tbl* table);\n\n\t/**\n\t * 设置 int 类型的配置项\n\t * @param table {master_int_tbl*}\n\t */\n\tvoid set_cfg_int(master_int_tbl* table);\n\n\t/**\n\t * 设置 int64 类型的配置项\n\t * @param table {master_int64_tbl*}\n\t */\n\tvoid set_cfg_int64(master_int64_tbl* table);\n\n\t/**\n\t * 设置 字符串 类型的配置项\n\t * @param table {master_str_tbl*}\n\t */\n\tvoid set_cfg_str(master_str_tbl* table);\n```\n\n## 二、示例源程序\n```c++\n// master_aio.cpp : 定义控制台应用程序的入口点。\n//\n\n#include \"stdafx.h\"\n#include \"lib_acl.hpp\"\n\nstatic char *var_cfg_debug_msg;\n\nstatic acl::master_str_tbl var_conf_str_tab[] = {\n\t{ \"debug_msg\", \"test_msg\", &var_cfg_debug_msg },\n\n\t{ 0, 0, 0 }\n};\n\nstatic int  var_cfg_debug_enable;\nstatic int  var_cfg_keep_alive;\nstatic int  var_cfg_send_banner;\n\nstatic acl::master_bool_tbl var_conf_bool_tab[] = {\n\t{ \"debug_enable\", 1, &var_cfg_debug_enable },\n\t{ \"keep_alive\", 1, &var_cfg_keep_alive },\n\t{ \"send_banner\", 1, &var_cfg_send_banner },\n\n\t{ 0, 0, 0 }\n};\n\nstatic int  var_cfg_io_timeout;\n\nstatic acl::master_int_tbl var_conf_int_tab[] = {\n\t{ \"io_timeout\", 120, &var_cfg_io_timeout, 0, 0 },\n\n\t{ 0, 0 , 0 , 0, 0 }\n};\n\nstatic void (*format)(const char*, ...) = acl::log::msg1;\n\nusing namespace acl;\n\n//////////////////////////////////////////////////////////////////////////\n/**\n * 延迟读回调处理类\n */\nclass timer_reader: public aio_timer_reader\n{\npublic:\n\ttimer_reader(int delay)\n\t{\n\t\tdelay_ = delay;\n\t\tformat(\"timer_reader init, delay: %d\\r\\n\", delay);\n\t}\n\n\t~timer_reader()\n\t{\n\t}\n\n\t// aio_timer_reader 的子类必须重载 destroy 方法\n\tvoid destroy()\n\t{\n\t\tformat(\"timer_reader delete, delay: %d\\r\\n\", delay_);\n\t\tdelete this;\n\t}\n\n\t// 重载基类回调方法\n\tvoid timer_callback(unsigned int id)\n\t{\n\t\tformat(\"timer_reader(%u): timer_callback, delay: %d\\r\\n\", id, delay_);\n\n\t\t// 调用基类的处理过程\n\t\taio_timer_reader::timer_callback(id);\n\t}\n\nprivate:\n\tint   delay_;\n};\n\n/**\n * 延迟写回调处理类\n */\nclass timer_writer: public aio_timer_writer\n{\npublic:\n\ttimer_writer(int delay)\n\t{\n\t\tdelay_ = delay;\n\t\tformat(\"timer_writer init, delay: %d\\r\\n\", delay);\n\t}\n\n\t~timer_writer()\n\t{\n\t}\n\n\t// aio_timer_reader 的子类必须重载 destroy 方法\n\tvoid destroy()\n\t{\n\t\tformat(\"timer_writer delete, delay: %d\\r\\n\", delay_);\n\t\tdelete this;\n\t}\n\n\t// 重载基类回调方法\n\tvoid timer_callback(unsigned int id)\n\t{\n\t\tformat(\"timer_writer(%u): timer_callback, delay: %u\\r\\n\", id, delay_);\n\n\t\t// 调用基类的处理过程\n\t\taio_timer_writer::timer_callback(id);\n\t}\n\nprivate:\n\tint   delay_;\n};\n\nclass timer_test : public aio_timer_callback\n{\npublic:\n\ttimer_test() {}\n\t~timer_test() {}\nprotected:\n\t// 基类纯虚函数\n\tvoid timer_callback(unsigned int id)\n\t{\n\t\tformat(\"id: %u\\r\\n\", id);\n\t}\n\n\tvoid destroy(void)\n\t{\n\t\tdelete this;\n\t\tformat(\"timer delete now\\r\\n\");\n\t}\n};\n\n/**\n * 异步客户端流的回调类的子类\n */\nclass io_callback : public aio_callback\n{\npublic:\n\tio_callback(aio_socket_stream* client)\n\t\t: client_(client)\n\t\t, i_(0)\n\t{\n\t}\n\n\t~io_callback()\n\t{\n\t\tformat(\"delete io_callback now ...\\r\\n\");\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的读成功回调过程\n\t * @param data {char*} 读到的数据地址\n\t * @param len {int} 读到的数据长度\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool read_callback(char* data, int len)\n\t{\n\t\tif (++i_ < 10)\n\t\t\tformat(\">>gets(i: %d): %s\\r\\n\", i_, data);\n\n\t\t// 如果远程客户端希望退出，则关闭之\n\t\tif (strncmp(data, \"quit\", 4) == 0)\n\t\t{\n\t\t\tclient_->format(\"Bye!\\r\\n\");\n\t\t\tclient_->close();\n\t\t}\n\n\t\t// 如果远程客户端希望服务端也关闭，则中止异步事件过程\n\t\telse if (strncmp(data, \"stop\", 4) == 0)\n\t\t{\n\t\t\tclient_->format(\"Stop now!\\r\\n\");\n\t\t\tclient_->close();  // 关闭远程异步流\n\n\t\t\t// 通知异步引擎关闭循环过程\n\t\t\tclient_->get_handle().stop();\n\t\t}\n\n\t\t// 向远程客户端回写收到的数据\n\n\t\tint   delay = 0;\n\n\t\tif (strncmp(data, \"write_delay\", strlen(\"write_delay\")) == 0)\n\t\t{\n\t\t\t// 延迟写过程\n\n\t\t\tconst char* ptr = data + strlen(\"write_delay\");\n\t\t\tdelay = atoi(ptr);\n\t\t\tif (delay > 0)\n\t\t\t{\n\t\t\t\tformat(\">> write delay %d second ...\\r\\n\", delay);\n\t\t\t\ttimer_writer* timer = new timer_writer(delay);\n\t\t\t\tclient_->write(data, len, delay * 1000000, timer);\n\t\t\t\tclient_->gets(10, false);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\telse if (strncmp(data, \"read_delay\", strlen(\"read_delay\")) == 0)\n\t\t{\n\t\t\t// 延迟读过程\n\n\t\t\tconst char* ptr = data + strlen(\"read_delay\");\n\t\t\tdelay = atoi(ptr);\n\t\t\tif (delay > 0)\n\t\t\t{\n\t\t\t\tclient_->write(data, len);\n\t\t\t\tformat(\">> read delay %d second ...\\r\\n\", delay);\n\t\t\t\ttimer_reader* timer = new timer_reader(delay);\n\t\t\t\tclient_->gets(10, false, delay * 1000000, timer);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\n\t\tclient_->write(data, len);\n\t\t//client_->gets(10, false);\n\t\treturn true;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的写成功回调过程\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool write_callback()\n\t{\n\t\treturn true;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的关闭回调过程\n\t */\n\tvoid close_callback()\n\t{\n\t\t// 必须在此处删除该动态分配的回调类对象以防止内存泄露\n\t\tdelete this;\n\t}\n\n\t/**\n\t * 实现父类中的虚函数，客户端流的超时回调过程\n\t * @return {bool} 返回 true 表示继续，否则希望关闭该异步流\n\t */\n\tbool timeout_callback()\n\t{\n\t\tformat(\"Timeout ...\\r\\n\");\n\t\treturn true;\n\t}\n\nprivate:\n\taio_socket_stream* client_;\n\tint   i_;\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nclass master_aio_test : public master_aio\n{\npublic:\n\tmaster_aio_test() { timer_test_ = new timer_test(); }\n\n\t~master_aio_test() { handle_->keep_timer(false); }\n\nprotected:\n\t// 基类纯虚函数：当接收到一个新的连接时调用此函数\n\tbool on_accept(aio_socket_stream* client)\n\t{\n\t\t// 创建异步客户端流的回调对象并与该异步流进行绑定\n\t\tio_callback* callback = new io_callback(client);\n\n\t\t// 注册异步流的读回调过程\n\t\tclient->add_read_callback(callback);\n\n\t\t// 注册异步流的写回调过程\n\t\tclient->add_write_callback(callback);\n\n\t\t// 注册异步流的关闭回调过程\n\t\tclient->add_close_callback(callback);\n\n\t\t// 注册异步流的超时回调过程\n\t\tclient->add_timeout_callback(callback);\n\n\t\t// 写欢迎信息\n\t\tif (var_cfg_send_banner)\n\t\t\tclient->format(\"hello, you're welcome\\r\\n\");\n\n\t\t// 从异步流读一行数据\n\t\tclient->gets(10, false);\n\t\t//client->read();\n\t\treturn true;\n\t}\n\n\t// 基类虚函数：服务进程切换用户身份前调用此函数\n\tvoid proc_pre_jail()\n\t{\n\t\tformat(\"proc_pre_jail\\r\\n\");\n\t\t// 只有当程序启动后才能获得异步引擎句柄\n\t\thandle_ = get_handle();\n\t\thandle_->keep_timer(true); // 允许定时器被重复触发\n\t\t// 设置第一个定时任务，每隔1秒触发一次，定时任务ID为0\n\t\thandle_->set_timer(timer_test_, 1000000, 0);\n\t}\n\n\t// 基类虚函数：服务进程切换用户身份后调用此函数\n\tvoid proc_on_init()\n\t{\n\t\tformat(\"proc init\\r\\n\");\n\t\t// 设置第二个定时任务，每隔2秒触发一次，定时任务ID为1\n\t\thandle_->set_timer(timer_test_, 2000000, 1);\n\t}\n\n\t// 基类虚函数：服务进程退出前调用此函数\n\tvoid proc_on_exit()\n\t{\n\t\tformat(\"proc exit\\r\\n\");\n\t}\nprivate:\n\ttimer_test* timer_test_;\n\taio_handle* handle_;\n};\n//////////////////////////////////////////////////////////////////////////\n\nint main(int argc, char* argv[])\n{\n\tmaster_aio_test ma;  // master_aio 要求只能起一个实例\n\n\t// 设置配置参数表\n\tma.set_cfg_int(var_conf_int_tab);\n\tma.set_cfg_int64(NULL);\n\tma.set_cfg_str(var_conf_str_tab);\n\tma.set_cfg_bool(var_conf_bool_tab);\n\n\t// 开始运行\n\n\tif (argc >= 2 && strcmp(argv[1], \"alone\") == 0)\n\t{\n\t\tconst char* addr = \"127.0.0.1:8888\";\n\n\t\tif (argc >= 3)\n\t\t\taddr = argv[2];\n\n\t\tformat = (void (*)(const char*, ...)) printf;\n\t\tformat(\"listen: %s now\\r\\n\", addr);\n\t\tma.run_alone(addr);  // 单独运行方式\n\t}\n\telse\n\t\tma.run_daemon(argc, argv);  // acl_master 控制模式运行\n\treturn 0;\n}\n```\n\n该示例主要实现几个功能：接收一行数据并回写该数据、延迟回写所读的数据、延迟读下一行数据、设置定时器的定时任务。因为 master_aio 类是按非阻塞模式设计的（其实，该类主要对 acl 库中的非阻塞框架库用 C++ 进行了封装），所以该例子可以支持非常大的并发请求。可以通过配置文件指定系统事件 API 选择采用 select/poll/epoll 中的一种、规定进程的空闲退出时间、预先启动子进程的数量等参数。该例子所在目录：acl_cpp/samples/master_aio。\n\n在这个例子中，当服务端接收到客户端连接后，非阻塞框架会通过虚函数  on_accept 回调子类处理过程，子类需要在这个虚函数中需要将一个处理 IO 过程的类实例与这个非阻塞连接流进行绑定（通过 add_xxx_callback 方式），其中处理 IO 过程的类的基类定义为：aio_callback，子类需要实现其中的虚方法。\n\n## 三、配置文件及程序安装\n打开 acl_cpp/samples/master_aio/aio_echo.cf 配置文件，就其中几个配置参数说明一下：\n\n```\n## 由 acl_master 用来控制服务进程池的配置项\n# 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程\nmaster_disable = no\n\n# 表示本服务器进程监听 127.0.0.1 的 8888 端口\nmaster_service = 127.0.0.1:8888\n\n# 表示是 TCP 套接口服务类型\nmaster_type = inet\n\n# 表示该服务进程池的最大进程数为 2\nmaster_maxproc = 2\n\n# 需要预先启动的进程数，该值不应大于 master_maxproc\nmaster_prefork = 2\n\n# 进程程序名\nmaster_command = aio_echo\n\n# 进程日志记录文件，其中 {install_path} 需要用实际的安装路径代替\nmaster_log = {install_path}/var/log/aio_echo.log\n \n# 用 select 进行循环时的时间间隔\n# 单位为秒\naio_delay_sec = 1\n# 单位为微秒\naio_delay_usec = 500\n# 采用事件循环的方式: select(default), poll, kernel(epoll/devpoll/kqueue)\naio_event_mode = select\n# 是否将 socket 接收与IO功能分开: yes/no, 如果为 yes 可以大大提高 accept() 速度\naio_accept_alone = yes\n# 线程池的最大线程数, 如果该值为0则表示采用单线程非阻塞模式.\naio_max_threads = 0\n# 每个线程的空闲时间.\naio_thread_idle_limit = 60\n# 允许访问的客户端IP地址范围\naio_access_allow = 10.0.0.1:255.255.255.255, 127.0.0.1:127.0.0.1\n# 当 acl_master 退出时，如果该值置1则该程序不等所有连接处理完毕便立即退出\naio_quick_abort = 1\n```\n\n例如当 acl_master 服务器框架程序的安装目录为：/opt/acl，则：\n\n- /opt/acl/libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；\n- /opt/acl/conf：该目录存放 acl_master 程序配置文件 main.cf；\n- /opt/acl/conf/service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；\n- /opt/acl/var/log：该目录存放日志文件；\n- /opt/acl/var/pid：该目录存放进程号文件。\n\n该程序编译通过后，需要把可执行程序放在 /opt/acl/libexec 目录下，把配置文件放在 /opt/acl/conf/service 目录下。\n\n在 /opt/acl/sh 下有启动/停止 acl_master 服务进程的控制脚本；运行脚本：./start.sh，然后请用下面方法检查服务是否已经启动：\n\nps -ef|grep acl_master # 查看服务器控制进程是否已经启动\n\nnetstat -nap|grep LISTEN|grep 5001 # 查看服务端口号是否已经被监听\n\n当然，您也可以查看 /opt/acl/var/log/acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。\n\n可以命令行如下测试：telnet 127.0.0.1 8888\n\ngithub: https://github.com/acl-dev/acl\ngitee: https://gitee.com/acl-dev/acl\n \n","slug":"master_aio","published":1,"updated":"2023-01-24T07:18:55.563Z","_id":"cld9wjkeh000e7x9khziq491w","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在文章《使用 acl::master_threads 类编写多进程多线程服务器程序》讲述了如何编写 LINUX 平台下阻塞式服务器程序的多线程。虽然这种模式都可以处理并发任务，并且效率也不低，但是毕竟线程和进程资源是操作系统的宝贵资源，如果要支持非常高的并发请求，则会因为系统限制而不能创建更多的进程或线程。大家常见的 webserver Nginx 就是以支持高并发而闻名，Nginx 本身就是非阻塞设计的典型应用，当然还有很多其它服务器程序也是非阻塞的：ircd、Squid、Varnish、Bind 等。</p>\n<p>因为非阻塞程序编写有一定难度，所以现在有人在写非阻塞程序时不得不转向 Erlang、Nodejs 等一些脚本式语言，要想用 C&#x2F;C++ 来实现非阻塞程序还是有些难度：系统级 API 过于底层、容易出错、难于调试。虽然也有一些 C++ 库（象ACE）提供了非阻塞库，但这些库的入门门槛还是挺高的。根据本人多年在非阻塞编程方面的经验，总结出一套比较实用的 C&#x2F;C++ 非阻塞函数库，本文就讲述如果使用 acl_cpp 库中的 master_aio 类来编写非阻塞服务器程序（该服务器程序可以规定启动最大进程的个数，其中每个进程是一个独立的非阻塞进程）。在文章《非阻塞网络编程实例讲解》中给出了一个非阻塞网络程序的示例，您可以参考一下。</p>\n<h2 id=\"一、类接口定义\"><a href=\"#一、类接口定义\" class=\"headerlink\" title=\"一、类接口定义\"></a>一、类接口定义</h2><p>master_aio 是一个纯虚类，其中定义的接口需要子类实现，子类实例必须只能创建一个实例，接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 纯虚函数：当接收到一个客户端连接时调用此函数</span><br><span class=\"hljs-comment\"> * @param stream &#123;aio_socket_stream*&#125; 新接收到的客户端异步流对象</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 该函数如果返回 false 则通知服务器框架不再接收</span><br><span class=\"hljs-comment\"> *  远程客户端连接，否则继续接收客户端连接</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">on_accept</span><span class=\"hljs-params\">(aio_socket_stream* stream)</span> </span>= <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n\n<p>master_aio 提供了四个外部方法，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架</span><br><span class=\"hljs-comment\"> * 控制之下运行，一般用于生产机状态</span><br><span class=\"hljs-comment\"> * @param argc &#123;int&#125; 从 main 中传递的第一个参数，表示参数个数</span><br><span class=\"hljs-comment\"> * @param argv &#123;char**&#125; 从 main 中传递的第二个参数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run_daemon</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>** argv)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作</span><br><span class=\"hljs-comment\"> * @param addr &#123;const char*&#125; 服务监听地址</span><br><span class=\"hljs-comment\"> * @param conf &#123;const char*&#125; 配置文件全路径</span><br><span class=\"hljs-comment\"> * @param ht &#123;aio_handle_type&#125; 事件引擎的类型</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 监听是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">run_alone</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* conf = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\taio_handle_type ht = ENGINE_SELECT)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得异步IO的事件引擎句柄，通过此句柄，用户可以设置定时器等功能</span><br><span class=\"hljs-comment\"> * @return &#123;aio_handle*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">aio_handle* <span class=\"hljs-title\">get_handle</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在 run_alone 模式下，通知服务器框架关闭引擎，退出程序</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">stop</span><span class=\"hljs-params\">()</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>从上面两个函数，可以看出 master_aio 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。</p>\n<p>master_aio 的基类 master_base 的几个虚接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些</span><br><span class=\"hljs-comment\"> * 用户身份为 root 的权限操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_pre_jail</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程</span><br><span class=\"hljs-comment\"> * 的权限为普通受限级别</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_init</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程退出前调用的回调函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_exit</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">// 在 run_alone 状态下运行前，调用此函数初始化一些配置</span><br></code></pre></td></tr></table></figure>\n\n<p>基类的这几个虚函数用户可以根据需要调用。</p>\n<p>另外，基类 master_base 还提供了几个用来读配置选项的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 bool 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_bool_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_bool</span><span class=\"hljs-params\">(master_bool_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 int 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_int_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_int</span><span class=\"hljs-params\">(master_int_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 int64 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_int64_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_int64</span><span class=\"hljs-params\">(master_int64_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 字符串 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_str_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_str</span><span class=\"hljs-params\">(master_str_tbl* table)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、示例源程序\"><a href=\"#二、示例源程序\" class=\"headerlink\" title=\"二、示例源程序\"></a>二、示例源程序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// master_aio.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_debug_msg;<br><br><span class=\"hljs-type\">static</span> acl::master_str_tbl var_conf_str_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_msg&quot;</span>, <span class=\"hljs-string\">&quot;test_msg&quot;</span>, &amp;var_cfg_debug_msg &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_debug_enable;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_keep_alive;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_send_banner;<br><br><span class=\"hljs-type\">static</span> acl::master_bool_tbl var_conf_bool_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_enable&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_debug_enable &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;keep_alive&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_keep_alive &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;send_banner&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_send_banner &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_io_timeout;<br><br><span class=\"hljs-type\">static</span> acl::master_int_tbl var_conf_int_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;io_timeout&quot;</span>, <span class=\"hljs-number\">120</span>, &amp;var_cfg_io_timeout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-title\">void</span> <span class=\"hljs-params\">(*format)</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>*, ...)</span> </span>= acl::log::msg1;<br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 延迟读回调处理类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">timer_reader</span>: <span class=\"hljs-keyword\">public</span> aio_timer_reader<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">timer_reader</span>(<span class=\"hljs-type\">int</span> delay)<br>\t&#123;<br>\t\tdelay_ = delay;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_reader init, delay: %d\\r\\n&quot;</span>, delay);<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">timer_reader</span>()<br>\t&#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// aio_timer_reader 的子类必须重载 destroy 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_reader delete, delay: %d\\r\\n&quot;</span>, delay_);<br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 重载基类回调方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">timer_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_reader(%u): timer_callback, delay: %d\\r\\n&quot;</span>, id, delay_);<br><br>\t\t<span class=\"hljs-comment\">// 调用基类的处理过程</span><br>\t\taio_timer_reader::<span class=\"hljs-built_in\">timer_callback</span>(id);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span>   delay_;<br>&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 延迟写回调处理类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">timer_writer</span>: <span class=\"hljs-keyword\">public</span> aio_timer_writer<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">timer_writer</span>(<span class=\"hljs-type\">int</span> delay)<br>\t&#123;<br>\t\tdelay_ = delay;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_writer init, delay: %d\\r\\n&quot;</span>, delay);<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">timer_writer</span>()<br>\t&#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// aio_timer_reader 的子类必须重载 destroy 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_writer delete, delay: %d\\r\\n&quot;</span>, delay_);<br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 重载基类回调方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">timer_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_writer(%u): timer_callback, delay: %u\\r\\n&quot;</span>, id, delay_);<br><br>\t\t<span class=\"hljs-comment\">// 调用基类的处理过程</span><br>\t\taio_timer_writer::<span class=\"hljs-built_in\">timer_callback</span>(id);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span>   delay_;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">timer_test</span> : <span class=\"hljs-keyword\">public</span> aio_timer_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">timer_test</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">timer_test</span>() &#123;&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">timer_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;id: %u\\r\\n&quot;</span>, id);<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer delete now\\r\\n&quot;</span>);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 异步客户端流的回调类的子类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">io_callback</span> : <span class=\"hljs-keyword\">public</span> aio_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">io_callback</span>(aio_socket_stream* client)<br>\t\t: <span class=\"hljs-built_in\">client_</span>(client)<br>\t\t, <span class=\"hljs-built_in\">i_</span>(<span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">io_callback</span>()<br>\t&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;delete io_callback now ...\\r\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的读成功回调过程</span><br><span class=\"hljs-comment\">\t * @param data &#123;char*&#125; 读到的数据地址</span><br><span class=\"hljs-comment\">\t * @param len &#123;int&#125; 读到的数据长度</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">read_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* data, <span class=\"hljs-type\">int</span> len)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (++i_ &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tformat(<span class=\"hljs-string\">&quot;&gt;&gt;gets(i: %d): %s\\r\\n&quot;</span>, i_, data);<br><br>\t\t<span class=\"hljs-comment\">// 如果远程客户端希望退出，则关闭之</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncmp</span>(data, <span class=\"hljs-string\">&quot;quit&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Bye!\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 如果远程客户端希望服务端也关闭，则中止异步事件过程</span><br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncmp</span>(data, <span class=\"hljs-string\">&quot;stop&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Stop now!\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();  <span class=\"hljs-comment\">// 关闭远程异步流</span><br><br>\t\t\t<span class=\"hljs-comment\">// 通知异步引擎关闭循环过程</span><br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">stop</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 向远程客户端回写收到的数据</span><br><br>\t\t<span class=\"hljs-type\">int</span>   delay = <span class=\"hljs-number\">0</span>;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncmp</span>(data, <span class=\"hljs-string\">&quot;write_delay&quot;</span>, <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;write_delay&quot;</span>)) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 延迟写过程</span><br><br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ptr = data + <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;write_delay&quot;</span>);<br>\t\t\tdelay = <span class=\"hljs-built_in\">atoi</span>(ptr);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (delay &gt; <span class=\"hljs-number\">0</span>)<br>\t\t\t&#123;<br>\t\t\t\tformat(<span class=\"hljs-string\">&quot;&gt;&gt; write delay %d second ...\\r\\n&quot;</span>, delay);<br>\t\t\t\ttimer_writer* timer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">timer_writer</span>(delay);<br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(data, len, delay * <span class=\"hljs-number\">1000000</span>, timer);<br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">gets</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-literal\">false</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncmp</span>(data, <span class=\"hljs-string\">&quot;read_delay&quot;</span>, <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;read_delay&quot;</span>)) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 延迟读过程</span><br><br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ptr = data + <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;read_delay&quot;</span>);<br>\t\t\tdelay = <span class=\"hljs-built_in\">atoi</span>(ptr);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (delay &gt; <span class=\"hljs-number\">0</span>)<br>\t\t\t&#123;<br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(data, len);<br>\t\t\t\tformat(<span class=\"hljs-string\">&quot;&gt;&gt; read delay %d second ...\\r\\n&quot;</span>, delay);<br>\t\t\t\ttimer_reader* timer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">timer_reader</span>(delay);<br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">gets</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-literal\">false</span>, delay * <span class=\"hljs-number\">1000000</span>, timer);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(data, len);<br>\t\t<span class=\"hljs-comment\">//client_-&gt;gets(10, false);</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的写成功回调过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的关闭回调过程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">close_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 必须在此处删除该动态分配的回调类对象以防止内存泄露</span><br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的超时回调过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">timeout_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;Timeout ...\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\taio_socket_stream* client_;<br>\t<span class=\"hljs-type\">int</span>   i_;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">master_aio_test</span> : <span class=\"hljs-keyword\">public</span> master_aio<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">master_aio_test</span>() &#123; timer_test_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">timer_test</span>(); &#125;<br><br>\t~<span class=\"hljs-built_in\">master_aio_test</span>() &#123; handle_-&gt;<span class=\"hljs-built_in\">keep_timer</span>(<span class=\"hljs-literal\">false</span>); &#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数：当接收到一个新的连接时调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">on_accept</span><span class=\"hljs-params\">(aio_socket_stream* client)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 创建异步客户端流的回调对象并与该异步流进行绑定</span><br>\t\tio_callback* callback = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">io_callback</span>(client);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的读回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_read_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的写回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_write_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的关闭回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_close_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的超时回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_timeout_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 写欢迎信息</span><br>\t\t<span class=\"hljs-keyword\">if</span> (var_cfg_send_banner)<br>\t\t\tclient-&gt;format(<span class=\"hljs-string\">&quot;hello, you&#x27;re welcome\\r\\n&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 从异步流读一行数据</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">gets</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-literal\">false</span>);<br>\t\t<span class=\"hljs-comment\">//client-&gt;read();</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程切换用户身份前调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_pre_jail</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc_pre_jail\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-comment\">// 只有当程序启动后才能获得异步引擎句柄</span><br>\t\thandle_ = <span class=\"hljs-built_in\">get_handle</span>();<br>\t\thandle_-&gt;<span class=\"hljs-built_in\">keep_timer</span>(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 允许定时器被重复触发</span><br>\t\t<span class=\"hljs-comment\">// 设置第一个定时任务，每隔1秒触发一次，定时任务ID为0</span><br>\t\thandle_-&gt;<span class=\"hljs-built_in\">set_timer</span>(timer_test_, <span class=\"hljs-number\">1000000</span>, <span class=\"hljs-number\">0</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程切换用户身份后调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_init</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc init\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-comment\">// 设置第二个定时任务，每隔2秒触发一次，定时任务ID为1</span><br>\t\thandle_-&gt;<span class=\"hljs-built_in\">set_timer</span>(timer_test_, <span class=\"hljs-number\">2000000</span>, <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程退出前调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_exit</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc exit\\r\\n&quot;</span>);<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\ttimer_test* timer_test_;<br>\taio_handle* handle_;<br>&#125;;<br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmaster_aio_test ma;  <span class=\"hljs-comment\">// master_aio 要求只能起一个实例</span><br><br>\t<span class=\"hljs-comment\">// 设置配置参数表</span><br>\tma.<span class=\"hljs-built_in\">set_cfg_int</span>(var_conf_int_tab);<br>\tma.<span class=\"hljs-built_in\">set_cfg_int64</span>(<span class=\"hljs-literal\">NULL</span>);<br>\tma.<span class=\"hljs-built_in\">set_cfg_str</span>(var_conf_str_tab);<br>\tma.<span class=\"hljs-built_in\">set_cfg_bool</span>(var_conf_bool_tab);<br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-string\">&quot;alone&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">3</span>)<br>\t\t\taddr = argv[<span class=\"hljs-number\">2</span>];<br><br>\t\tformat = (<span class=\"hljs-built_in\">void</span> (*)(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>*, ...)) printf;<br>\t\tformat(<span class=\"hljs-string\">&quot;listen: %s now\\r\\n&quot;</span>, addr);<br>\t\tma.<span class=\"hljs-built_in\">run_alone</span>(addr);  <span class=\"hljs-comment\">// 单独运行方式</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\tma.<span class=\"hljs-built_in\">run_daemon</span>(argc, argv);  <span class=\"hljs-comment\">// acl_master 控制模式运行</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该示例主要实现几个功能：接收一行数据并回写该数据、延迟回写所读的数据、延迟读下一行数据、设置定时器的定时任务。因为 master_aio 类是按非阻塞模式设计的（其实，该类主要对 acl 库中的非阻塞框架库用 C++ 进行了封装），所以该例子可以支持非常大的并发请求。可以通过配置文件指定系统事件 API 选择采用 select&#x2F;poll&#x2F;epoll 中的一种、规定进程的空闲退出时间、预先启动子进程的数量等参数。该例子所在目录：acl_cpp&#x2F;samples&#x2F;master_aio。</p>\n<p>在这个例子中，当服务端接收到客户端连接后，非阻塞框架会通过虚函数  on_accept 回调子类处理过程，子类需要在这个虚函数中需要将一个处理 IO 过程的类实例与这个非阻塞连接流进行绑定（通过 add_xxx_callback 方式），其中处理 IO 过程的类的基类定义为：aio_callback，子类需要实现其中的虚方法。</p>\n<h2 id=\"三、配置文件及程序安装\"><a href=\"#三、配置文件及程序安装\" class=\"headerlink\" title=\"三、配置文件及程序安装\"></a>三、配置文件及程序安装</h2><p>打开 acl_cpp&#x2F;samples&#x2F;master_aio&#x2F;aio_echo.cf 配置文件，就其中几个配置参数说明一下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-comment\">## 由 acl_master 用来控制服务进程池的配置项</span><br><span class=\"hljs-comment\"># 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程</span><br><span class=\"hljs-attr\">master_disable</span> = <span class=\"hljs-literal\">no</span><br><br><span class=\"hljs-comment\"># 表示本服务器进程监听 127.0.0.1 的 8888 端口</span><br><span class=\"hljs-attr\">master_service</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">8888</span><br><br><span class=\"hljs-comment\"># 表示是 TCP 套接口服务类型</span><br><span class=\"hljs-attr\">master_type</span> = inet<br><br><span class=\"hljs-comment\"># 表示该服务进程池的最大进程数为 2</span><br><span class=\"hljs-attr\">master_maxproc</span> = <span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\"># 需要预先启动的进程数，该值不应大于 master_maxproc</span><br><span class=\"hljs-attr\">master_prefork</span> = <span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\"># 进程程序名</span><br><span class=\"hljs-attr\">master_command</span> = aio_echo<br><br><span class=\"hljs-comment\"># 进程日志记录文件，其中 &#123;install_path&#125; 需要用实际的安装路径代替</span><br><span class=\"hljs-attr\">master_log</span> = &#123;install_path&#125;/var/log/aio_echo.log<br> <br><span class=\"hljs-comment\"># 用 select 进行循环时的时间间隔</span><br><span class=\"hljs-comment\"># 单位为秒</span><br><span class=\"hljs-attr\">aio_delay_sec</span> = <span class=\"hljs-number\">1</span><br><span class=\"hljs-comment\"># 单位为微秒</span><br><span class=\"hljs-attr\">aio_delay_usec</span> = <span class=\"hljs-number\">500</span><br><span class=\"hljs-comment\"># 采用事件循环的方式: select(default), poll, kernel(epoll/devpoll/kqueue)</span><br><span class=\"hljs-attr\">aio_event_mode</span> = select<br><span class=\"hljs-comment\"># 是否将 socket 接收与IO功能分开: yes/no, 如果为 yes 可以大大提高 accept() 速度</span><br><span class=\"hljs-attr\">aio_accept_alone</span> = <span class=\"hljs-literal\">yes</span><br><span class=\"hljs-comment\"># 线程池的最大线程数, 如果该值为0则表示采用单线程非阻塞模式.</span><br><span class=\"hljs-attr\">aio_max_threads</span> = <span class=\"hljs-number\">0</span><br><span class=\"hljs-comment\"># 每个线程的空闲时间.</span><br><span class=\"hljs-attr\">aio_thread_idle_limit</span> = <span class=\"hljs-number\">60</span><br><span class=\"hljs-comment\"># 允许访问的客户端IP地址范围</span><br><span class=\"hljs-attr\">aio_access_allow</span> = <span class=\"hljs-number\">10.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">255.255</span>.<span class=\"hljs-number\">255.255</span>, <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br><span class=\"hljs-comment\"># 当 acl_master 退出时，如果该值置1则该程序不等所有连接处理完毕便立即退出</span><br><span class=\"hljs-attr\">aio_quick_abort</span> = <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>例如当 acl_master 服务器框架程序的安装目录为：&#x2F;opt&#x2F;acl，则：</p>\n<ul>\n<li>&#x2F;opt&#x2F;acl&#x2F;libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;conf：该目录存放 acl_master 程序配置文件 main.cf；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;log：该目录存放日志文件；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;pid：该目录存放进程号文件。</li>\n</ul>\n<p>该程序编译通过后，需要把可执行程序放在 &#x2F;opt&#x2F;acl&#x2F;libexec 目录下，把配置文件放在 &#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service 目录下。</p>\n<p>在 &#x2F;opt&#x2F;acl&#x2F;sh 下有启动&#x2F;停止 acl_master 服务进程的控制脚本；运行脚本：.&#x2F;start.sh，然后请用下面方法检查服务是否已经启动：</p>\n<p>ps -ef|grep acl_master # 查看服务器控制进程是否已经启动</p>\n<p>netstat -nap|grep LISTEN|grep 5001 # 查看服务端口号是否已经被监听</p>\n<p>当然，您也可以查看 &#x2F;opt&#x2F;acl&#x2F;var&#x2F;log&#x2F;acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。</p>\n<p>可以命令行如下测试：telnet 127.0.0.1 8888</p>\n<p>github: <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee: <a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在文章《使用 acl::master_threads 类编写多进程多线程服务器程序》讲述了如何编写 LINUX 平台下阻塞式服务器程序的多线程。虽然这种模式都可以处理并发任务，并且效率也不低，但是毕竟线程和进程资源是操作系统的宝贵资源，如果要支持非常高的并发请求，则会因为系统限制而不能创建更多的进程或线程。大家常见的 webserver Nginx 就是以支持高并发而闻名，Nginx 本身就是非阻塞设计的典型应用，当然还有很多其它服务器程序也是非阻塞的：ircd、Squid、Varnish、Bind 等。</p>\n<p>因为非阻塞程序编写有一定难度，所以现在有人在写非阻塞程序时不得不转向 Erlang、Nodejs 等一些脚本式语言，要想用 C&#x2F;C++ 来实现非阻塞程序还是有些难度：系统级 API 过于底层、容易出错、难于调试。虽然也有一些 C++ 库（象ACE）提供了非阻塞库，但这些库的入门门槛还是挺高的。根据本人多年在非阻塞编程方面的经验，总结出一套比较实用的 C&#x2F;C++ 非阻塞函数库，本文就讲述如果使用 acl_cpp 库中的 master_aio 类来编写非阻塞服务器程序（该服务器程序可以规定启动最大进程的个数，其中每个进程是一个独立的非阻塞进程）。在文章《非阻塞网络编程实例讲解》中给出了一个非阻塞网络程序的示例，您可以参考一下。</p>\n<h2 id=\"一、类接口定义\"><a href=\"#一、类接口定义\" class=\"headerlink\" title=\"一、类接口定义\"></a>一、类接口定义</h2><p>master_aio 是一个纯虚类，其中定义的接口需要子类实现，子类实例必须只能创建一个实例，接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 纯虚函数：当接收到一个客户端连接时调用此函数</span><br><span class=\"hljs-comment\"> * @param stream &#123;aio_socket_stream*&#125; 新接收到的客户端异步流对象</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 该函数如果返回 false 则通知服务器框架不再接收</span><br><span class=\"hljs-comment\"> *  远程客户端连接，否则继续接收客户端连接</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">on_accept</span><span class=\"hljs-params\">(aio_socket_stream* stream)</span> </span>= <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n\n<p>master_aio 提供了四个外部方法，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架</span><br><span class=\"hljs-comment\"> * 控制之下运行，一般用于生产机状态</span><br><span class=\"hljs-comment\"> * @param argc &#123;int&#125; 从 main 中传递的第一个参数，表示参数个数</span><br><span class=\"hljs-comment\"> * @param argv &#123;char**&#125; 从 main 中传递的第二个参数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run_daemon</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>** argv)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作</span><br><span class=\"hljs-comment\"> * @param addr &#123;const char*&#125; 服务监听地址</span><br><span class=\"hljs-comment\"> * @param conf &#123;const char*&#125; 配置文件全路径</span><br><span class=\"hljs-comment\"> * @param ht &#123;aio_handle_type&#125; 事件引擎的类型</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 监听是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">run_alone</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* conf = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\taio_handle_type ht = ENGINE_SELECT)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得异步IO的事件引擎句柄，通过此句柄，用户可以设置定时器等功能</span><br><span class=\"hljs-comment\"> * @return &#123;aio_handle*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">aio_handle* <span class=\"hljs-title\">get_handle</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在 run_alone 模式下，通知服务器框架关闭引擎，退出程序</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">stop</span><span class=\"hljs-params\">()</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>从上面两个函数，可以看出 master_aio 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。</p>\n<p>master_aio 的基类 master_base 的几个虚接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些</span><br><span class=\"hljs-comment\"> * 用户身份为 root 的权限操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_pre_jail</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程</span><br><span class=\"hljs-comment\"> * 的权限为普通受限级别</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_init</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程退出前调用的回调函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_exit</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">// 在 run_alone 状态下运行前，调用此函数初始化一些配置</span><br></code></pre></td></tr></table></figure>\n\n<p>基类的这几个虚函数用户可以根据需要调用。</p>\n<p>另外，基类 master_base 还提供了几个用来读配置选项的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 bool 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_bool_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_bool</span><span class=\"hljs-params\">(master_bool_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 int 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_int_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_int</span><span class=\"hljs-params\">(master_int_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 int64 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_int64_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_int64</span><span class=\"hljs-params\">(master_int64_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 字符串 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_str_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_str</span><span class=\"hljs-params\">(master_str_tbl* table)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、示例源程序\"><a href=\"#二、示例源程序\" class=\"headerlink\" title=\"二、示例源程序\"></a>二、示例源程序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br><span class=\"line\">263</span><br><span class=\"line\">264</span><br><span class=\"line\">265</span><br><span class=\"line\">266</span><br><span class=\"line\">267</span><br><span class=\"line\">268</span><br><span class=\"line\">269</span><br><span class=\"line\">270</span><br><span class=\"line\">271</span><br><span class=\"line\">272</span><br><span class=\"line\">273</span><br><span class=\"line\">274</span><br><span class=\"line\">275</span><br><span class=\"line\">276</span><br><span class=\"line\">277</span><br><span class=\"line\">278</span><br><span class=\"line\">279</span><br><span class=\"line\">280</span><br><span class=\"line\">281</span><br><span class=\"line\">282</span><br><span class=\"line\">283</span><br><span class=\"line\">284</span><br><span class=\"line\">285</span><br><span class=\"line\">286</span><br><span class=\"line\">287</span><br><span class=\"line\">288</span><br><span class=\"line\">289</span><br><span class=\"line\">290</span><br><span class=\"line\">291</span><br><span class=\"line\">292</span><br><span class=\"line\">293</span><br><span class=\"line\">294</span><br><span class=\"line\">295</span><br><span class=\"line\">296</span><br><span class=\"line\">297</span><br><span class=\"line\">298</span><br><span class=\"line\">299</span><br><span class=\"line\">300</span><br><span class=\"line\">301</span><br><span class=\"line\">302</span><br><span class=\"line\">303</span><br><span class=\"line\">304</span><br><span class=\"line\">305</span><br><span class=\"line\">306</span><br><span class=\"line\">307</span><br><span class=\"line\">308</span><br><span class=\"line\">309</span><br><span class=\"line\">310</span><br><span class=\"line\">311</span><br><span class=\"line\">312</span><br><span class=\"line\">313</span><br><span class=\"line\">314</span><br><span class=\"line\">315</span><br><span class=\"line\">316</span><br><span class=\"line\">317</span><br><span class=\"line\">318</span><br><span class=\"line\">319</span><br><span class=\"line\">320</span><br><span class=\"line\">321</span><br><span class=\"line\">322</span><br><span class=\"line\">323</span><br><span class=\"line\">324</span><br><span class=\"line\">325</span><br><span class=\"line\">326</span><br><span class=\"line\">327</span><br><span class=\"line\">328</span><br><span class=\"line\">329</span><br><span class=\"line\">330</span><br><span class=\"line\">331</span><br><span class=\"line\">332</span><br><span class=\"line\">333</span><br><span class=\"line\">334</span><br><span class=\"line\">335</span><br><span class=\"line\">336</span><br><span class=\"line\">337</span><br><span class=\"line\">338</span><br><span class=\"line\">339</span><br><span class=\"line\">340</span><br><span class=\"line\">341</span><br><span class=\"line\">342</span><br><span class=\"line\">343</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// master_aio.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_debug_msg;<br><br><span class=\"hljs-type\">static</span> acl::master_str_tbl var_conf_str_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_msg&quot;</span>, <span class=\"hljs-string\">&quot;test_msg&quot;</span>, &amp;var_cfg_debug_msg &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_debug_enable;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_keep_alive;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_send_banner;<br><br><span class=\"hljs-type\">static</span> acl::master_bool_tbl var_conf_bool_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_enable&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_debug_enable &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;keep_alive&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_keep_alive &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;send_banner&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_send_banner &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_io_timeout;<br><br><span class=\"hljs-type\">static</span> acl::master_int_tbl var_conf_int_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;io_timeout&quot;</span>, <span class=\"hljs-number\">120</span>, &amp;var_cfg_io_timeout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-title\">void</span> <span class=\"hljs-params\">(*format)</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>*, ...)</span> </span>= acl::log::msg1;<br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 延迟读回调处理类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">timer_reader</span>: <span class=\"hljs-keyword\">public</span> aio_timer_reader<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">timer_reader</span>(<span class=\"hljs-type\">int</span> delay)<br>\t&#123;<br>\t\tdelay_ = delay;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_reader init, delay: %d\\r\\n&quot;</span>, delay);<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">timer_reader</span>()<br>\t&#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// aio_timer_reader 的子类必须重载 destroy 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_reader delete, delay: %d\\r\\n&quot;</span>, delay_);<br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 重载基类回调方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">timer_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_reader(%u): timer_callback, delay: %d\\r\\n&quot;</span>, id, delay_);<br><br>\t\t<span class=\"hljs-comment\">// 调用基类的处理过程</span><br>\t\taio_timer_reader::<span class=\"hljs-built_in\">timer_callback</span>(id);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span>   delay_;<br>&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 延迟写回调处理类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">timer_writer</span>: <span class=\"hljs-keyword\">public</span> aio_timer_writer<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">timer_writer</span>(<span class=\"hljs-type\">int</span> delay)<br>\t&#123;<br>\t\tdelay_ = delay;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_writer init, delay: %d\\r\\n&quot;</span>, delay);<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">timer_writer</span>()<br>\t&#123;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// aio_timer_reader 的子类必须重载 destroy 方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_writer delete, delay: %d\\r\\n&quot;</span>, delay_);<br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 重载基类回调方法</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">timer_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer_writer(%u): timer_callback, delay: %u\\r\\n&quot;</span>, id, delay_);<br><br>\t\t<span class=\"hljs-comment\">// 调用基类的处理过程</span><br>\t\taio_timer_writer::<span class=\"hljs-built_in\">timer_callback</span>(id);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span>   delay_;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">timer_test</span> : <span class=\"hljs-keyword\">public</span> aio_timer_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">timer_test</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">timer_test</span>() &#123;&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">timer_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> id)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;id: %u\\r\\n&quot;</span>, id);<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">destroy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t\tformat(<span class=\"hljs-string\">&quot;timer delete now\\r\\n&quot;</span>);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 异步客户端流的回调类的子类</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">io_callback</span> : <span class=\"hljs-keyword\">public</span> aio_callback<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">io_callback</span>(aio_socket_stream* client)<br>\t\t: <span class=\"hljs-built_in\">client_</span>(client)<br>\t\t, <span class=\"hljs-built_in\">i_</span>(<span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">io_callback</span>()<br>\t&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;delete io_callback now ...\\r\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的读成功回调过程</span><br><span class=\"hljs-comment\">\t * @param data &#123;char*&#125; 读到的数据地址</span><br><span class=\"hljs-comment\">\t * @param len &#123;int&#125; 读到的数据长度</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">read_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">char</span>* data, <span class=\"hljs-type\">int</span> len)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (++i_ &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tformat(<span class=\"hljs-string\">&quot;&gt;&gt;gets(i: %d): %s\\r\\n&quot;</span>, i_, data);<br><br>\t\t<span class=\"hljs-comment\">// 如果远程客户端希望退出，则关闭之</span><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncmp</span>(data, <span class=\"hljs-string\">&quot;quit&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Bye!\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 如果远程客户端希望服务端也关闭，则中止异步事件过程</span><br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncmp</span>(data, <span class=\"hljs-string\">&quot;stop&quot;</span>, <span class=\"hljs-number\">4</span>) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tclient_-&gt;format(<span class=\"hljs-string\">&quot;Stop now!\\r\\n&quot;</span>);<br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">close</span>();  <span class=\"hljs-comment\">// 关闭远程异步流</span><br><br>\t\t\t<span class=\"hljs-comment\">// 通知异步引擎关闭循环过程</span><br>\t\t\tclient_-&gt;<span class=\"hljs-built_in\">get_handle</span>().<span class=\"hljs-built_in\">stop</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 向远程客户端回写收到的数据</span><br><br>\t\t<span class=\"hljs-type\">int</span>   delay = <span class=\"hljs-number\">0</span>;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncmp</span>(data, <span class=\"hljs-string\">&quot;write_delay&quot;</span>, <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;write_delay&quot;</span>)) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 延迟写过程</span><br><br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ptr = data + <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;write_delay&quot;</span>);<br>\t\t\tdelay = <span class=\"hljs-built_in\">atoi</span>(ptr);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (delay &gt; <span class=\"hljs-number\">0</span>)<br>\t\t\t&#123;<br>\t\t\t\tformat(<span class=\"hljs-string\">&quot;&gt;&gt; write delay %d second ...\\r\\n&quot;</span>, delay);<br>\t\t\t\ttimer_writer* timer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">timer_writer</span>(delay);<br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(data, len, delay * <span class=\"hljs-number\">1000000</span>, timer);<br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">gets</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-literal\">false</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">strncmp</span>(data, <span class=\"hljs-string\">&quot;read_delay&quot;</span>, <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;read_delay&quot;</span>)) == <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 延迟读过程</span><br><br>\t\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ptr = data + <span class=\"hljs-built_in\">strlen</span>(<span class=\"hljs-string\">&quot;read_delay&quot;</span>);<br>\t\t\tdelay = <span class=\"hljs-built_in\">atoi</span>(ptr);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (delay &gt; <span class=\"hljs-number\">0</span>)<br>\t\t\t&#123;<br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(data, len);<br>\t\t\t\tformat(<span class=\"hljs-string\">&quot;&gt;&gt; read delay %d second ...\\r\\n&quot;</span>, delay);<br>\t\t\t\ttimer_reader* timer = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">timer_reader</span>(delay);<br>\t\t\t\tclient_-&gt;<span class=\"hljs-built_in\">gets</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-literal\">false</span>, delay * <span class=\"hljs-number\">1000000</span>, timer);<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br><br>\t\tclient_-&gt;<span class=\"hljs-built_in\">write</span>(data, len);<br>\t\t<span class=\"hljs-comment\">//client_-&gt;gets(10, false);</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的写成功回调过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">write_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的关闭回调过程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">close_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 必须在此处删除该动态分配的回调类对象以防止内存泄露</span><br>\t\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 实现父类中的虚函数，客户端流的超时回调过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 返回 true 表示继续，否则希望关闭该异步流</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">timeout_callback</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;Timeout ...\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\taio_socket_stream* client_;<br>\t<span class=\"hljs-type\">int</span>   i_;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">master_aio_test</span> : <span class=\"hljs-keyword\">public</span> master_aio<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">master_aio_test</span>() &#123; timer_test_ = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">timer_test</span>(); &#125;<br><br>\t~<span class=\"hljs-built_in\">master_aio_test</span>() &#123; handle_-&gt;<span class=\"hljs-built_in\">keep_timer</span>(<span class=\"hljs-literal\">false</span>); &#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数：当接收到一个新的连接时调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">on_accept</span><span class=\"hljs-params\">(aio_socket_stream* client)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-comment\">// 创建异步客户端流的回调对象并与该异步流进行绑定</span><br>\t\tio_callback* callback = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">io_callback</span>(client);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的读回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_read_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的写回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_write_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的关闭回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_close_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 注册异步流的超时回调过程</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">add_timeout_callback</span>(callback);<br><br>\t\t<span class=\"hljs-comment\">// 写欢迎信息</span><br>\t\t<span class=\"hljs-keyword\">if</span> (var_cfg_send_banner)<br>\t\t\tclient-&gt;format(<span class=\"hljs-string\">&quot;hello, you&#x27;re welcome\\r\\n&quot;</span>);<br><br>\t\t<span class=\"hljs-comment\">// 从异步流读一行数据</span><br>\t\tclient-&gt;<span class=\"hljs-built_in\">gets</span>(<span class=\"hljs-number\">10</span>, <span class=\"hljs-literal\">false</span>);<br>\t\t<span class=\"hljs-comment\">//client-&gt;read();</span><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程切换用户身份前调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_pre_jail</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc_pre_jail\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-comment\">// 只有当程序启动后才能获得异步引擎句柄</span><br>\t\thandle_ = <span class=\"hljs-built_in\">get_handle</span>();<br>\t\thandle_-&gt;<span class=\"hljs-built_in\">keep_timer</span>(<span class=\"hljs-literal\">true</span>); <span class=\"hljs-comment\">// 允许定时器被重复触发</span><br>\t\t<span class=\"hljs-comment\">// 设置第一个定时任务，每隔1秒触发一次，定时任务ID为0</span><br>\t\thandle_-&gt;<span class=\"hljs-built_in\">set_timer</span>(timer_test_, <span class=\"hljs-number\">1000000</span>, <span class=\"hljs-number\">0</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程切换用户身份后调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_init</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc init\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-comment\">// 设置第二个定时任务，每隔2秒触发一次，定时任务ID为1</span><br>\t\thandle_-&gt;<span class=\"hljs-built_in\">set_timer</span>(timer_test_, <span class=\"hljs-number\">2000000</span>, <span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程退出前调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_exit</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc exit\\r\\n&quot;</span>);<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\ttimer_test* timer_test_;<br>\taio_handle* handle_;<br>&#125;;<br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmaster_aio_test ma;  <span class=\"hljs-comment\">// master_aio 要求只能起一个实例</span><br><br>\t<span class=\"hljs-comment\">// 设置配置参数表</span><br>\tma.<span class=\"hljs-built_in\">set_cfg_int</span>(var_conf_int_tab);<br>\tma.<span class=\"hljs-built_in\">set_cfg_int64</span>(<span class=\"hljs-literal\">NULL</span>);<br>\tma.<span class=\"hljs-built_in\">set_cfg_str</span>(var_conf_str_tab);<br>\tma.<span class=\"hljs-built_in\">set_cfg_bool</span>(var_conf_bool_tab);<br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-string\">&quot;alone&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr = <span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">3</span>)<br>\t\t\taddr = argv[<span class=\"hljs-number\">2</span>];<br><br>\t\tformat = (<span class=\"hljs-built_in\">void</span> (*)(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>*, ...)) printf;<br>\t\tformat(<span class=\"hljs-string\">&quot;listen: %s now\\r\\n&quot;</span>, addr);<br>\t\tma.<span class=\"hljs-built_in\">run_alone</span>(addr);  <span class=\"hljs-comment\">// 单独运行方式</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\tma.<span class=\"hljs-built_in\">run_daemon</span>(argc, argv);  <span class=\"hljs-comment\">// acl_master 控制模式运行</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该示例主要实现几个功能：接收一行数据并回写该数据、延迟回写所读的数据、延迟读下一行数据、设置定时器的定时任务。因为 master_aio 类是按非阻塞模式设计的（其实，该类主要对 acl 库中的非阻塞框架库用 C++ 进行了封装），所以该例子可以支持非常大的并发请求。可以通过配置文件指定系统事件 API 选择采用 select&#x2F;poll&#x2F;epoll 中的一种、规定进程的空闲退出时间、预先启动子进程的数量等参数。该例子所在目录：acl_cpp&#x2F;samples&#x2F;master_aio。</p>\n<p>在这个例子中，当服务端接收到客户端连接后，非阻塞框架会通过虚函数  on_accept 回调子类处理过程，子类需要在这个虚函数中需要将一个处理 IO 过程的类实例与这个非阻塞连接流进行绑定（通过 add_xxx_callback 方式），其中处理 IO 过程的类的基类定义为：aio_callback，子类需要实现其中的虚方法。</p>\n<h2 id=\"三、配置文件及程序安装\"><a href=\"#三、配置文件及程序安装\" class=\"headerlink\" title=\"三、配置文件及程序安装\"></a>三、配置文件及程序安装</h2><p>打开 acl_cpp&#x2F;samples&#x2F;master_aio&#x2F;aio_echo.cf 配置文件，就其中几个配置参数说明一下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-comment\">## 由 acl_master 用来控制服务进程池的配置项</span><br><span class=\"hljs-comment\"># 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程</span><br><span class=\"hljs-attr\">master_disable</span> = <span class=\"hljs-literal\">no</span><br><br><span class=\"hljs-comment\"># 表示本服务器进程监听 127.0.0.1 的 8888 端口</span><br><span class=\"hljs-attr\">master_service</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">8888</span><br><br><span class=\"hljs-comment\"># 表示是 TCP 套接口服务类型</span><br><span class=\"hljs-attr\">master_type</span> = inet<br><br><span class=\"hljs-comment\"># 表示该服务进程池的最大进程数为 2</span><br><span class=\"hljs-attr\">master_maxproc</span> = <span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\"># 需要预先启动的进程数，该值不应大于 master_maxproc</span><br><span class=\"hljs-attr\">master_prefork</span> = <span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\"># 进程程序名</span><br><span class=\"hljs-attr\">master_command</span> = aio_echo<br><br><span class=\"hljs-comment\"># 进程日志记录文件，其中 &#123;install_path&#125; 需要用实际的安装路径代替</span><br><span class=\"hljs-attr\">master_log</span> = &#123;install_path&#125;/var/log/aio_echo.log<br> <br><span class=\"hljs-comment\"># 用 select 进行循环时的时间间隔</span><br><span class=\"hljs-comment\"># 单位为秒</span><br><span class=\"hljs-attr\">aio_delay_sec</span> = <span class=\"hljs-number\">1</span><br><span class=\"hljs-comment\"># 单位为微秒</span><br><span class=\"hljs-attr\">aio_delay_usec</span> = <span class=\"hljs-number\">500</span><br><span class=\"hljs-comment\"># 采用事件循环的方式: select(default), poll, kernel(epoll/devpoll/kqueue)</span><br><span class=\"hljs-attr\">aio_event_mode</span> = select<br><span class=\"hljs-comment\"># 是否将 socket 接收与IO功能分开: yes/no, 如果为 yes 可以大大提高 accept() 速度</span><br><span class=\"hljs-attr\">aio_accept_alone</span> = <span class=\"hljs-literal\">yes</span><br><span class=\"hljs-comment\"># 线程池的最大线程数, 如果该值为0则表示采用单线程非阻塞模式.</span><br><span class=\"hljs-attr\">aio_max_threads</span> = <span class=\"hljs-number\">0</span><br><span class=\"hljs-comment\"># 每个线程的空闲时间.</span><br><span class=\"hljs-attr\">aio_thread_idle_limit</span> = <span class=\"hljs-number\">60</span><br><span class=\"hljs-comment\"># 允许访问的客户端IP地址范围</span><br><span class=\"hljs-attr\">aio_access_allow</span> = <span class=\"hljs-number\">10.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">255.255</span>.<span class=\"hljs-number\">255.255</span>, <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br><span class=\"hljs-comment\"># 当 acl_master 退出时，如果该值置1则该程序不等所有连接处理完毕便立即退出</span><br><span class=\"hljs-attr\">aio_quick_abort</span> = <span class=\"hljs-number\">1</span><br></code></pre></td></tr></table></figure>\n\n<p>例如当 acl_master 服务器框架程序的安装目录为：&#x2F;opt&#x2F;acl，则：</p>\n<ul>\n<li>&#x2F;opt&#x2F;acl&#x2F;libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;conf：该目录存放 acl_master 程序配置文件 main.cf；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;log：该目录存放日志文件；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;pid：该目录存放进程号文件。</li>\n</ul>\n<p>该程序编译通过后，需要把可执行程序放在 &#x2F;opt&#x2F;acl&#x2F;libexec 目录下，把配置文件放在 &#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service 目录下。</p>\n<p>在 &#x2F;opt&#x2F;acl&#x2F;sh 下有启动&#x2F;停止 acl_master 服务进程的控制脚本；运行脚本：.&#x2F;start.sh，然后请用下面方法检查服务是否已经启动：</p>\n<p>ps -ef|grep acl_master # 查看服务器控制进程是否已经启动</p>\n<p>netstat -nap|grep LISTEN|grep 5001 # 查看服务端口号是否已经被监听</p>\n<p>当然，您也可以查看 &#x2F;opt&#x2F;acl&#x2F;var&#x2F;log&#x2F;acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。</p>\n<p>可以命令行如下测试：telnet 127.0.0.1 8888</p>\n<p>github: <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee: <a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"使用 acl::master_threads 类编写多进程多线程服务器程序","date":"2012-05-26T05:02:00.000Z","_content":"\n本文主要讲述如何使用 acl_cpp 中的 master_threads 类编写可以由 acl_master 服务器父进程控制的服务器应用程序。\n\n## 一、类接口说明\nmaster_threads 是一个纯虚类，其中定义的接口需要子类实现，如下：\n```c++\n\t/**\n\t * 纯虚函数：当某个客户端连接有数据可读或关闭或出错时调用此函数\n\t * @param stream {socket_stream*}\n\t * @return {bool} 返回 false 则表示当函数返回后需要关闭连接，\n\t *  否则表示需要保持长连接，如果该流出错，则应用应该返回 false\n\t */\n\tvirtual bool thread_on_read(socket_stream*) = 0;\n\n\t/**\n\t * 当线程池中的某个线程获得一个连接时的回调函数，\n\t * 子类可以做一些初始化工作\n\t * @param stream {socket_stream*}\n\t * @return {bool} 如果返回 false 则表示子类要求关闭连接，而不\n\t *  必将该连接再传递至 thread_main 过程\n\t */\n\tvirtual bool thread_on_accept(socket_stream*) { return true; }\n\n\t/**\n\t * 当与某个线程绑定的连接关闭时的回调函数\n\t * @param stream {socket_stream*}\n\t */\n\tvirtual void thread_on_close(socket_stream* ) {}\n\n\t/**\n\t * 当线程池中一个新线程被创建时的回调函数\n\t */\n\tvirtual void thread_on_init() {}\n\n\t/**\n\t * 当线程池中一个线程退出时的回调函数\n\t */\n\tvirtual void thread_on_exit() {}\n```\n\nmaster_threads 类提供了两个函数：\n```c++\n\t/**\n\t * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架\n\t * 控制之下运行，一般用于生产机状态\n\t * @param argc {int} 从 main 中传递的第一个参数，表示参数个数\n\t * @param argv {char**} 从 main 中传递的第二个参数\n\t */\n\tvoid run_daemon(int argc, char** argv);\n\n\t/**\n\t * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作\n\t * @param addr {const char*} 服务监听地址\n\t * @param conf {const char*} 配置文件全路径\n\t * @param count {unsigned int} 循环服务的次数，达到此值后函数自动返回；\n\t *  若该值为 0 则表示程序一直循环处理外来请求而不返回\n\t * @param threads_count {int} 当该值大于 1 时表示自动采用线程池方式，\n\t *  该值只有当 count != 1 时才有效，即若 count == 1 则仅运行一次就返回\n\t *  且不会启动线程处理客户端请求\n\t * @return {bool} 监听是否成功\n\t */\n\tbool run_alone(const char* addr, const char* conf = NULL,\n\t\tunsigned int count = 1, int threads_count = 1);\n```\n\n从上面两个函数，可以看出 master_threads 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。\n\nmaster_threads 的基类 master_base 的几个虚接口如下：\n```c++\n\t/**\n\t * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些\n\t * 用户身份为 root 的权限操作\n\t */\n\tvirtual void proc_pre_jail() {}\n\n\t/**\n\t * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程\n\t * 的权限为普通受限级别\n\t */\n\tvirtual void proc_on_init() {}\n\n\t/**\n\t * 当进程退出前调用的回调函数\n\t */\n\tvirtual void proc_on_exit() {}\n```\n\n\t// 在 run_alone 状态下运行前，调用此函数初始化一些配置\n\n基类的这几个虚函数用户可以根据需要调用。\n \n另外，基类 master_base 还提供了几个用来读配置选项的函数：\n```c++\n\t/**\n\t * 设置 bool 类型的配置项\n\t * @param table {master_bool_tbl*}\n\t */\n\tvoid set_cfg_bool(master_bool_tbl* table);\n\n\t/**\n\t * 设置 int 类型的配置项\n\t * @param table {master_int_tbl*}\n\t */\n\tvoid set_cfg_int(master_int_tbl* table);\n\n\t/**\n\t * 设置 int64 类型的配置项\n\t * @param table {master_int64_tbl*}\n\t */\n\tvoid set_cfg_int64(master_int64_tbl* table);\n\n\t/**\n\t * 设置 字符串 类型的配置项\n\t * @param table {master_str_tbl*}\n\t */\n\tvoid set_cfg_str(master_str_tbl* table);\n```\n\n## 二、示例源程序\n\n```c++\n// master_threads.cpp : 定义控制台应用程序的入口点。\n//\n\n#include \"log.hpp\"\n#include \"util.hpp\"\n#include \"master_threads.hpp\"\n#include \"socket_stream.hpp\"\n\n// 字符串类型的配置项\nstatic char *var_cfg_debug_msg;\n\nstatic acl::master_str_tbl var_conf_str_tab[] = {\n\t{ \"debug_msg\", \"test_msg\", &var_cfg_debug_msg },\n\n\t{ 0, 0, 0 }\n};\n\n// 布尔类型的配置项\nstatic int  var_cfg_debug_enable;\nstatic int  var_cfg_keep_alive;\nstatic int  var_cfg_loop;\n\nstatic acl::master_bool_tbl var_conf_bool_tab[] = {\n\t{ \"debug_enable\", 1, &var_cfg_debug_enable },\n\t{ \"keep_alive\", 1, &var_cfg_keep_alive },\n\t{ \"loop_read\", 1, &var_cfg_loop },\n\n\t{ 0, 0, 0 }\n};\n\n// 整数类型的配置项\nstatic int  var_cfg_io_timeout;\n\nstatic acl::master_int_tbl var_conf_int_tab[] = {\n\t{ \"io_timeout\", 120, &var_cfg_io_timeout, 0, 0 },\n\n\t{ 0, 0 , 0 , 0, 0 }\n};\n\nstatic void (*format)(const char*, ...) = acl::log::msg1;\n\n//////////////////////////////////////////////////////////////////////////\n\nclass master_threads_test : public acl::master_threads\n{\npublic:\n\tmaster_threads_test()\n\t{\n\t}\n\n\t~master_threads_test()\n\t{\n\t}\n\nprotected:\n\t// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示\n\t// 继续与客户端保持长连接，否则表示需要关闭客户端连接\n\tbool thread_on_read(acl::socket_stream* stream)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tif (on_read(stream) == false)\n\t\t\t\treturn false;\n\t\t\tif (var_cfg_loop == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool on_read(acl::socket_stream* stream)\n\t{\n\t\tformat(\"%s(%d)\", __FILE__, __LINE__);\n\t\tacl::string buf;\n\t\tif (stream->gets(buf) == false) // 读一行数据\n\t\t{\n\t\t\tformat(\"gets error: %s\", acl::last_serror());\n\t\t\tformat(\"%s(%d)\", __FILE__, __LINE__);\n\t\t\treturn false;\n\t\t}\n\t\tif (buf == \"quit\")  // 如果客户端要求关闭连接，则返回 false 通知服务器框架关闭连接\n\t\t{\n\t\t\tstream->puts(\"bye!\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (buf.empty())\n\t\t{\n\t\t\tif (stream->write(\"\\r\\n\") == -1)\n\t\t\t{\n\t\t\t\tformat(\"write 1 error: %s\", acl::last_serror());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (stream->write(buf) == -1)\n\t\t{\n\t\t\tformat(\"write 2 error: %s, buf(%s), len: %d\",\n\t\t\t\tacl::last_serror(), buf.c_str(), (int) buf.length());\n\t\t\treturn false;\n\t\t}\n\t\telse if (stream->write(\"\\r\\n\") == -1)\n\t\t{\n\t\t\tformat(\"write 3 client error: %s\", acl::last_serror());\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许\n\t// 子类事先对客户端连接进行处理，返回 true 表示继续，否则\n\t// 要求关闭该客户端连接\n\tbool thread_on_accept(acl::socket_stream* stream)\n\t{\n\t\tformat(\"accept one client, peer: %s, local: %s, var_cfg_io_timeout: %d\\r\\n\",\n\t\t\tstream->get_peer(), stream->get_local(), var_cfg_io_timeout);\n\t\tif (stream->format(\"hello, you're welcome!\\r\\n\") == -1)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t// 基类虚函数：当客户端连接关闭时调用此函数\n\tvoid thread_on_close(acl::socket_stream*)\n\t{\n\t\tformat(\"client closed now\\r\\n\");\n\t}\n\n\t// 基类虚函数：当线程池创建一个新线程时调用此函数\n\tvoid thread_on_init()\n\t{\n#ifdef WIN32\n\t\tformat(\"thread init: tid: %lu\\r\\n\", GetCurrentThreadId());\n#else\n\t\tformat(\"thread init: tid: %lu\\r\\n\", pthread_self());\n#endif\n\t}\n\n\t// 基类虚函数：当线程池中的一个线程退出时调用此函数\n\tvirtual void thread_on_exit()\n\t{\n#ifdef WIN32\n\t\tformat(\"thread exit: tid: %lu\\r\\n\", GetCurrentThreadId());\n#else\n\t\tformat(\"thread exit: tid: %lu\\r\\n\", pthread_self());\n#endif\n\t}\n\n\t// 基类虚函数：服务进程切换用户身份前调用此函数\n\tvoid proc_pre_jail()\n\t{\n\t\tformat(\"proc_pre_jail\\r\\n\");\n\t}\n\n\t// 基类虚函数：服务进程切换用户身份后调用此函数\n\tvoid proc_on_init()\n\t{\n\t\tformat(\"proc init\\r\\n\");\n\t}\n\n\t// 基类虚函数：服务进程退出前调用此函数\n\tvoid proc_on_exit()\n\t{\n\t\tformat(\"proc exit\\r\\n\");\n\t}\n};\n\nint main(int argc, char* argv[])\n{\n\tmaster_threads_test mt;\n\n\t// 设置配置参数表\n\tmt.set_cfg_int(var_conf_int_tab);\n\tmt.set_cfg_int64(NULL);\n\tmt.set_cfg_str(var_conf_str_tab);\n\tmt.set_cfg_bool(var_conf_bool_tab);\n\n\t// 开始运行\n\n\tif (argc >= 2 && strcmp(argv[1], \"alone\") == 0)\n\t{\n\t\tformat = (void (*)(const char*, ...)) printf;\n\t\tformat(\"listen: 127.0.0.1:8888\\r\\n\");\n\t\tmt.run_alone(\"127.0.0.1:8888\", NULL, 2, 10);  // 单独运行方式\n\t}\n\telse\n\t\tmt.run_daemon(argc, argv);  // acl_master 控制模式运行\n\treturn 0;\n}\n```\n\n这是一个简单的提供 echo 行服务的服务器程序，可以支持多个并发连接，而且可以通过配置文件控制所启动的最大进程数、每个进程的最大线程数、进程空闲时间、线程空闲时间等控制参数，因为 acl 中的服务器框架都是半驻留的，所以既可以保证运行效率，又能够在空闲释放系统资源。该例子所在目录：acl_cpp/samples/master_threads。\n\n需要指出的一点是，master_threads 内部是单例的，即要求该类的对象只能有一个，否则内部自动产生断言。只所以没有采用单例模板来设计单例，主要是为了不对外暴露 acl 库中的接口，使使用 acl_cpp 库的用户不必关心 acl 库的头文件在哪儿。\n\n## 三、配置文件及程序安装\n\n打开 acl_cpp/samples/master_threads/ioctl_echo.cf 配置文件，就其中几个配置参数说明一下：\n\n```\n## 由 acl_master 用来控制服务进程池的配置项\n# 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程\nmaster_disable = no\n\n# 表示本服务器进程监听 127.0.0.1 的 5001 端口\nmaster_service = 127.0.0.1:5001\n\n# 表示是 TCP 套接口服务类型\nmaster_type = inet\n\n# 表示该服务进程池的最大进程数为 2\nmaster_maxproc = 2\n\n# 进程日志记录文件，其中 {install_path} 需要用实际的安装路径代替\nmaster_log = {install_path}/var/log/ioctl_echo.log\n\n## 与该服务器框架模板相关的配置参数项\n# 每个服务进程中最大的线程数为 250\nioctl_max_threads = 250\n\n# 线程的堆栈空间大小，单位为字节，0表示使用系统缺省值\nioctl_stacksize = 0\n\n# 每个进程实例处理连接数的最大次数，超过此值后进程实例主动退出\nioctl_use_limit = 100\n\n# 每个进程实例的空闲超时时间，超过此值后进程实例主动退出\nioctl_idle_limit = 120\n\n# 进程运行时的用户身份\nioctl_owner = root\n\n# 采用事件循环的方式: select(default)/poll/kernel(epoll/devpoll/kqueue)\nioctl_event_mode = select\n\n# 允许访问 udserver 的客户端IP地址范围\nioctl_access_allow = 10.0.0.1:10.0.0.255, 127.0.0.1:127.0.0.1\n```\n\n例如当 acl_master 服务器框架程序的安装目录为：/opt/acl，则：\n\n- /opt/acl/libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；\n- /opt/acl/conf：该目录存放 acl_master 程序配置文件 main.cf；\n- /opt/acl/conf/service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；\n- /opt/acl/var/log：该目录存放日志文件；\n- /opt/acl/var/pid：该目录存放进程号文件。\n\n该程序编译通过后，需要把可执行程序放在 /opt/acl/libexec 目录下，把配置文件放在 /opt/acl/conf/service 目录下。\n\n在 /opt/acl/sh 下有启动/停止 acl_master 服务进程的控制脚本；运行脚本：./start.sh，然后请用下面方法检查服务是否已经启动：\n\n`$ps -ef|grep acl_master`  查看服务器控制进程是否已经启动\n\n`$netstat -nap|grep LISTEN|grep 5001` 查看服务端口号是否已经被监听\n\n当然，您也可以查看 /opt/acl/var/log/acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。\n\n可以命令行如下测试：`$telnet 127.0.0.1 5001`","source":"_posts/master_threads.md","raw":"---\ntitle: 使用 acl::master_threads 类编写多进程多线程服务器程序\ndate: 2012-05-26 13:02\ncategories: 服务编程\n---\n\n本文主要讲述如何使用 acl_cpp 中的 master_threads 类编写可以由 acl_master 服务器父进程控制的服务器应用程序。\n\n## 一、类接口说明\nmaster_threads 是一个纯虚类，其中定义的接口需要子类实现，如下：\n```c++\n\t/**\n\t * 纯虚函数：当某个客户端连接有数据可读或关闭或出错时调用此函数\n\t * @param stream {socket_stream*}\n\t * @return {bool} 返回 false 则表示当函数返回后需要关闭连接，\n\t *  否则表示需要保持长连接，如果该流出错，则应用应该返回 false\n\t */\n\tvirtual bool thread_on_read(socket_stream*) = 0;\n\n\t/**\n\t * 当线程池中的某个线程获得一个连接时的回调函数，\n\t * 子类可以做一些初始化工作\n\t * @param stream {socket_stream*}\n\t * @return {bool} 如果返回 false 则表示子类要求关闭连接，而不\n\t *  必将该连接再传递至 thread_main 过程\n\t */\n\tvirtual bool thread_on_accept(socket_stream*) { return true; }\n\n\t/**\n\t * 当与某个线程绑定的连接关闭时的回调函数\n\t * @param stream {socket_stream*}\n\t */\n\tvirtual void thread_on_close(socket_stream* ) {}\n\n\t/**\n\t * 当线程池中一个新线程被创建时的回调函数\n\t */\n\tvirtual void thread_on_init() {}\n\n\t/**\n\t * 当线程池中一个线程退出时的回调函数\n\t */\n\tvirtual void thread_on_exit() {}\n```\n\nmaster_threads 类提供了两个函数：\n```c++\n\t/**\n\t * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架\n\t * 控制之下运行，一般用于生产机状态\n\t * @param argc {int} 从 main 中传递的第一个参数，表示参数个数\n\t * @param argv {char**} 从 main 中传递的第二个参数\n\t */\n\tvoid run_daemon(int argc, char** argv);\n\n\t/**\n\t * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作\n\t * @param addr {const char*} 服务监听地址\n\t * @param conf {const char*} 配置文件全路径\n\t * @param count {unsigned int} 循环服务的次数，达到此值后函数自动返回；\n\t *  若该值为 0 则表示程序一直循环处理外来请求而不返回\n\t * @param threads_count {int} 当该值大于 1 时表示自动采用线程池方式，\n\t *  该值只有当 count != 1 时才有效，即若 count == 1 则仅运行一次就返回\n\t *  且不会启动线程处理客户端请求\n\t * @return {bool} 监听是否成功\n\t */\n\tbool run_alone(const char* addr, const char* conf = NULL,\n\t\tunsigned int count = 1, int threads_count = 1);\n```\n\n从上面两个函数，可以看出 master_threads 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。\n\nmaster_threads 的基类 master_base 的几个虚接口如下：\n```c++\n\t/**\n\t * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些\n\t * 用户身份为 root 的权限操作\n\t */\n\tvirtual void proc_pre_jail() {}\n\n\t/**\n\t * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程\n\t * 的权限为普通受限级别\n\t */\n\tvirtual void proc_on_init() {}\n\n\t/**\n\t * 当进程退出前调用的回调函数\n\t */\n\tvirtual void proc_on_exit() {}\n```\n\n\t// 在 run_alone 状态下运行前，调用此函数初始化一些配置\n\n基类的这几个虚函数用户可以根据需要调用。\n \n另外，基类 master_base 还提供了几个用来读配置选项的函数：\n```c++\n\t/**\n\t * 设置 bool 类型的配置项\n\t * @param table {master_bool_tbl*}\n\t */\n\tvoid set_cfg_bool(master_bool_tbl* table);\n\n\t/**\n\t * 设置 int 类型的配置项\n\t * @param table {master_int_tbl*}\n\t */\n\tvoid set_cfg_int(master_int_tbl* table);\n\n\t/**\n\t * 设置 int64 类型的配置项\n\t * @param table {master_int64_tbl*}\n\t */\n\tvoid set_cfg_int64(master_int64_tbl* table);\n\n\t/**\n\t * 设置 字符串 类型的配置项\n\t * @param table {master_str_tbl*}\n\t */\n\tvoid set_cfg_str(master_str_tbl* table);\n```\n\n## 二、示例源程序\n\n```c++\n// master_threads.cpp : 定义控制台应用程序的入口点。\n//\n\n#include \"log.hpp\"\n#include \"util.hpp\"\n#include \"master_threads.hpp\"\n#include \"socket_stream.hpp\"\n\n// 字符串类型的配置项\nstatic char *var_cfg_debug_msg;\n\nstatic acl::master_str_tbl var_conf_str_tab[] = {\n\t{ \"debug_msg\", \"test_msg\", &var_cfg_debug_msg },\n\n\t{ 0, 0, 0 }\n};\n\n// 布尔类型的配置项\nstatic int  var_cfg_debug_enable;\nstatic int  var_cfg_keep_alive;\nstatic int  var_cfg_loop;\n\nstatic acl::master_bool_tbl var_conf_bool_tab[] = {\n\t{ \"debug_enable\", 1, &var_cfg_debug_enable },\n\t{ \"keep_alive\", 1, &var_cfg_keep_alive },\n\t{ \"loop_read\", 1, &var_cfg_loop },\n\n\t{ 0, 0, 0 }\n};\n\n// 整数类型的配置项\nstatic int  var_cfg_io_timeout;\n\nstatic acl::master_int_tbl var_conf_int_tab[] = {\n\t{ \"io_timeout\", 120, &var_cfg_io_timeout, 0, 0 },\n\n\t{ 0, 0 , 0 , 0, 0 }\n};\n\nstatic void (*format)(const char*, ...) = acl::log::msg1;\n\n//////////////////////////////////////////////////////////////////////////\n\nclass master_threads_test : public acl::master_threads\n{\npublic:\n\tmaster_threads_test()\n\t{\n\t}\n\n\t~master_threads_test()\n\t{\n\t}\n\nprotected:\n\t// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示\n\t// 继续与客户端保持长连接，否则表示需要关闭客户端连接\n\tbool thread_on_read(acl::socket_stream* stream)\n\t{\n\t\twhile (true)\n\t\t{\n\t\t\tif (on_read(stream) == false)\n\t\t\t\treturn false;\n\t\t\tif (var_cfg_loop == 0)\n\t\t\t\tbreak;\n\t\t}\n\t\treturn true;\n\t}\n\n\tbool on_read(acl::socket_stream* stream)\n\t{\n\t\tformat(\"%s(%d)\", __FILE__, __LINE__);\n\t\tacl::string buf;\n\t\tif (stream->gets(buf) == false) // 读一行数据\n\t\t{\n\t\t\tformat(\"gets error: %s\", acl::last_serror());\n\t\t\tformat(\"%s(%d)\", __FILE__, __LINE__);\n\t\t\treturn false;\n\t\t}\n\t\tif (buf == \"quit\")  // 如果客户端要求关闭连接，则返回 false 通知服务器框架关闭连接\n\t\t{\n\t\t\tstream->puts(\"bye!\");\n\t\t\treturn false;\n\t\t}\n\n\t\tif (buf.empty())\n\t\t{\n\t\t\tif (stream->write(\"\\r\\n\") == -1)\n\t\t\t{\n\t\t\t\tformat(\"write 1 error: %s\", acl::last_serror());\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\telse if (stream->write(buf) == -1)\n\t\t{\n\t\t\tformat(\"write 2 error: %s, buf(%s), len: %d\",\n\t\t\t\tacl::last_serror(), buf.c_str(), (int) buf.length());\n\t\t\treturn false;\n\t\t}\n\t\telse if (stream->write(\"\\r\\n\") == -1)\n\t\t{\n\t\t\tformat(\"write 3 client error: %s\", acl::last_serror());\n\t\t\treturn false;\n\t\t}\n\t\treturn true;\n\t}\n\n\t// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许\n\t// 子类事先对客户端连接进行处理，返回 true 表示继续，否则\n\t// 要求关闭该客户端连接\n\tbool thread_on_accept(acl::socket_stream* stream)\n\t{\n\t\tformat(\"accept one client, peer: %s, local: %s, var_cfg_io_timeout: %d\\r\\n\",\n\t\t\tstream->get_peer(), stream->get_local(), var_cfg_io_timeout);\n\t\tif (stream->format(\"hello, you're welcome!\\r\\n\") == -1)\n\t\t\treturn false;\n\t\treturn true;\n\t}\n\n\t// 基类虚函数：当客户端连接关闭时调用此函数\n\tvoid thread_on_close(acl::socket_stream*)\n\t{\n\t\tformat(\"client closed now\\r\\n\");\n\t}\n\n\t// 基类虚函数：当线程池创建一个新线程时调用此函数\n\tvoid thread_on_init()\n\t{\n#ifdef WIN32\n\t\tformat(\"thread init: tid: %lu\\r\\n\", GetCurrentThreadId());\n#else\n\t\tformat(\"thread init: tid: %lu\\r\\n\", pthread_self());\n#endif\n\t}\n\n\t// 基类虚函数：当线程池中的一个线程退出时调用此函数\n\tvirtual void thread_on_exit()\n\t{\n#ifdef WIN32\n\t\tformat(\"thread exit: tid: %lu\\r\\n\", GetCurrentThreadId());\n#else\n\t\tformat(\"thread exit: tid: %lu\\r\\n\", pthread_self());\n#endif\n\t}\n\n\t// 基类虚函数：服务进程切换用户身份前调用此函数\n\tvoid proc_pre_jail()\n\t{\n\t\tformat(\"proc_pre_jail\\r\\n\");\n\t}\n\n\t// 基类虚函数：服务进程切换用户身份后调用此函数\n\tvoid proc_on_init()\n\t{\n\t\tformat(\"proc init\\r\\n\");\n\t}\n\n\t// 基类虚函数：服务进程退出前调用此函数\n\tvoid proc_on_exit()\n\t{\n\t\tformat(\"proc exit\\r\\n\");\n\t}\n};\n\nint main(int argc, char* argv[])\n{\n\tmaster_threads_test mt;\n\n\t// 设置配置参数表\n\tmt.set_cfg_int(var_conf_int_tab);\n\tmt.set_cfg_int64(NULL);\n\tmt.set_cfg_str(var_conf_str_tab);\n\tmt.set_cfg_bool(var_conf_bool_tab);\n\n\t// 开始运行\n\n\tif (argc >= 2 && strcmp(argv[1], \"alone\") == 0)\n\t{\n\t\tformat = (void (*)(const char*, ...)) printf;\n\t\tformat(\"listen: 127.0.0.1:8888\\r\\n\");\n\t\tmt.run_alone(\"127.0.0.1:8888\", NULL, 2, 10);  // 单独运行方式\n\t}\n\telse\n\t\tmt.run_daemon(argc, argv);  // acl_master 控制模式运行\n\treturn 0;\n}\n```\n\n这是一个简单的提供 echo 行服务的服务器程序，可以支持多个并发连接，而且可以通过配置文件控制所启动的最大进程数、每个进程的最大线程数、进程空闲时间、线程空闲时间等控制参数，因为 acl 中的服务器框架都是半驻留的，所以既可以保证运行效率，又能够在空闲释放系统资源。该例子所在目录：acl_cpp/samples/master_threads。\n\n需要指出的一点是，master_threads 内部是单例的，即要求该类的对象只能有一个，否则内部自动产生断言。只所以没有采用单例模板来设计单例，主要是为了不对外暴露 acl 库中的接口，使使用 acl_cpp 库的用户不必关心 acl 库的头文件在哪儿。\n\n## 三、配置文件及程序安装\n\n打开 acl_cpp/samples/master_threads/ioctl_echo.cf 配置文件，就其中几个配置参数说明一下：\n\n```\n## 由 acl_master 用来控制服务进程池的配置项\n# 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程\nmaster_disable = no\n\n# 表示本服务器进程监听 127.0.0.1 的 5001 端口\nmaster_service = 127.0.0.1:5001\n\n# 表示是 TCP 套接口服务类型\nmaster_type = inet\n\n# 表示该服务进程池的最大进程数为 2\nmaster_maxproc = 2\n\n# 进程日志记录文件，其中 {install_path} 需要用实际的安装路径代替\nmaster_log = {install_path}/var/log/ioctl_echo.log\n\n## 与该服务器框架模板相关的配置参数项\n# 每个服务进程中最大的线程数为 250\nioctl_max_threads = 250\n\n# 线程的堆栈空间大小，单位为字节，0表示使用系统缺省值\nioctl_stacksize = 0\n\n# 每个进程实例处理连接数的最大次数，超过此值后进程实例主动退出\nioctl_use_limit = 100\n\n# 每个进程实例的空闲超时时间，超过此值后进程实例主动退出\nioctl_idle_limit = 120\n\n# 进程运行时的用户身份\nioctl_owner = root\n\n# 采用事件循环的方式: select(default)/poll/kernel(epoll/devpoll/kqueue)\nioctl_event_mode = select\n\n# 允许访问 udserver 的客户端IP地址范围\nioctl_access_allow = 10.0.0.1:10.0.0.255, 127.0.0.1:127.0.0.1\n```\n\n例如当 acl_master 服务器框架程序的安装目录为：/opt/acl，则：\n\n- /opt/acl/libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；\n- /opt/acl/conf：该目录存放 acl_master 程序配置文件 main.cf；\n- /opt/acl/conf/service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；\n- /opt/acl/var/log：该目录存放日志文件；\n- /opt/acl/var/pid：该目录存放进程号文件。\n\n该程序编译通过后，需要把可执行程序放在 /opt/acl/libexec 目录下，把配置文件放在 /opt/acl/conf/service 目录下。\n\n在 /opt/acl/sh 下有启动/停止 acl_master 服务进程的控制脚本；运行脚本：./start.sh，然后请用下面方法检查服务是否已经启动：\n\n`$ps -ef|grep acl_master`  查看服务器控制进程是否已经启动\n\n`$netstat -nap|grep LISTEN|grep 5001` 查看服务端口号是否已经被监听\n\n当然，您也可以查看 /opt/acl/var/log/acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。\n\n可以命令行如下测试：`$telnet 127.0.0.1 5001`","slug":"master_threads","published":1,"updated":"2023-01-24T06:34:03.078Z","_id":"cld9wk4hj000g7x9kflqx26u8","comments":1,"layout":"post","photos":[],"link":"","content":"<p>本文主要讲述如何使用 acl_cpp 中的 master_threads 类编写可以由 acl_master 服务器父进程控制的服务器应用程序。</p>\n<h2 id=\"一、类接口说明\"><a href=\"#一、类接口说明\" class=\"headerlink\" title=\"一、类接口说明\"></a>一、类接口说明</h2><p>master_threads 是一个纯虚类，其中定义的接口需要子类实现，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 纯虚函数：当某个客户端连接有数据可读或关闭或出错时调用此函数</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 false 则表示当函数返回后需要关闭连接，</span><br><span class=\"hljs-comment\"> *  否则表示需要保持长连接，如果该流出错，则应用应该返回 false</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_read</span><span class=\"hljs-params\">(socket_stream*)</span> </span>= <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当线程池中的某个线程获得一个连接时的回调函数，</span><br><span class=\"hljs-comment\"> * 子类可以做一些初始化工作</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 如果返回 false 则表示子类要求关闭连接，而不</span><br><span class=\"hljs-comment\"> *  必将该连接再传递至 thread_main 过程</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_accept</span><span class=\"hljs-params\">(socket_stream*)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; &#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当与某个线程绑定的连接关闭时的回调函数</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_close</span><span class=\"hljs-params\">(socket_stream* )</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当线程池中一个新线程被创建时的回调函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_init</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当线程池中一个线程退出时的回调函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_exit</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>master_threads 类提供了两个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架</span><br><span class=\"hljs-comment\"> * 控制之下运行，一般用于生产机状态</span><br><span class=\"hljs-comment\"> * @param argc &#123;int&#125; 从 main 中传递的第一个参数，表示参数个数</span><br><span class=\"hljs-comment\"> * @param argv &#123;char**&#125; 从 main 中传递的第二个参数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run_daemon</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>** argv)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作</span><br><span class=\"hljs-comment\"> * @param addr &#123;const char*&#125; 服务监听地址</span><br><span class=\"hljs-comment\"> * @param conf &#123;const char*&#125; 配置文件全路径</span><br><span class=\"hljs-comment\"> * @param count &#123;unsigned int&#125; 循环服务的次数，达到此值后函数自动返回；</span><br><span class=\"hljs-comment\"> *  若该值为 0 则表示程序一直循环处理外来请求而不返回</span><br><span class=\"hljs-comment\"> * @param threads_count &#123;int&#125; 当该值大于 1 时表示自动采用线程池方式，</span><br><span class=\"hljs-comment\"> *  该值只有当 count != 1 时才有效，即若 count == 1 则仅运行一次就返回</span><br><span class=\"hljs-comment\"> *  且不会启动线程处理客户端请求</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 监听是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">run_alone</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* conf = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> count = <span class=\"hljs-number\">1</span>, <span class=\"hljs-type\">int</span> threads_count = <span class=\"hljs-number\">1</span>)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>从上面两个函数，可以看出 master_threads 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。</p>\n<p>master_threads 的基类 master_base 的几个虚接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些</span><br><span class=\"hljs-comment\"> * 用户身份为 root 的权限操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_pre_jail</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程</span><br><span class=\"hljs-comment\"> * 的权限为普通受限级别</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_init</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程退出前调用的回调函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_exit</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<pre><code class=\"hljs\">// 在 run_alone 状态下运行前，调用此函数初始化一些配置\n</code></pre>\n<p>基类的这几个虚函数用户可以根据需要调用。</p>\n<p>另外，基类 master_base 还提供了几个用来读配置选项的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 bool 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_bool_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_bool</span><span class=\"hljs-params\">(master_bool_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 int 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_int_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_int</span><span class=\"hljs-params\">(master_int_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 int64 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_int64_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_int64</span><span class=\"hljs-params\">(master_int64_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 字符串 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_str_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_str</span><span class=\"hljs-params\">(master_str_tbl* table)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、示例源程序\"><a href=\"#二、示例源程序\" class=\"headerlink\" title=\"二、示例源程序\"></a>二、示例源程序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// master_threads.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;log.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;util.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;master_threads.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;socket_stream.hpp&quot;</span></span><br><br><span class=\"hljs-comment\">// 字符串类型的配置项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_debug_msg;<br><br><span class=\"hljs-type\">static</span> acl::master_str_tbl var_conf_str_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_msg&quot;</span>, <span class=\"hljs-string\">&quot;test_msg&quot;</span>, &amp;var_cfg_debug_msg &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 布尔类型的配置项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_debug_enable;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_keep_alive;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_loop;<br><br><span class=\"hljs-type\">static</span> acl::master_bool_tbl var_conf_bool_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_enable&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_debug_enable &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;keep_alive&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_keep_alive &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;loop_read&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_loop &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 整数类型的配置项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_io_timeout;<br><br><span class=\"hljs-type\">static</span> acl::master_int_tbl var_conf_int_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;io_timeout&quot;</span>, <span class=\"hljs-number\">120</span>, &amp;var_cfg_io_timeout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-title\">void</span> <span class=\"hljs-params\">(*format)</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>*, ...)</span> </span>= acl::log::msg1;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">master_threads_test</span> : <span class=\"hljs-keyword\">public</span> acl::master_threads<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">master_threads_test</span>()<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">master_threads_test</span>()<br>\t&#123;<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示</span><br>\t<span class=\"hljs-comment\">// 继续与客户端保持长连接，否则表示需要关闭客户端连接</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_read</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">on_read</span>(stream) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (var_cfg_loop == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">on_read</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;%s(%d)&quot;</span>, __FILE__, __LINE__);<br>\t\tacl::string buf;<br>\t\t<span class=\"hljs-keyword\">if</span> (stream-&gt;<span class=\"hljs-built_in\">gets</span>(buf) == <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// 读一行数据</span><br>\t\t&#123;<br>\t\t\tformat(<span class=\"hljs-string\">&quot;gets error: %s&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\tformat(<span class=\"hljs-string\">&quot;%s(%d)&quot;</span>, __FILE__, __LINE__);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (buf == <span class=\"hljs-string\">&quot;quit&quot;</span>)  <span class=\"hljs-comment\">// 如果客户端要求关闭连接，则返回 false 通知服务器框架关闭连接</span><br>\t\t&#123;<br>\t\t\tstream-&gt;<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;bye!&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (buf.<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (stream-&gt;<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>) == <span class=\"hljs-number\">-1</span>)<br>\t\t\t&#123;<br>\t\t\t\tformat(<span class=\"hljs-string\">&quot;write 1 error: %s&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (stream-&gt;<span class=\"hljs-built_in\">write</span>(buf) == <span class=\"hljs-number\">-1</span>)<br>\t\t&#123;<br>\t\t\tformat(<span class=\"hljs-string\">&quot;write 2 error: %s, buf(%s), len: %d&quot;</span>,<br>\t\t\t\tacl::<span class=\"hljs-built_in\">last_serror</span>(), buf.<span class=\"hljs-built_in\">c_str</span>(), (<span class=\"hljs-type\">int</span>) buf.<span class=\"hljs-built_in\">length</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (stream-&gt;<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>) == <span class=\"hljs-number\">-1</span>)<br>\t\t&#123;<br>\t\t\tformat(<span class=\"hljs-string\">&quot;write 3 client error: %s&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许</span><br>\t<span class=\"hljs-comment\">// 子类事先对客户端连接进行处理，返回 true 表示继续，否则</span><br>\t<span class=\"hljs-comment\">// 要求关闭该客户端连接</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_accept</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;accept one client, peer: %s, local: %s, var_cfg_io_timeout: %d\\r\\n&quot;</span>,<br>\t\t\tstream-&gt;<span class=\"hljs-built_in\">get_peer</span>(), stream-&gt;<span class=\"hljs-built_in\">get_local</span>(), var_cfg_io_timeout);<br>\t\t<span class=\"hljs-keyword\">if</span> (stream-&gt;format(<span class=\"hljs-string\">&quot;hello, you&#x27;re welcome!\\r\\n&quot;</span>) == <span class=\"hljs-number\">-1</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当客户端连接关闭时调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_close</span><span class=\"hljs-params\">(acl::socket_stream*)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;client closed now\\r\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当线程池创建一个新线程时调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_init</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t\tformat(<span class=\"hljs-string\">&quot;thread init: tid: %lu\\r\\n&quot;</span>, <span class=\"hljs-built_in\">GetCurrentThreadId</span>());<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>\t\tformat(<span class=\"hljs-string\">&quot;thread init: tid: %lu\\r\\n&quot;</span>, <span class=\"hljs-built_in\">pthread_self</span>());<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当线程池中的一个线程退出时调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_exit</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t\tformat(<span class=\"hljs-string\">&quot;thread exit: tid: %lu\\r\\n&quot;</span>, <span class=\"hljs-built_in\">GetCurrentThreadId</span>());<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>\t\tformat(<span class=\"hljs-string\">&quot;thread exit: tid: %lu\\r\\n&quot;</span>, <span class=\"hljs-built_in\">pthread_self</span>());<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程切换用户身份前调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_pre_jail</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc_pre_jail\\r\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程切换用户身份后调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_init</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc init\\r\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程退出前调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_exit</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc exit\\r\\n&quot;</span>);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmaster_threads_test mt;<br><br>\t<span class=\"hljs-comment\">// 设置配置参数表</span><br>\tmt.<span class=\"hljs-built_in\">set_cfg_int</span>(var_conf_int_tab);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_int64</span>(<span class=\"hljs-literal\">NULL</span>);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_str</span>(var_conf_str_tab);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_bool</span>(var_conf_bool_tab);<br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-string\">&quot;alone&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\tformat = (<span class=\"hljs-built_in\">void</span> (*)(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>*, ...)) printf;<br>\t\tformat(<span class=\"hljs-string\">&quot;listen: 127.0.0.1:8888\\r\\n&quot;</span>);<br>\t\tmt.<span class=\"hljs-built_in\">run_alone</span>(<span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">// 单独运行方式</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\tmt.<span class=\"hljs-built_in\">run_daemon</span>(argc, argv);  <span class=\"hljs-comment\">// acl_master 控制模式运行</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这是一个简单的提供 echo 行服务的服务器程序，可以支持多个并发连接，而且可以通过配置文件控制所启动的最大进程数、每个进程的最大线程数、进程空闲时间、线程空闲时间等控制参数，因为 acl 中的服务器框架都是半驻留的，所以既可以保证运行效率，又能够在空闲释放系统资源。该例子所在目录：acl_cpp&#x2F;samples&#x2F;master_threads。</p>\n<p>需要指出的一点是，master_threads 内部是单例的，即要求该类的对象只能有一个，否则内部自动产生断言。只所以没有采用单例模板来设计单例，主要是为了不对外暴露 acl 库中的接口，使使用 acl_cpp 库的用户不必关心 acl 库的头文件在哪儿。</p>\n<h2 id=\"三、配置文件及程序安装\"><a href=\"#三、配置文件及程序安装\" class=\"headerlink\" title=\"三、配置文件及程序安装\"></a>三、配置文件及程序安装</h2><p>打开 acl_cpp&#x2F;samples&#x2F;master_threads&#x2F;ioctl_echo.cf 配置文件，就其中几个配置参数说明一下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-comment\">## 由 acl_master 用来控制服务进程池的配置项</span><br><span class=\"hljs-comment\"># 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程</span><br><span class=\"hljs-attr\">master_disable</span> = <span class=\"hljs-literal\">no</span><br><br><span class=\"hljs-comment\"># 表示本服务器进程监听 127.0.0.1 的 5001 端口</span><br><span class=\"hljs-attr\">master_service</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">5001</span><br><br><span class=\"hljs-comment\"># 表示是 TCP 套接口服务类型</span><br><span class=\"hljs-attr\">master_type</span> = inet<br><br><span class=\"hljs-comment\"># 表示该服务进程池的最大进程数为 2</span><br><span class=\"hljs-attr\">master_maxproc</span> = <span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\"># 进程日志记录文件，其中 &#123;install_path&#125; 需要用实际的安装路径代替</span><br><span class=\"hljs-attr\">master_log</span> = &#123;install_path&#125;/var/log/ioctl_echo.log<br><br><span class=\"hljs-comment\">## 与该服务器框架模板相关的配置参数项</span><br><span class=\"hljs-comment\"># 每个服务进程中最大的线程数为 250</span><br><span class=\"hljs-attr\">ioctl_max_threads</span> = <span class=\"hljs-number\">250</span><br><br><span class=\"hljs-comment\"># 线程的堆栈空间大小，单位为字节，0表示使用系统缺省值</span><br><span class=\"hljs-attr\">ioctl_stacksize</span> = <span class=\"hljs-number\">0</span><br><br><span class=\"hljs-comment\"># 每个进程实例处理连接数的最大次数，超过此值后进程实例主动退出</span><br><span class=\"hljs-attr\">ioctl_use_limit</span> = <span class=\"hljs-number\">100</span><br><br><span class=\"hljs-comment\"># 每个进程实例的空闲超时时间，超过此值后进程实例主动退出</span><br><span class=\"hljs-attr\">ioctl_idle_limit</span> = <span class=\"hljs-number\">120</span><br><br><span class=\"hljs-comment\"># 进程运行时的用户身份</span><br><span class=\"hljs-attr\">ioctl_owner</span> = root<br><br><span class=\"hljs-comment\"># 采用事件循环的方式: select(default)/poll/kernel(epoll/devpoll/kqueue)</span><br><span class=\"hljs-attr\">ioctl_event_mode</span> = select<br><br><span class=\"hljs-comment\"># 允许访问 udserver 的客户端IP地址范围</span><br><span class=\"hljs-attr\">ioctl_access_allow</span> = <span class=\"hljs-number\">10.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">10.0</span>.<span class=\"hljs-number\">0.255</span>, <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br></code></pre></td></tr></table></figure>\n\n<p>例如当 acl_master 服务器框架程序的安装目录为：&#x2F;opt&#x2F;acl，则：</p>\n<ul>\n<li>&#x2F;opt&#x2F;acl&#x2F;libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;conf：该目录存放 acl_master 程序配置文件 main.cf；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;log：该目录存放日志文件；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;pid：该目录存放进程号文件。</li>\n</ul>\n<p>该程序编译通过后，需要把可执行程序放在 &#x2F;opt&#x2F;acl&#x2F;libexec 目录下，把配置文件放在 &#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service 目录下。</p>\n<p>在 &#x2F;opt&#x2F;acl&#x2F;sh 下有启动&#x2F;停止 acl_master 服务进程的控制脚本；运行脚本：.&#x2F;start.sh，然后请用下面方法检查服务是否已经启动：</p>\n<p><code>$ps -ef|grep acl_master</code>  查看服务器控制进程是否已经启动</p>\n<p><code>$netstat -nap|grep LISTEN|grep 5001</code> 查看服务端口号是否已经被监听</p>\n<p>当然，您也可以查看 &#x2F;opt&#x2F;acl&#x2F;var&#x2F;log&#x2F;acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。</p>\n<p>可以命令行如下测试：<code>$telnet 127.0.0.1 5001</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文主要讲述如何使用 acl_cpp 中的 master_threads 类编写可以由 acl_master 服务器父进程控制的服务器应用程序。</p>\n<h2 id=\"一、类接口说明\"><a href=\"#一、类接口说明\" class=\"headerlink\" title=\"一、类接口说明\"></a>一、类接口说明</h2><p>master_threads 是一个纯虚类，其中定义的接口需要子类实现，如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 纯虚函数：当某个客户端连接有数据可读或关闭或出错时调用此函数</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 false 则表示当函数返回后需要关闭连接，</span><br><span class=\"hljs-comment\"> *  否则表示需要保持长连接，如果该流出错，则应用应该返回 false</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_read</span><span class=\"hljs-params\">(socket_stream*)</span> </span>= <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当线程池中的某个线程获得一个连接时的回调函数，</span><br><span class=\"hljs-comment\"> * 子类可以做一些初始化工作</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 如果返回 false 则表示子类要求关闭连接，而不</span><br><span class=\"hljs-comment\"> *  必将该连接再传递至 thread_main 过程</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_accept</span><span class=\"hljs-params\">(socket_stream*)</span> </span>&#123; <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>; &#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当与某个线程绑定的连接关闭时的回调函数</span><br><span class=\"hljs-comment\"> * @param stream &#123;socket_stream*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_close</span><span class=\"hljs-params\">(socket_stream* )</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当线程池中一个新线程被创建时的回调函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_init</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当线程池中一个线程退出时的回调函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_exit</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<p>master_threads 类提供了两个函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 开始运行，调用该函数是指该服务进程是在 acl_master 服务框架</span><br><span class=\"hljs-comment\"> * 控制之下运行，一般用于生产机状态</span><br><span class=\"hljs-comment\"> * @param argc &#123;int&#125; 从 main 中传递的第一个参数，表示参数个数</span><br><span class=\"hljs-comment\"> * @param argv &#123;char**&#125; 从 main 中传递的第二个参数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run_daemon</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>** argv)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在单独运行时的处理函数，用户可以调用此函数进行一些必要的调试工作</span><br><span class=\"hljs-comment\"> * @param addr &#123;const char*&#125; 服务监听地址</span><br><span class=\"hljs-comment\"> * @param conf &#123;const char*&#125; 配置文件全路径</span><br><span class=\"hljs-comment\"> * @param count &#123;unsigned int&#125; 循环服务的次数，达到此值后函数自动返回；</span><br><span class=\"hljs-comment\"> *  若该值为 0 则表示程序一直循环处理外来请求而不返回</span><br><span class=\"hljs-comment\"> * @param threads_count &#123;int&#125; 当该值大于 1 时表示自动采用线程池方式，</span><br><span class=\"hljs-comment\"> *  该值只有当 count != 1 时才有效，即若 count == 1 则仅运行一次就返回</span><br><span class=\"hljs-comment\"> *  且不会启动线程处理客户端请求</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 监听是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">run_alone</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* conf = <span class=\"hljs-literal\">NULL</span>,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> count = <span class=\"hljs-number\">1</span>, <span class=\"hljs-type\">int</span> threads_count = <span class=\"hljs-number\">1</span>)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>从上面两个函数，可以看出 master_threads 类当在生产环境下（由 acl_master 进程统一控制调度），用户需要调用 run_daemon 函数；如果用户在开发过程中需要手工进行调试，则可以调用 run_alone 函数。</p>\n<p>master_threads 的基类 master_base 的几个虚接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程切换用户身份前调用的回调函数，可以在此函数中做一些</span><br><span class=\"hljs-comment\"> * 用户身份为 root 的权限操作</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_pre_jail</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程切换用户身份后调用的回调函数，此函数被调用时，进程</span><br><span class=\"hljs-comment\"> * 的权限为普通受限级别</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_init</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当进程退出前调用的回调函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_exit</span><span class=\"hljs-params\">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure>\n\n<pre><code>// 在 run_alone 状态下运行前，调用此函数初始化一些配置\n</code></pre>\n<p>基类的这几个虚函数用户可以根据需要调用。</p>\n<p>另外，基类 master_base 还提供了几个用来读配置选项的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 bool 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_bool_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_bool</span><span class=\"hljs-params\">(master_bool_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 int 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_int_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_int</span><span class=\"hljs-params\">(master_int_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 int64 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_int64_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_int64</span><span class=\"hljs-params\">(master_int64_tbl* table)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置 字符串 类型的配置项</span><br><span class=\"hljs-comment\"> * @param table &#123;master_str_tbl*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_cfg_str</span><span class=\"hljs-params\">(master_str_tbl* table)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、示例源程序\"><a href=\"#二、示例源程序\" class=\"headerlink\" title=\"二、示例源程序\"></a>二、示例源程序</h2><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// master_threads.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;log.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;util.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;master_threads.hpp&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;socket_stream.hpp&quot;</span></span><br><br><span class=\"hljs-comment\">// 字符串类型的配置项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">char</span> *var_cfg_debug_msg;<br><br><span class=\"hljs-type\">static</span> acl::master_str_tbl var_conf_str_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_msg&quot;</span>, <span class=\"hljs-string\">&quot;test_msg&quot;</span>, &amp;var_cfg_debug_msg &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 布尔类型的配置项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_debug_enable;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_keep_alive;<br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_loop;<br><br><span class=\"hljs-type\">static</span> acl::master_bool_tbl var_conf_bool_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;debug_enable&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_debug_enable &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;keep_alive&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_keep_alive &#125;,<br>\t&#123; <span class=\"hljs-string\">&quot;loop_read&quot;</span>, <span class=\"hljs-number\">1</span>, &amp;var_cfg_loop &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-comment\">// 整数类型的配置项</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span>  var_cfg_io_timeout;<br><br><span class=\"hljs-type\">static</span> acl::master_int_tbl var_conf_int_tab[] = &#123;<br>\t&#123; <span class=\"hljs-string\">&quot;io_timeout&quot;</span>, <span class=\"hljs-number\">120</span>, &amp;var_cfg_io_timeout, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;,<br><br>\t&#123; <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span> , <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span> &#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-title\">void</span> <span class=\"hljs-params\">(*format)</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>*, ...)</span> </span>= acl::log::msg1;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">master_threads_test</span> : <span class=\"hljs-keyword\">public</span> acl::master_threads<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">master_threads_test</span>()<br>\t&#123;<br>\t&#125;<br><br>\t~<span class=\"hljs-built_in\">master_threads_test</span>()<br>\t&#123;<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数：当客户端连接有数据可读或关闭时回调此函数，返回 true 表示</span><br>\t<span class=\"hljs-comment\">// 继续与客户端保持长连接，否则表示需要关闭客户端连接</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_read</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">on_read</span>(stream) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (var_cfg_loop == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">on_read</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;%s(%d)&quot;</span>, __FILE__, __LINE__);<br>\t\tacl::string buf;<br>\t\t<span class=\"hljs-keyword\">if</span> (stream-&gt;<span class=\"hljs-built_in\">gets</span>(buf) == <span class=\"hljs-literal\">false</span>) <span class=\"hljs-comment\">// 读一行数据</span><br>\t\t&#123;<br>\t\t\tformat(<span class=\"hljs-string\">&quot;gets error: %s&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\tformat(<span class=\"hljs-string\">&quot;%s(%d)&quot;</span>, __FILE__, __LINE__);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (buf == <span class=\"hljs-string\">&quot;quit&quot;</span>)  <span class=\"hljs-comment\">// 如果客户端要求关闭连接，则返回 false 通知服务器框架关闭连接</span><br>\t\t&#123;<br>\t\t\tstream-&gt;<span class=\"hljs-built_in\">puts</span>(<span class=\"hljs-string\">&quot;bye!&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">if</span> (buf.<span class=\"hljs-built_in\">empty</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (stream-&gt;<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>) == <span class=\"hljs-number\">-1</span>)<br>\t\t\t&#123;<br>\t\t\t\tformat(<span class=\"hljs-string\">&quot;write 1 error: %s&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t\t&#125;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (stream-&gt;<span class=\"hljs-built_in\">write</span>(buf) == <span class=\"hljs-number\">-1</span>)<br>\t\t&#123;<br>\t\t\tformat(<span class=\"hljs-string\">&quot;write 2 error: %s, buf(%s), len: %d&quot;</span>,<br>\t\t\t\tacl::<span class=\"hljs-built_in\">last_serror</span>(), buf.<span class=\"hljs-built_in\">c_str</span>(), (<span class=\"hljs-type\">int</span>) buf.<span class=\"hljs-built_in\">length</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (stream-&gt;<span class=\"hljs-built_in\">write</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>) == <span class=\"hljs-number\">-1</span>)<br>\t\t&#123;<br>\t\t\tformat(<span class=\"hljs-string\">&quot;write 3 client error: %s&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当接收到一个客户端请求时，调用此函数，允许</span><br>\t<span class=\"hljs-comment\">// 子类事先对客户端连接进行处理，返回 true 表示继续，否则</span><br>\t<span class=\"hljs-comment\">// 要求关闭该客户端连接</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_accept</span><span class=\"hljs-params\">(acl::socket_stream* stream)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;accept one client, peer: %s, local: %s, var_cfg_io_timeout: %d\\r\\n&quot;</span>,<br>\t\t\tstream-&gt;<span class=\"hljs-built_in\">get_peer</span>(), stream-&gt;<span class=\"hljs-built_in\">get_local</span>(), var_cfg_io_timeout);<br>\t\t<span class=\"hljs-keyword\">if</span> (stream-&gt;format(<span class=\"hljs-string\">&quot;hello, you&#x27;re welcome!\\r\\n&quot;</span>) == <span class=\"hljs-number\">-1</span>)<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当客户端连接关闭时调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_close</span><span class=\"hljs-params\">(acl::socket_stream*)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;client closed now\\r\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当线程池创建一个新线程时调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_init</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t\tformat(<span class=\"hljs-string\">&quot;thread init: tid: %lu\\r\\n&quot;</span>, <span class=\"hljs-built_in\">GetCurrentThreadId</span>());<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>\t\tformat(<span class=\"hljs-string\">&quot;thread init: tid: %lu\\r\\n&quot;</span>, <span class=\"hljs-built_in\">pthread_self</span>());<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：当线程池中的一个线程退出时调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_exit</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t\tformat(<span class=\"hljs-string\">&quot;thread exit: tid: %lu\\r\\n&quot;</span>, <span class=\"hljs-built_in\">GetCurrentThreadId</span>());<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>\t\tformat(<span class=\"hljs-string\">&quot;thread exit: tid: %lu\\r\\n&quot;</span>, <span class=\"hljs-built_in\">pthread_self</span>());<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程切换用户身份前调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_pre_jail</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc_pre_jail\\r\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程切换用户身份后调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_init</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc init\\r\\n&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：服务进程退出前调用此函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">proc_on_exit</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tformat(<span class=\"hljs-string\">&quot;proc exit\\r\\n&quot;</span>);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc, <span class=\"hljs-type\">char</span>* argv[])</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tmaster_threads_test mt;<br><br>\t<span class=\"hljs-comment\">// 设置配置参数表</span><br>\tmt.<span class=\"hljs-built_in\">set_cfg_int</span>(var_conf_int_tab);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_int64</span>(<span class=\"hljs-literal\">NULL</span>);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_str</span>(var_conf_str_tab);<br>\tmt.<span class=\"hljs-built_in\">set_cfg_bool</span>(var_conf_bool_tab);<br><br>\t<span class=\"hljs-comment\">// 开始运行</span><br><br>\t<span class=\"hljs-keyword\">if</span> (argc &gt;= <span class=\"hljs-number\">2</span> &amp;&amp; <span class=\"hljs-built_in\">strcmp</span>(argv[<span class=\"hljs-number\">1</span>], <span class=\"hljs-string\">&quot;alone&quot;</span>) == <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\tformat = (<span class=\"hljs-built_in\">void</span> (*)(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>*, ...)) printf;<br>\t\tformat(<span class=\"hljs-string\">&quot;listen: 127.0.0.1:8888\\r\\n&quot;</span>);<br>\t\tmt.<span class=\"hljs-built_in\">run_alone</span>(<span class=\"hljs-string\">&quot;127.0.0.1:8888&quot;</span>, <span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">// 单独运行方式</span><br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\tmt.<span class=\"hljs-built_in\">run_daemon</span>(argc, argv);  <span class=\"hljs-comment\">// acl_master 控制模式运行</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>这是一个简单的提供 echo 行服务的服务器程序，可以支持多个并发连接，而且可以通过配置文件控制所启动的最大进程数、每个进程的最大线程数、进程空闲时间、线程空闲时间等控制参数，因为 acl 中的服务器框架都是半驻留的，所以既可以保证运行效率，又能够在空闲释放系统资源。该例子所在目录：acl_cpp&#x2F;samples&#x2F;master_threads。</p>\n<p>需要指出的一点是，master_threads 内部是单例的，即要求该类的对象只能有一个，否则内部自动产生断言。只所以没有采用单例模板来设计单例，主要是为了不对外暴露 acl 库中的接口，使使用 acl_cpp 库的用户不必关心 acl 库的头文件在哪儿。</p>\n<h2 id=\"三、配置文件及程序安装\"><a href=\"#三、配置文件及程序安装\" class=\"headerlink\" title=\"三、配置文件及程序安装\"></a>三、配置文件及程序安装</h2><p>打开 acl_cpp&#x2F;samples&#x2F;master_threads&#x2F;ioctl_echo.cf 配置文件，就其中几个配置参数说明一下：</p>\n<figure class=\"highlight ini\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs ini\"><span class=\"hljs-comment\">## 由 acl_master 用来控制服务进程池的配置项</span><br><span class=\"hljs-comment\"># 为 no 表示启用该进程服务，为 yes 表示禁止该服务进程</span><br><span class=\"hljs-attr\">master_disable</span> = <span class=\"hljs-literal\">no</span><br><br><span class=\"hljs-comment\"># 表示本服务器进程监听 127.0.0.1 的 5001 端口</span><br><span class=\"hljs-attr\">master_service</span> = <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">5001</span><br><br><span class=\"hljs-comment\"># 表示是 TCP 套接口服务类型</span><br><span class=\"hljs-attr\">master_type</span> = inet<br><br><span class=\"hljs-comment\"># 表示该服务进程池的最大进程数为 2</span><br><span class=\"hljs-attr\">master_maxproc</span> = <span class=\"hljs-number\">2</span><br><br><span class=\"hljs-comment\"># 进程日志记录文件，其中 &#123;install_path&#125; 需要用实际的安装路径代替</span><br><span class=\"hljs-attr\">master_log</span> = &#123;install_path&#125;/var/log/ioctl_echo.log<br><br><span class=\"hljs-comment\">## 与该服务器框架模板相关的配置参数项</span><br><span class=\"hljs-comment\"># 每个服务进程中最大的线程数为 250</span><br><span class=\"hljs-attr\">ioctl_max_threads</span> = <span class=\"hljs-number\">250</span><br><br><span class=\"hljs-comment\"># 线程的堆栈空间大小，单位为字节，0表示使用系统缺省值</span><br><span class=\"hljs-attr\">ioctl_stacksize</span> = <span class=\"hljs-number\">0</span><br><br><span class=\"hljs-comment\"># 每个进程实例处理连接数的最大次数，超过此值后进程实例主动退出</span><br><span class=\"hljs-attr\">ioctl_use_limit</span> = <span class=\"hljs-number\">100</span><br><br><span class=\"hljs-comment\"># 每个进程实例的空闲超时时间，超过此值后进程实例主动退出</span><br><span class=\"hljs-attr\">ioctl_idle_limit</span> = <span class=\"hljs-number\">120</span><br><br><span class=\"hljs-comment\"># 进程运行时的用户身份</span><br><span class=\"hljs-attr\">ioctl_owner</span> = root<br><br><span class=\"hljs-comment\"># 采用事件循环的方式: select(default)/poll/kernel(epoll/devpoll/kqueue)</span><br><span class=\"hljs-attr\">ioctl_event_mode</span> = select<br><br><span class=\"hljs-comment\"># 允许访问 udserver 的客户端IP地址范围</span><br><span class=\"hljs-attr\">ioctl_access_allow</span> = <span class=\"hljs-number\">10.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">10.0</span>.<span class=\"hljs-number\">0.255</span>, <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span><br></code></pre></td></tr></table></figure>\n\n<p>例如当 acl_master 服务器框架程序的安装目录为：&#x2F;opt&#x2F;acl，则：</p>\n<ul>\n<li>&#x2F;opt&#x2F;acl&#x2F;libexec： 该目录存储服务器程序（acl_master 程序也存放在该目录下）；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;conf：该目录存放 acl_master 程序配置文件 main.cf；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service：该目录存放服务子进程的程序配置文件，该路径由 main.cf 文件指定；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;log：该目录存放日志文件；</li>\n<li>&#x2F;opt&#x2F;acl&#x2F;var&#x2F;pid：该目录存放进程号文件。</li>\n</ul>\n<p>该程序编译通过后，需要把可执行程序放在 &#x2F;opt&#x2F;acl&#x2F;libexec 目录下，把配置文件放在 &#x2F;opt&#x2F;acl&#x2F;conf&#x2F;service 目录下。</p>\n<p>在 &#x2F;opt&#x2F;acl&#x2F;sh 下有启动&#x2F;停止 acl_master 服务进程的控制脚本；运行脚本：.&#x2F;start.sh，然后请用下面方法检查服务是否已经启动：</p>\n<p><code>$ps -ef|grep acl_master</code>  查看服务器控制进程是否已经启动</p>\n<p><code>$netstat -nap|grep LISTEN|grep 5001</code> 查看服务端口号是否已经被监听</p>\n<p>当然，您也可以查看 &#x2F;opt&#x2F;acl&#x2F;var&#x2F;log&#x2F;acl_master 日志文件，查看服务进程的启动过程及监听服务是否正常监听。</p>\n<p>可以命令行如下测试：<code>$telnet 127.0.0.1 5001</code></p>\n"},{"title":"利用ACL库开发高并发半驻留式线程池程序","date":"2009-06-07T05:41:00.000Z","_content":"\n## 一、概述\n在当今强调多核开发的年代，要求程序员能够写出高并发的程序，而利用多个核一般有两种方式：采用多线程方式或多进程方式。每处理一个新任务时如果临时产生一个线程或进程且处理完任务后线程或进程便立即退出，显示这种方式是非常低效的，于是人们一般采用线程池的模型（这在JAVA 或 .NET 中非常普遍）或多进程进程池模型（这一般在UNIX平台应用较多）。此外，对于线程池或进程池模型又分为两种情形：常驻留内存或半驻留内存，常驻内存是指预先产生一批线程或进程，等待新任务到达，这些线程或进程即使在空闲状态也会常驻内存；半驻留内存是指当来新任务时如果线程池或进程池没有可利用线程或进程则启动新的线程或进程来处理新任务，处理完后，线程或进程并不立即退出，而是空闲指定时间，如果在空闲阀值时间到达前有新任务到达则立即处理新任务，如果到达空闲超时后依然没有新任务到达，则这些空闲的线程或进程便退出，以让出系统资源。所以，对比常驻内存方式和半驻留内存方式，不难看出半驻留方式更有按需分配的意味。\n\n下面仅以ACL框架中的半驻留线程池模型为例介绍了如何写一个半驻留线程池的程序。\n\n## 二、半驻留线程池函数接口说明\n### 2.1）线程池的创建、销毁及任务添加等接口\n```c++\n/**\n * 创建一个线程池对象\n * @param attr {acl_pthread_pool_attr_t*} 线程池创建时的属性，如果该参数为空，\n *  则采用默认参数: ACL_PTHREAD_POOL_DEF_XXX\n * @return {acl_pthread_pool_t*}, 如果不为空则表示成功，否则失败\n*/\nACL_API acl_pthread_pool_t *acl_pthread_pool_create(const acl_pthread_pool_attr_t *attr);\n\n/**\n * 销毁一个线程池对象, 成功销毁后该对象不能再用.\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @return {int} 0: 成功; != 0: 失败\n */\nACL_API int acl_pthread_pool_destroy(acl_pthread_pool_t *thr_pool);\n\n/**\n * 向线程池添加一个任务\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @param run_fn {void (*)(*)} 当有可用工作线程时所调用的回调处理函数\n * @param run_arg {void*} 回调函数 run_fn 所需要的回调参数\n * @return {int} 0: 成功; != 0: 失败\n */\nACL_API int acl_pthread_pool_add(acl_pthread_pool_t *thr_pool,\n        void (*run_fn)(void *), void *run_arg);\n\n/**\n * 当前线程池中的线程数\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @return {int} 返回线程池中的总线程数\n */\nACL_API int acl_pthread_pool_size(acl_pthread_pool_t *thr_pool);\n```\n\n### 2.2）线程池属性设置接口\n```c++\n/**\n * 初始化线程池属性值\n * @param attr {acl_pthread_pool_attr_t*}\n */\nACL_API void acl_pthread_pool_attr_init(acl_pthread_pool_attr_t *attr);\n\n/**\n * 设置线程池属性中的最大堆栈大小(字节)\n * @param attr {acl_pthread_pool_attr_t*}\n * @param size {size_t}\n */\nACL_API void acl_pthread_pool_attr_set_stacksize(acl_pthread_pool_attr_t *attr, size_t size);\n\n/**\n * 设置线程池属性中的最大线程数限制值\n * @param attr {acl_pthread_pool_attr_t*}\n * @param threads_limit {int} 线程池中的最大线程数\n */\nACL_API void acl_pthread_pool_attr_set_threads_limit(acl_pthread_pool_attr_t *attr, \n    int threads_limit);\n/**\n * 设置线程池属性中线程空闲超时值\n * @param attr {acl_pthread_pool_attr_t*}\n * @param idle_timeout {int} 线程空闲超时时间(秒)\n */\nACL_API void acl_pthread_pool_attr_set_idle_timeout(acl_pthread_pool_attr_t *attr, \n    int idle_timeout);\n```\n\n### 2.3）线程池中的工作线程创建、退出时设置回调函数接口\n```c++\n/**\n * 添加注册函数，在线程创建后立即执行此初始化函数\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @param init_fn {int (*)(void*)} 工作线程初始化函数, 如果该函数返回 < 0,\n *  则该线程自动退出。\n * @param init_arg {void*} init_fn 所需要的参数\n * @return {int} 0: OK; != 0: Error.\n */\nACL_API int acl_pthread_pool_atinit(acl_pthread_pool_t *thr_pool,\n        int (*init_fn)(void *), void *init_arg);\n\n/**\n * 添加注册函数，在线程退出立即执行此初函数\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @param free_fn {void (*)(void*)} 工作线程退出前必须执行的函数\n * @param free_arg {void*} free_fn 所需要的参数\n * @return {int} 0: OK; != 0: Error.\n */\nACL_API int acl_pthread_pool_atfree(acl_pthread_pool_t *thr_pool,\n        void (*free_fn)(void *), void *free_arg);\n```\n\n## 三、半驻留线程池例子\n### 3.1）程序代码\n```c++\n#include \"lib_acl.h\"\n#include <assert.h>\n\n/**\n * 用户自定义数据结构\n */\ntypedef struct THREAD_CTX {\n\tacl_pthread_pool_t *thr_pool;\n\tint   i;\n} THREAD_CTX;\n\n/* 全局性静态变量 */\nstatic acl_pthread_pool_t *__thr_pool = NULL;\n\n/* 线程局部存储变量(C99支持此种方式声明，方便许多) */\nstatic __thread unsigned int __local = 0;\n\nstatic void work_thread_fn(void *arg)\n{\n\tTHREAD_CTX *ctx = (THREAD_CTX*) arg; /* 获得用户自定义对象 */\n\tint   i = 5;\n\n\t/* 仅是验证参数传递过程 */\n\tassert(ctx->thr_pool == __thr_pool);\n\n\twhile (i-- > 0) {\n\t\tprintf(\"thread start! tid=%d, i=%d, __local=%d\\r\\n\",\n\t\t\t\tacl_pthread_self(), ctx->i, __local);\n\t\t/* 在本线程中将线程局部变量加1 */\n\t\t__local++;\n\t\tsleep(1);\n\t}\n\n\tacl_myfree(ctx);\n\n\t/* 至此，该工作线程进入空闲状态，直到空闲超时退出 */\n}\n\nstatic int on_thread_init(void *arg)\n{\n\tconst char *myname = \"on_thread_init\";\n\tacl_pthread_pool_t *thr_pool = (acl_pthread_pool_t*) arg;\n\n\t/* 判断一下，仅是为了验证参数传递过程 */\n\tassert(thr_pool == __thr_pool);\n\tprintf(\"%s: thread(%d) init now\\r\\n\", myname, acl_pthread_self());\n\n\t/* 返回0表示继续执行该线程获得的新任务，返回-1表示停止执行该任务 */\n\treturn (0);\n}\n\nstatic void on_thread_exit(void *arg)\n{\n\tconst char *myname = \"on_thread_exit\";\n\tacl_pthread_pool_t *thr_pool = (acl_pthread_pool_t*) arg;\n\n\t/* 判断一下，仅是为了验证参数传递过程 */\n\tassert(thr_pool == __thr_pool);\n\tprintf(\"%s: thread(%d) exit now\\r\\n\", myname, acl_pthread_self());\n}\n\nstatic void run_thread_pool(acl_pthread_pool_t *thr_pool)\n{\n\tTHREAD_CTX *ctx;  /* 用户自定义参数 */\n\n\t/* 设置全局静态变量 */\n\t__thr_pool = thr_pool;\n\n\t/* 设置线程开始时的回调函数 */\n\t(void) acl_pthread_pool_atinit(thr_pool, on_thread_init, thr_pool);\n\n\t/* 设置线程退出时的回调函数 */\n\t(void) acl_pthread_pool_atfree(thr_pool, on_thread_exit, thr_pool);\n\n\tctx = (THREAD_CTX*) acl_mycalloc(1, sizeof(THREAD_CTX));\n\tassert(ctx);\n\tctx->thr_pool = thr_pool;\n\tctx->i = 0;\n\n\t/**\n\t * 向线程池中添加第一个任务，即启动第一个工作线程\n\t * @param thr_pool 线程池句柄\n\t * @param workq_thread_fn 工作线程的回调函数\n\t * @param ctx 用户定义参数\n\t */\n\tacl_pthread_pool_add(thr_pool, work_thread_fn, ctx);\n\tsleep(1);\n\n\tctx = (THREAD_CTX*) acl_mycalloc(1, sizeof(THREAD_CTX));\n\tassert(ctx);\n\tctx->thr_pool = thr_pool;\n\tctx->i = 1;\n\t/* 向线程池中添加第二个任务，即启动第二个工作线程 */\n\tacl_pthread_pool_add(thr_pool, work_thread_fn, ctx);\n}\n\nint main(int argc acl_unused, char *argv[] acl_unused)\n{\n\tacl_pthread_pool_t *thr_pool;\n\tint  max_threads = 20;  /* 最多并发20个线程 */\n\tint  idle_timeout = 10; /* 每个工作线程空闲10秒后自动退出 */\n\tacl_pthread_pool_attr_t attr;\n\n\tacl_pthread_pool_attr_init(&attr);\n\tacl_pthread_pool_attr_set_threads_limit(&attr, max_threads);\n\tacl_pthread_pool_attr_set_idle_timeout(&attr, idle_timeout);\n\n\t/* 创建半驻留线程句柄 */\n\tthr_pool = acl_pthread_pool_create(&attr);\n\tassert(thr_pool);\n\trun_thread_pool(thr_pool);\n\n\tif (0) {\n\t\t/* 如果立即运行 acl_pthread_pool_destroy，则由于调用了线程池销毁函数，\n\t\t * 主线程便立刻通知空闲线程退出，所有空闲线程不必等待空闲超时时间便可退出,\n\t\t */\n\t\tprintf(\"> wait all threads to be idle and free thread pool\\r\\n\");\n\t\t/* 立即销毁线程池 */\n\t\tacl_pthread_pool_destroy(thr_pool);\n\t} else {\n\t\t/* 因为不立即调用 acl_pthread_pool_destroy，所有所有空闲线程都是当空闲\n\t\t * 超时时间到达后才退出\n\t\t */\n\t\twhile (1) {\n\t\t\tint   ret;\n\n\t\t\tret = acl_pthread_pool_size(thr_pool);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintf(\"> current threads in thread pool is: %d\\r\\n\", ret);\n\t\t\tsleep(1);\n\t\t}\n\t\t/* 线程池中的工作线程数为0时销毁线程池 */\n\t\tprintf(\"> all worker thread exit now\\r\\n\");\n\t\tacl_pthread_pool_destroy(thr_pool);\n\t}\n\n\t/* 主线程等待用户在终端输入任意字符后退出 */\n\tprintf(\"> enter any key to exit\\r\\n\");\n\tgetchar();\n\n\treturn (0);\n}\n```\n\n### 3.2) 编译链接\n从　http://www.sourceforge.net/projects/acl/ 站点下载 acl_project 代码，在WIN32平台下请用VC2003编译，打开 acl_project\\win32_build\\vc\\acl_project_vc2003.sln 编译后在目录　acl_project\\dist\\lib_acl\\lib\\win32　下生成lib_acl_vc2003.lib, 然后在示例的控制台工程中包含该库，并包含acl_project\\lib_acl\\include　下的 lib_acl.h 头文件，编译上述源代码即可。\n因为本例子代码在 ACL 的例子里有，所以可以直接编译 acl_project\\win32_build\\vc\\samples\\samples_vc2003.sln 中的 thread_pool 项目即可。\n\n### 3.3) 运行\n运行示例程序后，在我的机器的显示结果如下：\n```\non_thread_init: thread(23012) init now\nthread start! tid=23012, i=0, __local=0\nthread start! tid=23012, i=0, __local=1\n> current threads in thread pool is: 2\non_thread_init: thread(23516) init now\nthread start! tid=23516, i=1, __local=0\nthread start! tid=23516, i=1, __local=1\n> current threads in thread pool is: 2\nthread start! tid=23012, i=0, __local=2\nthread start! tid=23516, i=1, __local=2\nthread start! tid=23012, i=0, __local=3\n> current threads in thread pool is: 2\nthread start! tid=23516, i=1, __local=3\nthread start! tid=23012, i=0, __local=4\n> current threads in thread pool is: 2\nthread start! tid=23516, i=1, __local=4\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\non_thread_exit: thread(23012) exit now\n> current threads in thread pool is: 1\non_thread_exit: thread(23516) exit now\n> all worker thread exit now\n> enter any key to exit\n```\n\n## 四、小结\n可以看出，使用ACL库创建半驻留式高并发多线程程序是比较简单的，ACL线程池库的接口定义及实现尽量与POSIX中规定的POSIX线程的实现接口相似，创建与使用ACL线程池库的步骤如下：\n- acl_pthread_pool_attr_init: 初始化创建线程池对象所需要属性信息(可以通过 acl_pthread_pool_attr_set_threads_limit 设置线程池最大并发数及用 acl_pthread_pool_attr_set_idle_timeout 设置线程池中工作线程的空闲退出时间间隔)\n- acl_pthread_pool_create: 创建线程池对象\n- acl_pthread_pool_add: 向线程池中添加新任务，新任务将由线程池中的某一工作线程执行\n- acl_pthread_pool_destroy: 通知并等待线程池中的工作线程执行完任务后退出，同时销毁线程池对象\n\n还可以在选择在创建线程池对象后，调用 acl_pthread_pool_atinit 设置工作线程第一次被创建时回调用户自定义函数过程，或当线程空闲退出后调用 acl_pthread_pool_atfree 中设置的回调函数。\n另外，可以将创建线程池的过程进行一抽象，写成如下形式：\n\n```c++\n/**\n * 创建半驻留线程池的过程\n * @return {acl_pthread_pool_t*} 新创建的线程池句柄\n */\nstatic acl_pthread_pool_t *create_thread_pool(void)\n{\n\tacl_pthread_pool_t *thr_pool;  /* 线程池句柄 */\n\tint  max_threads = 100;  /* 最多并发100个线程 */\n\tint  idle_timeout = 10;  /* 每个工作线程空闲10秒后自动退出 */\n\tacl_pthread_pool_attr_t attr;  /* 线程池初始化时的属性 */\n\n\t/* 初始化线程池对象属性 */\n\tacl_pthread_pool_attr_init(&attr);\n\tacl_pthread_pool_attr_set_threads_limit(&attr, max_threads);\n\tacl_pthread_pool_attr_set_idle_timeout(&attr, idle_timeout);\n\n\t/* 创建半驻留线程句柄 */\n\tthr_pool = acl_pthread_pool_create(&attr);\n\tassert(thr_pool);\n\treturn (thr_pool);\n}\n```\n\n其实，利用ACL创建线程池还有一个简化接口（只所以叫 acl_thread_xxx 没有加 p, 是因为这个接口不太遵守 Posix的一些规范），如下：\n\n```c++\n/**\n * 更简单地创建线程对象的方法\n * @param threads_limit {int}  线程池中最大并发线程数\n * @param idle_timeout {int} 工作线程空闲超时退出时间(秒)，如果为0则工作线程永不退出\n * @return {acl_pthread_pool_t*}, 如果不为空则表示成功，否则失败\n */\nACL_API acl_pthread_pool_t *acl_thread_pool_create(int threads_limit, int idle_timeout);\n```\n\n这样，用户就可以非常方便地创建自己的线程池了，而且别忘了，这个线程池还是可以是半驻留的（当然也是跨平台的，可以运行在　Linux/Solaris/FreeBSD/Win32 的环境下）。\n\ngithub：https://github.com/acl-dev/acl/\ngitee：https://gitee.com/acl-dev/acl/","source":"_posts/threads.md","raw":"---\ntitle: 利用ACL库开发高并发半驻留式线程池程序\ndate: 2009-06-07 13:41\ncategories: 线程编程\n---\n\n## 一、概述\n在当今强调多核开发的年代，要求程序员能够写出高并发的程序，而利用多个核一般有两种方式：采用多线程方式或多进程方式。每处理一个新任务时如果临时产生一个线程或进程且处理完任务后线程或进程便立即退出，显示这种方式是非常低效的，于是人们一般采用线程池的模型（这在JAVA 或 .NET 中非常普遍）或多进程进程池模型（这一般在UNIX平台应用较多）。此外，对于线程池或进程池模型又分为两种情形：常驻留内存或半驻留内存，常驻内存是指预先产生一批线程或进程，等待新任务到达，这些线程或进程即使在空闲状态也会常驻内存；半驻留内存是指当来新任务时如果线程池或进程池没有可利用线程或进程则启动新的线程或进程来处理新任务，处理完后，线程或进程并不立即退出，而是空闲指定时间，如果在空闲阀值时间到达前有新任务到达则立即处理新任务，如果到达空闲超时后依然没有新任务到达，则这些空闲的线程或进程便退出，以让出系统资源。所以，对比常驻内存方式和半驻留内存方式，不难看出半驻留方式更有按需分配的意味。\n\n下面仅以ACL框架中的半驻留线程池模型为例介绍了如何写一个半驻留线程池的程序。\n\n## 二、半驻留线程池函数接口说明\n### 2.1）线程池的创建、销毁及任务添加等接口\n```c++\n/**\n * 创建一个线程池对象\n * @param attr {acl_pthread_pool_attr_t*} 线程池创建时的属性，如果该参数为空，\n *  则采用默认参数: ACL_PTHREAD_POOL_DEF_XXX\n * @return {acl_pthread_pool_t*}, 如果不为空则表示成功，否则失败\n*/\nACL_API acl_pthread_pool_t *acl_pthread_pool_create(const acl_pthread_pool_attr_t *attr);\n\n/**\n * 销毁一个线程池对象, 成功销毁后该对象不能再用.\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @return {int} 0: 成功; != 0: 失败\n */\nACL_API int acl_pthread_pool_destroy(acl_pthread_pool_t *thr_pool);\n\n/**\n * 向线程池添加一个任务\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @param run_fn {void (*)(*)} 当有可用工作线程时所调用的回调处理函数\n * @param run_arg {void*} 回调函数 run_fn 所需要的回调参数\n * @return {int} 0: 成功; != 0: 失败\n */\nACL_API int acl_pthread_pool_add(acl_pthread_pool_t *thr_pool,\n        void (*run_fn)(void *), void *run_arg);\n\n/**\n * 当前线程池中的线程数\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @return {int} 返回线程池中的总线程数\n */\nACL_API int acl_pthread_pool_size(acl_pthread_pool_t *thr_pool);\n```\n\n### 2.2）线程池属性设置接口\n```c++\n/**\n * 初始化线程池属性值\n * @param attr {acl_pthread_pool_attr_t*}\n */\nACL_API void acl_pthread_pool_attr_init(acl_pthread_pool_attr_t *attr);\n\n/**\n * 设置线程池属性中的最大堆栈大小(字节)\n * @param attr {acl_pthread_pool_attr_t*}\n * @param size {size_t}\n */\nACL_API void acl_pthread_pool_attr_set_stacksize(acl_pthread_pool_attr_t *attr, size_t size);\n\n/**\n * 设置线程池属性中的最大线程数限制值\n * @param attr {acl_pthread_pool_attr_t*}\n * @param threads_limit {int} 线程池中的最大线程数\n */\nACL_API void acl_pthread_pool_attr_set_threads_limit(acl_pthread_pool_attr_t *attr, \n    int threads_limit);\n/**\n * 设置线程池属性中线程空闲超时值\n * @param attr {acl_pthread_pool_attr_t*}\n * @param idle_timeout {int} 线程空闲超时时间(秒)\n */\nACL_API void acl_pthread_pool_attr_set_idle_timeout(acl_pthread_pool_attr_t *attr, \n    int idle_timeout);\n```\n\n### 2.3）线程池中的工作线程创建、退出时设置回调函数接口\n```c++\n/**\n * 添加注册函数，在线程创建后立即执行此初始化函数\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @param init_fn {int (*)(void*)} 工作线程初始化函数, 如果该函数返回 < 0,\n *  则该线程自动退出。\n * @param init_arg {void*} init_fn 所需要的参数\n * @return {int} 0: OK; != 0: Error.\n */\nACL_API int acl_pthread_pool_atinit(acl_pthread_pool_t *thr_pool,\n        int (*init_fn)(void *), void *init_arg);\n\n/**\n * 添加注册函数，在线程退出立即执行此初函数\n * @param thr_pool {acl_pthread_pool_t*} 线程池对象，不能为空\n * @param free_fn {void (*)(void*)} 工作线程退出前必须执行的函数\n * @param free_arg {void*} free_fn 所需要的参数\n * @return {int} 0: OK; != 0: Error.\n */\nACL_API int acl_pthread_pool_atfree(acl_pthread_pool_t *thr_pool,\n        void (*free_fn)(void *), void *free_arg);\n```\n\n## 三、半驻留线程池例子\n### 3.1）程序代码\n```c++\n#include \"lib_acl.h\"\n#include <assert.h>\n\n/**\n * 用户自定义数据结构\n */\ntypedef struct THREAD_CTX {\n\tacl_pthread_pool_t *thr_pool;\n\tint   i;\n} THREAD_CTX;\n\n/* 全局性静态变量 */\nstatic acl_pthread_pool_t *__thr_pool = NULL;\n\n/* 线程局部存储变量(C99支持此种方式声明，方便许多) */\nstatic __thread unsigned int __local = 0;\n\nstatic void work_thread_fn(void *arg)\n{\n\tTHREAD_CTX *ctx = (THREAD_CTX*) arg; /* 获得用户自定义对象 */\n\tint   i = 5;\n\n\t/* 仅是验证参数传递过程 */\n\tassert(ctx->thr_pool == __thr_pool);\n\n\twhile (i-- > 0) {\n\t\tprintf(\"thread start! tid=%d, i=%d, __local=%d\\r\\n\",\n\t\t\t\tacl_pthread_self(), ctx->i, __local);\n\t\t/* 在本线程中将线程局部变量加1 */\n\t\t__local++;\n\t\tsleep(1);\n\t}\n\n\tacl_myfree(ctx);\n\n\t/* 至此，该工作线程进入空闲状态，直到空闲超时退出 */\n}\n\nstatic int on_thread_init(void *arg)\n{\n\tconst char *myname = \"on_thread_init\";\n\tacl_pthread_pool_t *thr_pool = (acl_pthread_pool_t*) arg;\n\n\t/* 判断一下，仅是为了验证参数传递过程 */\n\tassert(thr_pool == __thr_pool);\n\tprintf(\"%s: thread(%d) init now\\r\\n\", myname, acl_pthread_self());\n\n\t/* 返回0表示继续执行该线程获得的新任务，返回-1表示停止执行该任务 */\n\treturn (0);\n}\n\nstatic void on_thread_exit(void *arg)\n{\n\tconst char *myname = \"on_thread_exit\";\n\tacl_pthread_pool_t *thr_pool = (acl_pthread_pool_t*) arg;\n\n\t/* 判断一下，仅是为了验证参数传递过程 */\n\tassert(thr_pool == __thr_pool);\n\tprintf(\"%s: thread(%d) exit now\\r\\n\", myname, acl_pthread_self());\n}\n\nstatic void run_thread_pool(acl_pthread_pool_t *thr_pool)\n{\n\tTHREAD_CTX *ctx;  /* 用户自定义参数 */\n\n\t/* 设置全局静态变量 */\n\t__thr_pool = thr_pool;\n\n\t/* 设置线程开始时的回调函数 */\n\t(void) acl_pthread_pool_atinit(thr_pool, on_thread_init, thr_pool);\n\n\t/* 设置线程退出时的回调函数 */\n\t(void) acl_pthread_pool_atfree(thr_pool, on_thread_exit, thr_pool);\n\n\tctx = (THREAD_CTX*) acl_mycalloc(1, sizeof(THREAD_CTX));\n\tassert(ctx);\n\tctx->thr_pool = thr_pool;\n\tctx->i = 0;\n\n\t/**\n\t * 向线程池中添加第一个任务，即启动第一个工作线程\n\t * @param thr_pool 线程池句柄\n\t * @param workq_thread_fn 工作线程的回调函数\n\t * @param ctx 用户定义参数\n\t */\n\tacl_pthread_pool_add(thr_pool, work_thread_fn, ctx);\n\tsleep(1);\n\n\tctx = (THREAD_CTX*) acl_mycalloc(1, sizeof(THREAD_CTX));\n\tassert(ctx);\n\tctx->thr_pool = thr_pool;\n\tctx->i = 1;\n\t/* 向线程池中添加第二个任务，即启动第二个工作线程 */\n\tacl_pthread_pool_add(thr_pool, work_thread_fn, ctx);\n}\n\nint main(int argc acl_unused, char *argv[] acl_unused)\n{\n\tacl_pthread_pool_t *thr_pool;\n\tint  max_threads = 20;  /* 最多并发20个线程 */\n\tint  idle_timeout = 10; /* 每个工作线程空闲10秒后自动退出 */\n\tacl_pthread_pool_attr_t attr;\n\n\tacl_pthread_pool_attr_init(&attr);\n\tacl_pthread_pool_attr_set_threads_limit(&attr, max_threads);\n\tacl_pthread_pool_attr_set_idle_timeout(&attr, idle_timeout);\n\n\t/* 创建半驻留线程句柄 */\n\tthr_pool = acl_pthread_pool_create(&attr);\n\tassert(thr_pool);\n\trun_thread_pool(thr_pool);\n\n\tif (0) {\n\t\t/* 如果立即运行 acl_pthread_pool_destroy，则由于调用了线程池销毁函数，\n\t\t * 主线程便立刻通知空闲线程退出，所有空闲线程不必等待空闲超时时间便可退出,\n\t\t */\n\t\tprintf(\"> wait all threads to be idle and free thread pool\\r\\n\");\n\t\t/* 立即销毁线程池 */\n\t\tacl_pthread_pool_destroy(thr_pool);\n\t} else {\n\t\t/* 因为不立即调用 acl_pthread_pool_destroy，所有所有空闲线程都是当空闲\n\t\t * 超时时间到达后才退出\n\t\t */\n\t\twhile (1) {\n\t\t\tint   ret;\n\n\t\t\tret = acl_pthread_pool_size(thr_pool);\n\t\t\tif (ret == 0)\n\t\t\t\tbreak;\n\t\t\tprintf(\"> current threads in thread pool is: %d\\r\\n\", ret);\n\t\t\tsleep(1);\n\t\t}\n\t\t/* 线程池中的工作线程数为0时销毁线程池 */\n\t\tprintf(\"> all worker thread exit now\\r\\n\");\n\t\tacl_pthread_pool_destroy(thr_pool);\n\t}\n\n\t/* 主线程等待用户在终端输入任意字符后退出 */\n\tprintf(\"> enter any key to exit\\r\\n\");\n\tgetchar();\n\n\treturn (0);\n}\n```\n\n### 3.2) 编译链接\n从　http://www.sourceforge.net/projects/acl/ 站点下载 acl_project 代码，在WIN32平台下请用VC2003编译，打开 acl_project\\win32_build\\vc\\acl_project_vc2003.sln 编译后在目录　acl_project\\dist\\lib_acl\\lib\\win32　下生成lib_acl_vc2003.lib, 然后在示例的控制台工程中包含该库，并包含acl_project\\lib_acl\\include　下的 lib_acl.h 头文件，编译上述源代码即可。\n因为本例子代码在 ACL 的例子里有，所以可以直接编译 acl_project\\win32_build\\vc\\samples\\samples_vc2003.sln 中的 thread_pool 项目即可。\n\n### 3.3) 运行\n运行示例程序后，在我的机器的显示结果如下：\n```\non_thread_init: thread(23012) init now\nthread start! tid=23012, i=0, __local=0\nthread start! tid=23012, i=0, __local=1\n> current threads in thread pool is: 2\non_thread_init: thread(23516) init now\nthread start! tid=23516, i=1, __local=0\nthread start! tid=23516, i=1, __local=1\n> current threads in thread pool is: 2\nthread start! tid=23012, i=0, __local=2\nthread start! tid=23516, i=1, __local=2\nthread start! tid=23012, i=0, __local=3\n> current threads in thread pool is: 2\nthread start! tid=23516, i=1, __local=3\nthread start! tid=23012, i=0, __local=4\n> current threads in thread pool is: 2\nthread start! tid=23516, i=1, __local=4\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\n> current threads in thread pool is: 2\non_thread_exit: thread(23012) exit now\n> current threads in thread pool is: 1\non_thread_exit: thread(23516) exit now\n> all worker thread exit now\n> enter any key to exit\n```\n\n## 四、小结\n可以看出，使用ACL库创建半驻留式高并发多线程程序是比较简单的，ACL线程池库的接口定义及实现尽量与POSIX中规定的POSIX线程的实现接口相似，创建与使用ACL线程池库的步骤如下：\n- acl_pthread_pool_attr_init: 初始化创建线程池对象所需要属性信息(可以通过 acl_pthread_pool_attr_set_threads_limit 设置线程池最大并发数及用 acl_pthread_pool_attr_set_idle_timeout 设置线程池中工作线程的空闲退出时间间隔)\n- acl_pthread_pool_create: 创建线程池对象\n- acl_pthread_pool_add: 向线程池中添加新任务，新任务将由线程池中的某一工作线程执行\n- acl_pthread_pool_destroy: 通知并等待线程池中的工作线程执行完任务后退出，同时销毁线程池对象\n\n还可以在选择在创建线程池对象后，调用 acl_pthread_pool_atinit 设置工作线程第一次被创建时回调用户自定义函数过程，或当线程空闲退出后调用 acl_pthread_pool_atfree 中设置的回调函数。\n另外，可以将创建线程池的过程进行一抽象，写成如下形式：\n\n```c++\n/**\n * 创建半驻留线程池的过程\n * @return {acl_pthread_pool_t*} 新创建的线程池句柄\n */\nstatic acl_pthread_pool_t *create_thread_pool(void)\n{\n\tacl_pthread_pool_t *thr_pool;  /* 线程池句柄 */\n\tint  max_threads = 100;  /* 最多并发100个线程 */\n\tint  idle_timeout = 10;  /* 每个工作线程空闲10秒后自动退出 */\n\tacl_pthread_pool_attr_t attr;  /* 线程池初始化时的属性 */\n\n\t/* 初始化线程池对象属性 */\n\tacl_pthread_pool_attr_init(&attr);\n\tacl_pthread_pool_attr_set_threads_limit(&attr, max_threads);\n\tacl_pthread_pool_attr_set_idle_timeout(&attr, idle_timeout);\n\n\t/* 创建半驻留线程句柄 */\n\tthr_pool = acl_pthread_pool_create(&attr);\n\tassert(thr_pool);\n\treturn (thr_pool);\n}\n```\n\n其实，利用ACL创建线程池还有一个简化接口（只所以叫 acl_thread_xxx 没有加 p, 是因为这个接口不太遵守 Posix的一些规范），如下：\n\n```c++\n/**\n * 更简单地创建线程对象的方法\n * @param threads_limit {int}  线程池中最大并发线程数\n * @param idle_timeout {int} 工作线程空闲超时退出时间(秒)，如果为0则工作线程永不退出\n * @return {acl_pthread_pool_t*}, 如果不为空则表示成功，否则失败\n */\nACL_API acl_pthread_pool_t *acl_thread_pool_create(int threads_limit, int idle_timeout);\n```\n\n这样，用户就可以非常方便地创建自己的线程池了，而且别忘了，这个线程池还是可以是半驻留的（当然也是跨平台的，可以运行在　Linux/Solaris/FreeBSD/Win32 的环境下）。\n\ngithub：https://github.com/acl-dev/acl/\ngitee：https://gitee.com/acl-dev/acl/","slug":"threads","published":1,"updated":"2023-01-24T07:56:17.007Z","_id":"cld9xuv8f000i7x9kbbf6btt5","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>在当今强调多核开发的年代，要求程序员能够写出高并发的程序，而利用多个核一般有两种方式：采用多线程方式或多进程方式。每处理一个新任务时如果临时产生一个线程或进程且处理完任务后线程或进程便立即退出，显示这种方式是非常低效的，于是人们一般采用线程池的模型（这在JAVA 或 .NET 中非常普遍）或多进程进程池模型（这一般在UNIX平台应用较多）。此外，对于线程池或进程池模型又分为两种情形：常驻留内存或半驻留内存，常驻内存是指预先产生一批线程或进程，等待新任务到达，这些线程或进程即使在空闲状态也会常驻内存；半驻留内存是指当来新任务时如果线程池或进程池没有可利用线程或进程则启动新的线程或进程来处理新任务，处理完后，线程或进程并不立即退出，而是空闲指定时间，如果在空闲阀值时间到达前有新任务到达则立即处理新任务，如果到达空闲超时后依然没有新任务到达，则这些空闲的线程或进程便退出，以让出系统资源。所以，对比常驻内存方式和半驻留内存方式，不难看出半驻留方式更有按需分配的意味。</p>\n<p>下面仅以ACL框架中的半驻留线程池模型为例介绍了如何写一个半驻留线程池的程序。</p>\n<h2 id=\"二、半驻留线程池函数接口说明\"><a href=\"#二、半驻留线程池函数接口说明\" class=\"headerlink\" title=\"二、半驻留线程池函数接口说明\"></a>二、半驻留线程池函数接口说明</h2><h3 id=\"2-1）线程池的创建、销毁及任务添加等接口\"><a href=\"#2-1）线程池的创建、销毁及任务添加等接口\" class=\"headerlink\" title=\"2.1）线程池的创建、销毁及任务添加等接口\"></a>2.1）线程池的创建、销毁及任务添加等接口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 创建一个线程池对象</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125; 线程池创建时的属性，如果该参数为空，</span><br><span class=\"hljs-comment\"> *  则采用默认参数: ACL_PTHREAD_POOL_DEF_XXX</span><br><span class=\"hljs-comment\"> * @return &#123;acl_pthread_pool_t*&#125;, 如果不为空则表示成功，否则失败</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">acl_pthread_pool_t</span> *<span class=\"hljs-title\">acl_pthread_pool_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 销毁一个线程池对象, 成功销毁后该对象不能再用.</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: 成功; != 0: 失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_destroy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 向线程池添加一个任务</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @param run_fn &#123;void (*)(*)&#125; 当有可用工作线程时所调用的回调处理函数</span><br><span class=\"hljs-comment\"> * @param run_arg &#123;void*&#125; 回调函数 run_fn 所需要的回调参数</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: 成功; != 0: 失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-type\">void</span> (*run_fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *run_arg)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当前线程池中的线程数</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 返回线程池中的总线程数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_size</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2）线程池属性设置接口\"><a href=\"#2-2）线程池属性设置接口\" class=\"headerlink\" title=\"2.2）线程池属性设置接口\"></a>2.2）线程池属性设置接口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 初始化线程池属性值</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_pthread_pool_attr_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置线程池属性中的最大堆栈大小(字节)</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class=\"hljs-comment\"> * @param size &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_pthread_pool_attr_set_stacksize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr, <span class=\"hljs-type\">size_t</span> size)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置线程池属性中的最大线程数限制值</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class=\"hljs-comment\"> * @param threads_limit &#123;int&#125; 线程池中的最大线程数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_pthread_pool_attr_set_threads_limit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr, </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">int</span> threads_limit)</span></span>;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置线程池属性中线程空闲超时值</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class=\"hljs-comment\"> * @param idle_timeout &#123;int&#125; 线程空闲超时时间(秒)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_pthread_pool_attr_set_idle_timeout</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr, </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">int</span> idle_timeout)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3）线程池中的工作线程创建、退出时设置回调函数接口\"><a href=\"#2-3）线程池中的工作线程创建、退出时设置回调函数接口\" class=\"headerlink\" title=\"2.3）线程池中的工作线程创建、退出时设置回调函数接口\"></a>2.3）线程池中的工作线程创建、退出时设置回调函数接口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 添加注册函数，在线程创建后立即执行此初始化函数</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @param init_fn &#123;int (*)(void*)&#125; 工作线程初始化函数, 如果该函数返回 &lt; 0,</span><br><span class=\"hljs-comment\"> *  则该线程自动退出。</span><br><span class=\"hljs-comment\"> * @param init_arg &#123;void*&#125; init_fn 所需要的参数</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: OK; != 0: Error.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_atinit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-type\">int</span> (*init_fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *init_arg)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 添加注册函数，在线程退出立即执行此初函数</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @param free_fn &#123;void (*)(void*)&#125; 工作线程退出前必须执行的函数</span><br><span class=\"hljs-comment\"> * @param free_arg &#123;void*&#125; free_fn 所需要的参数</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: OK; != 0: Error.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_atfree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-type\">void</span> (*free_fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *free_arg)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、半驻留线程池例子\"><a href=\"#三、半驻留线程池例子\" class=\"headerlink\" title=\"三、半驻留线程池例子\"></a>三、半驻留线程池例子</h2><h3 id=\"3-1）程序代码\"><a href=\"#3-1）程序代码\" class=\"headerlink\" title=\"3.1）程序代码\"></a>3.1）程序代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 用户自定义数据结构</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">THREAD_CTX</span> &#123;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool;<br>\t<span class=\"hljs-type\">int</span>   i;<br>&#125; THREAD_CTX;<br><br><span class=\"hljs-comment\">/* 全局性静态变量 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">acl_pthread_pool_t</span> *__thr_pool = <span class=\"hljs-literal\">NULL</span>;<br><br><span class=\"hljs-comment\">/* 线程局部存储变量(C99支持此种方式声明，方便许多) */</span><br><span class=\"hljs-type\">static</span> __thread <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> __local = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">work_thread_fn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTHREAD_CTX *ctx = (THREAD_CTX*) arg; <span class=\"hljs-comment\">/* 获得用户自定义对象 */</span><br>\t<span class=\"hljs-type\">int</span>   i = <span class=\"hljs-number\">5</span>;<br><br>\t<span class=\"hljs-comment\">/* 仅是验证参数传递过程 */</span><br>\t<span class=\"hljs-built_in\">assert</span>(ctx-&gt;thr_pool == __thr_pool);<br><br>\t<span class=\"hljs-keyword\">while</span> (i-- &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;thread start! tid=%d, i=%d, __local=%d\\r\\n&quot;</span>,<br>\t\t\t\t<span class=\"hljs-built_in\">acl_pthread_self</span>(), ctx-&gt;i, __local);<br>\t\t<span class=\"hljs-comment\">/* 在本线程中将线程局部变量加1 */</span><br>\t\t__local++;<br>\t\t<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">acl_myfree</span>(ctx);<br><br>\t<span class=\"hljs-comment\">/* 至此，该工作线程进入空闲状态，直到空闲超时退出 */</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">on_thread_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *myname = <span class=\"hljs-string\">&quot;on_thread_init&quot;</span>;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool = (<span class=\"hljs-type\">acl_pthread_pool_t</span>*) arg;<br><br>\t<span class=\"hljs-comment\">/* 判断一下，仅是为了验证参数传递过程 */</span><br>\t<span class=\"hljs-built_in\">assert</span>(thr_pool == __thr_pool);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread(%d) init now\\r\\n&quot;</span>, myname, <span class=\"hljs-built_in\">acl_pthread_self</span>());<br><br>\t<span class=\"hljs-comment\">/* 返回0表示继续执行该线程获得的新任务，返回-1表示停止执行该任务 */</span><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">on_thread_exit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *myname = <span class=\"hljs-string\">&quot;on_thread_exit&quot;</span>;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool = (<span class=\"hljs-type\">acl_pthread_pool_t</span>*) arg;<br><br>\t<span class=\"hljs-comment\">/* 判断一下，仅是为了验证参数传递过程 */</span><br>\t<span class=\"hljs-built_in\">assert</span>(thr_pool == __thr_pool);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread(%d) exit now\\r\\n&quot;</span>, myname, <span class=\"hljs-built_in\">acl_pthread_self</span>());<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run_thread_pool</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTHREAD_CTX *ctx;  <span class=\"hljs-comment\">/* 用户自定义参数 */</span><br><br>\t<span class=\"hljs-comment\">/* 设置全局静态变量 */</span><br>\t__thr_pool = thr_pool;<br><br>\t<span class=\"hljs-comment\">/* 设置线程开始时的回调函数 */</span><br>\t(<span class=\"hljs-type\">void</span>) <span class=\"hljs-built_in\">acl_pthread_pool_atinit</span>(thr_pool, on_thread_init, thr_pool);<br><br>\t<span class=\"hljs-comment\">/* 设置线程退出时的回调函数 */</span><br>\t(<span class=\"hljs-type\">void</span>) <span class=\"hljs-built_in\">acl_pthread_pool_atfree</span>(thr_pool, on_thread_exit, thr_pool);<br><br>\tctx = (THREAD_CTX*) <span class=\"hljs-built_in\">acl_mycalloc</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">sizeof</span>(THREAD_CTX));<br>\t<span class=\"hljs-built_in\">assert</span>(ctx);<br>\tctx-&gt;thr_pool = thr_pool;<br>\tctx-&gt;i = <span class=\"hljs-number\">0</span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 向线程池中添加第一个任务，即启动第一个工作线程</span><br><span class=\"hljs-comment\">\t * @param thr_pool 线程池句柄</span><br><span class=\"hljs-comment\">\t * @param workq_thread_fn 工作线程的回调函数</span><br><span class=\"hljs-comment\">\t * @param ctx 用户定义参数</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-built_in\">acl_pthread_pool_add</span>(thr_pool, work_thread_fn, ctx);<br>\t<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">1</span>);<br><br>\tctx = (THREAD_CTX*) <span class=\"hljs-built_in\">acl_mycalloc</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">sizeof</span>(THREAD_CTX));<br>\t<span class=\"hljs-built_in\">assert</span>(ctx);<br>\tctx-&gt;thr_pool = thr_pool;<br>\tctx-&gt;i = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-comment\">/* 向线程池中添加第二个任务，即启动第二个工作线程 */</span><br>\t<span class=\"hljs-built_in\">acl_pthread_pool_add</span>(thr_pool, work_thread_fn, ctx);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc acl_unused, <span class=\"hljs-type\">char</span> *argv[] acl_unused)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool;<br>\t<span class=\"hljs-type\">int</span>  max_threads = <span class=\"hljs-number\">20</span>;  <span class=\"hljs-comment\">/* 最多并发20个线程 */</span><br>\t<span class=\"hljs-type\">int</span>  idle_timeout = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">/* 每个工作线程空闲10秒后自动退出 */</span><br>\t<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> attr;<br><br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_init</span>(&amp;attr);<br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_set_threads_limit</span>(&amp;attr, max_threads);<br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_set_idle_timeout</span>(&amp;attr, idle_timeout);<br><br>\t<span class=\"hljs-comment\">/* 创建半驻留线程句柄 */</span><br>\tthr_pool = <span class=\"hljs-built_in\">acl_pthread_pool_create</span>(&amp;attr);<br>\t<span class=\"hljs-built_in\">assert</span>(thr_pool);<br>\t<span class=\"hljs-built_in\">run_thread_pool</span>(thr_pool);<br><br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">/* 如果立即运行 acl_pthread_pool_destroy，则由于调用了线程池销毁函数，</span><br><span class=\"hljs-comment\">\t\t * 主线程便立刻通知空闲线程退出，所有空闲线程不必等待空闲超时时间便可退出,</span><br><span class=\"hljs-comment\">\t\t */</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt; wait all threads to be idle and free thread pool\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-comment\">/* 立即销毁线程池 */</span><br>\t\t<span class=\"hljs-built_in\">acl_pthread_pool_destroy</span>(thr_pool);<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-comment\">/* 因为不立即调用 acl_pthread_pool_destroy，所有所有空闲线程都是当空闲</span><br><span class=\"hljs-comment\">\t\t * 超时时间到达后才退出</span><br><span class=\"hljs-comment\">\t\t */</span><br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\t\t<span class=\"hljs-type\">int</span>   ret;<br><br>\t\t\tret = <span class=\"hljs-built_in\">acl_pthread_pool_size</span>(thr_pool);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt; current threads in thread pool is: %d\\r\\n&quot;</span>, ret);<br>\t\t\t<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">1</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">/* 线程池中的工作线程数为0时销毁线程池 */</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt; all worker thread exit now\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">acl_pthread_pool_destroy</span>(thr_pool);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 主线程等待用户在终端输入任意字符后退出 */</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt; enter any key to exit\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">getchar</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-编译链接\"><a href=\"#3-2-编译链接\" class=\"headerlink\" title=\"3.2) 编译链接\"></a>3.2) 编译链接</h3><p>从　<a href=\"http://www.sourceforge.net/projects/acl/\">http://www.sourceforge.net/projects/acl/</a> 站点下载 acl_project 代码，在WIN32平台下请用VC2003编译，打开 acl_project\\win32_build\\vc\\acl_project_vc2003.sln 编译后在目录　acl_project\\dist\\lib_acl\\lib\\win32　下生成lib_acl_vc2003.lib, 然后在示例的控制台工程中包含该库，并包含acl_project\\lib_acl\\include　下的 lib_acl.h 头文件，编译上述源代码即可。<br>因为本例子代码在 ACL 的例子里有，所以可以直接编译 acl_project\\win32_build\\vc\\samples\\samples_vc2003.sln 中的 thread_pool 项目即可。</p>\n<h3 id=\"3-3-运行\"><a href=\"#3-3-运行\" class=\"headerlink\" title=\"3.3) 运行\"></a>3.3) 运行</h3><p>运行示例程序后，在我的机器的显示结果如下：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">on_thread_init: thread(23012) init now<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=0<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=1<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>on_thread_init: thread(23516) init now<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=0<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=1<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=3<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=3<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=4<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=4<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>on_thread_exit: thread(23012) exit now<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 1<br>on_thread_exit: thread(23516) exit now<br>&gt; all worker thread exit now<br>&gt; enter any key <span class=\"hljs-keyword\">to</span> exit<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h2><p>可以看出，使用ACL库创建半驻留式高并发多线程程序是比较简单的，ACL线程池库的接口定义及实现尽量与POSIX中规定的POSIX线程的实现接口相似，创建与使用ACL线程池库的步骤如下：</p>\n<ul>\n<li>acl_pthread_pool_attr_init: 初始化创建线程池对象所需要属性信息(可以通过 acl_pthread_pool_attr_set_threads_limit 设置线程池最大并发数及用 acl_pthread_pool_attr_set_idle_timeout 设置线程池中工作线程的空闲退出时间间隔)</li>\n<li>acl_pthread_pool_create: 创建线程池对象</li>\n<li>acl_pthread_pool_add: 向线程池中添加新任务，新任务将由线程池中的某一工作线程执行</li>\n<li>acl_pthread_pool_destroy: 通知并等待线程池中的工作线程执行完任务后退出，同时销毁线程池对象</li>\n</ul>\n<p>还可以在选择在创建线程池对象后，调用 acl_pthread_pool_atinit 设置工作线程第一次被创建时回调用户自定义函数过程，或当线程空闲退出后调用 acl_pthread_pool_atfree 中设置的回调函数。<br>另外，可以将创建线程池的过程进行一抽象，写成如下形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 创建半驻留线程池的过程</span><br><span class=\"hljs-comment\"> * @return &#123;acl_pthread_pool_t*&#125; 新创建的线程池句柄</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">acl_pthread_pool_t</span> *<span class=\"hljs-title\">create_thread_pool</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool;  <span class=\"hljs-comment\">/* 线程池句柄 */</span><br>\t<span class=\"hljs-type\">int</span>  max_threads = <span class=\"hljs-number\">100</span>;  <span class=\"hljs-comment\">/* 最多并发100个线程 */</span><br>\t<span class=\"hljs-type\">int</span>  idle_timeout = <span class=\"hljs-number\">10</span>;  <span class=\"hljs-comment\">/* 每个工作线程空闲10秒后自动退出 */</span><br>\t<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> attr;  <span class=\"hljs-comment\">/* 线程池初始化时的属性 */</span><br><br>\t<span class=\"hljs-comment\">/* 初始化线程池对象属性 */</span><br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_init</span>(&amp;attr);<br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_set_threads_limit</span>(&amp;attr, max_threads);<br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_set_idle_timeout</span>(&amp;attr, idle_timeout);<br><br>\t<span class=\"hljs-comment\">/* 创建半驻留线程句柄 */</span><br>\tthr_pool = <span class=\"hljs-built_in\">acl_pthread_pool_create</span>(&amp;attr);<br>\t<span class=\"hljs-built_in\">assert</span>(thr_pool);<br>\t<span class=\"hljs-keyword\">return</span> (thr_pool);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其实，利用ACL创建线程池还有一个简化接口（只所以叫 acl_thread_xxx 没有加 p, 是因为这个接口不太遵守 Posix的一些规范），如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 更简单地创建线程对象的方法</span><br><span class=\"hljs-comment\"> * @param threads_limit &#123;int&#125;  线程池中最大并发线程数</span><br><span class=\"hljs-comment\"> * @param idle_timeout &#123;int&#125; 工作线程空闲超时退出时间(秒)，如果为0则工作线程永不退出</span><br><span class=\"hljs-comment\"> * @return &#123;acl_pthread_pool_t*&#125;, 如果不为空则表示成功，否则失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">acl_pthread_pool_t</span> *<span class=\"hljs-title\">acl_thread_pool_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> threads_limit, <span class=\"hljs-type\">int</span> idle_timeout)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>这样，用户就可以非常方便地创建自己的线程池了，而且别忘了，这个线程池还是可以是半驻留的（当然也是跨平台的，可以运行在　Linux&#x2F;Solaris&#x2F;FreeBSD&#x2F;Win32 的环境下）。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl/\">https://github.com/acl-dev/acl/</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl/\">https://gitee.com/acl-dev/acl/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>在当今强调多核开发的年代，要求程序员能够写出高并发的程序，而利用多个核一般有两种方式：采用多线程方式或多进程方式。每处理一个新任务时如果临时产生一个线程或进程且处理完任务后线程或进程便立即退出，显示这种方式是非常低效的，于是人们一般采用线程池的模型（这在JAVA 或 .NET 中非常普遍）或多进程进程池模型（这一般在UNIX平台应用较多）。此外，对于线程池或进程池模型又分为两种情形：常驻留内存或半驻留内存，常驻内存是指预先产生一批线程或进程，等待新任务到达，这些线程或进程即使在空闲状态也会常驻内存；半驻留内存是指当来新任务时如果线程池或进程池没有可利用线程或进程则启动新的线程或进程来处理新任务，处理完后，线程或进程并不立即退出，而是空闲指定时间，如果在空闲阀值时间到达前有新任务到达则立即处理新任务，如果到达空闲超时后依然没有新任务到达，则这些空闲的线程或进程便退出，以让出系统资源。所以，对比常驻内存方式和半驻留内存方式，不难看出半驻留方式更有按需分配的意味。</p>\n<p>下面仅以ACL框架中的半驻留线程池模型为例介绍了如何写一个半驻留线程池的程序。</p>\n<h2 id=\"二、半驻留线程池函数接口说明\"><a href=\"#二、半驻留线程池函数接口说明\" class=\"headerlink\" title=\"二、半驻留线程池函数接口说明\"></a>二、半驻留线程池函数接口说明</h2><h3 id=\"2-1）线程池的创建、销毁及任务添加等接口\"><a href=\"#2-1）线程池的创建、销毁及任务添加等接口\" class=\"headerlink\" title=\"2.1）线程池的创建、销毁及任务添加等接口\"></a>2.1）线程池的创建、销毁及任务添加等接口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 创建一个线程池对象</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125; 线程池创建时的属性，如果该参数为空，</span><br><span class=\"hljs-comment\"> *  则采用默认参数: ACL_PTHREAD_POOL_DEF_XXX</span><br><span class=\"hljs-comment\"> * @return &#123;acl_pthread_pool_t*&#125;, 如果不为空则表示成功，否则失败</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">acl_pthread_pool_t</span> *<span class=\"hljs-title\">acl_pthread_pool_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 销毁一个线程池对象, 成功销毁后该对象不能再用.</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: 成功; != 0: 失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_destroy</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 向线程池添加一个任务</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @param run_fn &#123;void (*)(*)&#125; 当有可用工作线程时所调用的回调处理函数</span><br><span class=\"hljs-comment\"> * @param run_arg &#123;void*&#125; 回调函数 run_fn 所需要的回调参数</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: 成功; != 0: 失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_add</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-type\">void</span> (*run_fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *run_arg)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当前线程池中的线程数</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 返回线程池中的总线程数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_size</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-2）线程池属性设置接口\"><a href=\"#2-2）线程池属性设置接口\" class=\"headerlink\" title=\"2.2）线程池属性设置接口\"></a>2.2）线程池属性设置接口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 初始化线程池属性值</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_pthread_pool_attr_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置线程池属性中的最大堆栈大小(字节)</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class=\"hljs-comment\"> * @param size &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_pthread_pool_attr_set_stacksize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr, <span class=\"hljs-type\">size_t</span> size)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置线程池属性中的最大线程数限制值</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class=\"hljs-comment\"> * @param threads_limit &#123;int&#125; 线程池中的最大线程数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_pthread_pool_attr_set_threads_limit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr, </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">int</span> threads_limit)</span></span>;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置线程池属性中线程空闲超时值</span><br><span class=\"hljs-comment\"> * @param attr &#123;acl_pthread_pool_attr_t*&#125;</span><br><span class=\"hljs-comment\"> * @param idle_timeout &#123;int&#125; 线程空闲超时时间(秒)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_pthread_pool_attr_set_idle_timeout</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> *attr, </span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">    <span class=\"hljs-type\">int</span> idle_timeout)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"2-3）线程池中的工作线程创建、退出时设置回调函数接口\"><a href=\"#2-3）线程池中的工作线程创建、退出时设置回调函数接口\" class=\"headerlink\" title=\"2.3）线程池中的工作线程创建、退出时设置回调函数接口\"></a>2.3）线程池中的工作线程创建、退出时设置回调函数接口</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 添加注册函数，在线程创建后立即执行此初始化函数</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @param init_fn &#123;int (*)(void*)&#125; 工作线程初始化函数, 如果该函数返回 &lt; 0,</span><br><span class=\"hljs-comment\"> *  则该线程自动退出。</span><br><span class=\"hljs-comment\"> * @param init_arg &#123;void*&#125; init_fn 所需要的参数</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: OK; != 0: Error.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_atinit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-type\">int</span> (*init_fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *init_arg)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 添加注册函数，在线程退出立即执行此初函数</span><br><span class=\"hljs-comment\"> * @param thr_pool &#123;acl_pthread_pool_t*&#125; 线程池对象，不能为空</span><br><span class=\"hljs-comment\"> * @param free_fn &#123;void (*)(void*)&#125; 工作线程退出前必须执行的函数</span><br><span class=\"hljs-comment\"> * @param free_arg &#123;void*&#125; free_fn 所需要的参数</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 0: OK; != 0: Error.</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_pthread_pool_atfree</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        <span class=\"hljs-type\">void</span> (*free_fn)(<span class=\"hljs-type\">void</span> *), <span class=\"hljs-type\">void</span> *free_arg)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、半驻留线程池例子\"><a href=\"#三、半驻留线程池例子\" class=\"headerlink\" title=\"三、半驻留线程池例子\"></a>三、半驻留线程池例子</h2><h3 id=\"3-1）程序代码\"><a href=\"#3-1）程序代码\" class=\"headerlink\" title=\"3.1）程序代码\"></a>3.1）程序代码</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 用户自定义数据结构</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">THREAD_CTX</span> &#123;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool;<br>\t<span class=\"hljs-type\">int</span>   i;<br>&#125; THREAD_CTX;<br><br><span class=\"hljs-comment\">/* 全局性静态变量 */</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">acl_pthread_pool_t</span> *__thr_pool = <span class=\"hljs-literal\">NULL</span>;<br><br><span class=\"hljs-comment\">/* 线程局部存储变量(C99支持此种方式声明，方便许多) */</span><br><span class=\"hljs-type\">static</span> __thread <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">int</span> __local = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">work_thread_fn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTHREAD_CTX *ctx = (THREAD_CTX*) arg; <span class=\"hljs-comment\">/* 获得用户自定义对象 */</span><br>\t<span class=\"hljs-type\">int</span>   i = <span class=\"hljs-number\">5</span>;<br><br>\t<span class=\"hljs-comment\">/* 仅是验证参数传递过程 */</span><br>\t<span class=\"hljs-built_in\">assert</span>(ctx-&gt;thr_pool == __thr_pool);<br><br>\t<span class=\"hljs-keyword\">while</span> (i-- &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;thread start! tid=%d, i=%d, __local=%d\\r\\n&quot;</span>,<br>\t\t\t\t<span class=\"hljs-built_in\">acl_pthread_self</span>(), ctx-&gt;i, __local);<br>\t\t<span class=\"hljs-comment\">/* 在本线程中将线程局部变量加1 */</span><br>\t\t__local++;<br>\t\t<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">1</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">acl_myfree</span>(ctx);<br><br>\t<span class=\"hljs-comment\">/* 至此，该工作线程进入空闲状态，直到空闲超时退出 */</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">on_thread_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *myname = <span class=\"hljs-string\">&quot;on_thread_init&quot;</span>;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool = (<span class=\"hljs-type\">acl_pthread_pool_t</span>*) arg;<br><br>\t<span class=\"hljs-comment\">/* 判断一下，仅是为了验证参数传递过程 */</span><br>\t<span class=\"hljs-built_in\">assert</span>(thr_pool == __thr_pool);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread(%d) init now\\r\\n&quot;</span>, myname, <span class=\"hljs-built_in\">acl_pthread_self</span>());<br><br>\t<span class=\"hljs-comment\">/* 返回0表示继续执行该线程获得的新任务，返回-1表示停止执行该任务 */</span><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">on_thread_exit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *myname = <span class=\"hljs-string\">&quot;on_thread_exit&quot;</span>;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool = (<span class=\"hljs-type\">acl_pthread_pool_t</span>*) arg;<br><br>\t<span class=\"hljs-comment\">/* 判断一下，仅是为了验证参数传递过程 */</span><br>\t<span class=\"hljs-built_in\">assert</span>(thr_pool == __thr_pool);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread(%d) exit now\\r\\n&quot;</span>, myname, <span class=\"hljs-built_in\">acl_pthread_self</span>());<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run_thread_pool</span><span class=\"hljs-params\">(<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tTHREAD_CTX *ctx;  <span class=\"hljs-comment\">/* 用户自定义参数 */</span><br><br>\t<span class=\"hljs-comment\">/* 设置全局静态变量 */</span><br>\t__thr_pool = thr_pool;<br><br>\t<span class=\"hljs-comment\">/* 设置线程开始时的回调函数 */</span><br>\t(<span class=\"hljs-type\">void</span>) <span class=\"hljs-built_in\">acl_pthread_pool_atinit</span>(thr_pool, on_thread_init, thr_pool);<br><br>\t<span class=\"hljs-comment\">/* 设置线程退出时的回调函数 */</span><br>\t(<span class=\"hljs-type\">void</span>) <span class=\"hljs-built_in\">acl_pthread_pool_atfree</span>(thr_pool, on_thread_exit, thr_pool);<br><br>\tctx = (THREAD_CTX*) <span class=\"hljs-built_in\">acl_mycalloc</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">sizeof</span>(THREAD_CTX));<br>\t<span class=\"hljs-built_in\">assert</span>(ctx);<br>\tctx-&gt;thr_pool = thr_pool;<br>\tctx-&gt;i = <span class=\"hljs-number\">0</span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 向线程池中添加第一个任务，即启动第一个工作线程</span><br><span class=\"hljs-comment\">\t * @param thr_pool 线程池句柄</span><br><span class=\"hljs-comment\">\t * @param workq_thread_fn 工作线程的回调函数</span><br><span class=\"hljs-comment\">\t * @param ctx 用户定义参数</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-built_in\">acl_pthread_pool_add</span>(thr_pool, work_thread_fn, ctx);<br>\t<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">1</span>);<br><br>\tctx = (THREAD_CTX*) <span class=\"hljs-built_in\">acl_mycalloc</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-built_in\">sizeof</span>(THREAD_CTX));<br>\t<span class=\"hljs-built_in\">assert</span>(ctx);<br>\tctx-&gt;thr_pool = thr_pool;<br>\tctx-&gt;i = <span class=\"hljs-number\">1</span>;<br>\t<span class=\"hljs-comment\">/* 向线程池中添加第二个任务，即启动第二个工作线程 */</span><br>\t<span class=\"hljs-built_in\">acl_pthread_pool_add</span>(thr_pool, work_thread_fn, ctx);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> argc acl_unused, <span class=\"hljs-type\">char</span> *argv[] acl_unused)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool;<br>\t<span class=\"hljs-type\">int</span>  max_threads = <span class=\"hljs-number\">20</span>;  <span class=\"hljs-comment\">/* 最多并发20个线程 */</span><br>\t<span class=\"hljs-type\">int</span>  idle_timeout = <span class=\"hljs-number\">10</span>; <span class=\"hljs-comment\">/* 每个工作线程空闲10秒后自动退出 */</span><br>\t<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> attr;<br><br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_init</span>(&amp;attr);<br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_set_threads_limit</span>(&amp;attr, max_threads);<br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_set_idle_timeout</span>(&amp;attr, idle_timeout);<br><br>\t<span class=\"hljs-comment\">/* 创建半驻留线程句柄 */</span><br>\tthr_pool = <span class=\"hljs-built_in\">acl_pthread_pool_create</span>(&amp;attr);<br>\t<span class=\"hljs-built_in\">assert</span>(thr_pool);<br>\t<span class=\"hljs-built_in\">run_thread_pool</span>(thr_pool);<br><br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">/* 如果立即运行 acl_pthread_pool_destroy，则由于调用了线程池销毁函数，</span><br><span class=\"hljs-comment\">\t\t * 主线程便立刻通知空闲线程退出，所有空闲线程不必等待空闲超时时间便可退出,</span><br><span class=\"hljs-comment\">\t\t */</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt; wait all threads to be idle and free thread pool\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-comment\">/* 立即销毁线程池 */</span><br>\t\t<span class=\"hljs-built_in\">acl_pthread_pool_destroy</span>(thr_pool);<br>\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t<span class=\"hljs-comment\">/* 因为不立即调用 acl_pthread_pool_destroy，所有所有空闲线程都是当空闲</span><br><span class=\"hljs-comment\">\t\t * 超时时间到达后才退出</span><br><span class=\"hljs-comment\">\t\t */</span><br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\t\t<span class=\"hljs-type\">int</span>   ret;<br><br>\t\t\tret = <span class=\"hljs-built_in\">acl_pthread_pool_size</span>(thr_pool);<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt; current threads in thread pool is: %d\\r\\n&quot;</span>, ret);<br>\t\t\t<span class=\"hljs-built_in\">sleep</span>(<span class=\"hljs-number\">1</span>);<br>\t\t&#125;<br>\t\t<span class=\"hljs-comment\">/* 线程池中的工作线程数为0时销毁线程池 */</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt; all worker thread exit now\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">acl_pthread_pool_destroy</span>(thr_pool);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">/* 主线程等待用户在终端输入任意字符后退出 */</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt; enter any key to exit\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">getchar</span>();<br><br>\t<span class=\"hljs-keyword\">return</span> (<span class=\"hljs-number\">0</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h3 id=\"3-2-编译链接\"><a href=\"#3-2-编译链接\" class=\"headerlink\" title=\"3.2) 编译链接\"></a>3.2) 编译链接</h3><p>从　<a href=\"http://www.sourceforge.net/projects/acl/\">http://www.sourceforge.net/projects/acl/</a> 站点下载 acl_project 代码，在WIN32平台下请用VC2003编译，打开 acl_project\\win32_build\\vc\\acl_project_vc2003.sln 编译后在目录　acl_project\\dist\\lib_acl\\lib\\win32　下生成lib_acl_vc2003.lib, 然后在示例的控制台工程中包含该库，并包含acl_project\\lib_acl\\include　下的 lib_acl.h 头文件，编译上述源代码即可。<br>因为本例子代码在 ACL 的例子里有，所以可以直接编译 acl_project\\win32_build\\vc\\samples\\samples_vc2003.sln 中的 thread_pool 项目即可。</p>\n<h3 id=\"3-3-运行\"><a href=\"#3-3-运行\" class=\"headerlink\" title=\"3.3) 运行\"></a>3.3) 运行</h3><p>运行示例程序后，在我的机器的显示结果如下：</p>\n<figure class=\"highlight routeros\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs routeros\">on_thread_init: thread(23012) init now<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=0<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=1<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>on_thread_init: thread(23516) init now<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=0<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=1<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=3<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=3<br>thread start! <span class=\"hljs-attribute\">tid</span>=23012, <span class=\"hljs-attribute\">i</span>=0, <span class=\"hljs-attribute\">__local</span>=4<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>thread start! <span class=\"hljs-attribute\">tid</span>=23516, <span class=\"hljs-attribute\">i</span>=1, <span class=\"hljs-attribute\">__local</span>=4<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 2<br>on_thread_exit: thread(23012) exit now<br>&gt; current threads <span class=\"hljs-keyword\">in</span> thread<span class=\"hljs-built_in\"> pool </span>is: 1<br>on_thread_exit: thread(23516) exit now<br>&gt; all worker thread exit now<br>&gt; enter any key <span class=\"hljs-keyword\">to</span> exit<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h2><p>可以看出，使用ACL库创建半驻留式高并发多线程程序是比较简单的，ACL线程池库的接口定义及实现尽量与POSIX中规定的POSIX线程的实现接口相似，创建与使用ACL线程池库的步骤如下：</p>\n<ul>\n<li>acl_pthread_pool_attr_init: 初始化创建线程池对象所需要属性信息(可以通过 acl_pthread_pool_attr_set_threads_limit 设置线程池最大并发数及用 acl_pthread_pool_attr_set_idle_timeout 设置线程池中工作线程的空闲退出时间间隔)</li>\n<li>acl_pthread_pool_create: 创建线程池对象</li>\n<li>acl_pthread_pool_add: 向线程池中添加新任务，新任务将由线程池中的某一工作线程执行</li>\n<li>acl_pthread_pool_destroy: 通知并等待线程池中的工作线程执行完任务后退出，同时销毁线程池对象</li>\n</ul>\n<p>还可以在选择在创建线程池对象后，调用 acl_pthread_pool_atinit 设置工作线程第一次被创建时回调用户自定义函数过程，或当线程空闲退出后调用 acl_pthread_pool_atfree 中设置的回调函数。<br>另外，可以将创建线程池的过程进行一抽象，写成如下形式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 创建半驻留线程池的过程</span><br><span class=\"hljs-comment\"> * @return &#123;acl_pthread_pool_t*&#125; 新创建的线程池句柄</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">acl_pthread_pool_t</span> *<span class=\"hljs-title\">create_thread_pool</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">acl_pthread_pool_t</span> *thr_pool;  <span class=\"hljs-comment\">/* 线程池句柄 */</span><br>\t<span class=\"hljs-type\">int</span>  max_threads = <span class=\"hljs-number\">100</span>;  <span class=\"hljs-comment\">/* 最多并发100个线程 */</span><br>\t<span class=\"hljs-type\">int</span>  idle_timeout = <span class=\"hljs-number\">10</span>;  <span class=\"hljs-comment\">/* 每个工作线程空闲10秒后自动退出 */</span><br>\t<span class=\"hljs-type\">acl_pthread_pool_attr_t</span> attr;  <span class=\"hljs-comment\">/* 线程池初始化时的属性 */</span><br><br>\t<span class=\"hljs-comment\">/* 初始化线程池对象属性 */</span><br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_init</span>(&amp;attr);<br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_set_threads_limit</span>(&amp;attr, max_threads);<br>\t<span class=\"hljs-built_in\">acl_pthread_pool_attr_set_idle_timeout</span>(&amp;attr, idle_timeout);<br><br>\t<span class=\"hljs-comment\">/* 创建半驻留线程句柄 */</span><br>\tthr_pool = <span class=\"hljs-built_in\">acl_pthread_pool_create</span>(&amp;attr);<br>\t<span class=\"hljs-built_in\">assert</span>(thr_pool);<br>\t<span class=\"hljs-keyword\">return</span> (thr_pool);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>其实，利用ACL创建线程池还有一个简化接口（只所以叫 acl_thread_xxx 没有加 p, 是因为这个接口不太遵守 Posix的一些规范），如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 更简单地创建线程对象的方法</span><br><span class=\"hljs-comment\"> * @param threads_limit &#123;int&#125;  线程池中最大并发线程数</span><br><span class=\"hljs-comment\"> * @param idle_timeout &#123;int&#125; 工作线程空闲超时退出时间(秒)，如果为0则工作线程永不退出</span><br><span class=\"hljs-comment\"> * @return &#123;acl_pthread_pool_t*&#125;, 如果不为空则表示成功，否则失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">acl_pthread_pool_t</span> *<span class=\"hljs-title\">acl_thread_pool_create</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> threads_limit, <span class=\"hljs-type\">int</span> idle_timeout)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>这样，用户就可以非常方便地创建自己的线程池了，而且别忘了，这个线程池还是可以是半驻留的（当然也是跨平台的，可以运行在　Linux&#x2F;Solaris&#x2F;FreeBSD&#x2F;Win32 的环境下）。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl/\">https://github.com/acl-dev/acl/</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl/\">https://gitee.com/acl-dev/acl/</a></p>\n"},{"title":"acl 日志记录方式介绍","date":"2013-06-23T15:18:00.000Z","_content":"\n在使用 acl 库编写应用过程中，记录日志是一个非常重要的过程，acl 从几个层面提供了日志的不同记录方式。在 acl 的 C 库部分(lib_acl.a)，有三个源文件与日志记录相关：acl_msg.c/acl_msg.h, acl_mylog.c/acl_mylog.h, acl_debug.c/acl_debug.h。其中，acl_mylog.c 是真正记录日志的源文件，acl_msg.c 则是在 acl_mylog.c 基础之上的二次封装，acl_debug.c 是在 acl_msg.c 基础之上的再次封装。下面根据此三个日志源文件从三个层次描述日志记录的过程。\n\n##  一、ac_mylog.c/acl_mylog.h\n打开 acl_mylog.h 头文件，可以看到主要有三个函数：acl_open_log（打开日志文件），acl_write_to_log（写日志）以及acl_close_log（关闭日志）---（这三个函数是最基础的日志记录过程，当然我们不必直接使用）。该库支持两类日志记录方式：1、本地文件记录方式，2、与 syslog-ng 结合的网络日志记录方式。本地文件记录方式是 acl 日志库对外提供的最简单的日志记录方式，此方式不依赖于第三方日志库，但不应用在生产环境中，因为该方式不支持日志回滚等高级特性，为了便于生产上使用，所以产生了第二种方式（与 syslog-ng 结合），查看日志打开接口（如下）：\n\n```c++\n/**\n * 打开日志文件\n * @param recipients {const char*} 日志接收器列表，由 \"|\" 分隔，接收器\n *  可以是本地文件或远程套接口，如:\n *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock\n *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,\n *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象\n * @param plog_pre {const char*} 日志记录信息前的提示信息，建议用进程\n *  名填写此值\n */\nACL_API int acl_open_log(const char *recipients, const char *plog_pre);\n```\n\n从上面的函数声明可以看出，acl 的日志记录允许同时输出至多个日志管道中（最简单的方式就是直接写入本地磁盘文件：/tmp/test.log），同时更应看到，其中有三个奇怪的日志文件表达方式：UDP:IP:PORT, TCP:IP:PORT, UNIX:/xxx，其实这三种方式均是与 syslog-ng 相关，即分别表示：\n\n- 1、以 UDP 方式发送日志至 syslog-ng；\n- 2、以 TCP 方式发送日志至 syslog-ng；\n- 3、以 UNIX 域套接字方式发送日志至 syslog-ng。\n\n因为日志管理是一个非常复杂的过程，所以在 acl 除了提供最简单的日志文件记录外，更建议用户将日志输出至 syslog-ng 中（作者自己的项目也往往是这样做的）。\n\n## 二、acl_msg.c/acl_msg.h\n该日志库提供了更为高级的日志记录方法，不仅提供了灵活的日志记录函数，同时还允许用户注册自己的日志记录函数库，该日志库主要函数接口如下：\n\n```c++\n/**\n * 日志打开函数\n * @param log_file {const char*} 日志接收者集合，由 \"|\" 分隔，接收器\n *  可以是本地文件或远程套接口，如:\n *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock\n *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,\n *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象\n * @param plog_pre {const char*} 日志记录信息前的提示信息，建议用进程\n * @param info_pre {const char*} 日志记录信息前的提示信息\n */\nACL_API void acl_msg_open(const char *log_file, const char *info_pre);\n\n/**\n * 关闭日志函数\n */\nACL_API void acl_msg_close(void);\n\n       上面是日志打开与关闭的函数，看上去算是相对简单。下面是几个日志记录的函数接口：\n\n/**\n * 一般级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_info(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_info(const char *fmt,...);\n#endif\n\n/**\n * 警告级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_warn(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_warn(const char *fmt,...);\n#endif\n\n/**\n * 错误级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_error(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_error(const char *fmt,...);\n#endif\n\n/**\n * 致命级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_fatal(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_fatal(const char *fmt,...);\n#endif\n\n/**\n * 恐慌级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_panic(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_panic(const char *fmt,...);\n#endif\n```\n\n可以看到，这些函数的使用方式与 printf 类似，另外，在 UNIX 下使用 GCC 编译时前面还有一个修饰符：__attribute__((format(printf,m,n)))，这主要是方便 gcc 编译器针对变参进行语法检查（大家应该知道变参是如此方便灵活而又如此容易出错）。\n\n为了方便程序开发过程中的调试，下面的函数当用户未调用 acl_msg_open 打开日志而直接使用 acl_msg_xxx 写日志时，决定是否将日志信息输出至屏幕（这个函数应该在程序初始化时调用）：\n\n```c++\n/**\n * 当未调用 acl_msg_open 方式打开日志时，调用了 acl_msg_info/error/fatal/warn\n * 的操作，是否允许信息输出至标准输出屏幕上，通过此函数来设置该开关，该开关\n * 仅影响是否需要将信息输出至终端屏幕而不影响是否输出至文件中\n * @param onoff {int} 非 0 表示允许输出至屏幕\n */\nACL_API void acl_msg_stdout_enable(int onoff);\n\n       前面曾说过，acl 的日志库还允许用户使用自己的日志记录过程，但要求用户必须在程序初始化时注册自己的日志处理函数，如下：\n\n/**\n * 在打开日志前调用此函数注册应用自己的日志打开函数、日志关闭函数、日志记录函数\n * @param open_fn {ACL_MSG_OPEN_FN} 自定义日志打开函数\n * @param close_fn {ACL_MSG_CLOSE_FN} 自定义日志关闭函数\n * @param write_fn {ACL_MSG_WRITE_FN} 自定义日志记录函数\n * @param ctx {void*} 自定义参数\n */\nACL_API void acl_msg_register(ACL_MSG_OPEN_FN open_fn, ACL_MSG_CLOSE_FN close_fn,\n        ACL_MSG_WRITE_FN write_fn, void *ctx);\n```\n\n调用此函数后，以后的日志记录过程（即当用户调用：acl_msg_xxx 相关过程时）的内容便输出便由用户的日志库控制。\n\n除了以上主要的日志函数接口，在 acl_msg 中还提供了以下几个函数，便于用户知晓程序出错原因：\n\n```c++\n/**\n * 获得上次系统调用出错时的错误描述信息，该函数内部采用了线程局部变量，所以是线程\n * 安全的，但使用起来更简单些\n * @return {const char *} 返回错误提示信息 \n */\nACL_API const char *acl_last_serror(void);\n\n/**\n * 获得上次系统调用出错时的错误号\n * @return {int} 错误号\n */\nACL_API int acl_last_error(void);\n```\n\n## 三、acl_debug.c/acl_debug.h\n该日志函数库是在 acl_msg 之上的再一次封装，该库的思想来源于 squid 的日志记录方式，可以将日志分成不同的类别，每一个类别又分成不同的级别，这样用户就可以非常方便地通过配置文件来记录不同类别的不同级别的日志信息了。在程序初始化时需先调用如此函数：\n\n```c++\n/**\n * 初始化日志调试调用接口\n * @param pStr {const char*} 调试类别（建议值在100至1000之间）标签及级别字符串，\n *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...\n */\nACL_API void acl_debug_init(const char *pStr);\n\n/**\n * 初始化日志调试调用接口\n * @param pStr {const char*} 调试标签及级别字符串，\n *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...\n * @param max_debug_level {int} 最大调试标签值\n */\nACL_API void acl_debug_init2(const char *pStr, int max_debug_level);\n```\n\n其中，第一个参数是一个由日志记录类别与级别组成的字符串，格式为：类别1:最大记录级别, 类别2:最大记录级别, ...。例如：100:2; 102:3; 103:4，其含义是日志将会记录类别为 100 的所有级别值小于2、类别为 101 的所有级别值小于 3 以及类别为 103 的所有级别值小于 4 的日志信息。关于记录类别需要注意：类别值最好是 >= 100，且 < 1000（当使用 acl_debug_init2 初始化时只要类别值 >= 100 即可，因为第二个参数指定了最大类别值），这是因为 acl 库内部一些保留的类别值都在 0 -- 100 之间。\n\n那么具体的使用这些类别与级别记录日志的接口是什么呢？如下所示：\n\n```c++\n/**\n * 日志调试宏接口\n * @param SECTION {int} 调试标签值\n * @param LEVEL {int} 对应于SECTION调试标签的级别\n */\n#define acl_debug(SECTION, LEVEL) \\\n\t!acl_do_debug((SECTION), (LEVEL)) ? (void) 0 : acl_msg_info\n\n        看到了吧，用户其实只需要调用一个宏即可，如下面的例子： \n\n\t/* 初始化日志类别记录 */\n\tconst char *str = \"101:2; 103:4; 105:3\";\n\t/* 记录所有类别值为 101 级别小于等于 2、类别值为 102 级别小于等于 4、类别值为 105 级别小于等于 3 的日志内容 */\n\tacl_debug_init(str);\n\n\t......\n\t/* 下面的日志因符合类别值 101 级别值 <= 2 而被记录 */\n\tacl_debug(101, 2)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\n\t/* 下面日志符合类别 105 的记录级别 */\n\tacl_debug(105, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\n\t/* 下面的日志因不符合类别值 103 的记录级别条件而被忽略 */\n\tacl_debug(103, 5)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\n\t/* 下面日志的类别值 102 因不存在而被忽略 */\n\tacl_debug(102, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n```\n\n此外，为了方便，还可以传给 acl_debug_init 的参数写为：\"all:1\"，意思是所有类别的级别值 <= 1 的日志都将被记录，如下面的内容都会被记录：\n\n```\n\tacl_debug_init(\"all:1\");\n......\n\tacl_debug(100, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(101, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(101, 0)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(102, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(103, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(104, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(105, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n        ......\n```\n\nok，有关日志  acl 日志记录函数就先写这些，使用者可以根据项目需要采用不同的日志记录方式。\n\ngithub 地址：https://github.com/acl-dev/acl\ngitee 地址：https://gitee.com/acl-dev/acl\n \n\n","source":"_posts/log.md","raw":"---\ntitle: acl 日志记录方式介绍\ndate: 2013-06-23 23:18\ncategories: 日志\n---\n\n在使用 acl 库编写应用过程中，记录日志是一个非常重要的过程，acl 从几个层面提供了日志的不同记录方式。在 acl 的 C 库部分(lib_acl.a)，有三个源文件与日志记录相关：acl_msg.c/acl_msg.h, acl_mylog.c/acl_mylog.h, acl_debug.c/acl_debug.h。其中，acl_mylog.c 是真正记录日志的源文件，acl_msg.c 则是在 acl_mylog.c 基础之上的二次封装，acl_debug.c 是在 acl_msg.c 基础之上的再次封装。下面根据此三个日志源文件从三个层次描述日志记录的过程。\n\n##  一、ac_mylog.c/acl_mylog.h\n打开 acl_mylog.h 头文件，可以看到主要有三个函数：acl_open_log（打开日志文件），acl_write_to_log（写日志）以及acl_close_log（关闭日志）---（这三个函数是最基础的日志记录过程，当然我们不必直接使用）。该库支持两类日志记录方式：1、本地文件记录方式，2、与 syslog-ng 结合的网络日志记录方式。本地文件记录方式是 acl 日志库对外提供的最简单的日志记录方式，此方式不依赖于第三方日志库，但不应用在生产环境中，因为该方式不支持日志回滚等高级特性，为了便于生产上使用，所以产生了第二种方式（与 syslog-ng 结合），查看日志打开接口（如下）：\n\n```c++\n/**\n * 打开日志文件\n * @param recipients {const char*} 日志接收器列表，由 \"|\" 分隔，接收器\n *  可以是本地文件或远程套接口，如:\n *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock\n *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,\n *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象\n * @param plog_pre {const char*} 日志记录信息前的提示信息，建议用进程\n *  名填写此值\n */\nACL_API int acl_open_log(const char *recipients, const char *plog_pre);\n```\n\n从上面的函数声明可以看出，acl 的日志记录允许同时输出至多个日志管道中（最简单的方式就是直接写入本地磁盘文件：/tmp/test.log），同时更应看到，其中有三个奇怪的日志文件表达方式：UDP:IP:PORT, TCP:IP:PORT, UNIX:/xxx，其实这三种方式均是与 syslog-ng 相关，即分别表示：\n\n- 1、以 UDP 方式发送日志至 syslog-ng；\n- 2、以 TCP 方式发送日志至 syslog-ng；\n- 3、以 UNIX 域套接字方式发送日志至 syslog-ng。\n\n因为日志管理是一个非常复杂的过程，所以在 acl 除了提供最简单的日志文件记录外，更建议用户将日志输出至 syslog-ng 中（作者自己的项目也往往是这样做的）。\n\n## 二、acl_msg.c/acl_msg.h\n该日志库提供了更为高级的日志记录方法，不仅提供了灵活的日志记录函数，同时还允许用户注册自己的日志记录函数库，该日志库主要函数接口如下：\n\n```c++\n/**\n * 日志打开函数\n * @param log_file {const char*} 日志接收者集合，由 \"|\" 分隔，接收器\n *  可以是本地文件或远程套接口，如:\n *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock\n *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,\n *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象\n * @param plog_pre {const char*} 日志记录信息前的提示信息，建议用进程\n * @param info_pre {const char*} 日志记录信息前的提示信息\n */\nACL_API void acl_msg_open(const char *log_file, const char *info_pre);\n\n/**\n * 关闭日志函数\n */\nACL_API void acl_msg_close(void);\n\n       上面是日志打开与关闭的函数，看上去算是相对简单。下面是几个日志记录的函数接口：\n\n/**\n * 一般级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_info(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_info(const char *fmt,...);\n#endif\n\n/**\n * 警告级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_warn(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_warn(const char *fmt,...);\n#endif\n\n/**\n * 错误级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_error(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_error(const char *fmt,...);\n#endif\n\n/**\n * 致命级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_fatal(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_fatal(const char *fmt,...);\n#endif\n\n/**\n * 恐慌级别日志信息记录函数\n * @param fmt {const char*} 参数格式\n * @param ... 变参序列\n */\n#ifdef\tWIN32\nACL_API void acl_msg_panic(const char *fmt,...);\n#else\nACL_API void __attribute__((format(printf,1,2)))\n\tacl_msg_panic(const char *fmt,...);\n#endif\n```\n\n可以看到，这些函数的使用方式与 printf 类似，另外，在 UNIX 下使用 GCC 编译时前面还有一个修饰符：__attribute__((format(printf,m,n)))，这主要是方便 gcc 编译器针对变参进行语法检查（大家应该知道变参是如此方便灵活而又如此容易出错）。\n\n为了方便程序开发过程中的调试，下面的函数当用户未调用 acl_msg_open 打开日志而直接使用 acl_msg_xxx 写日志时，决定是否将日志信息输出至屏幕（这个函数应该在程序初始化时调用）：\n\n```c++\n/**\n * 当未调用 acl_msg_open 方式打开日志时，调用了 acl_msg_info/error/fatal/warn\n * 的操作，是否允许信息输出至标准输出屏幕上，通过此函数来设置该开关，该开关\n * 仅影响是否需要将信息输出至终端屏幕而不影响是否输出至文件中\n * @param onoff {int} 非 0 表示允许输出至屏幕\n */\nACL_API void acl_msg_stdout_enable(int onoff);\n\n       前面曾说过，acl 的日志库还允许用户使用自己的日志记录过程，但要求用户必须在程序初始化时注册自己的日志处理函数，如下：\n\n/**\n * 在打开日志前调用此函数注册应用自己的日志打开函数、日志关闭函数、日志记录函数\n * @param open_fn {ACL_MSG_OPEN_FN} 自定义日志打开函数\n * @param close_fn {ACL_MSG_CLOSE_FN} 自定义日志关闭函数\n * @param write_fn {ACL_MSG_WRITE_FN} 自定义日志记录函数\n * @param ctx {void*} 自定义参数\n */\nACL_API void acl_msg_register(ACL_MSG_OPEN_FN open_fn, ACL_MSG_CLOSE_FN close_fn,\n        ACL_MSG_WRITE_FN write_fn, void *ctx);\n```\n\n调用此函数后，以后的日志记录过程（即当用户调用：acl_msg_xxx 相关过程时）的内容便输出便由用户的日志库控制。\n\n除了以上主要的日志函数接口，在 acl_msg 中还提供了以下几个函数，便于用户知晓程序出错原因：\n\n```c++\n/**\n * 获得上次系统调用出错时的错误描述信息，该函数内部采用了线程局部变量，所以是线程\n * 安全的，但使用起来更简单些\n * @return {const char *} 返回错误提示信息 \n */\nACL_API const char *acl_last_serror(void);\n\n/**\n * 获得上次系统调用出错时的错误号\n * @return {int} 错误号\n */\nACL_API int acl_last_error(void);\n```\n\n## 三、acl_debug.c/acl_debug.h\n该日志函数库是在 acl_msg 之上的再一次封装，该库的思想来源于 squid 的日志记录方式，可以将日志分成不同的类别，每一个类别又分成不同的级别，这样用户就可以非常方便地通过配置文件来记录不同类别的不同级别的日志信息了。在程序初始化时需先调用如此函数：\n\n```c++\n/**\n * 初始化日志调试调用接口\n * @param pStr {const char*} 调试类别（建议值在100至1000之间）标签及级别字符串，\n *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...\n */\nACL_API void acl_debug_init(const char *pStr);\n\n/**\n * 初始化日志调试调用接口\n * @param pStr {const char*} 调试标签及级别字符串，\n *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...\n * @param max_debug_level {int} 最大调试标签值\n */\nACL_API void acl_debug_init2(const char *pStr, int max_debug_level);\n```\n\n其中，第一个参数是一个由日志记录类别与级别组成的字符串，格式为：类别1:最大记录级别, 类别2:最大记录级别, ...。例如：100:2; 102:3; 103:4，其含义是日志将会记录类别为 100 的所有级别值小于2、类别为 101 的所有级别值小于 3 以及类别为 103 的所有级别值小于 4 的日志信息。关于记录类别需要注意：类别值最好是 >= 100，且 < 1000（当使用 acl_debug_init2 初始化时只要类别值 >= 100 即可，因为第二个参数指定了最大类别值），这是因为 acl 库内部一些保留的类别值都在 0 -- 100 之间。\n\n那么具体的使用这些类别与级别记录日志的接口是什么呢？如下所示：\n\n```c++\n/**\n * 日志调试宏接口\n * @param SECTION {int} 调试标签值\n * @param LEVEL {int} 对应于SECTION调试标签的级别\n */\n#define acl_debug(SECTION, LEVEL) \\\n\t!acl_do_debug((SECTION), (LEVEL)) ? (void) 0 : acl_msg_info\n\n        看到了吧，用户其实只需要调用一个宏即可，如下面的例子： \n\n\t/* 初始化日志类别记录 */\n\tconst char *str = \"101:2; 103:4; 105:3\";\n\t/* 记录所有类别值为 101 级别小于等于 2、类别值为 102 级别小于等于 4、类别值为 105 级别小于等于 3 的日志内容 */\n\tacl_debug_init(str);\n\n\t......\n\t/* 下面的日志因符合类别值 101 级别值 <= 2 而被记录 */\n\tacl_debug(101, 2)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\n\t/* 下面日志符合类别 105 的记录级别 */\n\tacl_debug(105, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\n\t/* 下面的日志因不符合类别值 103 的记录级别条件而被忽略 */\n\tacl_debug(103, 5)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\n\t/* 下面日志的类别值 102 因不存在而被忽略 */\n\tacl_debug(102, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n```\n\n此外，为了方便，还可以传给 acl_debug_init 的参数写为：\"all:1\"，意思是所有类别的级别值 <= 1 的日志都将被记录，如下面的内容都会被记录：\n\n```\n\tacl_debug_init(\"all:1\");\n......\n\tacl_debug(100, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(101, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(101, 0)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(102, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(103, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(104, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n\tacl_debug(105, 1)(\"%s(%d): log time: %ld\", __FILE__, __LINE__, time(NULL));\n        ......\n```\n\nok，有关日志  acl 日志记录函数就先写这些，使用者可以根据项目需要采用不同的日志记录方式。\n\ngithub 地址：https://github.com/acl-dev/acl\ngitee 地址：https://gitee.com/acl-dev/acl\n \n\n","slug":"log","published":1,"updated":"2023-01-24T08:01:26.620Z","_id":"cld9y3v0m000l7x9kasrkfao0","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在使用 acl 库编写应用过程中，记录日志是一个非常重要的过程，acl 从几个层面提供了日志的不同记录方式。在 acl 的 C 库部分(lib_acl.a)，有三个源文件与日志记录相关：acl_msg.c&#x2F;acl_msg.h, acl_mylog.c&#x2F;acl_mylog.h, acl_debug.c&#x2F;acl_debug.h。其中，acl_mylog.c 是真正记录日志的源文件，acl_msg.c 则是在 acl_mylog.c 基础之上的二次封装，acl_debug.c 是在 acl_msg.c 基础之上的再次封装。下面根据此三个日志源文件从三个层次描述日志记录的过程。</p>\n<h2 id=\"一、ac-mylog-c-x2F-acl-mylog-h\"><a href=\"#一、ac-mylog-c-x2F-acl-mylog-h\" class=\"headerlink\" title=\"一、ac_mylog.c&#x2F;acl_mylog.h\"></a>一、ac_mylog.c&#x2F;acl_mylog.h</h2><p>打开 acl_mylog.h 头文件，可以看到主要有三个函数：acl_open_log（打开日志文件），acl_write_to_log（写日志）以及acl_close_log（关闭日志）—（这三个函数是最基础的日志记录过程，当然我们不必直接使用）。该库支持两类日志记录方式：1、本地文件记录方式，2、与 syslog-ng 结合的网络日志记录方式。本地文件记录方式是 acl 日志库对外提供的最简单的日志记录方式，此方式不依赖于第三方日志库，但不应用在生产环境中，因为该方式不支持日志回滚等高级特性，为了便于生产上使用，所以产生了第二种方式（与 syslog-ng 结合），查看日志打开接口（如下）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打开日志文件</span><br><span class=\"hljs-comment\"> * @param recipients &#123;const char*&#125; 日志接收器列表，由 &quot;|&quot; 分隔，接收器</span><br><span class=\"hljs-comment\"> *  可以是本地文件或远程套接口，如:</span><br><span class=\"hljs-comment\"> *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock</span><br><span class=\"hljs-comment\"> *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,</span><br><span class=\"hljs-comment\"> *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象</span><br><span class=\"hljs-comment\"> * @param plog_pre &#123;const char*&#125; 日志记录信息前的提示信息，建议用进程</span><br><span class=\"hljs-comment\"> *  名填写此值</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_open_log</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *recipients, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *plog_pre)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>从上面的函数声明可以看出，acl 的日志记录允许同时输出至多个日志管道中（最简单的方式就是直接写入本地磁盘文件：&#x2F;tmp&#x2F;test.log），同时更应看到，其中有三个奇怪的日志文件表达方式：UDP:IP:PORT, TCP:IP:PORT, UNIX:&#x2F;xxx，其实这三种方式均是与 syslog-ng 相关，即分别表示：</p>\n<ul>\n<li>1、以 UDP 方式发送日志至 syslog-ng；</li>\n<li>2、以 TCP 方式发送日志至 syslog-ng；</li>\n<li>3、以 UNIX 域套接字方式发送日志至 syslog-ng。</li>\n</ul>\n<p>因为日志管理是一个非常复杂的过程，所以在 acl 除了提供最简单的日志文件记录外，更建议用户将日志输出至 syslog-ng 中（作者自己的项目也往往是这样做的）。</p>\n<h2 id=\"二、acl-msg-c-x2F-acl-msg-h\"><a href=\"#二、acl-msg-c-x2F-acl-msg-h\" class=\"headerlink\" title=\"二、acl_msg.c&#x2F;acl_msg.h\"></a>二、acl_msg.c&#x2F;acl_msg.h</h2><p>该日志库提供了更为高级的日志记录方法，不仅提供了灵活的日志记录函数，同时还允许用户注册自己的日志记录函数库，该日志库主要函数接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 日志打开函数</span><br><span class=\"hljs-comment\"> * @param log_file &#123;const char*&#125; 日志接收者集合，由 &quot;|&quot; 分隔，接收器</span><br><span class=\"hljs-comment\"> *  可以是本地文件或远程套接口，如:</span><br><span class=\"hljs-comment\"> *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock</span><br><span class=\"hljs-comment\"> *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,</span><br><span class=\"hljs-comment\"> *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象</span><br><span class=\"hljs-comment\"> * @param plog_pre &#123;const char*&#125; 日志记录信息前的提示信息，建议用进程</span><br><span class=\"hljs-comment\"> * @param info_pre &#123;const char*&#125; 日志记录信息前的提示信息</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_open</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *log_file, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *info_pre)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 关闭日志函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_close</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br>       上面是日志打开与关闭的函数，看上去算是相对简单。下面是几个日志记录的函数接口：<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 一般级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_info</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_info</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 警告级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_warn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_warn</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 错误级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_error</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_error</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 致命级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_fatal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_fatal</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 恐慌级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_panic</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_panic</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到，这些函数的使用方式与 printf 类似，另外，在 UNIX 下使用 GCC 编译时前面还有一个修饰符：<strong>attribute</strong>((format(printf,m,n)))，这主要是方便 gcc 编译器针对变参进行语法检查（大家应该知道变参是如此方便灵活而又如此容易出错）。</p>\n<p>为了方便程序开发过程中的调试，下面的函数当用户未调用 acl_msg_open 打开日志而直接使用 acl_msg_xxx 写日志时，决定是否将日志信息输出至屏幕（这个函数应该在程序初始化时调用）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当未调用 acl_msg_open 方式打开日志时，调用了 acl_msg_info/error/fatal/warn</span><br><span class=\"hljs-comment\"> * 的操作，是否允许信息输出至标准输出屏幕上，通过此函数来设置该开关，该开关</span><br><span class=\"hljs-comment\"> * 仅影响是否需要将信息输出至终端屏幕而不影响是否输出至文件中</span><br><span class=\"hljs-comment\"> * @param onoff &#123;int&#125; 非 0 表示允许输出至屏幕</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_stdout_enable</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> onoff)</span></span>;<br><br>       前面曾说过，acl 的日志库还允许用户使用自己的日志记录过程，但要求用户必须在程序初始化时注册自己的日志处理函数，如下：<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在打开日志前调用此函数注册应用自己的日志打开函数、日志关闭函数、日志记录函数</span><br><span class=\"hljs-comment\"> * @param open_fn &#123;ACL_MSG_OPEN_FN&#125; 自定义日志打开函数</span><br><span class=\"hljs-comment\"> * @param close_fn &#123;ACL_MSG_CLOSE_FN&#125; 自定义日志关闭函数</span><br><span class=\"hljs-comment\"> * @param write_fn &#123;ACL_MSG_WRITE_FN&#125; 自定义日志记录函数</span><br><span class=\"hljs-comment\"> * @param ctx &#123;void*&#125; 自定义参数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_register</span><span class=\"hljs-params\">(ACL_MSG_OPEN_FN open_fn, ACL_MSG_CLOSE_FN close_fn,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        ACL_MSG_WRITE_FN write_fn, <span class=\"hljs-type\">void</span> *ctx)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>调用此函数后，以后的日志记录过程（即当用户调用：acl_msg_xxx 相关过程时）的内容便输出便由用户的日志库控制。</p>\n<p>除了以上主要的日志函数接口，在 acl_msg 中还提供了以下几个函数，便于用户知晓程序出错原因：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得上次系统调用出错时的错误描述信息，该函数内部采用了线程局部变量，所以是线程</span><br><span class=\"hljs-comment\"> * 安全的，但使用起来更简单些</span><br><span class=\"hljs-comment\"> * @return &#123;const char *&#125; 返回错误提示信息 </span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *<span class=\"hljs-title\">acl_last_serror</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得上次系统调用出错时的错误号</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 错误号</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_last_error</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、acl-debug-c-x2F-acl-debug-h\"><a href=\"#三、acl-debug-c-x2F-acl-debug-h\" class=\"headerlink\" title=\"三、acl_debug.c&#x2F;acl_debug.h\"></a>三、acl_debug.c&#x2F;acl_debug.h</h2><p>该日志函数库是在 acl_msg 之上的再一次封装，该库的思想来源于 squid 的日志记录方式，可以将日志分成不同的类别，每一个类别又分成不同的级别，这样用户就可以非常方便地通过配置文件来记录不同类别的不同级别的日志信息了。在程序初始化时需先调用如此函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 初始化日志调试调用接口</span><br><span class=\"hljs-comment\"> * @param pStr &#123;const char*&#125; 调试类别（建议值在100至1000之间）标签及级别字符串，</span><br><span class=\"hljs-comment\"> *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_debug_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *pStr)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 初始化日志调试调用接口</span><br><span class=\"hljs-comment\"> * @param pStr &#123;const char*&#125; 调试标签及级别字符串，</span><br><span class=\"hljs-comment\"> *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...</span><br><span class=\"hljs-comment\"> * @param max_debug_level &#123;int&#125; 最大调试标签值</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_debug_init2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *pStr, <span class=\"hljs-type\">int</span> max_debug_level)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>其中，第一个参数是一个由日志记录类别与级别组成的字符串，格式为：类别1:最大记录级别, 类别2:最大记录级别, …。例如：100:2; 102:3; 103:4，其含义是日志将会记录类别为 100 的所有级别值小于2、类别为 101 的所有级别值小于 3 以及类别为 103 的所有级别值小于 4 的日志信息。关于记录类别需要注意：类别值最好是 &gt;&#x3D; 100，且 &lt; 1000（当使用 acl_debug_init2 初始化时只要类别值 &gt;&#x3D; 100 即可，因为第二个参数指定了最大类别值），这是因为 acl 库内部一些保留的类别值都在 0 – 100 之间。</p>\n<p>那么具体的使用这些类别与级别记录日志的接口是什么呢？如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 日志调试宏接口</span><br><span class=\"hljs-comment\"> * @param SECTION &#123;int&#125; 调试标签值</span><br><span class=\"hljs-comment\"> * @param LEVEL &#123;int&#125; 对应于SECTION调试标签的级别</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> acl_debug(SECTION, LEVEL) \\</span><br><span class=\"hljs-meta\">\t!acl_do_debug((SECTION), (LEVEL)) ? (void) 0 : acl_msg_info</span><br><br>        看到了吧，用户其实只需要调用一个宏即可，如下面的例子： <br><br>\t<span class=\"hljs-comment\">/* 初始化日志类别记录 */</span><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *str = <span class=\"hljs-string\">&quot;101:2; 103:4; 105:3&quot;</span>;<br>\t<span class=\"hljs-comment\">/* 记录所有类别值为 101 级别小于等于 2、类别值为 102 级别小于等于 4、类别值为 105 级别小于等于 3 的日志内容 */</span><br>\t<span class=\"hljs-built_in\">acl_debug_init</span>(str);<br><br>\t......<br>\t<span class=\"hljs-comment\">/* 下面的日志因符合类别值 101 级别值 &lt;= 2 而被记录 */</span><br>\t<span class=\"hljs-built_in\">acl_debug</span>(<span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">2</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>));<br><br>\t<span class=\"hljs-comment\">/* 下面日志符合类别 105 的记录级别 */</span><br>\t<span class=\"hljs-built_in\">acl_debug</span>(<span class=\"hljs-number\">105</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>));<br><br>\t<span class=\"hljs-comment\">/* 下面的日志因不符合类别值 103 的记录级别条件而被忽略 */</span><br>\t<span class=\"hljs-built_in\">acl_debug</span>(<span class=\"hljs-number\">103</span>, <span class=\"hljs-number\">5</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>));<br><br>\t<span class=\"hljs-comment\">/* 下面日志的类别值 102 因不存在而被忽略 */</span><br>\t<span class=\"hljs-built_in\">acl_debug</span>(<span class=\"hljs-number\">102</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>));<br></code></pre></td></tr></table></figure>\n\n<p>此外，为了方便，还可以传给 acl_debug_init 的参数写为：”all:1”，意思是所有类别的级别值 &lt;&#x3D; 1 的日志都将被记录，如下面的内容都会被记录：</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">\tacl_debug_init(<span class=\"hljs-string\">&quot;all:1&quot;</span>);<br>......<br>\tacl_debug(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">0</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">102</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">103</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">104</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">105</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>        ......<br></code></pre></td></tr></table></figure>\n\n<p>ok，有关日志  acl 日志记录函数就先写这些，使用者可以根据项目需要采用不同的日志记录方式。</p>\n<p>github 地址：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee 地址：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在使用 acl 库编写应用过程中，记录日志是一个非常重要的过程，acl 从几个层面提供了日志的不同记录方式。在 acl 的 C 库部分(lib_acl.a)，有三个源文件与日志记录相关：acl_msg.c&#x2F;acl_msg.h, acl_mylog.c&#x2F;acl_mylog.h, acl_debug.c&#x2F;acl_debug.h。其中，acl_mylog.c 是真正记录日志的源文件，acl_msg.c 则是在 acl_mylog.c 基础之上的二次封装，acl_debug.c 是在 acl_msg.c 基础之上的再次封装。下面根据此三个日志源文件从三个层次描述日志记录的过程。</p>\n<h2 id=\"一、ac-mylog-c-x2F-acl-mylog-h\"><a href=\"#一、ac-mylog-c-x2F-acl-mylog-h\" class=\"headerlink\" title=\"一、ac_mylog.c&#x2F;acl_mylog.h\"></a>一、ac_mylog.c&#x2F;acl_mylog.h</h2><p>打开 acl_mylog.h 头文件，可以看到主要有三个函数：acl_open_log（打开日志文件），acl_write_to_log（写日志）以及acl_close_log（关闭日志）—（这三个函数是最基础的日志记录过程，当然我们不必直接使用）。该库支持两类日志记录方式：1、本地文件记录方式，2、与 syslog-ng 结合的网络日志记录方式。本地文件记录方式是 acl 日志库对外提供的最简单的日志记录方式，此方式不依赖于第三方日志库，但不应用在生产环境中，因为该方式不支持日志回滚等高级特性，为了便于生产上使用，所以产生了第二种方式（与 syslog-ng 结合），查看日志打开接口（如下）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打开日志文件</span><br><span class=\"hljs-comment\"> * @param recipients &#123;const char*&#125; 日志接收器列表，由 &quot;|&quot; 分隔，接收器</span><br><span class=\"hljs-comment\"> *  可以是本地文件或远程套接口，如:</span><br><span class=\"hljs-comment\"> *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock</span><br><span class=\"hljs-comment\"> *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,</span><br><span class=\"hljs-comment\"> *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象</span><br><span class=\"hljs-comment\"> * @param plog_pre &#123;const char*&#125; 日志记录信息前的提示信息，建议用进程</span><br><span class=\"hljs-comment\"> *  名填写此值</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_open_log</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *recipients, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *plog_pre)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>从上面的函数声明可以看出，acl 的日志记录允许同时输出至多个日志管道中（最简单的方式就是直接写入本地磁盘文件：&#x2F;tmp&#x2F;test.log），同时更应看到，其中有三个奇怪的日志文件表达方式：UDP:IP:PORT, TCP:IP:PORT, UNIX:&#x2F;xxx，其实这三种方式均是与 syslog-ng 相关，即分别表示：</p>\n<ul>\n<li>1、以 UDP 方式发送日志至 syslog-ng；</li>\n<li>2、以 TCP 方式发送日志至 syslog-ng；</li>\n<li>3、以 UNIX 域套接字方式发送日志至 syslog-ng。</li>\n</ul>\n<p>因为日志管理是一个非常复杂的过程，所以在 acl 除了提供最简单的日志文件记录外，更建议用户将日志输出至 syslog-ng 中（作者自己的项目也往往是这样做的）。</p>\n<h2 id=\"二、acl-msg-c-x2F-acl-msg-h\"><a href=\"#二、acl-msg-c-x2F-acl-msg-h\" class=\"headerlink\" title=\"二、acl_msg.c&#x2F;acl_msg.h\"></a>二、acl_msg.c&#x2F;acl_msg.h</h2><p>该日志库提供了更为高级的日志记录方法，不仅提供了灵活的日志记录函数，同时还允许用户注册自己的日志记录函数库，该日志库主要函数接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 日志打开函数</span><br><span class=\"hljs-comment\"> * @param log_file &#123;const char*&#125; 日志接收者集合，由 &quot;|&quot; 分隔，接收器</span><br><span class=\"hljs-comment\"> *  可以是本地文件或远程套接口，如:</span><br><span class=\"hljs-comment\"> *  /tmp/test.log|UDP:127.0.0.1:12345|TCP:127.0.0.1:12345|UNIX:/tmp/test.sock</span><br><span class=\"hljs-comment\"> *  该配置要求将所有日志同时发给 /tmp/test.log, UDP:127.0.0.1:12345,</span><br><span class=\"hljs-comment\"> *  TCP:127.0.0.1:12345 和 UNIX:/tmp/test.sock 四个日志接收器对象</span><br><span class=\"hljs-comment\"> * @param plog_pre &#123;const char*&#125; 日志记录信息前的提示信息，建议用进程</span><br><span class=\"hljs-comment\"> * @param info_pre &#123;const char*&#125; 日志记录信息前的提示信息</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_open</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *log_file, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *info_pre)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 关闭日志函数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_close</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br>       上面是日志打开与关闭的函数，看上去算是相对简单。下面是几个日志记录的函数接口：<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 一般级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_info</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_info</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 警告级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_warn</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_warn</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 错误级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_error</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_error</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 致命级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_fatal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_fatal</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 恐慌级别日志信息记录函数</span><br><span class=\"hljs-comment\"> * @param fmt &#123;const char*&#125; 参数格式</span><br><span class=\"hljs-comment\"> * @param ... 变参序列</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span>\tWIN32</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_panic</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...)</span></span>;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">else</span></span><br>ACL_API <span class=\"hljs-type\">void</span> __attribute__((format(printf,<span class=\"hljs-number\">1</span>,<span class=\"hljs-number\">2</span>)))<br>\t<span class=\"hljs-built_in\">acl_msg_panic</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *fmt,...);<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br></code></pre></td></tr></table></figure>\n\n<p>可以看到，这些函数的使用方式与 printf 类似，另外，在 UNIX 下使用 GCC 编译时前面还有一个修饰符：<strong>attribute</strong>((format(printf,m,n)))，这主要是方便 gcc 编译器针对变参进行语法检查（大家应该知道变参是如此方便灵活而又如此容易出错）。</p>\n<p>为了方便程序开发过程中的调试，下面的函数当用户未调用 acl_msg_open 打开日志而直接使用 acl_msg_xxx 写日志时，决定是否将日志信息输出至屏幕（这个函数应该在程序初始化时调用）：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当未调用 acl_msg_open 方式打开日志时，调用了 acl_msg_info/error/fatal/warn</span><br><span class=\"hljs-comment\"> * 的操作，是否允许信息输出至标准输出屏幕上，通过此函数来设置该开关，该开关</span><br><span class=\"hljs-comment\"> * 仅影响是否需要将信息输出至终端屏幕而不影响是否输出至文件中</span><br><span class=\"hljs-comment\"> * @param onoff &#123;int&#125; 非 0 表示允许输出至屏幕</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_stdout_enable</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> onoff)</span></span>;<br><br>       前面曾说过，acl 的日志库还允许用户使用自己的日志记录过程，但要求用户必须在程序初始化时注册自己的日志处理函数，如下：<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在打开日志前调用此函数注册应用自己的日志打开函数、日志关闭函数、日志记录函数</span><br><span class=\"hljs-comment\"> * @param open_fn &#123;ACL_MSG_OPEN_FN&#125; 自定义日志打开函数</span><br><span class=\"hljs-comment\"> * @param close_fn &#123;ACL_MSG_CLOSE_FN&#125; 自定义日志关闭函数</span><br><span class=\"hljs-comment\"> * @param write_fn &#123;ACL_MSG_WRITE_FN&#125; 自定义日志记录函数</span><br><span class=\"hljs-comment\"> * @param ctx &#123;void*&#125; 自定义参数</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_msg_register</span><span class=\"hljs-params\">(ACL_MSG_OPEN_FN open_fn, ACL_MSG_CLOSE_FN close_fn,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">        ACL_MSG_WRITE_FN write_fn, <span class=\"hljs-type\">void</span> *ctx)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>调用此函数后，以后的日志记录过程（即当用户调用：acl_msg_xxx 相关过程时）的内容便输出便由用户的日志库控制。</p>\n<p>除了以上主要的日志函数接口，在 acl_msg 中还提供了以下几个函数，便于用户知晓程序出错原因：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得上次系统调用出错时的错误描述信息，该函数内部采用了线程局部变量，所以是线程</span><br><span class=\"hljs-comment\"> * 安全的，但使用起来更简单些</span><br><span class=\"hljs-comment\"> * @return &#123;const char *&#125; 返回错误提示信息 </span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *<span class=\"hljs-title\">acl_last_serror</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得上次系统调用出错时的错误号</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 错误号</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">int</span> <span class=\"hljs-title\">acl_last_error</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、acl-debug-c-x2F-acl-debug-h\"><a href=\"#三、acl-debug-c-x2F-acl-debug-h\" class=\"headerlink\" title=\"三、acl_debug.c&#x2F;acl_debug.h\"></a>三、acl_debug.c&#x2F;acl_debug.h</h2><p>该日志函数库是在 acl_msg 之上的再一次封装，该库的思想来源于 squid 的日志记录方式，可以将日志分成不同的类别，每一个类别又分成不同的级别，这样用户就可以非常方便地通过配置文件来记录不同类别的不同级别的日志信息了。在程序初始化时需先调用如此函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 初始化日志调试调用接口</span><br><span class=\"hljs-comment\"> * @param pStr &#123;const char*&#125; 调试类别（建议值在100至1000之间）标签及级别字符串，</span><br><span class=\"hljs-comment\"> *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_debug_init</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *pStr)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 初始化日志调试调用接口</span><br><span class=\"hljs-comment\"> * @param pStr &#123;const char*&#125; 调试标签及级别字符串，</span><br><span class=\"hljs-comment\"> *  格式: 1,1; 2,10; 3,8...  or 1:1; 2:10; 3:8...</span><br><span class=\"hljs-comment\"> * @param max_debug_level &#123;int&#125; 最大调试标签值</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">ACL_API <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">acl_debug_init2</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *pStr, <span class=\"hljs-type\">int</span> max_debug_level)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>其中，第一个参数是一个由日志记录类别与级别组成的字符串，格式为：类别1:最大记录级别, 类别2:最大记录级别, …。例如：100:2; 102:3; 103:4，其含义是日志将会记录类别为 100 的所有级别值小于2、类别为 101 的所有级别值小于 3 以及类别为 103 的所有级别值小于 4 的日志信息。关于记录类别需要注意：类别值最好是 &gt;&#x3D; 100，且 &lt; 1000（当使用 acl_debug_init2 初始化时只要类别值 &gt;&#x3D; 100 即可，因为第二个参数指定了最大类别值），这是因为 acl 库内部一些保留的类别值都在 0 – 100 之间。</p>\n<p>那么具体的使用这些类别与级别记录日志的接口是什么呢？如下所示：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 日志调试宏接口</span><br><span class=\"hljs-comment\"> * @param SECTION &#123;int&#125; 调试标签值</span><br><span class=\"hljs-comment\"> * @param LEVEL &#123;int&#125; 对应于SECTION调试标签的级别</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span> acl_debug(SECTION, LEVEL) \\</span><br><span class=\"hljs-meta\">\t!acl_do_debug((SECTION), (LEVEL)) ? (void) 0 : acl_msg_info</span><br><br>        看到了吧，用户其实只需要调用一个宏即可，如下面的例子： <br><br>\t<span class=\"hljs-comment\">/* 初始化日志类别记录 */</span><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *str = <span class=\"hljs-string\">&quot;101:2; 103:4; 105:3&quot;</span>;<br>\t<span class=\"hljs-comment\">/* 记录所有类别值为 101 级别小于等于 2、类别值为 102 级别小于等于 4、类别值为 105 级别小于等于 3 的日志内容 */</span><br>\t<span class=\"hljs-built_in\">acl_debug_init</span>(str);<br><br>\t......<br>\t<span class=\"hljs-comment\">/* 下面的日志因符合类别值 101 级别值 &lt;= 2 而被记录 */</span><br>\t<span class=\"hljs-built_in\">acl_debug</span>(<span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">2</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>));<br><br>\t<span class=\"hljs-comment\">/* 下面日志符合类别 105 的记录级别 */</span><br>\t<span class=\"hljs-built_in\">acl_debug</span>(<span class=\"hljs-number\">105</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>));<br><br>\t<span class=\"hljs-comment\">/* 下面的日志因不符合类别值 103 的记录级别条件而被忽略 */</span><br>\t<span class=\"hljs-built_in\">acl_debug</span>(<span class=\"hljs-number\">103</span>, <span class=\"hljs-number\">5</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>));<br><br>\t<span class=\"hljs-comment\">/* 下面日志的类别值 102 因不存在而被忽略 */</span><br>\t<span class=\"hljs-built_in\">acl_debug</span>(<span class=\"hljs-number\">102</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE__, __LINE__, <span class=\"hljs-built_in\">time</span>(<span class=\"hljs-literal\">NULL</span>));<br></code></pre></td></tr></table></figure>\n\n<p>此外，为了方便，还可以传给 acl_debug_init 的参数写为：”all:1”，意思是所有类别的级别值 &lt;&#x3D; 1 的日志都将被记录，如下面的内容都会被记录：</p>\n<figure class=\"highlight perl\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs perl\">\tacl_debug_init(<span class=\"hljs-string\">&quot;all:1&quot;</span>);<br>......<br>\tacl_debug(<span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">101</span>, <span class=\"hljs-number\">0</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">102</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">103</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">104</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>\tacl_debug(<span class=\"hljs-number\">105</span>, <span class=\"hljs-number\">1</span>)(<span class=\"hljs-string\">&quot;%s(%d): log time: %ld&quot;</span>, __FILE_<span class=\"hljs-number\">_</span>, __LINE_<span class=\"hljs-number\">_</span>, <span class=\"hljs-keyword\">time</span>(NULL));<br>        ......<br></code></pre></td></tr></table></figure>\n\n<p>ok，有关日志  acl 日志记录函数就先写这些，使用者可以根据项目需要采用不同的日志记录方式。</p>\n<p>github 地址：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee 地址：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"线程池设计中的惊群问题","date":"2014-03-08T16:30:00.000Z","_content":"\n多线程编程已经是现在网络编程中常用的编程技术，设计一个良好的线程池库显得尤为重要。在 UNIX（WIN32下可以采用类似的方法，acl 库中的线程池是跨平台的） 环境下设计线程池库主要是如何用好如下系统 API：\n\n- 1、pthread_cond_signal/pthread_cond_broadcast：生产者线程通知线程池中的某个或一些消费者线程池，接收处理任务；\n- 2、pthread_cond_wait：线程池中的消费者线程等待线程条件变量被通知；\n- 3、pthread_mutex_lock/pthread_mutex_unlock：线程互斥锁的加锁及解锁函数。\n\n下面的代码示例是大家常见的线程池的设计方式：\n\n```c\n// 线程任务类型定义\nstruct thread_job {\n\tstruct thread_job *next;  // 指向下一个线程任务\n\tvoid (*func)(void*);      // 应用回调处理函数 \n\tvoid *arg;                // 回调函数的参数\n\t...\n};\n\n// 线程池类型定义\nstruct thread_pool {\n\tint   max_threads;        // 线程池中最大线程数限制\n\tint   curr_threads;       // 当前线程池中总的线程数\n\tint   idle_threads;       // 当前线程池中空闲的线程数\n\tpthread_mutex_t mutex;    // 线程互斥锁\n\tpthread_cond_t  cond;     // 线程条件变量\n\tthread_job *first;        // 线程任务链表的表头\n\tthread_job *last;         // 线程任务链表的表尾\n\t...\t\n}\n\n// 线程池中的消费者线程处理过程\nstatic void *consumer_thread(void *arg)\n{\n\tstruct thread_pool *pool = (struct thread_pool*) arg;\n\tstruct thread_job  *job;\n\tint   status;\n\n\t// 该消费者线程需要先加锁\n\tpthread_mutex_lock(&pool->mutex);\n\n\twhile (1) {\n\t\tif (pool->first != NULL) {\n\t\t\t// 有线程任务时，则取出并在下面进行处理\n\t\t\tjob = pool->first;\n\t\t\tpool->first = job->next;\n\t\t\tif (pool->last == job)\n\t\t\t\tpool->last = NULL;\n\n\t\t\t// 解锁，允许其它消费者线程加锁或生产者线程添加新的任务\n\t\t\tpthread_mutex_unlock(&pool->mutex);\n\n\t\t\t// 回调应用的处理函数\n\t\t\tjob->func(job->arg);\n\n\t\t\t// 释放动态分配的内存\n\t\t\tfree(job);\n\n\t\t\t// 重新去加锁\n\t\t\tpthread_mutex_lock(&pool->mutex);\n\t\t} else {\n\t\t\tpool->idle_threads++;\n\n\t\t\t// 在调用 pthread_cond_wait 等待线程条件变量被通知且自动解锁\n\t\t\tstatus = pthread_cond_wait(&pool->cond, &pool->mutex);\n\n\t\t\tpool->idle_threads--;\n\n\t\t\tif (status == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// 等待线程条件变量异常，则该线程需要退出\n\t\t\tpool->curr_threads--;\n\t\t\tpthread_mutex_unlock(&pool->mutex);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n// 生产者线程调用此函数添加新的处理任务\nvoid add_thread_job(struct thread_pool *pool, void (*func)(void*), void *arg)\n{\n\t// 动态分配任务对象\n\tstruct thread_job *job = (struct thread_job*) calloc(1, sizeof(*job));\n\n\tjob->func = func;\n\tjob->arg = arg;\n\n\tpthread_mutex_lock(&pool->mutex);\n\n\t// 将新任务添加进线程池的任务链表中\n\tif (pool->first == NULL)\n\t\tpool->first = job;\n\telse\n\t\tpool->last->next = job;\n\tpool->last = job;\n\tjob->next = NULL;\n\t\n\tif (pool->idle_threads > 0) {\n\t\t// 如果有空闲消费者线程，则通知空闲线程进行处理，同时需要解锁\n\n\t\tpthread_mutex_unlock(&pool->mutex);\n\t\tpthread_cond_signal(&pool->cond);\n\t} else if (pool->curr_threads < pool->max_threads) {\n\t\t// 如果未超过最大线程数限制，则创建一个新的消费者线程\n\n\t\tpthread_t id;\n\t\tpthread_attr_t attr;\n\n\t\tpthread_attr_init(&attr);\n\n\t\t// 将线程属性设为分离模式，这样当线程退出时其资源自动由系统回收\n\t\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\t\t// 创建一个消费者线程\n\t\tif (pthread_create(&id, &attr, consumer_thread, pool) == 0)\n\t\t\tpool->curr_threads++;\n\n\t\tpthread_mutex_unlock(&pool->mutex);\n\t\tpthread_attr_destroy(&attr);\n\t}\n}\n\n// 创建线程池对象\nstruct thread_pool *create_thread_pool(int max_threads)\n{\n\tstruct thread_pool *pool = (struct thread_pool*) calloc(1, sizeof(*pool));\n\t\n\tpool->max_threads = max_threads;\n\tpthread_mutex_init(&pool->mutex);\n\tpthread_cond_init(&pool->cond);\n\t...\n\n\treturn pool;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// 使用上面线程池的示例如下：\n\n// 由消费者线程回调的处理过程\nstatic void thread_callback(void* arg)\n{\n      ...\n}\n\nvoid test(void)\n{\n\tstruct thread_pool *pool = create_thread_pool(100);\n\tint   i;\n\n\t// 循环添加 1000000 次线程处理任务\n\tfor (i = 0; i < 1000000; i++)\n\t\tadd_thread_job(pool, thread_callback, NULL);\n}\n```\n\n乍一看去，似乎也没有什么问题，象很多经典的开源代码中也是这样设计的，但有一个重要问题被忽视了：线程池设计中的惊群现象。大家可以看到，整个线程池只有一个线程条件变量和线程互斥锁，生产者线程和消费者线程（即线程池中的子线程）正是通过这两个变量进行同步的。生产者线程每添加一个新任务，都会调用 pthread_cond_signal 一次，由操作系统唤醒一个在线程条件变量等待的消费者线程，但如果查看 pthread_cond_signal API 的系统帮助，你会发现其中有一句话：调用此函数后，系统会唤醒在相同条件变量上等待的一个或多个线程。而正是这句模棱两可的话没有引起很多线程池设计者的注意，这也是整个线程池中消费者线程收到信号通知后产生惊群现象的根源所在，并且是消费者线程数量越多，惊群现象越严重----意味着 CPU 占用越高，线程池的调度性能越低。\n\n要想避免如上线程池设计中的惊群问题，在仍然共用一个线程互斥锁的条件下，给每一个消费者线程创建一个线程条件变量，生产者线程在添加任务时，找到空闲的消费者线程，将任务置入该消费者的任务队列中同时只通知 (pthread_cond_signal) 该消费者的线程条件变量，消费者线程与生产者线程虽然共用相同的线程互斥锁（因为有全局资源及调用 pthread_cond_wait 所需），但线程条件变量的通知过程却是定向通知的，未被通知的消费者线程不会被唤醒，这样惊群现象也就不会产生了。\n\n当然，还有一些设计上的细节需要注意，比如：当没有空闲消费者线程时，需要将任务添加进线程池的全局任务队列中，消费者线程处理完自己的任务后需要查看一下线程池中的全局任务队列中是否还有未处理的任务。\n\n更多的线程池的设计细节请参考 acl (https://sourceforge.net/projects/acl/) 库中 lib_acl/src/thread/acl_pthread_pool.c 中的代码。\n\ngithub：https://github.com/acl-dev/acl\ngitee： https://github.com/acl-dev/acl","source":"_posts/threads_shock.md","raw":"---\ntitle: 线程池设计中的惊群问题\ndate: 2014-03-09 00:30\ncategories: 线程编程\n---\n\n多线程编程已经是现在网络编程中常用的编程技术，设计一个良好的线程池库显得尤为重要。在 UNIX（WIN32下可以采用类似的方法，acl 库中的线程池是跨平台的） 环境下设计线程池库主要是如何用好如下系统 API：\n\n- 1、pthread_cond_signal/pthread_cond_broadcast：生产者线程通知线程池中的某个或一些消费者线程池，接收处理任务；\n- 2、pthread_cond_wait：线程池中的消费者线程等待线程条件变量被通知；\n- 3、pthread_mutex_lock/pthread_mutex_unlock：线程互斥锁的加锁及解锁函数。\n\n下面的代码示例是大家常见的线程池的设计方式：\n\n```c\n// 线程任务类型定义\nstruct thread_job {\n\tstruct thread_job *next;  // 指向下一个线程任务\n\tvoid (*func)(void*);      // 应用回调处理函数 \n\tvoid *arg;                // 回调函数的参数\n\t...\n};\n\n// 线程池类型定义\nstruct thread_pool {\n\tint   max_threads;        // 线程池中最大线程数限制\n\tint   curr_threads;       // 当前线程池中总的线程数\n\tint   idle_threads;       // 当前线程池中空闲的线程数\n\tpthread_mutex_t mutex;    // 线程互斥锁\n\tpthread_cond_t  cond;     // 线程条件变量\n\tthread_job *first;        // 线程任务链表的表头\n\tthread_job *last;         // 线程任务链表的表尾\n\t...\t\n}\n\n// 线程池中的消费者线程处理过程\nstatic void *consumer_thread(void *arg)\n{\n\tstruct thread_pool *pool = (struct thread_pool*) arg;\n\tstruct thread_job  *job;\n\tint   status;\n\n\t// 该消费者线程需要先加锁\n\tpthread_mutex_lock(&pool->mutex);\n\n\twhile (1) {\n\t\tif (pool->first != NULL) {\n\t\t\t// 有线程任务时，则取出并在下面进行处理\n\t\t\tjob = pool->first;\n\t\t\tpool->first = job->next;\n\t\t\tif (pool->last == job)\n\t\t\t\tpool->last = NULL;\n\n\t\t\t// 解锁，允许其它消费者线程加锁或生产者线程添加新的任务\n\t\t\tpthread_mutex_unlock(&pool->mutex);\n\n\t\t\t// 回调应用的处理函数\n\t\t\tjob->func(job->arg);\n\n\t\t\t// 释放动态分配的内存\n\t\t\tfree(job);\n\n\t\t\t// 重新去加锁\n\t\t\tpthread_mutex_lock(&pool->mutex);\n\t\t} else {\n\t\t\tpool->idle_threads++;\n\n\t\t\t// 在调用 pthread_cond_wait 等待线程条件变量被通知且自动解锁\n\t\t\tstatus = pthread_cond_wait(&pool->cond, &pool->mutex);\n\n\t\t\tpool->idle_threads--;\n\n\t\t\tif (status == 0)\n\t\t\t\tcontinue;\n\n\t\t\t// 等待线程条件变量异常，则该线程需要退出\n\t\t\tpool->curr_threads--;\n\t\t\tpthread_mutex_unlock(&pool->mutex);\n\t\t\tbreak;\n\t\t}\n\t}\n\n\treturn NULL;\n}\n\n// 生产者线程调用此函数添加新的处理任务\nvoid add_thread_job(struct thread_pool *pool, void (*func)(void*), void *arg)\n{\n\t// 动态分配任务对象\n\tstruct thread_job *job = (struct thread_job*) calloc(1, sizeof(*job));\n\n\tjob->func = func;\n\tjob->arg = arg;\n\n\tpthread_mutex_lock(&pool->mutex);\n\n\t// 将新任务添加进线程池的任务链表中\n\tif (pool->first == NULL)\n\t\tpool->first = job;\n\telse\n\t\tpool->last->next = job;\n\tpool->last = job;\n\tjob->next = NULL;\n\t\n\tif (pool->idle_threads > 0) {\n\t\t// 如果有空闲消费者线程，则通知空闲线程进行处理，同时需要解锁\n\n\t\tpthread_mutex_unlock(&pool->mutex);\n\t\tpthread_cond_signal(&pool->cond);\n\t} else if (pool->curr_threads < pool->max_threads) {\n\t\t// 如果未超过最大线程数限制，则创建一个新的消费者线程\n\n\t\tpthread_t id;\n\t\tpthread_attr_t attr;\n\n\t\tpthread_attr_init(&attr);\n\n\t\t// 将线程属性设为分离模式，这样当线程退出时其资源自动由系统回收\n\t\tpthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);\n\n\t\t// 创建一个消费者线程\n\t\tif (pthread_create(&id, &attr, consumer_thread, pool) == 0)\n\t\t\tpool->curr_threads++;\n\n\t\tpthread_mutex_unlock(&pool->mutex);\n\t\tpthread_attr_destroy(&attr);\n\t}\n}\n\n// 创建线程池对象\nstruct thread_pool *create_thread_pool(int max_threads)\n{\n\tstruct thread_pool *pool = (struct thread_pool*) calloc(1, sizeof(*pool));\n\t\n\tpool->max_threads = max_threads;\n\tpthread_mutex_init(&pool->mutex);\n\tpthread_cond_init(&pool->cond);\n\t...\n\n\treturn pool;\n}\n\n///////////////////////////////////////////////////////////////////////////////////\n// 使用上面线程池的示例如下：\n\n// 由消费者线程回调的处理过程\nstatic void thread_callback(void* arg)\n{\n      ...\n}\n\nvoid test(void)\n{\n\tstruct thread_pool *pool = create_thread_pool(100);\n\tint   i;\n\n\t// 循环添加 1000000 次线程处理任务\n\tfor (i = 0; i < 1000000; i++)\n\t\tadd_thread_job(pool, thread_callback, NULL);\n}\n```\n\n乍一看去，似乎也没有什么问题，象很多经典的开源代码中也是这样设计的，但有一个重要问题被忽视了：线程池设计中的惊群现象。大家可以看到，整个线程池只有一个线程条件变量和线程互斥锁，生产者线程和消费者线程（即线程池中的子线程）正是通过这两个变量进行同步的。生产者线程每添加一个新任务，都会调用 pthread_cond_signal 一次，由操作系统唤醒一个在线程条件变量等待的消费者线程，但如果查看 pthread_cond_signal API 的系统帮助，你会发现其中有一句话：调用此函数后，系统会唤醒在相同条件变量上等待的一个或多个线程。而正是这句模棱两可的话没有引起很多线程池设计者的注意，这也是整个线程池中消费者线程收到信号通知后产生惊群现象的根源所在，并且是消费者线程数量越多，惊群现象越严重----意味着 CPU 占用越高，线程池的调度性能越低。\n\n要想避免如上线程池设计中的惊群问题，在仍然共用一个线程互斥锁的条件下，给每一个消费者线程创建一个线程条件变量，生产者线程在添加任务时，找到空闲的消费者线程，将任务置入该消费者的任务队列中同时只通知 (pthread_cond_signal) 该消费者的线程条件变量，消费者线程与生产者线程虽然共用相同的线程互斥锁（因为有全局资源及调用 pthread_cond_wait 所需），但线程条件变量的通知过程却是定向通知的，未被通知的消费者线程不会被唤醒，这样惊群现象也就不会产生了。\n\n当然，还有一些设计上的细节需要注意，比如：当没有空闲消费者线程时，需要将任务添加进线程池的全局任务队列中，消费者线程处理完自己的任务后需要查看一下线程池中的全局任务队列中是否还有未处理的任务。\n\n更多的线程池的设计细节请参考 acl (https://sourceforge.net/projects/acl/) 库中 lib_acl/src/thread/acl_pthread_pool.c 中的代码。\n\ngithub：https://github.com/acl-dev/acl\ngitee： https://github.com/acl-dev/acl","slug":"threads_shock","published":1,"updated":"2023-01-24T08:12:56.295Z","_id":"cld9yjrsq000o7x9k0npw0m9b","comments":1,"layout":"post","photos":[],"link":"","content":"<p>多线程编程已经是现在网络编程中常用的编程技术，设计一个良好的线程池库显得尤为重要。在 UNIX（WIN32下可以采用类似的方法，acl 库中的线程池是跨平台的） 环境下设计线程池库主要是如何用好如下系统 API：</p>\n<ul>\n<li>1、pthread_cond_signal&#x2F;pthread_cond_broadcast：生产者线程通知线程池中的某个或一些消费者线程池，接收处理任务；</li>\n<li>2、pthread_cond_wait：线程池中的消费者线程等待线程条件变量被通知；</li>\n<li>3、pthread_mutex_lock&#x2F;pthread_mutex_unlock：线程互斥锁的加锁及解锁函数。</li>\n</ul>\n<p>下面的代码示例是大家常见的线程池的设计方式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 线程任务类型定义</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_job</span> &#123;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_job</span> *<span class=\"hljs-title\">next</span>;</span>  <span class=\"hljs-comment\">// 指向下一个线程任务</span><br>\t<span class=\"hljs-type\">void</span> (*func)(<span class=\"hljs-type\">void</span>*);      <span class=\"hljs-comment\">// 应用回调处理函数 </span><br>\t<span class=\"hljs-type\">void</span> *arg;                <span class=\"hljs-comment\">// 回调函数的参数</span><br>\t...<br>&#125;;<br><br><span class=\"hljs-comment\">// 线程池类型定义</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_pool</span> &#123;</span><br>\t<span class=\"hljs-type\">int</span>   max_threads;        <span class=\"hljs-comment\">// 线程池中最大线程数限制</span><br>\t<span class=\"hljs-type\">int</span>   curr_threads;       <span class=\"hljs-comment\">// 当前线程池中总的线程数</span><br>\t<span class=\"hljs-type\">int</span>   idle_threads;       <span class=\"hljs-comment\">// 当前线程池中空闲的线程数</span><br>\t<span class=\"hljs-type\">pthread_mutex_t</span> mutex;    <span class=\"hljs-comment\">// 线程互斥锁</span><br>\t<span class=\"hljs-type\">pthread_cond_t</span>  cond;     <span class=\"hljs-comment\">// 线程条件变量</span><br>\tthread_job *first;        <span class=\"hljs-comment\">// 线程任务链表的表头</span><br>\tthread_job *last;         <span class=\"hljs-comment\">// 线程任务链表的表尾</span><br>\t...\t<br>&#125;<br><br><span class=\"hljs-comment\">// 线程池中的消费者线程处理过程</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> *<span class=\"hljs-title function_\">consumer_thread</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span><br>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_pool</span> *<span class=\"hljs-title\">pool</span> =</span> (<span class=\"hljs-keyword\">struct</span> thread_pool*) arg;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_job</span>  *<span class=\"hljs-title\">job</span>;</span><br>\t<span class=\"hljs-type\">int</span>   status;<br><br>\t<span class=\"hljs-comment\">// 该消费者线程需要先加锁</span><br>\tpthread_mutex_lock(&amp;pool-&gt;mutex);<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (pool-&gt;first != <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 有线程任务时，则取出并在下面进行处理</span><br>\t\t\tjob = pool-&gt;first;<br>\t\t\tpool-&gt;first = job-&gt;next;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (pool-&gt;last == job)<br>\t\t\t\tpool-&gt;last = <span class=\"hljs-literal\">NULL</span>;<br><br>\t\t\t<span class=\"hljs-comment\">// 解锁，允许其它消费者线程加锁或生产者线程添加新的任务</span><br>\t\t\tpthread_mutex_unlock(&amp;pool-&gt;mutex);<br><br>\t\t\t<span class=\"hljs-comment\">// 回调应用的处理函数</span><br>\t\t\tjob-&gt;func(job-&gt;arg);<br><br>\t\t\t<span class=\"hljs-comment\">// 释放动态分配的内存</span><br>\t\t\t<span class=\"hljs-built_in\">free</span>(job);<br><br>\t\t\t<span class=\"hljs-comment\">// 重新去加锁</span><br>\t\t\tpthread_mutex_lock(&amp;pool-&gt;mutex);<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tpool-&gt;idle_threads++;<br><br>\t\t\t<span class=\"hljs-comment\">// 在调用 pthread_cond_wait 等待线程条件变量被通知且自动解锁</span><br>\t\t\tstatus = pthread_cond_wait(&amp;pool-&gt;cond, &amp;pool-&gt;mutex);<br><br>\t\t\tpool-&gt;idle_threads--;<br><br>\t\t\t<span class=\"hljs-keyword\">if</span> (status == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span>;<br><br>\t\t\t<span class=\"hljs-comment\">// 等待线程条件变量异常，则该线程需要退出</span><br>\t\t\tpool-&gt;curr_threads--;<br>\t\t\tpthread_mutex_unlock(&amp;pool-&gt;mutex);<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 生产者线程调用此函数添加新的处理任务</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">add_thread_job</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> thread_pool *pool, <span class=\"hljs-type\">void</span> (*func)(<span class=\"hljs-type\">void</span>*), <span class=\"hljs-type\">void</span> *arg)</span><br>&#123;<br>\t<span class=\"hljs-comment\">// 动态分配任务对象</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_job</span> *<span class=\"hljs-title\">job</span> =</span> (<span class=\"hljs-keyword\">struct</span> thread_job*) <span class=\"hljs-built_in\">calloc</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(*job));<br><br>\tjob-&gt;func = func;<br>\tjob-&gt;arg = arg;<br><br>\tpthread_mutex_lock(&amp;pool-&gt;mutex);<br><br>\t<span class=\"hljs-comment\">// 将新任务添加进线程池的任务链表中</span><br>\t<span class=\"hljs-keyword\">if</span> (pool-&gt;first == <span class=\"hljs-literal\">NULL</span>)<br>\t\tpool-&gt;first = job;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\tpool-&gt;last-&gt;next = job;<br>\tpool-&gt;last = job;<br>\tjob-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\t<br>\t<span class=\"hljs-keyword\">if</span> (pool-&gt;idle_threads &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 如果有空闲消费者线程，则通知空闲线程进行处理，同时需要解锁</span><br><br>\t\tpthread_mutex_unlock(&amp;pool-&gt;mutex);<br>\t\tpthread_cond_signal(&amp;pool-&gt;cond);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pool-&gt;curr_threads &lt; pool-&gt;max_threads) &#123;<br>\t\t<span class=\"hljs-comment\">// 如果未超过最大线程数限制，则创建一个新的消费者线程</span><br><br>\t\t<span class=\"hljs-type\">pthread_t</span> id;<br>\t\t<span class=\"hljs-type\">pthread_attr_t</span> attr;<br><br>\t\tpthread_attr_init(&amp;attr);<br><br>\t\t<span class=\"hljs-comment\">// 将线程属性设为分离模式，这样当线程退出时其资源自动由系统回收</span><br>\t\tpthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);<br><br>\t\t<span class=\"hljs-comment\">// 创建一个消费者线程</span><br>\t\t<span class=\"hljs-keyword\">if</span> (pthread_create(&amp;id, &amp;attr, consumer_thread, pool) == <span class=\"hljs-number\">0</span>)<br>\t\t\tpool-&gt;curr_threads++;<br><br>\t\tpthread_mutex_unlock(&amp;pool-&gt;mutex);<br>\t\tpthread_attr_destroy(&amp;attr);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 创建线程池对象</span><br><span class=\"hljs-keyword\">struct</span> thread_pool *<span class=\"hljs-title function_\">create_thread_pool</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> max_threads)</span><br>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_pool</span> *<span class=\"hljs-title\">pool</span> =</span> (<span class=\"hljs-keyword\">struct</span> thread_pool*) <span class=\"hljs-built_in\">calloc</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(*pool));<br>\t<br>\tpool-&gt;max_threads = max_threads;<br>\tpthread_mutex_init(&amp;pool-&gt;mutex);<br>\tpthread_cond_init(&amp;pool-&gt;cond);<br>\t...<br><br>\t<span class=\"hljs-keyword\">return</span> pool;<br>&#125;<br><br><span class=\"hljs-comment\">///////////////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">// 使用上面线程池的示例如下：</span><br><br><span class=\"hljs-comment\">// 由消费者线程回调的处理过程</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* arg)</span><br>&#123;<br>      ...<br>&#125;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_pool</span> *<span class=\"hljs-title\">pool</span> =</span> create_thread_pool(<span class=\"hljs-number\">100</span>);<br>\t<span class=\"hljs-type\">int</span>   i;<br><br>\t<span class=\"hljs-comment\">// 循环添加 1000000 次线程处理任务</span><br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000000</span>; i++)<br>\t\tadd_thread_job(pool, thread_callback, <span class=\"hljs-literal\">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>乍一看去，似乎也没有什么问题，象很多经典的开源代码中也是这样设计的，但有一个重要问题被忽视了：线程池设计中的惊群现象。大家可以看到，整个线程池只有一个线程条件变量和线程互斥锁，生产者线程和消费者线程（即线程池中的子线程）正是通过这两个变量进行同步的。生产者线程每添加一个新任务，都会调用 pthread_cond_signal 一次，由操作系统唤醒一个在线程条件变量等待的消费者线程，但如果查看 pthread_cond_signal API 的系统帮助，你会发现其中有一句话：调用此函数后，系统会唤醒在相同条件变量上等待的一个或多个线程。而正是这句模棱两可的话没有引起很多线程池设计者的注意，这也是整个线程池中消费者线程收到信号通知后产生惊群现象的根源所在，并且是消费者线程数量越多，惊群现象越严重—-意味着 CPU 占用越高，线程池的调度性能越低。</p>\n<p>要想避免如上线程池设计中的惊群问题，在仍然共用一个线程互斥锁的条件下，给每一个消费者线程创建一个线程条件变量，生产者线程在添加任务时，找到空闲的消费者线程，将任务置入该消费者的任务队列中同时只通知 (pthread_cond_signal) 该消费者的线程条件变量，消费者线程与生产者线程虽然共用相同的线程互斥锁（因为有全局资源及调用 pthread_cond_wait 所需），但线程条件变量的通知过程却是定向通知的，未被通知的消费者线程不会被唤醒，这样惊群现象也就不会产生了。</p>\n<p>当然，还有一些设计上的细节需要注意，比如：当没有空闲消费者线程时，需要将任务添加进线程池的全局任务队列中，消费者线程处理完自己的任务后需要查看一下线程池中的全局任务队列中是否还有未处理的任务。</p>\n<p>更多的线程池的设计细节请参考 acl (<a href=\"https://sourceforge.net/projects/acl/\">https://sourceforge.net/projects/acl/</a>) 库中 lib_acl&#x2F;src&#x2F;thread&#x2F;acl_pthread_pool.c 中的代码。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee： <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>多线程编程已经是现在网络编程中常用的编程技术，设计一个良好的线程池库显得尤为重要。在 UNIX（WIN32下可以采用类似的方法，acl 库中的线程池是跨平台的） 环境下设计线程池库主要是如何用好如下系统 API：</p>\n<ul>\n<li>1、pthread_cond_signal&#x2F;pthread_cond_broadcast：生产者线程通知线程池中的某个或一些消费者线程池，接收处理任务；</li>\n<li>2、pthread_cond_wait：线程池中的消费者线程等待线程条件变量被通知；</li>\n<li>3、pthread_mutex_lock&#x2F;pthread_mutex_unlock：线程互斥锁的加锁及解锁函数。</li>\n</ul>\n<p>下面的代码示例是大家常见的线程池的设计方式：</p>\n<figure class=\"highlight c\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c\"><span class=\"hljs-comment\">// 线程任务类型定义</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_job</span> &#123;</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_job</span> *<span class=\"hljs-title\">next</span>;</span>  <span class=\"hljs-comment\">// 指向下一个线程任务</span><br>\t<span class=\"hljs-type\">void</span> (*func)(<span class=\"hljs-type\">void</span>*);      <span class=\"hljs-comment\">// 应用回调处理函数 </span><br>\t<span class=\"hljs-type\">void</span> *arg;                <span class=\"hljs-comment\">// 回调函数的参数</span><br>\t...<br>&#125;;<br><br><span class=\"hljs-comment\">// 线程池类型定义</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_pool</span> &#123;</span><br>\t<span class=\"hljs-type\">int</span>   max_threads;        <span class=\"hljs-comment\">// 线程池中最大线程数限制</span><br>\t<span class=\"hljs-type\">int</span>   curr_threads;       <span class=\"hljs-comment\">// 当前线程池中总的线程数</span><br>\t<span class=\"hljs-type\">int</span>   idle_threads;       <span class=\"hljs-comment\">// 当前线程池中空闲的线程数</span><br>\t<span class=\"hljs-type\">pthread_mutex_t</span> mutex;    <span class=\"hljs-comment\">// 线程互斥锁</span><br>\t<span class=\"hljs-type\">pthread_cond_t</span>  cond;     <span class=\"hljs-comment\">// 线程条件变量</span><br>\tthread_job *first;        <span class=\"hljs-comment\">// 线程任务链表的表头</span><br>\tthread_job *last;         <span class=\"hljs-comment\">// 线程任务链表的表尾</span><br>\t...\t<br>&#125;<br><br><span class=\"hljs-comment\">// 线程池中的消费者线程处理过程</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> *<span class=\"hljs-title function_\">consumer_thread</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span> *arg)</span><br>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_pool</span> *<span class=\"hljs-title\">pool</span> =</span> (<span class=\"hljs-keyword\">struct</span> thread_pool*) arg;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_job</span>  *<span class=\"hljs-title\">job</span>;</span><br>\t<span class=\"hljs-type\">int</span>   status;<br><br>\t<span class=\"hljs-comment\">// 该消费者线程需要先加锁</span><br>\tpthread_mutex_lock(&amp;pool-&gt;mutex);<br><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (pool-&gt;first != <span class=\"hljs-literal\">NULL</span>) &#123;<br>\t\t\t<span class=\"hljs-comment\">// 有线程任务时，则取出并在下面进行处理</span><br>\t\t\tjob = pool-&gt;first;<br>\t\t\tpool-&gt;first = job-&gt;next;<br>\t\t\t<span class=\"hljs-keyword\">if</span> (pool-&gt;last == job)<br>\t\t\t\tpool-&gt;last = <span class=\"hljs-literal\">NULL</span>;<br><br>\t\t\t<span class=\"hljs-comment\">// 解锁，允许其它消费者线程加锁或生产者线程添加新的任务</span><br>\t\t\tpthread_mutex_unlock(&amp;pool-&gt;mutex);<br><br>\t\t\t<span class=\"hljs-comment\">// 回调应用的处理函数</span><br>\t\t\tjob-&gt;func(job-&gt;arg);<br><br>\t\t\t<span class=\"hljs-comment\">// 释放动态分配的内存</span><br>\t\t\t<span class=\"hljs-built_in\">free</span>(job);<br><br>\t\t\t<span class=\"hljs-comment\">// 重新去加锁</span><br>\t\t\tpthread_mutex_lock(&amp;pool-&gt;mutex);<br>\t\t&#125; <span class=\"hljs-keyword\">else</span> &#123;<br>\t\t\tpool-&gt;idle_threads++;<br><br>\t\t\t<span class=\"hljs-comment\">// 在调用 pthread_cond_wait 等待线程条件变量被通知且自动解锁</span><br>\t\t\tstatus = pthread_cond_wait(&amp;pool-&gt;cond, &amp;pool-&gt;mutex);<br><br>\t\t\tpool-&gt;idle_threads--;<br><br>\t\t\t<span class=\"hljs-keyword\">if</span> (status == <span class=\"hljs-number\">0</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">continue</span>;<br><br>\t\t\t<span class=\"hljs-comment\">// 等待线程条件变量异常，则该线程需要退出</span><br>\t\t\tpool-&gt;curr_threads--;<br>\t\t\tpthread_mutex_unlock(&amp;pool-&gt;mutex);<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 生产者线程调用此函数添加新的处理任务</span><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">add_thread_job</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">struct</span> thread_pool *pool, <span class=\"hljs-type\">void</span> (*func)(<span class=\"hljs-type\">void</span>*), <span class=\"hljs-type\">void</span> *arg)</span><br>&#123;<br>\t<span class=\"hljs-comment\">// 动态分配任务对象</span><br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_job</span> *<span class=\"hljs-title\">job</span> =</span> (<span class=\"hljs-keyword\">struct</span> thread_job*) <span class=\"hljs-built_in\">calloc</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(*job));<br><br>\tjob-&gt;func = func;<br>\tjob-&gt;arg = arg;<br><br>\tpthread_mutex_lock(&amp;pool-&gt;mutex);<br><br>\t<span class=\"hljs-comment\">// 将新任务添加进线程池的任务链表中</span><br>\t<span class=\"hljs-keyword\">if</span> (pool-&gt;first == <span class=\"hljs-literal\">NULL</span>)<br>\t\tpool-&gt;first = job;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\tpool-&gt;last-&gt;next = job;<br>\tpool-&gt;last = job;<br>\tjob-&gt;next = <span class=\"hljs-literal\">NULL</span>;<br>\t<br>\t<span class=\"hljs-keyword\">if</span> (pool-&gt;idle_threads &gt; <span class=\"hljs-number\">0</span>) &#123;<br>\t\t<span class=\"hljs-comment\">// 如果有空闲消费者线程，则通知空闲线程进行处理，同时需要解锁</span><br><br>\t\tpthread_mutex_unlock(&amp;pool-&gt;mutex);<br>\t\tpthread_cond_signal(&amp;pool-&gt;cond);<br>\t&#125; <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pool-&gt;curr_threads &lt; pool-&gt;max_threads) &#123;<br>\t\t<span class=\"hljs-comment\">// 如果未超过最大线程数限制，则创建一个新的消费者线程</span><br><br>\t\t<span class=\"hljs-type\">pthread_t</span> id;<br>\t\t<span class=\"hljs-type\">pthread_attr_t</span> attr;<br><br>\t\tpthread_attr_init(&amp;attr);<br><br>\t\t<span class=\"hljs-comment\">// 将线程属性设为分离模式，这样当线程退出时其资源自动由系统回收</span><br>\t\tpthread_attr_setdetachstate(&amp;attr, PTHREAD_CREATE_DETACHED);<br><br>\t\t<span class=\"hljs-comment\">// 创建一个消费者线程</span><br>\t\t<span class=\"hljs-keyword\">if</span> (pthread_create(&amp;id, &amp;attr, consumer_thread, pool) == <span class=\"hljs-number\">0</span>)<br>\t\t\tpool-&gt;curr_threads++;<br><br>\t\tpthread_mutex_unlock(&amp;pool-&gt;mutex);<br>\t\tpthread_attr_destroy(&amp;attr);<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-comment\">// 创建线程池对象</span><br><span class=\"hljs-keyword\">struct</span> thread_pool *<span class=\"hljs-title function_\">create_thread_pool</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> max_threads)</span><br>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_pool</span> *<span class=\"hljs-title\">pool</span> =</span> (<span class=\"hljs-keyword\">struct</span> thread_pool*) <span class=\"hljs-built_in\">calloc</span>(<span class=\"hljs-number\">1</span>, <span class=\"hljs-keyword\">sizeof</span>(*pool));<br>\t<br>\tpool-&gt;max_threads = max_threads;<br>\tpthread_mutex_init(&amp;pool-&gt;mutex);<br>\tpthread_cond_init(&amp;pool-&gt;cond);<br>\t...<br><br>\t<span class=\"hljs-keyword\">return</span> pool;<br>&#125;<br><br><span class=\"hljs-comment\">///////////////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">// 使用上面线程池的示例如下：</span><br><br><span class=\"hljs-comment\">// 由消费者线程回调的处理过程</span><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">thread_callback</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* arg)</span><br>&#123;<br>      ...<br>&#125;<br><br><span class=\"hljs-type\">void</span> <span class=\"hljs-title function_\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span><br>&#123;<br>\t<span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">thread_pool</span> *<span class=\"hljs-title\">pool</span> =</span> create_thread_pool(<span class=\"hljs-number\">100</span>);<br>\t<span class=\"hljs-type\">int</span>   i;<br><br>\t<span class=\"hljs-comment\">// 循环添加 1000000 次线程处理任务</span><br>\t<span class=\"hljs-keyword\">for</span> (i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000000</span>; i++)<br>\t\tadd_thread_job(pool, thread_callback, <span class=\"hljs-literal\">NULL</span>);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>乍一看去，似乎也没有什么问题，象很多经典的开源代码中也是这样设计的，但有一个重要问题被忽视了：线程池设计中的惊群现象。大家可以看到，整个线程池只有一个线程条件变量和线程互斥锁，生产者线程和消费者线程（即线程池中的子线程）正是通过这两个变量进行同步的。生产者线程每添加一个新任务，都会调用 pthread_cond_signal 一次，由操作系统唤醒一个在线程条件变量等待的消费者线程，但如果查看 pthread_cond_signal API 的系统帮助，你会发现其中有一句话：调用此函数后，系统会唤醒在相同条件变量上等待的一个或多个线程。而正是这句模棱两可的话没有引起很多线程池设计者的注意，这也是整个线程池中消费者线程收到信号通知后产生惊群现象的根源所在，并且是消费者线程数量越多，惊群现象越严重—-意味着 CPU 占用越高，线程池的调度性能越低。</p>\n<p>要想避免如上线程池设计中的惊群问题，在仍然共用一个线程互斥锁的条件下，给每一个消费者线程创建一个线程条件变量，生产者线程在添加任务时，找到空闲的消费者线程，将任务置入该消费者的任务队列中同时只通知 (pthread_cond_signal) 该消费者的线程条件变量，消费者线程与生产者线程虽然共用相同的线程互斥锁（因为有全局资源及调用 pthread_cond_wait 所需），但线程条件变量的通知过程却是定向通知的，未被通知的消费者线程不会被唤醒，这样惊群现象也就不会产生了。</p>\n<p>当然，还有一些设计上的细节需要注意，比如：当没有空闲消费者线程时，需要将任务添加进线程池的全局任务队列中，消费者线程处理完自己的任务后需要查看一下线程池中的全局任务队列中是否还有未处理的任务。</p>\n<p>更多的线程池的设计细节请参考 acl (<a href=\"https://sourceforge.net/projects/acl/\">https://sourceforge.net/projects/acl/</a>) 库中 lib_acl&#x2F;src&#x2F;thread&#x2F;acl_pthread_pool.c 中的代码。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee： <a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a></p>\n"},{"title":"使用 acl 库编写高效的 C++ redis 客户端应用","date":"2015-02-09T17:03:00.000Z","_content":"\n## 一、概述\n（可以直接略过此段）redis 最近做为 nosql 数据服务应用越来越广泛，其相对于 memcached 的最大优点是提供了更加丰富的数据结构，所以应用场景就更为广泛。redis 的出现可谓是广大网络应用开发者的福音，同时有大量的开源人员贡献了客户端代码，象针对 java 语言的 jedis，php 语言的 phpredis/predis 等，这些语言的 redis 库既丰富又好用，而对 C/C++ 程序员似乎就没那么幸运了，官方提供了 C 版的 hiredis 作为客户端库，很多爱好者都是基于 hiredis 进行二次封装和开发形成了 C++ 客户端库，但这些库（包括官方的 hiredis）大都使用麻烦，给使用者造成了许多出错的机会。一直想开发一个更易用的接口型的 C++ 版 redis 客户端库（注：官方提供的库基本属于协议型的，这意味着使用者需要花费很多精力去填充各个协议字段同时还得要分析服务器可能返回的不同的结果类型），但每当看到 redis 那 150 多个客户端命令时便心生退缩，因为要给每个命令提供一个方便易用的 C++ 函数接口，则意味着非常巨大的开发工作量。\n\n在后来的多次项目开发中被官方的 hiredis 库屡次摧残后，终于忍受不了，决定重新开发一套全新的 redis 客户端 API，该库不仅要实现这 150 多个客户端命令，同时需要提供方便灵活的连接池及连接池集群管理功能（幸运的是在 acl 库中已经具备了通用的网络连接池及连接池集群管理模块），另外，根据之前的实践，有可能提供的函数接口要远大于这 150 多个，原因是针对同一个命令可能会因为不同的参数类型场景提供多个函数接口（最终的结果是提供了3，4百个函数 API，7000+行源码，2000+行头文件）；在仔细研究了 redis 的通信协议后便着手开始进行设计开发了（redis 的协议设计还是非常简单实用的，即能支持二进制，同时又便于手工调试）。在开发过程中大量参考了 http://redisdoc.com 网站上的中文在线翻译版（非常感谢 黄键宏 同学的辛勤工作）。\n\n## 二、acl redis 库分类\n根据 redis 的数据结构类型，分成 12 个大类，每个大类提供不同的函数接口，这 12 个 C++ 类展示如下：\n\n- 1、redis_key：redis 所有数据类型的统一键操作类；因为 redis 的数据结构类型都是基本的 KEY-VALUE 类型，其中 VALUE 分为不同的数据结构类型；\n- 2、redis_connectioin：与 redis-server 连接相关的类；\n- 3、redis_server：与 redis-server 服务管理相关的类；\n- 4、redis_string：redis 中用来表示字符串的数据类型；\n- 5、redis_hash：redis 中用来表示哈希表的数据类型；每一个数据对象由 “KEY-域值对集合” 组成，即一个 KEY 对应多个“域值对”，每个“域值对”由一个字段名与字段值组成；\n- 6、redis_list：redis 中用来表示列表的数据类型；\n- 7、redis_set：redis 中用来表示集合的数据类型；\n- 8、redis_zset：redis 中用来表示有序集合的数据类型；\n- 9、redis_pubsub：redis 中用来表示“发布-订阅”的数据类型；\n- 10、redis_hyperloglog：redis 中用来表示 hyperloglog 基数估值算法的数据类型；\n- 11、redis_script：redis 中用来与 lua 脚本进行转换交互的数据类型；\n- 12、redis_transaction：redis 中用以事务方式执行多条 redis 命令的数据类型（注：该事务处理方式与数据库的事务有很大不同，redis 中的事务处理过程没有数据库中的事务回滚机制，仅能保证其中的多条命令都被执行或都不被执行）；\n\n除了以上对应于官方 redis 命令的 12 个类别外，在 acl 库中还提供了另外几个类：\n\n- 13、redis_command：以上 12 个类的基类；\n- 14、redis_client：redis 客户端网络连接类；\n- 15、redis_result：redis 命令结果类；\n- 16、redis_pool：针对以上所有命令支持连接池方式；\n- 17、redis_manager：针对以上所有命令允许与多个 redis-server 服务建立连接池集群（即与每个 redis-server 建立一个连接池）；\n- 18、redis_cluster：支持 redis3.0 集群模式的类。\n\n## 三、acl redis 使用举例\n### 3.1、下面是一个使用 acl 框架中 redis 客户端库的简单例子：\n\n```c++\n/**\n * @param conn {acl::redis_client&} redis 连接对象\n * @return {bool} 操作过程是否成功\n */\nbool test_redis_string(acl::redis_client& conn, const char* key)\n{\n\t// 创建 redis string 类型的命令操作类对象，同时将连接类对象与操作类\n\t// 对象进行绑定\n\tacl::redis_string string_operation(&conn);\n\tconst char* value = \"test_value\";\n\n\t// 添加 K-V 值至 redis-server 中\n\tif (string_operation.set(key, value) == false)\n\t{\n\t\tconst acl::redis_result* res = string_operation.get_result();\n\t\tprintf(\"set key: %s error: %s\\r\\n\",\n\t\t\tkey, res ? res->get_error() : \"unknown error\");\n\t\treturn false;\n\t}\n\tprintf(\"set key: %s ok!\\r\\n\", key);\n\n\t// 需要重置连接对象的状态\n\tstring_operation.clear();\n\n\t// 从 redis-server 中取得对应 key 的值\n\tacl::string buf;\n\tif (string_operation.get(key, buf) == false)\n\t{\n\t\tconst acl::redis_result* res = string_operation.get_result();\n\t\tprintf(\"get key: %s error: %s\\r\\n\",\n\t\t\tkey, res ? res->get_error() : \"unknown error\");\n\t\treturn false;\n\t}\n\tprintf(\"get key: %s ok, value: %s\\r\\n\", key, buf.c_str());\n\n\t// 探测给定 key 是否存在于 redis-server 中，需要创建 redis 的 key\n\t// 类对象，同时将 redis 连接对象与之绑定\n\tacl::redis_key key_operation;\n\tkey_operation.set_client(conn);  // 将连接对象与操作对象进行绑定\n\tif (key_operation.exists(key) == false)\n\t{\n\t\tif (conn.eof())\n\t\t{\n\t\t\tprintf(\"disconnected from redis-server\\r\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tprintf(\"key: %s not exists\\r\\n\", key);\n\t}\n\telse\n\t\tprintf(\"key: %s exists\\r\\n\", key);\n\n\t// 删除指定 key 的字符串类对象\n\tif (key_operation.del(key, NULL) < 0)\n\t{\n\t\tprintf(\"del key: %s error\\r\\n\", key);\n\t\treturn false;\n\t}\n\telse\n\t\tprintf(\"del key: %s ok\\r\\n\", key);\n\n\treturn true;\n}\n\n/**\n * @param redis_addr {const char*} redis-server 服务器地址，\n *  格式为：ip:port，如：127.0.0.1:6379\n * @param conn_timeout {int} 连接 redis-server 的超时时间(秒)\n * @param rw_timeout {int} 与 redis-server 进行通信的 IO 超时时间(秒)\n */\nbool test_redis(const char* redis_addr, int conn_timeout, int rw_timeout)\n{\n\t// 创建 redis 客户端网络连接类对象\n\tacl::redis_client conn(redis_addr, conn_timeout, rw_timeout);\n\tconst char* key = \"test_key\";\n\treturn test_redis_string(conn, key);\n}\n```\n\n上面的简单例子的操作过程是：在 redis-server 中添加字符串类型数据 --> 从 redis-server 中获取指定的字符串数据 --> 判断指定指定 key 的对象在 redis-server 上是否存在 ---> 从 redis-server 中删除指定 key 的数据对象（即该例中的字符串对象）。通过以上简单示例，使用者需要注意以下几点：\n\n- acl 中的 redis 库的设计中 redis 连接类对象与命令操作类对象是分离的，12 个 redis 命令操作类对应 acl  redis 库中相应的 12 个命令操作类；\n- 在使用 redis 命令操作类时需要先将 redis 连接类对象与命令操作类对象进行绑定（以便于操作类内部可以利连接类中的网络连接、协议组包以及协议解析等方法）；\n- 在重复使用一个 redis 命令类对象时，需要首先重置该命令类对象的状态（即调用：clear()），这样主要是为了释放上一次命令操作过程的中间内存资源；\n- 一个 redis 连接类对象可以被多个命令类操作类对象使用（使用前需先绑定一次）；\n- 将 redis 连接对象与命令操作对象绑定有两种方式：可以在构造函数中传入非空 redis 连接对象，或调用操作对象的 set_client 方法进行绑定。\n\n### 3.2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：\n```c++\n/**\n * @param conn {acl::redis_client&} redis 连接对象\n * @return {bool} 操作过程是否成功\n */\nbool test_redis_string(acl::redis_client& conn, const char* key)\n{\n\t...... // 代码与上述代码相同，省略\n\n\treturn true;\n}\n\n// 子线程处理类\nclass test_thread : public acl::thread\n{\npublic:\n\ttest_thread(acl::redis_pool& pool) : pool_(pool) {}\n\n\t~test_thread() {}\n\nprotected:\n\t// 基类（acl::thread）纯虚函数\n\tvirtual void* run()\n\t{\n\t\tacl::string key;\n\t\t// 给每个线程一个自己的 key，以便以测试，其中 thread_id()\n\t\t// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号\n\t\tkey.format(\"test_key: %lu\", thread_id());\n\n\t\tacl::redis_client* conn;\n\n\t\tfor (int i = 0; i < 1000; i++)\n\t\t{\n\t\t\t// 从 redis 客户端连接池中获取一个 redis 连接对象\n\t\t\tconn = (acl::redis_client*) pool_.peek();\n\t\t\tif (conn == NULL)\n\t\t\t{\n\t\t\t\tprintf(\"peek redis connection error\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 进行 redis 客户端命令操作过程\n\t\t\tif (test_redis_string(*conn) == false)\n\t\t\t{\n\t\t\t\tprintf(\"redis operation error\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 回收连接对象\n\t\t\tpool_.put(conn, true);\n\t\t}\n\n\t\treturn NULL;\n\t}\n\nprivate:\n\tacl::redis_pool& pool_;\n};\n\nvoid test_redis_pool(const char* redis_addr, int max_threads,\n\tint conn_timeout, int rw_timeout)\n{\n\t// 创建 redis 连接池对象\n\tacl::redis_client_pool pool(redis_addr, max_threads);\n\t// 设置连接 redis 的超时时间及 IO 超时时间，单位都是秒\n\tpool.set_timeout(conn_timeout, rw_timeout);\n\n\t// 创建一组子线程\n\tstd::vector<test_thread*> threads;\n\tfor (int i = 0; i < max_threads; i++)\n\t{\n\t\ttest_thread* thread = new test_thread(pool);\n\t\tthreads.push_back(thread);\n\t\tthread->set_detachable(false);\n\t\tthread->start();\n\t}\n\n\t// 等待所有子线程正常退出\n\tstd::vector<test_thread*>::iterator it = threads.begin();\n\tfor (; it != threads.end(); ++it)\n\t{\n\t\t(*it)->wait();\n\t\tdelete (*it);\n\t}\n}\n```\n\n除了创建线程及 redis 连接池外，上面的例子与示例 1） 的代码与功能无异。\n\n### 3.3、下面对上面的示例2）稍作修改，使之可以支持 redis 集群连接池的方式，示例代码如下：\n```c++\n/**\n * @param conn {acl::redis_client&} redis 连接对象\n * @return {bool} 操作过程是否成功\n */\nbool test_redis_string(acl::redis_client& conn, const char* key)\n{\n\t......  // 与上面示例代码相同，略去\n\treturn true;\n}\n\n// 子线程处理类\nclass test_thread : public acl::thread\n{\npublic:\n\ttest_thread(acl::redis_cluster& cluster) : cluster_(cluster) {}\n\n\t~test_thread() {}\n\nprotected:\n\t// 基类（acl::thread）纯虚函数\n\tvirtual void* run()\n\t{\n\t\tacl::string key;\n\t\tacl::redis_client_pool* pool;\n\t\tacl::redis_client* conn;\n\n\t\tfor (int i = 0; i < 1000; i++)\n\t\t{\n\t\t\t// 从连接池集群管理器中获得一个 redis-server 的连接池对象\n\t\t\tpool = (acl::redis_client_pool*) cluster_.peek();\n\t\t\tif (pool == NULL)\n\t\t\t{\n\t\t\t\tprintf(\"peek connection pool failed\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 从 redis 客户端连接池中获取一个 redis 连接对象\n\t\t\tconn = (acl::redis_client*) pool_.peek();\n\t\t\tif (conn == NULL)\n\t\t\t{\n\t\t\t\tprintf(\"peek redis connection error\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 给每个线程一个自己的 key，以便以测试，其中 thread_id()\n\t\t\t// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号\n\t\t\tkey.format(\"test_key: %lu_%d\", thread_id(), i);\n\t\t\t// 进行 redis 客户端命令操作过程\n\t\t\tif (test_redis_string(*conn, key.c_str()) == false)\n\t\t\t{\n\t\t\t\tprintf(\"redis operation error\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 回收连接对象至连接池中\n\t\t\tpool_.put(conn, true);\n\t\t}\n\n\t\treturn NULL;\n\t}\n\nprivate:\n\tacl::redis_cluster& cluster_;\n};\n\nvoid test_redis_manager(const char* redis_addr, int max_threads,\n\tint conn_timeout, int rw_timeout)\n{\n\t// 创建 redis 集群连接池对象\n\tacl::redis_client_cluster cluster;\n\n\t// 添加多个 redis-server 的服务器实例地址\n\tcluster.set(\"127.0.0.1:6379\", max_threads, conn_timeout, rw_timeout);\n\tcluster.set(\"127.0.0.1:6380\", max_threads, conn_timeout, rw_timeout);\n\tcluster.set(\"127.0.0.1:6381\", max_threads, conn_timeout, rw_timeout);\n\n\t// 创建一组子线程\n\tstd::vector<test_thread*> threads;\n\tfor (int i = 0; i < max_threads; i++)\n\t{\n\t\ttest_thread* thread = new test_thread(cluster);\n\t\tthreads.push_back(thread);\n\t\tthread->set_detachable(false);\n\t\tthread->start();\n\t}\n\n\t// 等待所有子线程正常退出\n\tstd::vector<test_thread*>::iterator it = threads.begin();\n\tfor (; it != threads.end(); ++it)\n\t{\n\t\t(*it)->wait();\n\t\tdelete (*it);\n\t}\n}\n```\n\n该示例只修改了几处代码便支持了集群 redis 连接池方式，其处理过程是：创建集群连接池对象（可以添加多个 redis-server 服务地址） --> 从集群连接池对象中取得一个连接池对象 ---> 从该连接池对象中取得一个连接 ---> 该连接对象与 redis 操作类对象绑定后进行操作。\n\n上述示例的集群模式并非是 redis3.0 的集群模式，这种集群中的 redis-server 之间是不互联的， 集群的建立是由客户端来维护的，由客户决定数据存储在哪个 redis-server 实例上；而 redis3.0 的集群方式则与之大不同，在 redis3.0 中，redis-server 之间是互联互通的，而且支持数据的冗余备份，数据的存储位置是由服务端决定的，下面的例子是支持 redis3.0 集群模式的客户端例子：\n\n### 3.4、支持 redis3.0 集群模式的示例代码如下：\n```c++\n// 统一的键值前缀\nstatic acl::string __keypre(\"test_key_cluster\");\n\n// 测试 redis 字符串添加功能\nstatic bool test_redis_string(acl::redis_string& cmd, int i)\n{\n\tacl::string key;\n\tkey.format(\"%s_%d\", __keypre.c_str(), i);\n\n\tacl::string value;\n\tvalue.format(\"value_%s\", key.c_str());\n\t\n\tbool ret = cmd.set(key.c_str(), value.c_str());\n\treturn ret;\n\tif (i < 10)\n\t\tprintf(\"set key: %s, value: %s %s\\r\\n\", key.c_str(),\n\t\t\tvalue.c_str(), ret ? \"ok\" : \"error\");\n\treturn ret;\n}\n\n// 测试 redis 键是否存在功能\nstatic bool test_redis_exists(acl::redis_key& cmd, int i)\n{\n\tacl::string key;\n\n\tkey.format(\"%s_%d\", __keypre.c_str(), i);\n\n\tif (cmd.exists(key.c_str()) == false)\n\t{\n\t\tif (i < 10)\n\t\t\tprintf(\"no exists key: %s\\r\\n\", key.c_str());\n\t}\n\telse\n\t{\n\t\tif (i < 10)\n\t\t\tprintf(\"exists key: %s\\r\\n\", key.c_str());\n\t}\n\treturn true;\n}\n\n// 子线程处理类\nclass test_thread : public acl::thread\n{\npublic:\n\ttest_thread(acl::redis_cluster& cluster, int max_conns)\n\t: cluster_(cluster), max_conns_(max_conns) {}\n\n\t~test_thread() {}\n\nprotected:\n\t// 基类（acl::thread）纯虚函数\n\tvirtual void* run()\n\t{\n\t\tacl::redis_string cmd_string;\n\t\tacl::redis_key  cmd_key;\n\t\t\n\t\t// 设置 redis 客户端命令的集群操作模式\n\t\tcmd_key.set_cluster(&cluster_, max_conns_);\n\t\tcmd_string.set_cluster(&cluster_, max_conns_);\n\t\tfor (int i = 0; i < 1000; i++)\n\t\t{\n\t\t\t// 进行 redis 客户端命令操作过程\n\t\t\tif (test_redis_string(cmd_string, i) == false)\n\t\t\t\tbreak;\n\t\n\t\t\tif (test_redis_exists(cmd_key, i) == false)\n\t\t\t\tbreak;\n\n\t\t\t// 重置客户端命令状态\n\n\t\t\tcmd_string.clear();\n\t\t\tcmd_key.clear();\n\t\t}\n\n\t\treturn NULL;\n\t}\n\nprivate:\n\tacl::redis_cluster& cluster_;\n\tint max_conns_;\n};\n\nvoid test_redis_cluster(int max_threads int conn_timeout, int rw_timeout)\n{\n\t// 创建 redis 集群连接池对象\n\tacl::redis_client_cluster cluster;\n\n\t// 添加一个或多个 redis-server 的服务器实例地址，不必一次加载所有\n\t// 的 redis-server 服务器地址，redis_cluster 及相关类具有自动发现\n\t// 及动态添加 redis-server 服务实例的功能\n\n\tcluster.set(\"127.0.0.1:6379\", max_threads, conn_timeout, rw_timeout);\n\t// cluster.set(\"127.0.0.1:6380\", max_threads, conn_timeout, rw_timeout);\n\t// cluster.set(\"127.0.0.1:6381\", max_threads, conn_timeout, rw_timeout);\n\n\t// 创建一组子线程\n\tstd::vector<test_thread*> threads;\n\tfor (int i = 0; i < max_threads; i++)\n\t{\n\t\ttest_thread* thread = new test_thread(cluster, max_threads);\n\t\tthreads.push_back(thread);\n\t\tthread->set_detachable(false);\n\t\tthread->start();\n\t}\n\n\t// 等待所有子线程正常退出\n\tstd::vector<test_thread*>::iterator it = threads.begin();\n\tfor (; it != threads.end(); ++it)\n\t{\n\t\t(*it)->wait();\n\t\tdelete (*it);\n\t}\n}\n```\n\n从上面例子可以看出，使用 acl redis 客户端库操作 redis3.0 集群时，只需要将集群的句柄注入到每个 redis 客户端命令即（如上面黄色部分所示）；至于如何与 redis 集群交互将由 redis_cluster 及 redis 客户端命令类的基类 redis_command 进行处理；此外，还需要注意示例 4）与示例 3）所支持的集群方式的不同点如下：\n\n- 示例3 的集群模式下实际上是由客户端根据所连接的所有 redis 服务器的集合来决定数据存储结点，而实际上 redis 服务器之间并不互联；而示例 4 则是真正意义的 redis 服务端的集群模式，所有 redis 服务结点之间是互联互通的（可以配置数据结点存储的冗余数量）；\n- 示例3 的客户端必须在开始初始化时添加所有的 redis 服务结点，以便于采用轮循或者哈希访问模式；而示例4 在初始化时只需添加至少一个集群中的服务结点即可，随着访问次数的增加，会根据需要动态添加 redis 服务结点（ redis3.0 采用的重定向机制，即当访问某个 redis 结点时，若 key 值不存在于该结点上，则其会返回给客户端一个重定向指令，告诉客户端存储该 key 的 redis 服务结点，因此，根据此特性，acl redis 集群会根据重定向信息动态添加 redis 集群中的服务结点）；\n- 此外，示例4 是兼容示例3 的。\n\n## 四、小结\n以上介绍了 acl 框架中新增加的 redis 库的使用方法及处理过程，该库将复杂的协议及网络处理过程隐藏在实现内部，使用户使用起来感觉象是在调用本的函数。在示例 2）、3） 中提到了 acl 线程的使用，有关 acl 库中更为详细地使用线程的文章参见：《使用 acl_cpp 库编写多线程程序》。\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl\n\n ","source":"_posts/redis_client.md","raw":"---\ntitle: 使用 acl 库编写高效的 C++ redis 客户端应用\ndate: 2015-02-10 01:03\ncategories: redis使用\n---\n\n## 一、概述\n（可以直接略过此段）redis 最近做为 nosql 数据服务应用越来越广泛，其相对于 memcached 的最大优点是提供了更加丰富的数据结构，所以应用场景就更为广泛。redis 的出现可谓是广大网络应用开发者的福音，同时有大量的开源人员贡献了客户端代码，象针对 java 语言的 jedis，php 语言的 phpredis/predis 等，这些语言的 redis 库既丰富又好用，而对 C/C++ 程序员似乎就没那么幸运了，官方提供了 C 版的 hiredis 作为客户端库，很多爱好者都是基于 hiredis 进行二次封装和开发形成了 C++ 客户端库，但这些库（包括官方的 hiredis）大都使用麻烦，给使用者造成了许多出错的机会。一直想开发一个更易用的接口型的 C++ 版 redis 客户端库（注：官方提供的库基本属于协议型的，这意味着使用者需要花费很多精力去填充各个协议字段同时还得要分析服务器可能返回的不同的结果类型），但每当看到 redis 那 150 多个客户端命令时便心生退缩，因为要给每个命令提供一个方便易用的 C++ 函数接口，则意味着非常巨大的开发工作量。\n\n在后来的多次项目开发中被官方的 hiredis 库屡次摧残后，终于忍受不了，决定重新开发一套全新的 redis 客户端 API，该库不仅要实现这 150 多个客户端命令，同时需要提供方便灵活的连接池及连接池集群管理功能（幸运的是在 acl 库中已经具备了通用的网络连接池及连接池集群管理模块），另外，根据之前的实践，有可能提供的函数接口要远大于这 150 多个，原因是针对同一个命令可能会因为不同的参数类型场景提供多个函数接口（最终的结果是提供了3，4百个函数 API，7000+行源码，2000+行头文件）；在仔细研究了 redis 的通信协议后便着手开始进行设计开发了（redis 的协议设计还是非常简单实用的，即能支持二进制，同时又便于手工调试）。在开发过程中大量参考了 http://redisdoc.com 网站上的中文在线翻译版（非常感谢 黄键宏 同学的辛勤工作）。\n\n## 二、acl redis 库分类\n根据 redis 的数据结构类型，分成 12 个大类，每个大类提供不同的函数接口，这 12 个 C++ 类展示如下：\n\n- 1、redis_key：redis 所有数据类型的统一键操作类；因为 redis 的数据结构类型都是基本的 KEY-VALUE 类型，其中 VALUE 分为不同的数据结构类型；\n- 2、redis_connectioin：与 redis-server 连接相关的类；\n- 3、redis_server：与 redis-server 服务管理相关的类；\n- 4、redis_string：redis 中用来表示字符串的数据类型；\n- 5、redis_hash：redis 中用来表示哈希表的数据类型；每一个数据对象由 “KEY-域值对集合” 组成，即一个 KEY 对应多个“域值对”，每个“域值对”由一个字段名与字段值组成；\n- 6、redis_list：redis 中用来表示列表的数据类型；\n- 7、redis_set：redis 中用来表示集合的数据类型；\n- 8、redis_zset：redis 中用来表示有序集合的数据类型；\n- 9、redis_pubsub：redis 中用来表示“发布-订阅”的数据类型；\n- 10、redis_hyperloglog：redis 中用来表示 hyperloglog 基数估值算法的数据类型；\n- 11、redis_script：redis 中用来与 lua 脚本进行转换交互的数据类型；\n- 12、redis_transaction：redis 中用以事务方式执行多条 redis 命令的数据类型（注：该事务处理方式与数据库的事务有很大不同，redis 中的事务处理过程没有数据库中的事务回滚机制，仅能保证其中的多条命令都被执行或都不被执行）；\n\n除了以上对应于官方 redis 命令的 12 个类别外，在 acl 库中还提供了另外几个类：\n\n- 13、redis_command：以上 12 个类的基类；\n- 14、redis_client：redis 客户端网络连接类；\n- 15、redis_result：redis 命令结果类；\n- 16、redis_pool：针对以上所有命令支持连接池方式；\n- 17、redis_manager：针对以上所有命令允许与多个 redis-server 服务建立连接池集群（即与每个 redis-server 建立一个连接池）；\n- 18、redis_cluster：支持 redis3.0 集群模式的类。\n\n## 三、acl redis 使用举例\n### 3.1、下面是一个使用 acl 框架中 redis 客户端库的简单例子：\n\n```c++\n/**\n * @param conn {acl::redis_client&} redis 连接对象\n * @return {bool} 操作过程是否成功\n */\nbool test_redis_string(acl::redis_client& conn, const char* key)\n{\n\t// 创建 redis string 类型的命令操作类对象，同时将连接类对象与操作类\n\t// 对象进行绑定\n\tacl::redis_string string_operation(&conn);\n\tconst char* value = \"test_value\";\n\n\t// 添加 K-V 值至 redis-server 中\n\tif (string_operation.set(key, value) == false)\n\t{\n\t\tconst acl::redis_result* res = string_operation.get_result();\n\t\tprintf(\"set key: %s error: %s\\r\\n\",\n\t\t\tkey, res ? res->get_error() : \"unknown error\");\n\t\treturn false;\n\t}\n\tprintf(\"set key: %s ok!\\r\\n\", key);\n\n\t// 需要重置连接对象的状态\n\tstring_operation.clear();\n\n\t// 从 redis-server 中取得对应 key 的值\n\tacl::string buf;\n\tif (string_operation.get(key, buf) == false)\n\t{\n\t\tconst acl::redis_result* res = string_operation.get_result();\n\t\tprintf(\"get key: %s error: %s\\r\\n\",\n\t\t\tkey, res ? res->get_error() : \"unknown error\");\n\t\treturn false;\n\t}\n\tprintf(\"get key: %s ok, value: %s\\r\\n\", key, buf.c_str());\n\n\t// 探测给定 key 是否存在于 redis-server 中，需要创建 redis 的 key\n\t// 类对象，同时将 redis 连接对象与之绑定\n\tacl::redis_key key_operation;\n\tkey_operation.set_client(conn);  // 将连接对象与操作对象进行绑定\n\tif (key_operation.exists(key) == false)\n\t{\n\t\tif (conn.eof())\n\t\t{\n\t\t\tprintf(\"disconnected from redis-server\\r\\n\");\n\t\t\treturn false;\n\t\t}\n\n\t\tprintf(\"key: %s not exists\\r\\n\", key);\n\t}\n\telse\n\t\tprintf(\"key: %s exists\\r\\n\", key);\n\n\t// 删除指定 key 的字符串类对象\n\tif (key_operation.del(key, NULL) < 0)\n\t{\n\t\tprintf(\"del key: %s error\\r\\n\", key);\n\t\treturn false;\n\t}\n\telse\n\t\tprintf(\"del key: %s ok\\r\\n\", key);\n\n\treturn true;\n}\n\n/**\n * @param redis_addr {const char*} redis-server 服务器地址，\n *  格式为：ip:port，如：127.0.0.1:6379\n * @param conn_timeout {int} 连接 redis-server 的超时时间(秒)\n * @param rw_timeout {int} 与 redis-server 进行通信的 IO 超时时间(秒)\n */\nbool test_redis(const char* redis_addr, int conn_timeout, int rw_timeout)\n{\n\t// 创建 redis 客户端网络连接类对象\n\tacl::redis_client conn(redis_addr, conn_timeout, rw_timeout);\n\tconst char* key = \"test_key\";\n\treturn test_redis_string(conn, key);\n}\n```\n\n上面的简单例子的操作过程是：在 redis-server 中添加字符串类型数据 --> 从 redis-server 中获取指定的字符串数据 --> 判断指定指定 key 的对象在 redis-server 上是否存在 ---> 从 redis-server 中删除指定 key 的数据对象（即该例中的字符串对象）。通过以上简单示例，使用者需要注意以下几点：\n\n- acl 中的 redis 库的设计中 redis 连接类对象与命令操作类对象是分离的，12 个 redis 命令操作类对应 acl  redis 库中相应的 12 个命令操作类；\n- 在使用 redis 命令操作类时需要先将 redis 连接类对象与命令操作类对象进行绑定（以便于操作类内部可以利连接类中的网络连接、协议组包以及协议解析等方法）；\n- 在重复使用一个 redis 命令类对象时，需要首先重置该命令类对象的状态（即调用：clear()），这样主要是为了释放上一次命令操作过程的中间内存资源；\n- 一个 redis 连接类对象可以被多个命令类操作类对象使用（使用前需先绑定一次）；\n- 将 redis 连接对象与命令操作对象绑定有两种方式：可以在构造函数中传入非空 redis 连接对象，或调用操作对象的 set_client 方法进行绑定。\n\n### 3.2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：\n```c++\n/**\n * @param conn {acl::redis_client&} redis 连接对象\n * @return {bool} 操作过程是否成功\n */\nbool test_redis_string(acl::redis_client& conn, const char* key)\n{\n\t...... // 代码与上述代码相同，省略\n\n\treturn true;\n}\n\n// 子线程处理类\nclass test_thread : public acl::thread\n{\npublic:\n\ttest_thread(acl::redis_pool& pool) : pool_(pool) {}\n\n\t~test_thread() {}\n\nprotected:\n\t// 基类（acl::thread）纯虚函数\n\tvirtual void* run()\n\t{\n\t\tacl::string key;\n\t\t// 给每个线程一个自己的 key，以便以测试，其中 thread_id()\n\t\t// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号\n\t\tkey.format(\"test_key: %lu\", thread_id());\n\n\t\tacl::redis_client* conn;\n\n\t\tfor (int i = 0; i < 1000; i++)\n\t\t{\n\t\t\t// 从 redis 客户端连接池中获取一个 redis 连接对象\n\t\t\tconn = (acl::redis_client*) pool_.peek();\n\t\t\tif (conn == NULL)\n\t\t\t{\n\t\t\t\tprintf(\"peek redis connection error\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 进行 redis 客户端命令操作过程\n\t\t\tif (test_redis_string(*conn) == false)\n\t\t\t{\n\t\t\t\tprintf(\"redis operation error\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 回收连接对象\n\t\t\tpool_.put(conn, true);\n\t\t}\n\n\t\treturn NULL;\n\t}\n\nprivate:\n\tacl::redis_pool& pool_;\n};\n\nvoid test_redis_pool(const char* redis_addr, int max_threads,\n\tint conn_timeout, int rw_timeout)\n{\n\t// 创建 redis 连接池对象\n\tacl::redis_client_pool pool(redis_addr, max_threads);\n\t// 设置连接 redis 的超时时间及 IO 超时时间，单位都是秒\n\tpool.set_timeout(conn_timeout, rw_timeout);\n\n\t// 创建一组子线程\n\tstd::vector<test_thread*> threads;\n\tfor (int i = 0; i < max_threads; i++)\n\t{\n\t\ttest_thread* thread = new test_thread(pool);\n\t\tthreads.push_back(thread);\n\t\tthread->set_detachable(false);\n\t\tthread->start();\n\t}\n\n\t// 等待所有子线程正常退出\n\tstd::vector<test_thread*>::iterator it = threads.begin();\n\tfor (; it != threads.end(); ++it)\n\t{\n\t\t(*it)->wait();\n\t\tdelete (*it);\n\t}\n}\n```\n\n除了创建线程及 redis 连接池外，上面的例子与示例 1） 的代码与功能无异。\n\n### 3.3、下面对上面的示例2）稍作修改，使之可以支持 redis 集群连接池的方式，示例代码如下：\n```c++\n/**\n * @param conn {acl::redis_client&} redis 连接对象\n * @return {bool} 操作过程是否成功\n */\nbool test_redis_string(acl::redis_client& conn, const char* key)\n{\n\t......  // 与上面示例代码相同，略去\n\treturn true;\n}\n\n// 子线程处理类\nclass test_thread : public acl::thread\n{\npublic:\n\ttest_thread(acl::redis_cluster& cluster) : cluster_(cluster) {}\n\n\t~test_thread() {}\n\nprotected:\n\t// 基类（acl::thread）纯虚函数\n\tvirtual void* run()\n\t{\n\t\tacl::string key;\n\t\tacl::redis_client_pool* pool;\n\t\tacl::redis_client* conn;\n\n\t\tfor (int i = 0; i < 1000; i++)\n\t\t{\n\t\t\t// 从连接池集群管理器中获得一个 redis-server 的连接池对象\n\t\t\tpool = (acl::redis_client_pool*) cluster_.peek();\n\t\t\tif (pool == NULL)\n\t\t\t{\n\t\t\t\tprintf(\"peek connection pool failed\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 从 redis 客户端连接池中获取一个 redis 连接对象\n\t\t\tconn = (acl::redis_client*) pool_.peek();\n\t\t\tif (conn == NULL)\n\t\t\t{\n\t\t\t\tprintf(\"peek redis connection error\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 给每个线程一个自己的 key，以便以测试，其中 thread_id()\n\t\t\t// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号\n\t\t\tkey.format(\"test_key: %lu_%d\", thread_id(), i);\n\t\t\t// 进行 redis 客户端命令操作过程\n\t\t\tif (test_redis_string(*conn, key.c_str()) == false)\n\t\t\t{\n\t\t\t\tprintf(\"redis operation error\\r\\n\");\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\t// 回收连接对象至连接池中\n\t\t\tpool_.put(conn, true);\n\t\t}\n\n\t\treturn NULL;\n\t}\n\nprivate:\n\tacl::redis_cluster& cluster_;\n};\n\nvoid test_redis_manager(const char* redis_addr, int max_threads,\n\tint conn_timeout, int rw_timeout)\n{\n\t// 创建 redis 集群连接池对象\n\tacl::redis_client_cluster cluster;\n\n\t// 添加多个 redis-server 的服务器实例地址\n\tcluster.set(\"127.0.0.1:6379\", max_threads, conn_timeout, rw_timeout);\n\tcluster.set(\"127.0.0.1:6380\", max_threads, conn_timeout, rw_timeout);\n\tcluster.set(\"127.0.0.1:6381\", max_threads, conn_timeout, rw_timeout);\n\n\t// 创建一组子线程\n\tstd::vector<test_thread*> threads;\n\tfor (int i = 0; i < max_threads; i++)\n\t{\n\t\ttest_thread* thread = new test_thread(cluster);\n\t\tthreads.push_back(thread);\n\t\tthread->set_detachable(false);\n\t\tthread->start();\n\t}\n\n\t// 等待所有子线程正常退出\n\tstd::vector<test_thread*>::iterator it = threads.begin();\n\tfor (; it != threads.end(); ++it)\n\t{\n\t\t(*it)->wait();\n\t\tdelete (*it);\n\t}\n}\n```\n\n该示例只修改了几处代码便支持了集群 redis 连接池方式，其处理过程是：创建集群连接池对象（可以添加多个 redis-server 服务地址） --> 从集群连接池对象中取得一个连接池对象 ---> 从该连接池对象中取得一个连接 ---> 该连接对象与 redis 操作类对象绑定后进行操作。\n\n上述示例的集群模式并非是 redis3.0 的集群模式，这种集群中的 redis-server 之间是不互联的， 集群的建立是由客户端来维护的，由客户决定数据存储在哪个 redis-server 实例上；而 redis3.0 的集群方式则与之大不同，在 redis3.0 中，redis-server 之间是互联互通的，而且支持数据的冗余备份，数据的存储位置是由服务端决定的，下面的例子是支持 redis3.0 集群模式的客户端例子：\n\n### 3.4、支持 redis3.0 集群模式的示例代码如下：\n```c++\n// 统一的键值前缀\nstatic acl::string __keypre(\"test_key_cluster\");\n\n// 测试 redis 字符串添加功能\nstatic bool test_redis_string(acl::redis_string& cmd, int i)\n{\n\tacl::string key;\n\tkey.format(\"%s_%d\", __keypre.c_str(), i);\n\n\tacl::string value;\n\tvalue.format(\"value_%s\", key.c_str());\n\t\n\tbool ret = cmd.set(key.c_str(), value.c_str());\n\treturn ret;\n\tif (i < 10)\n\t\tprintf(\"set key: %s, value: %s %s\\r\\n\", key.c_str(),\n\t\t\tvalue.c_str(), ret ? \"ok\" : \"error\");\n\treturn ret;\n}\n\n// 测试 redis 键是否存在功能\nstatic bool test_redis_exists(acl::redis_key& cmd, int i)\n{\n\tacl::string key;\n\n\tkey.format(\"%s_%d\", __keypre.c_str(), i);\n\n\tif (cmd.exists(key.c_str()) == false)\n\t{\n\t\tif (i < 10)\n\t\t\tprintf(\"no exists key: %s\\r\\n\", key.c_str());\n\t}\n\telse\n\t{\n\t\tif (i < 10)\n\t\t\tprintf(\"exists key: %s\\r\\n\", key.c_str());\n\t}\n\treturn true;\n}\n\n// 子线程处理类\nclass test_thread : public acl::thread\n{\npublic:\n\ttest_thread(acl::redis_cluster& cluster, int max_conns)\n\t: cluster_(cluster), max_conns_(max_conns) {}\n\n\t~test_thread() {}\n\nprotected:\n\t// 基类（acl::thread）纯虚函数\n\tvirtual void* run()\n\t{\n\t\tacl::redis_string cmd_string;\n\t\tacl::redis_key  cmd_key;\n\t\t\n\t\t// 设置 redis 客户端命令的集群操作模式\n\t\tcmd_key.set_cluster(&cluster_, max_conns_);\n\t\tcmd_string.set_cluster(&cluster_, max_conns_);\n\t\tfor (int i = 0; i < 1000; i++)\n\t\t{\n\t\t\t// 进行 redis 客户端命令操作过程\n\t\t\tif (test_redis_string(cmd_string, i) == false)\n\t\t\t\tbreak;\n\t\n\t\t\tif (test_redis_exists(cmd_key, i) == false)\n\t\t\t\tbreak;\n\n\t\t\t// 重置客户端命令状态\n\n\t\t\tcmd_string.clear();\n\t\t\tcmd_key.clear();\n\t\t}\n\n\t\treturn NULL;\n\t}\n\nprivate:\n\tacl::redis_cluster& cluster_;\n\tint max_conns_;\n};\n\nvoid test_redis_cluster(int max_threads int conn_timeout, int rw_timeout)\n{\n\t// 创建 redis 集群连接池对象\n\tacl::redis_client_cluster cluster;\n\n\t// 添加一个或多个 redis-server 的服务器实例地址，不必一次加载所有\n\t// 的 redis-server 服务器地址，redis_cluster 及相关类具有自动发现\n\t// 及动态添加 redis-server 服务实例的功能\n\n\tcluster.set(\"127.0.0.1:6379\", max_threads, conn_timeout, rw_timeout);\n\t// cluster.set(\"127.0.0.1:6380\", max_threads, conn_timeout, rw_timeout);\n\t// cluster.set(\"127.0.0.1:6381\", max_threads, conn_timeout, rw_timeout);\n\n\t// 创建一组子线程\n\tstd::vector<test_thread*> threads;\n\tfor (int i = 0; i < max_threads; i++)\n\t{\n\t\ttest_thread* thread = new test_thread(cluster, max_threads);\n\t\tthreads.push_back(thread);\n\t\tthread->set_detachable(false);\n\t\tthread->start();\n\t}\n\n\t// 等待所有子线程正常退出\n\tstd::vector<test_thread*>::iterator it = threads.begin();\n\tfor (; it != threads.end(); ++it)\n\t{\n\t\t(*it)->wait();\n\t\tdelete (*it);\n\t}\n}\n```\n\n从上面例子可以看出，使用 acl redis 客户端库操作 redis3.0 集群时，只需要将集群的句柄注入到每个 redis 客户端命令即（如上面黄色部分所示）；至于如何与 redis 集群交互将由 redis_cluster 及 redis 客户端命令类的基类 redis_command 进行处理；此外，还需要注意示例 4）与示例 3）所支持的集群方式的不同点如下：\n\n- 示例3 的集群模式下实际上是由客户端根据所连接的所有 redis 服务器的集合来决定数据存储结点，而实际上 redis 服务器之间并不互联；而示例 4 则是真正意义的 redis 服务端的集群模式，所有 redis 服务结点之间是互联互通的（可以配置数据结点存储的冗余数量）；\n- 示例3 的客户端必须在开始初始化时添加所有的 redis 服务结点，以便于采用轮循或者哈希访问模式；而示例4 在初始化时只需添加至少一个集群中的服务结点即可，随着访问次数的增加，会根据需要动态添加 redis 服务结点（ redis3.0 采用的重定向机制，即当访问某个 redis 结点时，若 key 值不存在于该结点上，则其会返回给客户端一个重定向指令，告诉客户端存储该 key 的 redis 服务结点，因此，根据此特性，acl redis 集群会根据重定向信息动态添加 redis 集群中的服务结点）；\n- 此外，示例4 是兼容示例3 的。\n\n## 四、小结\n以上介绍了 acl 框架中新增加的 redis 库的使用方法及处理过程，该库将复杂的协议及网络处理过程隐藏在实现内部，使用户使用起来感觉象是在调用本的函数。在示例 2）、3） 中提到了 acl 线程的使用，有关 acl 库中更为详细地使用线程的文章参见：《使用 acl_cpp 库编写多线程程序》。\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl\n\n ","slug":"redis_client","published":1,"updated":"2023-01-24T08:53:12.775Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clda039u10000yr9ke63a02x3","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>（可以直接略过此段）redis 最近做为 nosql 数据服务应用越来越广泛，其相对于 memcached 的最大优点是提供了更加丰富的数据结构，所以应用场景就更为广泛。redis 的出现可谓是广大网络应用开发者的福音，同时有大量的开源人员贡献了客户端代码，象针对 java 语言的 jedis，php 语言的 phpredis&#x2F;predis 等，这些语言的 redis 库既丰富又好用，而对 C&#x2F;C++ 程序员似乎就没那么幸运了，官方提供了 C 版的 hiredis 作为客户端库，很多爱好者都是基于 hiredis 进行二次封装和开发形成了 C++ 客户端库，但这些库（包括官方的 hiredis）大都使用麻烦，给使用者造成了许多出错的机会。一直想开发一个更易用的接口型的 C++ 版 redis 客户端库（注：官方提供的库基本属于协议型的，这意味着使用者需要花费很多精力去填充各个协议字段同时还得要分析服务器可能返回的不同的结果类型），但每当看到 redis 那 150 多个客户端命令时便心生退缩，因为要给每个命令提供一个方便易用的 C++ 函数接口，则意味着非常巨大的开发工作量。</p>\n<p>在后来的多次项目开发中被官方的 hiredis 库屡次摧残后，终于忍受不了，决定重新开发一套全新的 redis 客户端 API，该库不仅要实现这 150 多个客户端命令，同时需要提供方便灵活的连接池及连接池集群管理功能（幸运的是在 acl 库中已经具备了通用的网络连接池及连接池集群管理模块），另外，根据之前的实践，有可能提供的函数接口要远大于这 150 多个，原因是针对同一个命令可能会因为不同的参数类型场景提供多个函数接口（最终的结果是提供了3，4百个函数 API，7000+行源码，2000+行头文件）；在仔细研究了 redis 的通信协议后便着手开始进行设计开发了（redis 的协议设计还是非常简单实用的，即能支持二进制，同时又便于手工调试）。在开发过程中大量参考了 <a href=\"http://redisdoc.com/\">http://redisdoc.com</a> 网站上的中文在线翻译版（非常感谢 黄键宏 同学的辛勤工作）。</p>\n<h2 id=\"二、acl-redis-库分类\"><a href=\"#二、acl-redis-库分类\" class=\"headerlink\" title=\"二、acl redis 库分类\"></a>二、acl redis 库分类</h2><p>根据 redis 的数据结构类型，分成 12 个大类，每个大类提供不同的函数接口，这 12 个 C++ 类展示如下：</p>\n<ul>\n<li>1、redis_key：redis 所有数据类型的统一键操作类；因为 redis 的数据结构类型都是基本的 KEY-VALUE 类型，其中 VALUE 分为不同的数据结构类型；</li>\n<li>2、redis_connectioin：与 redis-server 连接相关的类；</li>\n<li>3、redis_server：与 redis-server 服务管理相关的类；</li>\n<li>4、redis_string：redis 中用来表示字符串的数据类型；</li>\n<li>5、redis_hash：redis 中用来表示哈希表的数据类型；每一个数据对象由 “KEY-域值对集合” 组成，即一个 KEY 对应多个“域值对”，每个“域值对”由一个字段名与字段值组成；</li>\n<li>6、redis_list：redis 中用来表示列表的数据类型；</li>\n<li>7、redis_set：redis 中用来表示集合的数据类型；</li>\n<li>8、redis_zset：redis 中用来表示有序集合的数据类型；</li>\n<li>9、redis_pubsub：redis 中用来表示“发布-订阅”的数据类型；</li>\n<li>10、redis_hyperloglog：redis 中用来表示 hyperloglog 基数估值算法的数据类型；</li>\n<li>11、redis_script：redis 中用来与 lua 脚本进行转换交互的数据类型；</li>\n<li>12、redis_transaction：redis 中用以事务方式执行多条 redis 命令的数据类型（注：该事务处理方式与数据库的事务有很大不同，redis 中的事务处理过程没有数据库中的事务回滚机制，仅能保证其中的多条命令都被执行或都不被执行）；</li>\n</ul>\n<p>除了以上对应于官方 redis 命令的 12 个类别外，在 acl 库中还提供了另外几个类：</p>\n<ul>\n<li>13、redis_command：以上 12 个类的基类；</li>\n<li>14、redis_client：redis 客户端网络连接类；</li>\n<li>15、redis_result：redis 命令结果类；</li>\n<li>16、redis_pool：针对以上所有命令支持连接池方式；</li>\n<li>17、redis_manager：针对以上所有命令允许与多个 redis-server 服务建立连接池集群（即与每个 redis-server 建立一个连接池）；</li>\n<li>18、redis_cluster：支持 redis3.0 集群模式的类。</li>\n</ul>\n<h2 id=\"三、acl-redis-使用举例\"><a href=\"#三、acl-redis-使用举例\" class=\"headerlink\" title=\"三、acl redis 使用举例\"></a>三、acl redis 使用举例</h2><h3 id=\"3-1、下面是一个使用-acl-框架中-redis-客户端库的简单例子：\"><a href=\"#3-1、下面是一个使用-acl-框架中-redis-客户端库的简单例子：\" class=\"headerlink\" title=\"3.1、下面是一个使用 acl 框架中 redis 客户端库的简单例子：\"></a>3.1、下面是一个使用 acl 框架中 redis 客户端库的简单例子：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @param conn &#123;acl::redis_client&amp;&#125; redis 连接对象</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 操作过程是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_string</span><span class=\"hljs-params\">(acl::redis_client&amp; conn, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis string 类型的命令操作类对象，同时将连接类对象与操作类</span><br>\t<span class=\"hljs-comment\">// 对象进行绑定</span><br>\t<span class=\"hljs-function\">acl::redis_string <span class=\"hljs-title\">string_operation</span><span class=\"hljs-params\">(&amp;conn)</span></span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value = <span class=\"hljs-string\">&quot;test_value&quot;</span>;<br><br>\t<span class=\"hljs-comment\">// 添加 K-V 值至 redis-server 中</span><br>\t<span class=\"hljs-keyword\">if</span> (string_operation.<span class=\"hljs-built_in\">set</span>(key, value) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-type\">const</span> acl::redis_result* res = string_operation.<span class=\"hljs-built_in\">get_result</span>();<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;set key: %s error: %s\\r\\n&quot;</span>,<br>\t\t\tkey, res ? res-&gt;<span class=\"hljs-built_in\">get_error</span>() : <span class=\"hljs-string\">&quot;unknown error&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;set key: %s ok!\\r\\n&quot;</span>, key);<br><br>\t<span class=\"hljs-comment\">// 需要重置连接对象的状态</span><br>\tstring_operation.<span class=\"hljs-built_in\">clear</span>();<br><br>\t<span class=\"hljs-comment\">// 从 redis-server 中取得对应 key 的值</span><br>\tacl::string buf;<br>\t<span class=\"hljs-keyword\">if</span> (string_operation.<span class=\"hljs-built_in\">get</span>(key, buf) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-type\">const</span> acl::redis_result* res = string_operation.<span class=\"hljs-built_in\">get_result</span>();<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get key: %s error: %s\\r\\n&quot;</span>,<br>\t\t\tkey, res ? res-&gt;<span class=\"hljs-built_in\">get_error</span>() : <span class=\"hljs-string\">&quot;unknown error&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get key: %s ok, value: %s\\r\\n&quot;</span>, key, buf.<span class=\"hljs-built_in\">c_str</span>());<br><br>\t<span class=\"hljs-comment\">// 探测给定 key 是否存在于 redis-server 中，需要创建 redis 的 key</span><br>\t<span class=\"hljs-comment\">// 类对象，同时将 redis 连接对象与之绑定</span><br>\tacl::redis_key key_operation;<br>\tkey_operation.<span class=\"hljs-built_in\">set_client</span>(conn);  <span class=\"hljs-comment\">// 将连接对象与操作对象进行绑定</span><br>\t<span class=\"hljs-keyword\">if</span> (key_operation.<span class=\"hljs-built_in\">exists</span>(key) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (conn.<span class=\"hljs-built_in\">eof</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;disconnected from redis-server\\r\\n&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;key: %s not exists\\r\\n&quot;</span>, key);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;key: %s exists\\r\\n&quot;</span>, key);<br><br>\t<span class=\"hljs-comment\">// 删除指定 key 的字符串类对象</span><br>\t<span class=\"hljs-keyword\">if</span> (key_operation.<span class=\"hljs-built_in\">del</span>(key, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;del key: %s error\\r\\n&quot;</span>, key);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;del key: %s ok\\r\\n&quot;</span>, key);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @param redis_addr &#123;const char*&#125; redis-server 服务器地址，</span><br><span class=\"hljs-comment\"> *  格式为：ip:port，如：127.0.0.1:6379</span><br><span class=\"hljs-comment\"> * @param conn_timeout &#123;int&#125; 连接 redis-server 的超时时间(秒)</span><br><span class=\"hljs-comment\"> * @param rw_timeout &#123;int&#125; 与 redis-server 进行通信的 IO 超时时间(秒)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr, <span class=\"hljs-type\">int</span> conn_timeout, <span class=\"hljs-type\">int</span> rw_timeout)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis 客户端网络连接类对象</span><br>\t<span class=\"hljs-function\">acl::redis_client <span class=\"hljs-title\">conn</span><span class=\"hljs-params\">(redis_addr, conn_timeout, rw_timeout)</span></span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key = <span class=\"hljs-string\">&quot;test_key&quot;</span>;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">test_redis_string</span>(conn, key);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的简单例子的操作过程是：在 redis-server 中添加字符串类型数据 –&gt; 从 redis-server 中获取指定的字符串数据 –&gt; 判断指定指定 key 的对象在 redis-server 上是否存在 —&gt; 从 redis-server 中删除指定 key 的数据对象（即该例中的字符串对象）。通过以上简单示例，使用者需要注意以下几点：</p>\n<ul>\n<li>acl 中的 redis 库的设计中 redis 连接类对象与命令操作类对象是分离的，12 个 redis 命令操作类对应 acl  redis 库中相应的 12 个命令操作类；</li>\n<li>在使用 redis 命令操作类时需要先将 redis 连接类对象与命令操作类对象进行绑定（以便于操作类内部可以利连接类中的网络连接、协议组包以及协议解析等方法）；</li>\n<li>在重复使用一个 redis 命令类对象时，需要首先重置该命令类对象的状态（即调用：clear()），这样主要是为了释放上一次命令操作过程的中间内存资源；</li>\n<li>一个 redis 连接类对象可以被多个命令类操作类对象使用（使用前需先绑定一次）；</li>\n<li>将 redis 连接对象与命令操作对象绑定有两种方式：可以在构造函数中传入非空 redis 连接对象，或调用操作对象的 set_client 方法进行绑定。</li>\n</ul>\n<h3 id=\"3-2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：\"><a href=\"#3-2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：\" class=\"headerlink\" title=\"3.2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：\"></a>3.2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @param conn &#123;acl::redis_client&amp;&#125; redis 连接对象</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 操作过程是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_string</span><span class=\"hljs-params\">(acl::redis_client&amp; conn, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t...... <span class=\"hljs-comment\">// 代码与上述代码相同，省略</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 子线程处理类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">test_thread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">test_thread</span>(acl::redis_pool&amp; pool) : <span class=\"hljs-built_in\">pool_</span>(pool) &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">test_thread</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类（acl::thread）纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tacl::string key;<br>\t\t<span class=\"hljs-comment\">// 给每个线程一个自己的 key，以便以测试，其中 thread_id()</span><br>\t\t<span class=\"hljs-comment\">// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号</span><br>\t\tkey.format(<span class=\"hljs-string\">&quot;test_key: %lu&quot;</span>, <span class=\"hljs-built_in\">thread_id</span>());<br><br>\t\tacl::redis_client* conn;<br><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 从 redis 客户端连接池中获取一个 redis 连接对象</span><br>\t\t\tconn = (acl::redis_client*) pool_.<span class=\"hljs-built_in\">peek</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;peek redis connection error\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 进行 redis 客户端命令操作过程</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">test_redis_string</span>(*conn) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;redis operation error\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 回收连接对象</span><br>\t\t\tpool_.<span class=\"hljs-built_in\">put</span>(conn, <span class=\"hljs-literal\">true</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tacl::redis_pool&amp; pool_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_redis_pool</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr, <span class=\"hljs-type\">int</span> max_threads,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">int</span> conn_timeout, <span class=\"hljs-type\">int</span> rw_timeout)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis 连接池对象</span><br>\t<span class=\"hljs-function\">acl::redis_client_pool <span class=\"hljs-title\">pool</span><span class=\"hljs-params\">(redis_addr, max_threads)</span></span>;<br>\t<span class=\"hljs-comment\">// 设置连接 redis 的超时时间及 IO 超时时间，单位都是秒</span><br>\tpool.<span class=\"hljs-built_in\">set_timeout</span>(conn_timeout, rw_timeout);<br><br>\t<span class=\"hljs-comment\">// 创建一组子线程</span><br>\tstd::vector&lt;test_thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_threads; i++)<br>\t&#123;<br>\t\ttest_thread* thread = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">test_thread</span>(pool);<br>\t\tthreads.<span class=\"hljs-built_in\">push_back</span>(thread);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">false</span>);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">start</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 等待所有子线程正常退出</span><br>\tstd::vector&lt;test_thread*&gt;::iterator it = threads.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != threads.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\t(*it)-&gt;<span class=\"hljs-built_in\">wait</span>();<br>\t\t<span class=\"hljs-built_in\">delete</span> (*it);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>除了创建线程及 redis 连接池外，上面的例子与示例 1） 的代码与功能无异。</p>\n<h3 id=\"3-3、下面对上面的示例2）稍作修改，使之可以支持-redis-集群连接池的方式，示例代码如下：\"><a href=\"#3-3、下面对上面的示例2）稍作修改，使之可以支持-redis-集群连接池的方式，示例代码如下：\" class=\"headerlink\" title=\"3.3、下面对上面的示例2）稍作修改，使之可以支持 redis 集群连接池的方式，示例代码如下：\"></a>3.3、下面对上面的示例2）稍作修改，使之可以支持 redis 集群连接池的方式，示例代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @param conn &#123;acl::redis_client&amp;&#125; redis 连接对象</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 操作过程是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_string</span><span class=\"hljs-params\">(acl::redis_client&amp; conn, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t......  <span class=\"hljs-comment\">// 与上面示例代码相同，略去</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 子线程处理类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">test_thread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">test_thread</span>(acl::redis_cluster&amp; cluster) : <span class=\"hljs-built_in\">cluster_</span>(cluster) &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">test_thread</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类（acl::thread）纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tacl::string key;<br>\t\tacl::redis_client_pool* pool;<br>\t\tacl::redis_client* conn;<br><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 从连接池集群管理器中获得一个 redis-server 的连接池对象</span><br>\t\t\tpool = (acl::redis_client_pool*) cluster_.<span class=\"hljs-built_in\">peek</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (pool == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;peek connection pool failed\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 从 redis 客户端连接池中获取一个 redis 连接对象</span><br>\t\t\tconn = (acl::redis_client*) pool_.<span class=\"hljs-built_in\">peek</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;peek redis connection error\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 给每个线程一个自己的 key，以便以测试，其中 thread_id()</span><br>\t\t\t<span class=\"hljs-comment\">// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号</span><br>\t\t\tkey.format(<span class=\"hljs-string\">&quot;test_key: %lu_%d&quot;</span>, <span class=\"hljs-built_in\">thread_id</span>(), i);<br>\t\t\t<span class=\"hljs-comment\">// 进行 redis 客户端命令操作过程</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">test_redis_string</span>(*conn, key.<span class=\"hljs-built_in\">c_str</span>()) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;redis operation error\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 回收连接对象至连接池中</span><br>\t\t\tpool_.<span class=\"hljs-built_in\">put</span>(conn, <span class=\"hljs-literal\">true</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tacl::redis_cluster&amp; cluster_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_redis_manager</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr, <span class=\"hljs-type\">int</span> max_threads,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">int</span> conn_timeout, <span class=\"hljs-type\">int</span> rw_timeout)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis 集群连接池对象</span><br>\tacl::redis_client_cluster cluster;<br><br>\t<span class=\"hljs-comment\">// 添加多个 redis-server 的服务器实例地址</span><br>\tcluster.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&quot;127.0.0.1:6379&quot;</span>, max_threads, conn_timeout, rw_timeout);<br>\tcluster.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&quot;127.0.0.1:6380&quot;</span>, max_threads, conn_timeout, rw_timeout);<br>\tcluster.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&quot;127.0.0.1:6381&quot;</span>, max_threads, conn_timeout, rw_timeout);<br><br>\t<span class=\"hljs-comment\">// 创建一组子线程</span><br>\tstd::vector&lt;test_thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_threads; i++)<br>\t&#123;<br>\t\ttest_thread* thread = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">test_thread</span>(cluster);<br>\t\tthreads.<span class=\"hljs-built_in\">push_back</span>(thread);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">false</span>);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">start</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 等待所有子线程正常退出</span><br>\tstd::vector&lt;test_thread*&gt;::iterator it = threads.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != threads.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\t(*it)-&gt;<span class=\"hljs-built_in\">wait</span>();<br>\t\t<span class=\"hljs-built_in\">delete</span> (*it);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该示例只修改了几处代码便支持了集群 redis 连接池方式，其处理过程是：创建集群连接池对象（可以添加多个 redis-server 服务地址） –&gt; 从集群连接池对象中取得一个连接池对象 —&gt; 从该连接池对象中取得一个连接 —&gt; 该连接对象与 redis 操作类对象绑定后进行操作。</p>\n<p>上述示例的集群模式并非是 redis3.0 的集群模式，这种集群中的 redis-server 之间是不互联的， 集群的建立是由客户端来维护的，由客户决定数据存储在哪个 redis-server 实例上；而 redis3.0 的集群方式则与之大不同，在 redis3.0 中，redis-server 之间是互联互通的，而且支持数据的冗余备份，数据的存储位置是由服务端决定的，下面的例子是支持 redis3.0 集群模式的客户端例子：</p>\n<h3 id=\"3-4、支持-redis3-0-集群模式的示例代码如下：\"><a href=\"#3-4、支持-redis3-0-集群模式的示例代码如下：\" class=\"headerlink\" title=\"3.4、支持 redis3.0 集群模式的示例代码如下：\"></a>3.4、支持 redis3.0 集群模式的示例代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 统一的键值前缀</span><br><span class=\"hljs-type\">static</span> acl::string __keypre(<span class=\"hljs-string\">&quot;test_key_cluster&quot;</span>);<br><br><span class=\"hljs-comment\">// 测试 redis 字符串添加功能</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_string</span><span class=\"hljs-params\">(acl::redis_string&amp; cmd, <span class=\"hljs-type\">int</span> i)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::string key;<br>\tkey.format(<span class=\"hljs-string\">&quot;%s_%d&quot;</span>, __keypre.<span class=\"hljs-built_in\">c_str</span>(), i);<br><br>\tacl::string value;<br>\tvalue.format(<span class=\"hljs-string\">&quot;value_%s&quot;</span>, key.<span class=\"hljs-built_in\">c_str</span>());<br>\t<br>\t<span class=\"hljs-type\">bool</span> ret = cmd.<span class=\"hljs-built_in\">set</span>(key.<span class=\"hljs-built_in\">c_str</span>(), value.<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-keyword\">return</span> ret;<br>\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;set key: %s, value: %s %s\\r\\n&quot;</span>, key.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tvalue.<span class=\"hljs-built_in\">c_str</span>(), ret ? <span class=\"hljs-string\">&quot;ok&quot;</span> : <span class=\"hljs-string\">&quot;error&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br><br><span class=\"hljs-comment\">// 测试 redis 键是否存在功能</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_exists</span><span class=\"hljs-params\">(acl::redis_key&amp; cmd, <span class=\"hljs-type\">int</span> i)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::string key;<br><br>\tkey.format(<span class=\"hljs-string\">&quot;%s_%d&quot;</span>, __keypre.<span class=\"hljs-built_in\">c_str</span>(), i);<br><br>\t<span class=\"hljs-keyword\">if</span> (cmd.<span class=\"hljs-built_in\">exists</span>(key.<span class=\"hljs-built_in\">c_str</span>()) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;no exists key: %s\\r\\n&quot;</span>, key.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;exists key: %s\\r\\n&quot;</span>, key.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 子线程处理类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">test_thread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">test_thread</span>(acl::redis_cluster&amp; cluster, <span class=\"hljs-type\">int</span> max_conns)<br>\t: <span class=\"hljs-built_in\">cluster_</span>(cluster), <span class=\"hljs-built_in\">max_conns_</span>(max_conns) &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">test_thread</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类（acl::thread）纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tacl::redis_string cmd_string;<br>\t\tacl::redis_key  cmd_key;<br>\t\t<br>\t\t<span class=\"hljs-comment\">// 设置 redis 客户端命令的集群操作模式</span><br>\t\tcmd_key.<span class=\"hljs-built_in\">set_cluster</span>(&amp;cluster_, max_conns_);<br>\t\tcmd_string.<span class=\"hljs-built_in\">set_cluster</span>(&amp;cluster_, max_conns_);<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 进行 redis 客户端命令操作过程</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">test_redis_string</span>(cmd_string, i) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">test_redis_exists</span>(cmd_key, i) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br><br>\t\t\t<span class=\"hljs-comment\">// 重置客户端命令状态</span><br><br>\t\t\tcmd_string.<span class=\"hljs-built_in\">clear</span>();<br>\t\t\tcmd_key.<span class=\"hljs-built_in\">clear</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tacl::redis_cluster&amp; cluster_;<br>\t<span class=\"hljs-type\">int</span> max_conns_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_redis_cluster</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> max_threads <span class=\"hljs-type\">int</span> conn_timeout, <span class=\"hljs-type\">int</span> rw_timeout)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis 集群连接池对象</span><br>\tacl::redis_client_cluster cluster;<br><br>\t<span class=\"hljs-comment\">// 添加一个或多个 redis-server 的服务器实例地址，不必一次加载所有</span><br>\t<span class=\"hljs-comment\">// 的 redis-server 服务器地址，redis_cluster 及相关类具有自动发现</span><br>\t<span class=\"hljs-comment\">// 及动态添加 redis-server 服务实例的功能</span><br><br>\tcluster.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&quot;127.0.0.1:6379&quot;</span>, max_threads, conn_timeout, rw_timeout);<br>\t<span class=\"hljs-comment\">// cluster.set(&quot;127.0.0.1:6380&quot;, max_threads, conn_timeout, rw_timeout);</span><br>\t<span class=\"hljs-comment\">// cluster.set(&quot;127.0.0.1:6381&quot;, max_threads, conn_timeout, rw_timeout);</span><br><br>\t<span class=\"hljs-comment\">// 创建一组子线程</span><br>\tstd::vector&lt;test_thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_threads; i++)<br>\t&#123;<br>\t\ttest_thread* thread = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">test_thread</span>(cluster, max_threads);<br>\t\tthreads.<span class=\"hljs-built_in\">push_back</span>(thread);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">false</span>);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">start</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 等待所有子线程正常退出</span><br>\tstd::vector&lt;test_thread*&gt;::iterator it = threads.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != threads.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\t(*it)-&gt;<span class=\"hljs-built_in\">wait</span>();<br>\t\t<span class=\"hljs-built_in\">delete</span> (*it);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面例子可以看出，使用 acl redis 客户端库操作 redis3.0 集群时，只需要将集群的句柄注入到每个 redis 客户端命令即（如上面黄色部分所示）；至于如何与 redis 集群交互将由 redis_cluster 及 redis 客户端命令类的基类 redis_command 进行处理；此外，还需要注意示例 4）与示例 3）所支持的集群方式的不同点如下：</p>\n<ul>\n<li>示例3 的集群模式下实际上是由客户端根据所连接的所有 redis 服务器的集合来决定数据存储结点，而实际上 redis 服务器之间并不互联；而示例 4 则是真正意义的 redis 服务端的集群模式，所有 redis 服务结点之间是互联互通的（可以配置数据结点存储的冗余数量）；</li>\n<li>示例3 的客户端必须在开始初始化时添加所有的 redis 服务结点，以便于采用轮循或者哈希访问模式；而示例4 在初始化时只需添加至少一个集群中的服务结点即可，随着访问次数的增加，会根据需要动态添加 redis 服务结点（ redis3.0 采用的重定向机制，即当访问某个 redis 结点时，若 key 值不存在于该结点上，则其会返回给客户端一个重定向指令，告诉客户端存储该 key 的 redis 服务结点，因此，根据此特性，acl redis 集群会根据重定向信息动态添加 redis 集群中的服务结点）；</li>\n<li>此外，示例4 是兼容示例3 的。</li>\n</ul>\n<h2 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h2><p>以上介绍了 acl 框架中新增加的 redis 库的使用方法及处理过程，该库将复杂的协议及网络处理过程隐藏在实现内部，使用户使用起来感觉象是在调用本的函数。在示例 2）、3） 中提到了 acl 线程的使用，有关 acl 库中更为详细地使用线程的文章参见：《使用 acl_cpp 库编写多线程程序》。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>（可以直接略过此段）redis 最近做为 nosql 数据服务应用越来越广泛，其相对于 memcached 的最大优点是提供了更加丰富的数据结构，所以应用场景就更为广泛。redis 的出现可谓是广大网络应用开发者的福音，同时有大量的开源人员贡献了客户端代码，象针对 java 语言的 jedis，php 语言的 phpredis&#x2F;predis 等，这些语言的 redis 库既丰富又好用，而对 C&#x2F;C++ 程序员似乎就没那么幸运了，官方提供了 C 版的 hiredis 作为客户端库，很多爱好者都是基于 hiredis 进行二次封装和开发形成了 C++ 客户端库，但这些库（包括官方的 hiredis）大都使用麻烦，给使用者造成了许多出错的机会。一直想开发一个更易用的接口型的 C++ 版 redis 客户端库（注：官方提供的库基本属于协议型的，这意味着使用者需要花费很多精力去填充各个协议字段同时还得要分析服务器可能返回的不同的结果类型），但每当看到 redis 那 150 多个客户端命令时便心生退缩，因为要给每个命令提供一个方便易用的 C++ 函数接口，则意味着非常巨大的开发工作量。</p>\n<p>在后来的多次项目开发中被官方的 hiredis 库屡次摧残后，终于忍受不了，决定重新开发一套全新的 redis 客户端 API，该库不仅要实现这 150 多个客户端命令，同时需要提供方便灵活的连接池及连接池集群管理功能（幸运的是在 acl 库中已经具备了通用的网络连接池及连接池集群管理模块），另外，根据之前的实践，有可能提供的函数接口要远大于这 150 多个，原因是针对同一个命令可能会因为不同的参数类型场景提供多个函数接口（最终的结果是提供了3，4百个函数 API，7000+行源码，2000+行头文件）；在仔细研究了 redis 的通信协议后便着手开始进行设计开发了（redis 的协议设计还是非常简单实用的，即能支持二进制，同时又便于手工调试）。在开发过程中大量参考了 <a href=\"http://redisdoc.com/\">http://redisdoc.com</a> 网站上的中文在线翻译版（非常感谢 黄键宏 同学的辛勤工作）。</p>\n<h2 id=\"二、acl-redis-库分类\"><a href=\"#二、acl-redis-库分类\" class=\"headerlink\" title=\"二、acl redis 库分类\"></a>二、acl redis 库分类</h2><p>根据 redis 的数据结构类型，分成 12 个大类，每个大类提供不同的函数接口，这 12 个 C++ 类展示如下：</p>\n<ul>\n<li>1、redis_key：redis 所有数据类型的统一键操作类；因为 redis 的数据结构类型都是基本的 KEY-VALUE 类型，其中 VALUE 分为不同的数据结构类型；</li>\n<li>2、redis_connectioin：与 redis-server 连接相关的类；</li>\n<li>3、redis_server：与 redis-server 服务管理相关的类；</li>\n<li>4、redis_string：redis 中用来表示字符串的数据类型；</li>\n<li>5、redis_hash：redis 中用来表示哈希表的数据类型；每一个数据对象由 “KEY-域值对集合” 组成，即一个 KEY 对应多个“域值对”，每个“域值对”由一个字段名与字段值组成；</li>\n<li>6、redis_list：redis 中用来表示列表的数据类型；</li>\n<li>7、redis_set：redis 中用来表示集合的数据类型；</li>\n<li>8、redis_zset：redis 中用来表示有序集合的数据类型；</li>\n<li>9、redis_pubsub：redis 中用来表示“发布-订阅”的数据类型；</li>\n<li>10、redis_hyperloglog：redis 中用来表示 hyperloglog 基数估值算法的数据类型；</li>\n<li>11、redis_script：redis 中用来与 lua 脚本进行转换交互的数据类型；</li>\n<li>12、redis_transaction：redis 中用以事务方式执行多条 redis 命令的数据类型（注：该事务处理方式与数据库的事务有很大不同，redis 中的事务处理过程没有数据库中的事务回滚机制，仅能保证其中的多条命令都被执行或都不被执行）；</li>\n</ul>\n<p>除了以上对应于官方 redis 命令的 12 个类别外，在 acl 库中还提供了另外几个类：</p>\n<ul>\n<li>13、redis_command：以上 12 个类的基类；</li>\n<li>14、redis_client：redis 客户端网络连接类；</li>\n<li>15、redis_result：redis 命令结果类；</li>\n<li>16、redis_pool：针对以上所有命令支持连接池方式；</li>\n<li>17、redis_manager：针对以上所有命令允许与多个 redis-server 服务建立连接池集群（即与每个 redis-server 建立一个连接池）；</li>\n<li>18、redis_cluster：支持 redis3.0 集群模式的类。</li>\n</ul>\n<h2 id=\"三、acl-redis-使用举例\"><a href=\"#三、acl-redis-使用举例\" class=\"headerlink\" title=\"三、acl redis 使用举例\"></a>三、acl redis 使用举例</h2><h3 id=\"3-1、下面是一个使用-acl-框架中-redis-客户端库的简单例子：\"><a href=\"#3-1、下面是一个使用-acl-框架中-redis-客户端库的简单例子：\" class=\"headerlink\" title=\"3.1、下面是一个使用 acl 框架中 redis 客户端库的简单例子：\"></a>3.1、下面是一个使用 acl 框架中 redis 客户端库的简单例子：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @param conn &#123;acl::redis_client&amp;&#125; redis 连接对象</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 操作过程是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_string</span><span class=\"hljs-params\">(acl::redis_client&amp; conn, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis string 类型的命令操作类对象，同时将连接类对象与操作类</span><br>\t<span class=\"hljs-comment\">// 对象进行绑定</span><br>\t<span class=\"hljs-function\">acl::redis_string <span class=\"hljs-title\">string_operation</span><span class=\"hljs-params\">(&amp;conn)</span></span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* value = <span class=\"hljs-string\">&quot;test_value&quot;</span>;<br><br>\t<span class=\"hljs-comment\">// 添加 K-V 值至 redis-server 中</span><br>\t<span class=\"hljs-keyword\">if</span> (string_operation.<span class=\"hljs-built_in\">set</span>(key, value) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-type\">const</span> acl::redis_result* res = string_operation.<span class=\"hljs-built_in\">get_result</span>();<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;set key: %s error: %s\\r\\n&quot;</span>,<br>\t\t\tkey, res ? res-&gt;<span class=\"hljs-built_in\">get_error</span>() : <span class=\"hljs-string\">&quot;unknown error&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;set key: %s ok!\\r\\n&quot;</span>, key);<br><br>\t<span class=\"hljs-comment\">// 需要重置连接对象的状态</span><br>\tstring_operation.<span class=\"hljs-built_in\">clear</span>();<br><br>\t<span class=\"hljs-comment\">// 从 redis-server 中取得对应 key 的值</span><br>\tacl::string buf;<br>\t<span class=\"hljs-keyword\">if</span> (string_operation.<span class=\"hljs-built_in\">get</span>(key, buf) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-type\">const</span> acl::redis_result* res = string_operation.<span class=\"hljs-built_in\">get_result</span>();<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get key: %s error: %s\\r\\n&quot;</span>,<br>\t\t\tkey, res ? res-&gt;<span class=\"hljs-built_in\">get_error</span>() : <span class=\"hljs-string\">&quot;unknown error&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;get key: %s ok, value: %s\\r\\n&quot;</span>, key, buf.<span class=\"hljs-built_in\">c_str</span>());<br><br>\t<span class=\"hljs-comment\">// 探测给定 key 是否存在于 redis-server 中，需要创建 redis 的 key</span><br>\t<span class=\"hljs-comment\">// 类对象，同时将 redis 连接对象与之绑定</span><br>\tacl::redis_key key_operation;<br>\tkey_operation.<span class=\"hljs-built_in\">set_client</span>(conn);  <span class=\"hljs-comment\">// 将连接对象与操作对象进行绑定</span><br>\t<span class=\"hljs-keyword\">if</span> (key_operation.<span class=\"hljs-built_in\">exists</span>(key) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (conn.<span class=\"hljs-built_in\">eof</span>())<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;disconnected from redis-server\\r\\n&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;key: %s not exists\\r\\n&quot;</span>, key);<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;key: %s exists\\r\\n&quot;</span>, key);<br><br>\t<span class=\"hljs-comment\">// 删除指定 key 的字符串类对象</span><br>\t<span class=\"hljs-keyword\">if</span> (key_operation.<span class=\"hljs-built_in\">del</span>(key, <span class=\"hljs-literal\">NULL</span>) &lt; <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;del key: %s error\\r\\n&quot;</span>, key);<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;del key: %s ok\\r\\n&quot;</span>, key);<br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @param redis_addr &#123;const char*&#125; redis-server 服务器地址，</span><br><span class=\"hljs-comment\"> *  格式为：ip:port，如：127.0.0.1:6379</span><br><span class=\"hljs-comment\"> * @param conn_timeout &#123;int&#125; 连接 redis-server 的超时时间(秒)</span><br><span class=\"hljs-comment\"> * @param rw_timeout &#123;int&#125; 与 redis-server 进行通信的 IO 超时时间(秒)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr, <span class=\"hljs-type\">int</span> conn_timeout, <span class=\"hljs-type\">int</span> rw_timeout)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis 客户端网络连接类对象</span><br>\t<span class=\"hljs-function\">acl::redis_client <span class=\"hljs-title\">conn</span><span class=\"hljs-params\">(redis_addr, conn_timeout, rw_timeout)</span></span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key = <span class=\"hljs-string\">&quot;test_key&quot;</span>;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-built_in\">test_redis_string</span>(conn, key);<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的简单例子的操作过程是：在 redis-server 中添加字符串类型数据 –&gt; 从 redis-server 中获取指定的字符串数据 –&gt; 判断指定指定 key 的对象在 redis-server 上是否存在 —&gt; 从 redis-server 中删除指定 key 的数据对象（即该例中的字符串对象）。通过以上简单示例，使用者需要注意以下几点：</p>\n<ul>\n<li>acl 中的 redis 库的设计中 redis 连接类对象与命令操作类对象是分离的，12 个 redis 命令操作类对应 acl  redis 库中相应的 12 个命令操作类；</li>\n<li>在使用 redis 命令操作类时需要先将 redis 连接类对象与命令操作类对象进行绑定（以便于操作类内部可以利连接类中的网络连接、协议组包以及协议解析等方法）；</li>\n<li>在重复使用一个 redis 命令类对象时，需要首先重置该命令类对象的状态（即调用：clear()），这样主要是为了释放上一次命令操作过程的中间内存资源；</li>\n<li>一个 redis 连接类对象可以被多个命令类操作类对象使用（使用前需先绑定一次）；</li>\n<li>将 redis 连接对象与命令操作对象绑定有两种方式：可以在构造函数中传入非空 redis 连接对象，或调用操作对象的 set_client 方法进行绑定。</li>\n</ul>\n<h3 id=\"3-2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：\"><a href=\"#3-2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：\" class=\"headerlink\" title=\"3.2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：\"></a>3.2、对上面的例子稍加修改，使之能够支持连接池方式，示例代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @param conn &#123;acl::redis_client&amp;&#125; redis 连接对象</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 操作过程是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_string</span><span class=\"hljs-params\">(acl::redis_client&amp; conn, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t...... <span class=\"hljs-comment\">// 代码与上述代码相同，省略</span><br><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 子线程处理类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">test_thread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">test_thread</span>(acl::redis_pool&amp; pool) : <span class=\"hljs-built_in\">pool_</span>(pool) &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">test_thread</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类（acl::thread）纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tacl::string key;<br>\t\t<span class=\"hljs-comment\">// 给每个线程一个自己的 key，以便以测试，其中 thread_id()</span><br>\t\t<span class=\"hljs-comment\">// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号</span><br>\t\tkey.format(<span class=\"hljs-string\">&quot;test_key: %lu&quot;</span>, <span class=\"hljs-built_in\">thread_id</span>());<br><br>\t\tacl::redis_client* conn;<br><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 从 redis 客户端连接池中获取一个 redis 连接对象</span><br>\t\t\tconn = (acl::redis_client*) pool_.<span class=\"hljs-built_in\">peek</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;peek redis connection error\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 进行 redis 客户端命令操作过程</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">test_redis_string</span>(*conn) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;redis operation error\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 回收连接对象</span><br>\t\t\tpool_.<span class=\"hljs-built_in\">put</span>(conn, <span class=\"hljs-literal\">true</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tacl::redis_pool&amp; pool_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_redis_pool</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr, <span class=\"hljs-type\">int</span> max_threads,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">int</span> conn_timeout, <span class=\"hljs-type\">int</span> rw_timeout)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis 连接池对象</span><br>\t<span class=\"hljs-function\">acl::redis_client_pool <span class=\"hljs-title\">pool</span><span class=\"hljs-params\">(redis_addr, max_threads)</span></span>;<br>\t<span class=\"hljs-comment\">// 设置连接 redis 的超时时间及 IO 超时时间，单位都是秒</span><br>\tpool.<span class=\"hljs-built_in\">set_timeout</span>(conn_timeout, rw_timeout);<br><br>\t<span class=\"hljs-comment\">// 创建一组子线程</span><br>\tstd::vector&lt;test_thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_threads; i++)<br>\t&#123;<br>\t\ttest_thread* thread = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">test_thread</span>(pool);<br>\t\tthreads.<span class=\"hljs-built_in\">push_back</span>(thread);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">false</span>);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">start</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 等待所有子线程正常退出</span><br>\tstd::vector&lt;test_thread*&gt;::iterator it = threads.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != threads.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\t(*it)-&gt;<span class=\"hljs-built_in\">wait</span>();<br>\t\t<span class=\"hljs-built_in\">delete</span> (*it);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>除了创建线程及 redis 连接池外，上面的例子与示例 1） 的代码与功能无异。</p>\n<h3 id=\"3-3、下面对上面的示例2）稍作修改，使之可以支持-redis-集群连接池的方式，示例代码如下：\"><a href=\"#3-3、下面对上面的示例2）稍作修改，使之可以支持-redis-集群连接池的方式，示例代码如下：\" class=\"headerlink\" title=\"3.3、下面对上面的示例2）稍作修改，使之可以支持 redis 集群连接池的方式，示例代码如下：\"></a>3.3、下面对上面的示例2）稍作修改，使之可以支持 redis 集群连接池的方式，示例代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * @param conn &#123;acl::redis_client&amp;&#125; redis 连接对象</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 操作过程是否成功</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_string</span><span class=\"hljs-params\">(acl::redis_client&amp; conn, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* key)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t......  <span class=\"hljs-comment\">// 与上面示例代码相同，略去</span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 子线程处理类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">test_thread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">test_thread</span>(acl::redis_cluster&amp; cluster) : <span class=\"hljs-built_in\">cluster_</span>(cluster) &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">test_thread</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类（acl::thread）纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tacl::string key;<br>\t\tacl::redis_client_pool* pool;<br>\t\tacl::redis_client* conn;<br><br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 从连接池集群管理器中获得一个 redis-server 的连接池对象</span><br>\t\t\tpool = (acl::redis_client_pool*) cluster_.<span class=\"hljs-built_in\">peek</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (pool == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;peek connection pool failed\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 从 redis 客户端连接池中获取一个 redis 连接对象</span><br>\t\t\tconn = (acl::redis_client*) pool_.<span class=\"hljs-built_in\">peek</span>();<br>\t\t\t<span class=\"hljs-keyword\">if</span> (conn == <span class=\"hljs-literal\">NULL</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;peek redis connection error\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 给每个线程一个自己的 key，以便以测试，其中 thread_id()</span><br>\t\t\t<span class=\"hljs-comment\">// 函数是基类 acl::thread 的方法，用来获取线程唯一 ID 号</span><br>\t\t\tkey.format(<span class=\"hljs-string\">&quot;test_key: %lu_%d&quot;</span>, <span class=\"hljs-built_in\">thread_id</span>(), i);<br>\t\t\t<span class=\"hljs-comment\">// 进行 redis 客户端命令操作过程</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">test_redis_string</span>(*conn, key.<span class=\"hljs-built_in\">c_str</span>()) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t&#123;<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;redis operation error\\r\\n&quot;</span>);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br><br>\t\t\t<span class=\"hljs-comment\">// 回收连接对象至连接池中</span><br>\t\t\tpool_.<span class=\"hljs-built_in\">put</span>(conn, <span class=\"hljs-literal\">true</span>);<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tacl::redis_cluster&amp; cluster_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_redis_manager</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* redis_addr, <span class=\"hljs-type\">int</span> max_threads,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">int</span> conn_timeout, <span class=\"hljs-type\">int</span> rw_timeout)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis 集群连接池对象</span><br>\tacl::redis_client_cluster cluster;<br><br>\t<span class=\"hljs-comment\">// 添加多个 redis-server 的服务器实例地址</span><br>\tcluster.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&quot;127.0.0.1:6379&quot;</span>, max_threads, conn_timeout, rw_timeout);<br>\tcluster.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&quot;127.0.0.1:6380&quot;</span>, max_threads, conn_timeout, rw_timeout);<br>\tcluster.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&quot;127.0.0.1:6381&quot;</span>, max_threads, conn_timeout, rw_timeout);<br><br>\t<span class=\"hljs-comment\">// 创建一组子线程</span><br>\tstd::vector&lt;test_thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_threads; i++)<br>\t&#123;<br>\t\ttest_thread* thread = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">test_thread</span>(cluster);<br>\t\tthreads.<span class=\"hljs-built_in\">push_back</span>(thread);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">false</span>);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">start</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 等待所有子线程正常退出</span><br>\tstd::vector&lt;test_thread*&gt;::iterator it = threads.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != threads.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\t(*it)-&gt;<span class=\"hljs-built_in\">wait</span>();<br>\t\t<span class=\"hljs-built_in\">delete</span> (*it);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该示例只修改了几处代码便支持了集群 redis 连接池方式，其处理过程是：创建集群连接池对象（可以添加多个 redis-server 服务地址） –&gt; 从集群连接池对象中取得一个连接池对象 —&gt; 从该连接池对象中取得一个连接 —&gt; 该连接对象与 redis 操作类对象绑定后进行操作。</p>\n<p>上述示例的集群模式并非是 redis3.0 的集群模式，这种集群中的 redis-server 之间是不互联的， 集群的建立是由客户端来维护的，由客户决定数据存储在哪个 redis-server 实例上；而 redis3.0 的集群方式则与之大不同，在 redis3.0 中，redis-server 之间是互联互通的，而且支持数据的冗余备份，数据的存储位置是由服务端决定的，下面的例子是支持 redis3.0 集群模式的客户端例子：</p>\n<h3 id=\"3-4、支持-redis3-0-集群模式的示例代码如下：\"><a href=\"#3-4、支持-redis3-0-集群模式的示例代码如下：\" class=\"headerlink\" title=\"3.4、支持 redis3.0 集群模式的示例代码如下：\"></a>3.4、支持 redis3.0 集群模式的示例代码如下：</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 统一的键值前缀</span><br><span class=\"hljs-type\">static</span> acl::string __keypre(<span class=\"hljs-string\">&quot;test_key_cluster&quot;</span>);<br><br><span class=\"hljs-comment\">// 测试 redis 字符串添加功能</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_string</span><span class=\"hljs-params\">(acl::redis_string&amp; cmd, <span class=\"hljs-type\">int</span> i)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::string key;<br>\tkey.format(<span class=\"hljs-string\">&quot;%s_%d&quot;</span>, __keypre.<span class=\"hljs-built_in\">c_str</span>(), i);<br><br>\tacl::string value;<br>\tvalue.format(<span class=\"hljs-string\">&quot;value_%s&quot;</span>, key.<span class=\"hljs-built_in\">c_str</span>());<br>\t<br>\t<span class=\"hljs-type\">bool</span> ret = cmd.<span class=\"hljs-built_in\">set</span>(key.<span class=\"hljs-built_in\">c_str</span>(), value.<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-keyword\">return</span> ret;<br>\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;set key: %s, value: %s %s\\r\\n&quot;</span>, key.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tvalue.<span class=\"hljs-built_in\">c_str</span>(), ret ? <span class=\"hljs-string\">&quot;ok&quot;</span> : <span class=\"hljs-string\">&quot;error&quot;</span>);<br>\t<span class=\"hljs-keyword\">return</span> ret;<br>&#125;<br><br><span class=\"hljs-comment\">// 测试 redis 键是否存在功能</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">test_redis_exists</span><span class=\"hljs-params\">(acl::redis_key&amp; cmd, <span class=\"hljs-type\">int</span> i)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::string key;<br><br>\tkey.format(<span class=\"hljs-string\">&quot;%s_%d&quot;</span>, __keypre.<span class=\"hljs-built_in\">c_str</span>(), i);<br><br>\t<span class=\"hljs-keyword\">if</span> (cmd.<span class=\"hljs-built_in\">exists</span>(key.<span class=\"hljs-built_in\">c_str</span>()) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;no exists key: %s\\r\\n&quot;</span>, key.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;exists key: %s\\r\\n&quot;</span>, key.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>&#125;<br><br><span class=\"hljs-comment\">// 子线程处理类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">test_thread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">test_thread</span>(acl::redis_cluster&amp; cluster, <span class=\"hljs-type\">int</span> max_conns)<br>\t: <span class=\"hljs-built_in\">cluster_</span>(cluster), <span class=\"hljs-built_in\">max_conns_</span>(max_conns) &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">test_thread</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类（acl::thread）纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tacl::redis_string cmd_string;<br>\t\tacl::redis_key  cmd_key;<br>\t\t<br>\t\t<span class=\"hljs-comment\">// 设置 redis 客户端命令的集群操作模式</span><br>\t\tcmd_key.<span class=\"hljs-built_in\">set_cluster</span>(&amp;cluster_, max_conns_);<br>\t\tcmd_string.<span class=\"hljs-built_in\">set_cluster</span>(&amp;cluster_, max_conns_);<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">1000</span>; i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 进行 redis 客户端命令操作过程</span><br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">test_redis_string</span>(cmd_string, i) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<br>\t\t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">test_redis_exists</span>(cmd_key, i) == <span class=\"hljs-literal\">false</span>)<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br><br>\t\t\t<span class=\"hljs-comment\">// 重置客户端命令状态</span><br><br>\t\t\tcmd_string.<span class=\"hljs-built_in\">clear</span>();<br>\t\t\tcmd_key.<span class=\"hljs-built_in\">clear</span>();<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\tacl::redis_cluster&amp; cluster_;<br>\t<span class=\"hljs-type\">int</span> max_conns_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_redis_cluster</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> max_threads <span class=\"hljs-type\">int</span> conn_timeout, <span class=\"hljs-type\">int</span> rw_timeout)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 redis 集群连接池对象</span><br>\tacl::redis_client_cluster cluster;<br><br>\t<span class=\"hljs-comment\">// 添加一个或多个 redis-server 的服务器实例地址，不必一次加载所有</span><br>\t<span class=\"hljs-comment\">// 的 redis-server 服务器地址，redis_cluster 及相关类具有自动发现</span><br>\t<span class=\"hljs-comment\">// 及动态添加 redis-server 服务实例的功能</span><br><br>\tcluster.<span class=\"hljs-built_in\">set</span>(<span class=\"hljs-string\">&quot;127.0.0.1:6379&quot;</span>, max_threads, conn_timeout, rw_timeout);<br>\t<span class=\"hljs-comment\">// cluster.set(&quot;127.0.0.1:6380&quot;, max_threads, conn_timeout, rw_timeout);</span><br>\t<span class=\"hljs-comment\">// cluster.set(&quot;127.0.0.1:6381&quot;, max_threads, conn_timeout, rw_timeout);</span><br><br>\t<span class=\"hljs-comment\">// 创建一组子线程</span><br>\tstd::vector&lt;test_thread*&gt; threads;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; max_threads; i++)<br>\t&#123;<br>\t\ttest_thread* thread = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">test_thread</span>(cluster, max_threads);<br>\t\tthreads.<span class=\"hljs-built_in\">push_back</span>(thread);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">false</span>);<br>\t\tthread-&gt;<span class=\"hljs-built_in\">start</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 等待所有子线程正常退出</span><br>\tstd::vector&lt;test_thread*&gt;::iterator it = threads.<span class=\"hljs-built_in\">begin</span>();<br>\t<span class=\"hljs-keyword\">for</span> (; it != threads.<span class=\"hljs-built_in\">end</span>(); ++it)<br>\t&#123;<br>\t\t(*it)-&gt;<span class=\"hljs-built_in\">wait</span>();<br>\t\t<span class=\"hljs-built_in\">delete</span> (*it);<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面例子可以看出，使用 acl redis 客户端库操作 redis3.0 集群时，只需要将集群的句柄注入到每个 redis 客户端命令即（如上面黄色部分所示）；至于如何与 redis 集群交互将由 redis_cluster 及 redis 客户端命令类的基类 redis_command 进行处理；此外，还需要注意示例 4）与示例 3）所支持的集群方式的不同点如下：</p>\n<ul>\n<li>示例3 的集群模式下实际上是由客户端根据所连接的所有 redis 服务器的集合来决定数据存储结点，而实际上 redis 服务器之间并不互联；而示例 4 则是真正意义的 redis 服务端的集群模式，所有 redis 服务结点之间是互联互通的（可以配置数据结点存储的冗余数量）；</li>\n<li>示例3 的客户端必须在开始初始化时添加所有的 redis 服务结点，以便于采用轮循或者哈希访问模式；而示例4 在初始化时只需添加至少一个集群中的服务结点即可，随着访问次数的增加，会根据需要动态添加 redis 服务结点（ redis3.0 采用的重定向机制，即当访问某个 redis 结点时，若 key 值不存在于该结点上，则其会返回给客户端一个重定向指令，告诉客户端存储该 key 的 redis 服务结点，因此，根据此特性，acl redis 集群会根据重定向信息动态添加 redis 集群中的服务结点）；</li>\n<li>此外，示例4 是兼容示例3 的。</li>\n</ul>\n<h2 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h2><p>以上介绍了 acl 框架中新增加的 redis 库的使用方法及处理过程，该库将复杂的协议及网络处理过程隐藏在实现内部，使用户使用起来感觉象是在调用本的函数。在示例 2）、3） 中提到了 acl 线程的使用，有关 acl 库中更为详细地使用线程的文章参见：《使用 acl_cpp 库编写多线程程序》。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"一个 C++ redis 集群管理工具","date":"2015-04-19T16:01:00.000Z","_content":"\n集群版 redis3.0 发布以来，官方仅提供了一个使用 Ruby 写的集群管理工具，在创建 redis 集群时需要使用该工具。因为 Ruby 中的一些包依赖问题，导致一些生手在建立 redis 集群时吃尽了苦头。于是 acl 库作者基于 acl 中的 redis 模块库，用 C++ 语言写了一个 redis 集群管理工具: redis_builder，没有过多的包依赖，可以方便 redis 使用者快速地建立 redis 集群，此外，该工具还可以进行一些集群的其它管理工作。\n\n下面是 redis_builder 的一些功能：\n```\n./redis_build -h\nusage: redis_builder.exe -h[help]\n-s redis_addr[ip:port]\n-a cmd[nodes|slots|create|add_node|del_node|node_id|reshard]\n\n-p passwd\n-N new_node[ip:port]\n-S [add node as slave]\n-f configure_file\n\nfor samples:\n./redis_builder -s 127.0.0.1:6379 -a create -f cluster.xml\n./redis_builder -s 127.0.0.1:6379 -a nodes\n./redis_builder -s 127.0.0.1:6379 -a slots\n./redis_builder -s 127.0.0.1:6379 -a del_node -I node_id\n./redis_builder -s 127.0.0.1:6379 -a node_id\n\n./redis_builder -s 127.0.0.1:6379 -a reshard\n./redis_builder -s 127.0.0.1:6379 -a add_node -N 127.0.0.1:6380 -S\n```\n\n注：如果集群中的每个 redis 节点设置了密码验证，则使用该工具需要增加参数： -p [passwod]\n\n## 一、建立 redis 集群\n### 1.1、方法一：\n\n在启动所有的 redis 进程后，可以使用 redis_builder 将这些 redis 结点组成一个 redis 集群，redis_builder 使用 xml 格式的配置文件管理 redis 各个结点的关系，如该 cluster.xml 文件的内容例如：\n\n```xml\n<?xml version=\"1.0\"?>\n<xml>\n    <node addr = \"192.168.136.172:16380\">\n        <node addr = \"192.168.136.172:16381\" />\n        <node addr = \"192.168.136.172:16382\" />\n    </node>\n    <node addr = \"192.168.136.172:16383\">\n        <node addr = \"192.168.136.172:16384\" />\n        <node addr = \"192.168.136.172:16385\" />\n    </node>\n    <node addr = \"192.168.136.172:16386\">\n        <node addr = \"192.168.136.172:16387\" />\n        <node addr = \"192.168.136.172:16388\" />\n    </node>\n</xml>\n```\n\n这样就可以运行：./redis_builder -a create -f cluster.xml，则redis 集群便会自动建立起来，集群中主从结点的分布情况如下：\n\n```\nmaster: 192.168.136.172:16380\n        slave: 192.168.136.172:16381\n        slave: 192.168.136.172:16382\nmaster: 192.168.136.172:16383\n        slave: 192.168.136.172:16384\n        slave: 192.168.136.172:16385\nmaster: 192.168.136.172:16386\n        slave: 192.168.136.172:16387\n        slave: 192.168.136.172:16388\n```\n\n这种方式的好处是由配置文件直接指定集群中各个结点的主从关系，缺点是：当 redis 结点非常多时配置管理起来也非常麻烦，因此该工具提供了另外一种 redis 集群创建模式，如方法二：\n\n### 1.2、方法二\n运行方式：./redis_builder -a create -f cluster.xml -r 2，其中的 -r 参数指定每个从结点的从结点个数，当指定了 -r 参数后，配置文件中指定的主从关系便不再生效，由工具根据以下三个原则进行主从结点的自动分配：\n\n- 主从节点在不同的服务器上\n- 主节点尽量均分在各个服务器上\n- 从节点尽量均匀的分在不同的机器上\n\n如配置文件中的内容为：\n\n```xml\n<?xml version=\"1.0\"?>\n<xml>\n    <node addr = \"192.168.136.171:16380\" />\n    <node addr = \"192.168.136.171:16381\" />\n    <node addr = \"192.168.136.171:16382\" />\n    <node addr = \"192.168.136.172:16380\" />\n    <node addr = \"192.168.136.172:16381\" />\n    <node addr = \"192.168.136.172:16382\" />\n    <node addr = \"192.168.136.173:16380\" />\n    <node addr = \"192.168.136.173:16381\" />\n    <node addr = \"192.168.136.173:16382\" />\n</xml>\n```\n\n则主从结点的分布情况可能如下：\n\n```\nmaster: 192.168.136.171:16380\n        slave: 192.168.136.172:16380\n        slave: 192.168.136.173:16380\nmaster: 192.168.136.172:16381\n        slave: 192.168.136.173:16382\n        slave: 192.168.136.171:16382\nmaster: 192.168.136.173:16381\n        slave: 192.168.136.172:16382\n        slave: 192.168.136.171:16381\n```\n\n可以看出，主从结点的分配基本满足以上三个原则，这样的好处就是当一台服务出现问题，整个集群中的其它机器的从结点可以顺利接管主结点服务。\n\n## 二、显示当前 redis 集群中的结点信息：\n运行：`./redis_builder -s 192.168.136.171:16380 -a nodes` 显示如下信息：\n\n```\nmaster, id: 4dcf8df124888e614cf08bd4df7987986124dd23, addr: 192.168.136.171：16380\nslots range: 5462-10922\nslave, id: 2b02cda1384336956d22c6c84fbe339210959bcb, addr: 192.168.136.172:16380, master_id: 4dcf8df124888e614cf08bd4df7987986124dd23\nslave, id: a041490f734ca7478330acf5b609c542936214c2, addr: 192.168.136.173:16380, master_id: 4dcf8df124888e614cf08bd4df7987986124dd23\n---------------------------------------\nmaster, id: bfa250d0f6cae39623515dbce084b904f070fd96, addr: 192.168.136.172:16381\nslots range: 10923-16383\nslave, id: 4dfd12785d85b8c195c899511ac470aa9a2a4181, addr: 192.168.136.173:16382, master_id: bfa250d0f6cae39623515dbce084b904f070fd96\nslave, id: fff7ecf70418300e1d41c6bb572c5ba995cc44c3, addr: 192.168.136.171:16382, master_id: bfa250d0f6cae39623515dbce084b904f070fd96\n---------------------------------------\nmaster, id: ebecfb9cc3548b17b37f2de94346473baa59721c, addr: 192.168.136.173:16381\nslots range: 0-5461\nslave, id: 842db09336dee58bbcd13e4a93ee680d96fa9915, addr: 192.168.136.172:16382, master_id: ebecfb9cc3548b17b37f2de94346473baa59721c\nslave, id: 025f58e174f8cd156d1c9621d32956bac2a90032, addr: 192.168.136.171:16381, master_id: ebecfb9cc3548b17b37f2de94346473baa59721c\n```\n\n## 三、添加新的 redis 结点\n\n随着数据规模的扩大，如果当前 redis 集群需要添加新的 redis 结点，则可以动态扩充 redis 结点，下面提供了使用 redis_builder 增加新结点的步骤：\n\n### 3.1、确定新结点的主结点并给新结点的主结点添加从结点\n\n```\n./redis_builder -s 192.168.136.171:16383 -N 192.168.136.172:16383 -S -a add_node\n./redis_builder -s 192.168.136.171:16383 -N 192.168.136.173:16383 -S -a add_node\n```\n\n该命令确定新增结点的主结点为 192.168.136.171:16383，两个从结点为：192.168.136.172:16383 和 192.168.136.173:16383\n\n### 3.2、将新增结点并入已有集群中\n\n```\n./redis_builder -s 192.168.136.171:16380 -N 192.168.136.171:15383 -a add_node\n```\n\n这样，便给已有的 redis 集群添加了新的结点，注意步骤 3.2 与 3.1 中参数的不同，在步骤 3.2 中将新结点添加进集群时，只需指定集群中的一个主结点即可，且不能添加 -S 参数。\n\n在添加完新结点后， 还需要将集群中的其它结点的哈希槽及数据移至新结点上，以便达到数据均衡性。下面给出了数据迁移的过程：\n\n## 四、将数据重新分区\n\n运行：`./redis_builder -s 192.168.136.171:16383 -a reshard`\n\n```\naddr: 192.168.136.171:16380\n\nid: 10280b2f2d4938c7f3dffd6a56369f470b34f11adfd\nslots: 2500 - 8191\n-----------------------------------------------\naddr: 192.168.136.172:16381\n\nid: 24664d58862274c8a600dae3be5c6b38998d6824\nslots: 10692 - 16383\n-----------------------------------------------\naddr: 192.168.136.173:16381\n\nid: 5a422ace11d20ed7b3735661bd82d7ff0343164df\nslots: 0 - 2499\nslots: 8192 - 10691\n\n-----------------------------------------------\naddr: 192.168.136.171:16383\n\nid: 5a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf\n\nHow many slots do you want to move (from 1 to 16384) ? 2000       ------  此处指定需要迁移的哈希槽数量\n\nWhat is the receiving node ID?  5a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf   ----- 此处指定目标 redis 结点\n\nPlease input all the source node IDs.\n  Type 'all' to use all the nodes as source nodes for the hash slots\n  Type 'done' once you entered all the source node IDs.\nSource node #1:\n``` \n\n输入 all 后 redis_builder 工具会自动将数据从所有已存在结点中将哈希槽及存储于哈希槽中的数据迁移至目标结点中。\n\n## 五、编译 redis_builder\n因为该工具依赖于 lib_acl/lib_protocol/lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：\n\n```\n$cd lib_acl; make\n$cd lib_protocol; make\n$cd lib_acl_cpp; make\n```\n\n然后再进入 app/redis_tools/redis_builder 编译：\n```\n$cd app/redis_tools/redis_builder; make\n```\n\n## 六、参考\n\nredis_builder 的工具下载：https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder\n\nacl 中的 redis 模块例子：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis\n\nacl on github：https://github.com/acl-dev/acl\nacl on gitee：https://gitee.com/acl-dev/acl","source":"_posts/redis_builder.md","raw":"---\ntitle: 一个 C++ redis 集群管理工具\ndate: 2015-04-20 00:01\ncategories: redis使用\n---\n\n集群版 redis3.0 发布以来，官方仅提供了一个使用 Ruby 写的集群管理工具，在创建 redis 集群时需要使用该工具。因为 Ruby 中的一些包依赖问题，导致一些生手在建立 redis 集群时吃尽了苦头。于是 acl 库作者基于 acl 中的 redis 模块库，用 C++ 语言写了一个 redis 集群管理工具: redis_builder，没有过多的包依赖，可以方便 redis 使用者快速地建立 redis 集群，此外，该工具还可以进行一些集群的其它管理工作。\n\n下面是 redis_builder 的一些功能：\n```\n./redis_build -h\nusage: redis_builder.exe -h[help]\n-s redis_addr[ip:port]\n-a cmd[nodes|slots|create|add_node|del_node|node_id|reshard]\n\n-p passwd\n-N new_node[ip:port]\n-S [add node as slave]\n-f configure_file\n\nfor samples:\n./redis_builder -s 127.0.0.1:6379 -a create -f cluster.xml\n./redis_builder -s 127.0.0.1:6379 -a nodes\n./redis_builder -s 127.0.0.1:6379 -a slots\n./redis_builder -s 127.0.0.1:6379 -a del_node -I node_id\n./redis_builder -s 127.0.0.1:6379 -a node_id\n\n./redis_builder -s 127.0.0.1:6379 -a reshard\n./redis_builder -s 127.0.0.1:6379 -a add_node -N 127.0.0.1:6380 -S\n```\n\n注：如果集群中的每个 redis 节点设置了密码验证，则使用该工具需要增加参数： -p [passwod]\n\n## 一、建立 redis 集群\n### 1.1、方法一：\n\n在启动所有的 redis 进程后，可以使用 redis_builder 将这些 redis 结点组成一个 redis 集群，redis_builder 使用 xml 格式的配置文件管理 redis 各个结点的关系，如该 cluster.xml 文件的内容例如：\n\n```xml\n<?xml version=\"1.0\"?>\n<xml>\n    <node addr = \"192.168.136.172:16380\">\n        <node addr = \"192.168.136.172:16381\" />\n        <node addr = \"192.168.136.172:16382\" />\n    </node>\n    <node addr = \"192.168.136.172:16383\">\n        <node addr = \"192.168.136.172:16384\" />\n        <node addr = \"192.168.136.172:16385\" />\n    </node>\n    <node addr = \"192.168.136.172:16386\">\n        <node addr = \"192.168.136.172:16387\" />\n        <node addr = \"192.168.136.172:16388\" />\n    </node>\n</xml>\n```\n\n这样就可以运行：./redis_builder -a create -f cluster.xml，则redis 集群便会自动建立起来，集群中主从结点的分布情况如下：\n\n```\nmaster: 192.168.136.172:16380\n        slave: 192.168.136.172:16381\n        slave: 192.168.136.172:16382\nmaster: 192.168.136.172:16383\n        slave: 192.168.136.172:16384\n        slave: 192.168.136.172:16385\nmaster: 192.168.136.172:16386\n        slave: 192.168.136.172:16387\n        slave: 192.168.136.172:16388\n```\n\n这种方式的好处是由配置文件直接指定集群中各个结点的主从关系，缺点是：当 redis 结点非常多时配置管理起来也非常麻烦，因此该工具提供了另外一种 redis 集群创建模式，如方法二：\n\n### 1.2、方法二\n运行方式：./redis_builder -a create -f cluster.xml -r 2，其中的 -r 参数指定每个从结点的从结点个数，当指定了 -r 参数后，配置文件中指定的主从关系便不再生效，由工具根据以下三个原则进行主从结点的自动分配：\n\n- 主从节点在不同的服务器上\n- 主节点尽量均分在各个服务器上\n- 从节点尽量均匀的分在不同的机器上\n\n如配置文件中的内容为：\n\n```xml\n<?xml version=\"1.0\"?>\n<xml>\n    <node addr = \"192.168.136.171:16380\" />\n    <node addr = \"192.168.136.171:16381\" />\n    <node addr = \"192.168.136.171:16382\" />\n    <node addr = \"192.168.136.172:16380\" />\n    <node addr = \"192.168.136.172:16381\" />\n    <node addr = \"192.168.136.172:16382\" />\n    <node addr = \"192.168.136.173:16380\" />\n    <node addr = \"192.168.136.173:16381\" />\n    <node addr = \"192.168.136.173:16382\" />\n</xml>\n```\n\n则主从结点的分布情况可能如下：\n\n```\nmaster: 192.168.136.171:16380\n        slave: 192.168.136.172:16380\n        slave: 192.168.136.173:16380\nmaster: 192.168.136.172:16381\n        slave: 192.168.136.173:16382\n        slave: 192.168.136.171:16382\nmaster: 192.168.136.173:16381\n        slave: 192.168.136.172:16382\n        slave: 192.168.136.171:16381\n```\n\n可以看出，主从结点的分配基本满足以上三个原则，这样的好处就是当一台服务出现问题，整个集群中的其它机器的从结点可以顺利接管主结点服务。\n\n## 二、显示当前 redis 集群中的结点信息：\n运行：`./redis_builder -s 192.168.136.171:16380 -a nodes` 显示如下信息：\n\n```\nmaster, id: 4dcf8df124888e614cf08bd4df7987986124dd23, addr: 192.168.136.171：16380\nslots range: 5462-10922\nslave, id: 2b02cda1384336956d22c6c84fbe339210959bcb, addr: 192.168.136.172:16380, master_id: 4dcf8df124888e614cf08bd4df7987986124dd23\nslave, id: a041490f734ca7478330acf5b609c542936214c2, addr: 192.168.136.173:16380, master_id: 4dcf8df124888e614cf08bd4df7987986124dd23\n---------------------------------------\nmaster, id: bfa250d0f6cae39623515dbce084b904f070fd96, addr: 192.168.136.172:16381\nslots range: 10923-16383\nslave, id: 4dfd12785d85b8c195c899511ac470aa9a2a4181, addr: 192.168.136.173:16382, master_id: bfa250d0f6cae39623515dbce084b904f070fd96\nslave, id: fff7ecf70418300e1d41c6bb572c5ba995cc44c3, addr: 192.168.136.171:16382, master_id: bfa250d0f6cae39623515dbce084b904f070fd96\n---------------------------------------\nmaster, id: ebecfb9cc3548b17b37f2de94346473baa59721c, addr: 192.168.136.173:16381\nslots range: 0-5461\nslave, id: 842db09336dee58bbcd13e4a93ee680d96fa9915, addr: 192.168.136.172:16382, master_id: ebecfb9cc3548b17b37f2de94346473baa59721c\nslave, id: 025f58e174f8cd156d1c9621d32956bac2a90032, addr: 192.168.136.171:16381, master_id: ebecfb9cc3548b17b37f2de94346473baa59721c\n```\n\n## 三、添加新的 redis 结点\n\n随着数据规模的扩大，如果当前 redis 集群需要添加新的 redis 结点，则可以动态扩充 redis 结点，下面提供了使用 redis_builder 增加新结点的步骤：\n\n### 3.1、确定新结点的主结点并给新结点的主结点添加从结点\n\n```\n./redis_builder -s 192.168.136.171:16383 -N 192.168.136.172:16383 -S -a add_node\n./redis_builder -s 192.168.136.171:16383 -N 192.168.136.173:16383 -S -a add_node\n```\n\n该命令确定新增结点的主结点为 192.168.136.171:16383，两个从结点为：192.168.136.172:16383 和 192.168.136.173:16383\n\n### 3.2、将新增结点并入已有集群中\n\n```\n./redis_builder -s 192.168.136.171:16380 -N 192.168.136.171:15383 -a add_node\n```\n\n这样，便给已有的 redis 集群添加了新的结点，注意步骤 3.2 与 3.1 中参数的不同，在步骤 3.2 中将新结点添加进集群时，只需指定集群中的一个主结点即可，且不能添加 -S 参数。\n\n在添加完新结点后， 还需要将集群中的其它结点的哈希槽及数据移至新结点上，以便达到数据均衡性。下面给出了数据迁移的过程：\n\n## 四、将数据重新分区\n\n运行：`./redis_builder -s 192.168.136.171:16383 -a reshard`\n\n```\naddr: 192.168.136.171:16380\n\nid: 10280b2f2d4938c7f3dffd6a56369f470b34f11adfd\nslots: 2500 - 8191\n-----------------------------------------------\naddr: 192.168.136.172:16381\n\nid: 24664d58862274c8a600dae3be5c6b38998d6824\nslots: 10692 - 16383\n-----------------------------------------------\naddr: 192.168.136.173:16381\n\nid: 5a422ace11d20ed7b3735661bd82d7ff0343164df\nslots: 0 - 2499\nslots: 8192 - 10691\n\n-----------------------------------------------\naddr: 192.168.136.171:16383\n\nid: 5a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf\n\nHow many slots do you want to move (from 1 to 16384) ? 2000       ------  此处指定需要迁移的哈希槽数量\n\nWhat is the receiving node ID?  5a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf   ----- 此处指定目标 redis 结点\n\nPlease input all the source node IDs.\n  Type 'all' to use all the nodes as source nodes for the hash slots\n  Type 'done' once you entered all the source node IDs.\nSource node #1:\n``` \n\n输入 all 后 redis_builder 工具会自动将数据从所有已存在结点中将哈希槽及存储于哈希槽中的数据迁移至目标结点中。\n\n## 五、编译 redis_builder\n因为该工具依赖于 lib_acl/lib_protocol/lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：\n\n```\n$cd lib_acl; make\n$cd lib_protocol; make\n$cd lib_acl_cpp; make\n```\n\n然后再进入 app/redis_tools/redis_builder 编译：\n```\n$cd app/redis_tools/redis_builder; make\n```\n\n## 六、参考\n\nredis_builder 的工具下载：https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder\n\nacl 中的 redis 模块例子：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis\n\nacl on github：https://github.com/acl-dev/acl\nacl on gitee：https://gitee.com/acl-dev/acl","slug":"redis_builder","published":1,"updated":"2023-01-24T09:02:11.959Z","_id":"clda075ix0003yr9k7m324z1c","comments":1,"layout":"post","photos":[],"link":"","content":"<p>集群版 redis3.0 发布以来，官方仅提供了一个使用 Ruby 写的集群管理工具，在创建 redis 集群时需要使用该工具。因为 Ruby 中的一些包依赖问题，导致一些生手在建立 redis 集群时吃尽了苦头。于是 acl 库作者基于 acl 中的 redis 模块库，用 C++ 语言写了一个 redis 集群管理工具: redis_builder，没有过多的包依赖，可以方便 redis 使用者快速地建立 redis 集群，此外，该工具还可以进行一些集群的其它管理工作。</p>\n<p>下面是 redis_builder 的一些功能：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">./redis_build -h<br>usage: redis_builder<span class=\"hljs-selector-class\">.exe</span> -h<span class=\"hljs-selector-attr\">[help]</span><br>-s redis_addr<span class=\"hljs-selector-attr\">[ip:port]</span><br>-<span class=\"hljs-selector-tag\">a</span> cmd<span class=\"hljs-selector-attr\">[nodes|slots|create|add_node|del_node|node_id|reshard]</span><br><br>-<span class=\"hljs-selector-tag\">p</span> passwd<br>-N new_node<span class=\"hljs-selector-attr\">[ip:port]</span><br>-S <span class=\"hljs-selector-attr\">[add node as slave]</span><br>-f configure_file<br><br><span class=\"hljs-keyword\">for</span> samples:<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> create -f cluster<span class=\"hljs-selector-class\">.xml</span><br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> nodes<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> slots<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> del_node -I node_id<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> node_id<br><br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> reshard<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> add_node -N <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6380</span> -S<br></code></pre></td></tr></table></figure>\n\n<p>注：如果集群中的每个 redis 节点设置了密码验证，则使用该工具需要增加参数： -p [passwod]</p>\n<h2 id=\"一、建立-redis-集群\"><a href=\"#一、建立-redis-集群\" class=\"headerlink\" title=\"一、建立 redis 集群\"></a>一、建立 redis 集群</h2><h3 id=\"1-1、方法一：\"><a href=\"#1-1、方法一：\" class=\"headerlink\" title=\"1.1、方法一：\"></a>1.1、方法一：</h3><p>在启动所有的 redis 进程后，可以使用 redis_builder 将这些 redis 结点组成一个 redis 集群，redis_builder 使用 xml 格式的配置文件管理 redis 各个结点的关系，如该 cluster.xml 文件的内容例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span>?&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">xml</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16380&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16381&quot;</span> /&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16382&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">node</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16383&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16384&quot;</span> /&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16385&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">node</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16386&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16387&quot;</span> /&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16388&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">node</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">xml</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这样就可以运行：.&#x2F;redis_builder -a create -f cluster.xml，则redis 集群便会自动建立起来，集群中主从结点的分布情况如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.172:16380</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16381</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16382</span><br><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.172:16383</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16384</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16385</span><br><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.172:16386</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16387</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16388</span><br></code></pre></td></tr></table></figure>\n\n<p>这种方式的好处是由配置文件直接指定集群中各个结点的主从关系，缺点是：当 redis 结点非常多时配置管理起来也非常麻烦，因此该工具提供了另外一种 redis 集群创建模式，如方法二：</p>\n<h3 id=\"1-2、方法二\"><a href=\"#1-2、方法二\" class=\"headerlink\" title=\"1.2、方法二\"></a>1.2、方法二</h3><p>运行方式：.&#x2F;redis_builder -a create -f cluster.xml -r 2，其中的 -r 参数指定每个从结点的从结点个数，当指定了 -r 参数后，配置文件中指定的主从关系便不再生效，由工具根据以下三个原则进行主从结点的自动分配：</p>\n<ul>\n<li>主从节点在不同的服务器上</li>\n<li>主节点尽量均分在各个服务器上</li>\n<li>从节点尽量均匀的分在不同的机器上</li>\n</ul>\n<p>如配置文件中的内容为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span>?&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">xml</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.171:16380&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.171:16381&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.171:16382&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16380&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16381&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16382&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.173:16380&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.173:16381&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.173:16382&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">xml</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>则主从结点的分布情况可能如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.171:16380</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16380</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.173:16380</span><br><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.172:16381</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.173:16382</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.171:16382</span><br><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.173:16381</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16382</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.171:16381</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看出，主从结点的分配基本满足以上三个原则，这样的好处就是当一台服务出现问题，整个集群中的其它机器的从结点可以顺利接管主结点服务。</p>\n<h2 id=\"二、显示当前-redis-集群中的结点信息：\"><a href=\"#二、显示当前-redis-集群中的结点信息：\" class=\"headerlink\" title=\"二、显示当前 redis 集群中的结点信息：\"></a>二、显示当前 redis 集群中的结点信息：</h2><p>运行：<code>./redis_builder -s 192.168.136.171:16380 -a nodes</code> 显示如下信息：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">master,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">4dcf8df124888e614cf08bd4df7987986124dd23,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.171</span><span class=\"hljs-string\">：16380</span><br><span class=\"hljs-attr\">slots range:</span> <span class=\"hljs-number\">5462</span><span class=\"hljs-number\">-10922</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">2b02cda1384336956d22c6c84fbe339210959bcb,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.172</span><span class=\"hljs-string\">:16380,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">4dcf8df124888e614cf08bd4df7987986124dd23</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">a041490f734ca7478330acf5b609c542936214c2,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.173</span><span class=\"hljs-string\">:16380,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">4dcf8df124888e614cf08bd4df7987986124dd23</span><br><span class=\"hljs-string\">---------------------------------------</span><br><span class=\"hljs-string\">master,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">bfa250d0f6cae39623515dbce084b904f070fd96,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.172</span><span class=\"hljs-string\">:16381</span><br><span class=\"hljs-attr\">slots range:</span> <span class=\"hljs-number\">10923</span><span class=\"hljs-number\">-16383</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">4dfd12785d85b8c195c899511ac470aa9a2a4181,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.173</span><span class=\"hljs-string\">:16382,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">bfa250d0f6cae39623515dbce084b904f070fd96</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">fff7ecf70418300e1d41c6bb572c5ba995cc44c3,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.171</span><span class=\"hljs-string\">:16382,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">bfa250d0f6cae39623515dbce084b904f070fd96</span><br><span class=\"hljs-string\">---------------------------------------</span><br><span class=\"hljs-string\">master,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">ebecfb9cc3548b17b37f2de94346473baa59721c,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.173</span><span class=\"hljs-string\">:16381</span><br><span class=\"hljs-attr\">slots range:</span> <span class=\"hljs-number\">0</span><span class=\"hljs-number\">-5461</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">842db09336dee58bbcd13e4a93ee680d96fa9915,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.172</span><span class=\"hljs-string\">:16382,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">ebecfb9cc3548b17b37f2de94346473baa59721c</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">025f58e174f8cd156d1c9621d32956bac2a90032,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.171</span><span class=\"hljs-string\">:16381,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">ebecfb9cc3548b17b37f2de94346473baa59721c</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、添加新的-redis-结点\"><a href=\"#三、添加新的-redis-结点\" class=\"headerlink\" title=\"三、添加新的 redis 结点\"></a>三、添加新的 redis 结点</h2><p>随着数据规模的扩大，如果当前 redis 集群需要添加新的 redis 结点，则可以动态扩充 redis 结点，下面提供了使用 redis_builder 增加新结点的步骤：</p>\n<h3 id=\"3-1、确定新结点的主结点并给新结点的主结点添加从结点\"><a href=\"#3-1、确定新结点的主结点并给新结点的主结点添加从结点\" class=\"headerlink\" title=\"3.1、确定新结点的主结点并给新结点的主结点添加从结点\"></a>3.1、确定新结点的主结点并给新结点的主结点添加从结点</h3><figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">./redis_builder -s <span class=\"hljs-number\">192.168.136.171</span>:<span class=\"hljs-number\">16383</span> -N <span class=\"hljs-number\">192.168.136.172</span>:<span class=\"hljs-number\">16383</span> -S -a add_node<br>./redis_builder -s <span class=\"hljs-number\">192.168.136.171</span>:<span class=\"hljs-number\">16383</span> -N <span class=\"hljs-number\">192.168.136.173</span>:<span class=\"hljs-number\">16383</span> -S -a add_node<br></code></pre></td></tr></table></figure>\n\n<p>该命令确定新增结点的主结点为 192.168.136.171:16383，两个从结点为：192.168.136.172:16383 和 192.168.136.173:16383</p>\n<h3 id=\"3-2、将新增结点并入已有集群中\"><a href=\"#3-2、将新增结点并入已有集群中\" class=\"headerlink\" title=\"3.2、将新增结点并入已有集群中\"></a>3.2、将新增结点并入已有集群中</h3><figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">./redis_builder -s <span class=\"hljs-number\">192.168.136.171</span>:<span class=\"hljs-number\">16380</span> -N <span class=\"hljs-number\">192.168.136.171</span>:<span class=\"hljs-number\">15383</span> -a add_node<br></code></pre></td></tr></table></figure>\n\n<p>这样，便给已有的 redis 集群添加了新的结点，注意步骤 3.2 与 3.1 中参数的不同，在步骤 3.2 中将新结点添加进集群时，只需指定集群中的一个主结点即可，且不能添加 -S 参数。</p>\n<p>在添加完新结点后， 还需要将集群中的其它结点的哈希槽及数据移至新结点上，以便达到数据均衡性。下面给出了数据迁移的过程：</p>\n<h2 id=\"四、将数据重新分区\"><a href=\"#四、将数据重新分区\" class=\"headerlink\" title=\"四、将数据重新分区\"></a>四、将数据重新分区</h2><p>运行：<code>./redis_builder -s 192.168.136.171:16383 -a reshard</code></p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vbnet\"><span class=\"hljs-symbol\">addr:</span> <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">136.171</span>:<span class=\"hljs-number\">16380</span><br><br><span class=\"hljs-symbol\">id:</span> <span class=\"hljs-number\">10280</span>b2f2d4938c7f3dffd6a56369f470b34f11adfd<br><span class=\"hljs-symbol\">slots:</span> <span class=\"hljs-number\">2500</span> - <span class=\"hljs-number\">8191</span><br>-----------------------------------------------<br><span class=\"hljs-symbol\">addr:</span> <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">136.172</span>:<span class=\"hljs-number\">16381</span><br><br><span class=\"hljs-symbol\">id:</span> <span class=\"hljs-number\">24664</span>d58862274c8a600dae3be5c6b38998d6824<br><span class=\"hljs-symbol\">slots:</span> <span class=\"hljs-number\">10692</span> - <span class=\"hljs-number\">16383</span><br>-----------------------------------------------<br><span class=\"hljs-symbol\">addr:</span> <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">136.173</span>:<span class=\"hljs-number\">16381</span><br><br><span class=\"hljs-symbol\">id:</span> <span class=\"hljs-number\">5</span>a422ace11d20ed7b3735661bd82d7ff0343164df<br><span class=\"hljs-symbol\">slots:</span> <span class=\"hljs-number\">0</span> - <span class=\"hljs-number\">2499</span><br><span class=\"hljs-symbol\">slots:</span> <span class=\"hljs-number\">8192</span> - <span class=\"hljs-number\">10691</span><br><br>-----------------------------------------------<br><span class=\"hljs-symbol\">addr:</span> <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">136.171</span>:<span class=\"hljs-number\">16383</span><br><br><span class=\"hljs-symbol\">id:</span> <span class=\"hljs-number\">5</span>a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf<br><br>How many slots <span class=\"hljs-keyword\">do</span> you want <span class=\"hljs-keyword\">to</span> move (<span class=\"hljs-keyword\">from</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-number\">16384</span>) ? <span class=\"hljs-number\">2000</span>       ------  此处指定需要迁移的哈希槽数量<br><br>What <span class=\"hljs-built_in\">is</span> the receiving node ID?  <span class=\"hljs-number\">5</span>a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf   ----- 此处指定目标 redis 结点<br><br>Please input all the source node IDs.<br>  Type <span class=\"hljs-comment\">&#x27;all&#x27; to use all the nodes as source nodes for the hash slots</span><br>  Type <span class=\"hljs-comment\">&#x27;done&#x27; once you entered all the source node IDs.</span><br>Source node #<span class=\"hljs-number\">1</span>:<br></code></pre></td></tr></table></figure>\n\n<p>输入 all 后 redis_builder 工具会自动将数据从所有已存在结点中将哈希槽及存储于哈希槽中的数据迁移至目标结点中。</p>\n<h2 id=\"五、编译-redis-builder\"><a href=\"#五、编译-redis-builder\" class=\"headerlink\" title=\"五、编译 redis_builder\"></a>五、编译 redis_builder</h2><p>因为该工具依赖于 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_acl; make</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_protocol; make</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_acl_cpp; make</span><br></code></pre></td></tr></table></figure>\n\n<p>然后再进入 app&#x2F;redis_tools&#x2F;redis_builder 编译：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-variable\">$cd</span> app<span class=\"hljs-regexp\">/redis_tools/</span>redis_builder; make<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、参考\"><a href=\"#六、参考\" class=\"headerlink\" title=\"六、参考\"></a>六、参考</h2><p>redis_builder 的工具下载：<a href=\"https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder\">https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder</a></p>\n<p>acl 中的 redis 模块例子：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis</a></p>\n<p>acl on github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>acl on gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>集群版 redis3.0 发布以来，官方仅提供了一个使用 Ruby 写的集群管理工具，在创建 redis 集群时需要使用该工具。因为 Ruby 中的一些包依赖问题，导致一些生手在建立 redis 集群时吃尽了苦头。于是 acl 库作者基于 acl 中的 redis 模块库，用 C++ 语言写了一个 redis 集群管理工具: redis_builder，没有过多的包依赖，可以方便 redis 使用者快速地建立 redis 集群，此外，该工具还可以进行一些集群的其它管理工作。</p>\n<p>下面是 redis_builder 的一些功能：</p>\n<figure class=\"highlight stylus\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs stylus\">./redis_build -h<br>usage: redis_builder<span class=\"hljs-selector-class\">.exe</span> -h<span class=\"hljs-selector-attr\">[help]</span><br>-s redis_addr<span class=\"hljs-selector-attr\">[ip:port]</span><br>-<span class=\"hljs-selector-tag\">a</span> cmd<span class=\"hljs-selector-attr\">[nodes|slots|create|add_node|del_node|node_id|reshard]</span><br><br>-<span class=\"hljs-selector-tag\">p</span> passwd<br>-N new_node<span class=\"hljs-selector-attr\">[ip:port]</span><br>-S <span class=\"hljs-selector-attr\">[add node as slave]</span><br>-f configure_file<br><br><span class=\"hljs-keyword\">for</span> samples:<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> create -f cluster<span class=\"hljs-selector-class\">.xml</span><br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> nodes<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> slots<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> del_node -I node_id<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> node_id<br><br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> reshard<br>./redis_builder -s <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6379</span> -<span class=\"hljs-selector-tag\">a</span> add_node -N <span class=\"hljs-number\">127.0</span>.<span class=\"hljs-number\">0.1</span>:<span class=\"hljs-number\">6380</span> -S<br></code></pre></td></tr></table></figure>\n\n<p>注：如果集群中的每个 redis 节点设置了密码验证，则使用该工具需要增加参数： -p [passwod]</p>\n<h2 id=\"一、建立-redis-集群\"><a href=\"#一、建立-redis-集群\" class=\"headerlink\" title=\"一、建立 redis 集群\"></a>一、建立 redis 集群</h2><h3 id=\"1-1、方法一：\"><a href=\"#1-1、方法一：\" class=\"headerlink\" title=\"1.1、方法一：\"></a>1.1、方法一：</h3><p>在启动所有的 redis 进程后，可以使用 redis_builder 将这些 redis 结点组成一个 redis 集群，redis_builder 使用 xml 格式的配置文件管理 redis 各个结点的关系，如该 cluster.xml 文件的内容例如：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span>?&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">xml</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16380&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16381&quot;</span> /&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16382&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">node</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16383&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16384&quot;</span> /&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16385&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">node</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16386&quot;</span>&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16387&quot;</span> /&gt;</span><br>        <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16388&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">node</span>&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">xml</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>这样就可以运行：.&#x2F;redis_builder -a create -f cluster.xml，则redis 集群便会自动建立起来，集群中主从结点的分布情况如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.172:16380</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16381</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16382</span><br><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.172:16383</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16384</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16385</span><br><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.172:16386</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16387</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16388</span><br></code></pre></td></tr></table></figure>\n\n<p>这种方式的好处是由配置文件直接指定集群中各个结点的主从关系，缺点是：当 redis 结点非常多时配置管理起来也非常麻烦，因此该工具提供了另外一种 redis 集群创建模式，如方法二：</p>\n<h3 id=\"1-2、方法二\"><a href=\"#1-2、方法二\" class=\"headerlink\" title=\"1.2、方法二\"></a>1.2、方法二</h3><p>运行方式：.&#x2F;redis_builder -a create -f cluster.xml -r 2，其中的 -r 参数指定每个从结点的从结点个数，当指定了 -r 参数后，配置文件中指定的主从关系便不再生效，由工具根据以下三个原则进行主从结点的自动分配：</p>\n<ul>\n<li>主从节点在不同的服务器上</li>\n<li>主节点尽量均分在各个服务器上</li>\n<li>从节点尽量均匀的分在不同的机器上</li>\n</ul>\n<p>如配置文件中的内容为：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs xml\"><span class=\"hljs-meta\">&lt;?xml version=<span class=\"hljs-string\">&quot;1.0&quot;</span>?&gt;</span><br><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">xml</span>&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.171:16380&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.171:16381&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.171:16382&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16380&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16381&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.172:16382&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.173:16380&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.173:16381&quot;</span> /&gt;</span><br>    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">node</span> <span class=\"hljs-attr\">addr</span> = <span class=\"hljs-string\">&quot;192.168.136.173:16382&quot;</span> /&gt;</span><br><span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">xml</span>&gt;</span><br></code></pre></td></tr></table></figure>\n\n<p>则主从结点的分布情况可能如下：</p>\n<figure class=\"highlight apache\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs apache\"><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.171:16380</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16380</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.173:16380</span><br><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.172:16381</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.173:16382</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.171:16382</span><br><span class=\"hljs-attribute\">master</span>: <span class=\"hljs-number\">192.168.136.173:16381</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.172:16382</span><br>        <span class=\"hljs-attribute\">slave</span>: <span class=\"hljs-number\">192.168.136.171:16381</span><br></code></pre></td></tr></table></figure>\n\n<p>可以看出，主从结点的分配基本满足以上三个原则，这样的好处就是当一台服务出现问题，整个集群中的其它机器的从结点可以顺利接管主结点服务。</p>\n<h2 id=\"二、显示当前-redis-集群中的结点信息：\"><a href=\"#二、显示当前-redis-集群中的结点信息：\" class=\"headerlink\" title=\"二、显示当前 redis 集群中的结点信息：\"></a>二、显示当前 redis 集群中的结点信息：</h2><p>运行：<code>./redis_builder -s 192.168.136.171:16380 -a nodes</code> 显示如下信息：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-string\">master,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">4dcf8df124888e614cf08bd4df7987986124dd23,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.171</span><span class=\"hljs-string\">：16380</span><br><span class=\"hljs-attr\">slots range:</span> <span class=\"hljs-number\">5462</span><span class=\"hljs-number\">-10922</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">2b02cda1384336956d22c6c84fbe339210959bcb,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.172</span><span class=\"hljs-string\">:16380,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">4dcf8df124888e614cf08bd4df7987986124dd23</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">a041490f734ca7478330acf5b609c542936214c2,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.173</span><span class=\"hljs-string\">:16380,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">4dcf8df124888e614cf08bd4df7987986124dd23</span><br><span class=\"hljs-string\">---------------------------------------</span><br><span class=\"hljs-string\">master,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">bfa250d0f6cae39623515dbce084b904f070fd96,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.172</span><span class=\"hljs-string\">:16381</span><br><span class=\"hljs-attr\">slots range:</span> <span class=\"hljs-number\">10923</span><span class=\"hljs-number\">-16383</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">4dfd12785d85b8c195c899511ac470aa9a2a4181,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.173</span><span class=\"hljs-string\">:16382,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">bfa250d0f6cae39623515dbce084b904f070fd96</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">fff7ecf70418300e1d41c6bb572c5ba995cc44c3,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.171</span><span class=\"hljs-string\">:16382,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">bfa250d0f6cae39623515dbce084b904f070fd96</span><br><span class=\"hljs-string\">---------------------------------------</span><br><span class=\"hljs-string\">master,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">ebecfb9cc3548b17b37f2de94346473baa59721c,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.173</span><span class=\"hljs-string\">:16381</span><br><span class=\"hljs-attr\">slots range:</span> <span class=\"hljs-number\">0</span><span class=\"hljs-number\">-5461</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">842db09336dee58bbcd13e4a93ee680d96fa9915,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.172</span><span class=\"hljs-string\">:16382,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">ebecfb9cc3548b17b37f2de94346473baa59721c</span><br><span class=\"hljs-string\">slave,</span> <span class=\"hljs-attr\">id:</span> <span class=\"hljs-string\">025f58e174f8cd156d1c9621d32956bac2a90032,</span> <span class=\"hljs-attr\">addr:</span> <span class=\"hljs-number\">192.168</span><span class=\"hljs-number\">.136</span><span class=\"hljs-number\">.171</span><span class=\"hljs-string\">:16381,</span> <span class=\"hljs-attr\">master_id:</span> <span class=\"hljs-string\">ebecfb9cc3548b17b37f2de94346473baa59721c</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、添加新的-redis-结点\"><a href=\"#三、添加新的-redis-结点\" class=\"headerlink\" title=\"三、添加新的 redis 结点\"></a>三、添加新的 redis 结点</h2><p>随着数据规模的扩大，如果当前 redis 集群需要添加新的 redis 结点，则可以动态扩充 redis 结点，下面提供了使用 redis_builder 增加新结点的步骤：</p>\n<h3 id=\"3-1、确定新结点的主结点并给新结点的主结点添加从结点\"><a href=\"#3-1、确定新结点的主结点并给新结点的主结点添加从结点\" class=\"headerlink\" title=\"3.1、确定新结点的主结点并给新结点的主结点添加从结点\"></a>3.1、确定新结点的主结点并给新结点的主结点添加从结点</h3><figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">./redis_builder -s <span class=\"hljs-number\">192.168.136.171</span>:<span class=\"hljs-number\">16383</span> -N <span class=\"hljs-number\">192.168.136.172</span>:<span class=\"hljs-number\">16383</span> -S -a add_node<br>./redis_builder -s <span class=\"hljs-number\">192.168.136.171</span>:<span class=\"hljs-number\">16383</span> -N <span class=\"hljs-number\">192.168.136.173</span>:<span class=\"hljs-number\">16383</span> -S -a add_node<br></code></pre></td></tr></table></figure>\n\n<p>该命令确定新增结点的主结点为 192.168.136.171:16383，两个从结点为：192.168.136.172:16383 和 192.168.136.173:16383</p>\n<h3 id=\"3-2、将新增结点并入已有集群中\"><a href=\"#3-2、将新增结点并入已有集群中\" class=\"headerlink\" title=\"3.2、将新增结点并入已有集群中\"></a>3.2、将新增结点并入已有集群中</h3><figure class=\"highlight dns\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs dns\">./redis_builder -s <span class=\"hljs-number\">192.168.136.171</span>:<span class=\"hljs-number\">16380</span> -N <span class=\"hljs-number\">192.168.136.171</span>:<span class=\"hljs-number\">15383</span> -a add_node<br></code></pre></td></tr></table></figure>\n\n<p>这样，便给已有的 redis 集群添加了新的结点，注意步骤 3.2 与 3.1 中参数的不同，在步骤 3.2 中将新结点添加进集群时，只需指定集群中的一个主结点即可，且不能添加 -S 参数。</p>\n<p>在添加完新结点后， 还需要将集群中的其它结点的哈希槽及数据移至新结点上，以便达到数据均衡性。下面给出了数据迁移的过程：</p>\n<h2 id=\"四、将数据重新分区\"><a href=\"#四、将数据重新分区\" class=\"headerlink\" title=\"四、将数据重新分区\"></a>四、将数据重新分区</h2><p>运行：<code>./redis_builder -s 192.168.136.171:16383 -a reshard</code></p>\n<figure class=\"highlight vbnet\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs vbnet\"><span class=\"hljs-symbol\">addr:</span> <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">136.171</span>:<span class=\"hljs-number\">16380</span><br><br><span class=\"hljs-symbol\">id:</span> <span class=\"hljs-number\">10280</span>b2f2d4938c7f3dffd6a56369f470b34f11adfd<br><span class=\"hljs-symbol\">slots:</span> <span class=\"hljs-number\">2500</span> - <span class=\"hljs-number\">8191</span><br>-----------------------------------------------<br><span class=\"hljs-symbol\">addr:</span> <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">136.172</span>:<span class=\"hljs-number\">16381</span><br><br><span class=\"hljs-symbol\">id:</span> <span class=\"hljs-number\">24664</span>d58862274c8a600dae3be5c6b38998d6824<br><span class=\"hljs-symbol\">slots:</span> <span class=\"hljs-number\">10692</span> - <span class=\"hljs-number\">16383</span><br>-----------------------------------------------<br><span class=\"hljs-symbol\">addr:</span> <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">136.173</span>:<span class=\"hljs-number\">16381</span><br><br><span class=\"hljs-symbol\">id:</span> <span class=\"hljs-number\">5</span>a422ace11d20ed7b3735661bd82d7ff0343164df<br><span class=\"hljs-symbol\">slots:</span> <span class=\"hljs-number\">0</span> - <span class=\"hljs-number\">2499</span><br><span class=\"hljs-symbol\">slots:</span> <span class=\"hljs-number\">8192</span> - <span class=\"hljs-number\">10691</span><br><br>-----------------------------------------------<br><span class=\"hljs-symbol\">addr:</span> <span class=\"hljs-number\">192.168</span>.<span class=\"hljs-number\">136.171</span>:<span class=\"hljs-number\">16383</span><br><br><span class=\"hljs-symbol\">id:</span> <span class=\"hljs-number\">5</span>a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf<br><br>How many slots <span class=\"hljs-keyword\">do</span> you want <span class=\"hljs-keyword\">to</span> move (<span class=\"hljs-keyword\">from</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-keyword\">to</span> <span class=\"hljs-number\">16384</span>) ? <span class=\"hljs-number\">2000</span>       ------  此处指定需要迁移的哈希槽数量<br><br>What <span class=\"hljs-built_in\">is</span> the receiving node ID?  <span class=\"hljs-number\">5</span>a422ace11fsdfd23sdfsfsdfsfsfsfsfsfstdgdgdgf   ----- 此处指定目标 redis 结点<br><br>Please input all the source node IDs.<br>  Type <span class=\"hljs-comment\">&#x27;all&#x27; to use all the nodes as source nodes for the hash slots</span><br>  Type <span class=\"hljs-comment\">&#x27;done&#x27; once you entered all the source node IDs.</span><br>Source node #<span class=\"hljs-number\">1</span>:<br></code></pre></td></tr></table></figure>\n\n<p>输入 all 后 redis_builder 工具会自动将数据从所有已存在结点中将哈希槽及存储于哈希槽中的数据迁移至目标结点中。</p>\n<h2 id=\"五、编译-redis-builder\"><a href=\"#五、编译-redis-builder\" class=\"headerlink\" title=\"五、编译 redis_builder\"></a>五、编译 redis_builder</h2><p>因为该工具依赖于 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_acl; make</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_protocol; make</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_acl_cpp; make</span><br></code></pre></td></tr></table></figure>\n\n<p>然后再进入 app&#x2F;redis_tools&#x2F;redis_builder 编译：</p>\n<figure class=\"highlight awk\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs awk\"><span class=\"hljs-variable\">$cd</span> app<span class=\"hljs-regexp\">/redis_tools/</span>redis_builder; make<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"六、参考\"><a href=\"#六、参考\" class=\"headerlink\" title=\"六、参考\"></a>六、参考</h2><p>redis_builder 的工具下载：<a href=\"https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder\">https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder</a></p>\n<p>acl 中的 redis 模块例子：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis</a></p>\n<p>acl on github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>acl on gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"使用 redis_builder 管理 redis 集群","date":"2016-04-23T11:59:00.000Z","_content":"\n在 <一个 C++ redis 集群管理工具> 中主要讲述了如何使用 redis_builder 工具创建 redis 集群的过程，除此之外，该工具还具有更为强大的 redis 客户端管理功能（相对于官方提供的 redis-cli功能要强大的多）。本文主要讲解使用 redis_builder 以交互方式管理 redis 集群的过程。\n\n## 一、启动 redis_builder 的交互过程\n\n只要运行：./redis_builder -s redis_ip:redis_port，便进入 redis_builder 工具的命令行交互过程，其中 redis_ip 和 redis_port 为 redis 集群中的任一个节点的 IP 及端口号。启动成功后，显示界面如下：\n\n![redis_builder界面](/img/redis_builder.png)\n\n在上图中，首先显示了针对一些 redis 客户端命令的：是否采用广播方式，命令执行权限。\n\n“广播方式”的含义是：该命令需要向 redis 集群中的所有节点发送某个 redis 客户端命令，有的命令向所有主从节点广播，有的命令仅向所有主节点广播。对于象 config xxx xxx （如：config get save）类的命令，是需要向所有主从节点广播以获得所有节点的配置信息；对于象 dbsize 命令，则需要向所有主节点广播，以便获得整个集群总的键值数。\n\n“执行权限”的用处是：1、防止误操作，2、禁止使用 redis_builder 执行某些非常危险的命令。其中“执行权限”的三个级别分别为：yes --- 允许执行，warn --- 警告执行，no --- 禁止执行。对于大部分命令，如：get, incr, dbsize 等命令的执行对于整个系统一般是无害的，所以不会有限制，而对于象 del 类的命令则带有一定危险性，管理员可以配置该命令（下面单独介绍如何配置命令的执行权限）的执行为“警告”方式，这样当运行此类命令时，redis_builder 会首先提示警告信息让管理员再次确认是否真的要执行，这样做的好处是可以在一定程度上防止管理员误操作。\n\n## 二、配置 redis 客户端命令的执行权限\n当以命令行交互方式启动 redis_builder 时，该工具首先会强制检查该工具所在目录下是否有 redis_commands.txt 文件（该文件里配置着一些 redis 客户端命令的执行权限及广播方式），如果存在，则加载命令配置信息，如果该文件不存在则尝试加载由 -F 指定的命令配置信息。之所以要强制加载 redis_commands.txt 命令配置文件，主要适应这样一种应用场景：由 root 超级管理员创建了 redis_commands.txt 文件（属主当然为 root），普通用户只有读的权限，这样 root 管理员在 redis_commands.txt 中设置的 redis 命令执行权限普通用户是不能修改的。\n\n如果在 redis_builder 命令的相同目录下存在 redis_commands.txt 文件且内容如下：\n![redis命令权限](/img/redis_commands.png) \n\n则启动 redis_builder 交互方式后，则显示一些 redis 命令的执行权限如下（红圈内的命令为 redis_commands.txt 文件指定的）：\n\ni![redis命令权限](/img/redis_commands2.png)\n\n如果在 redis_commands.txt 指定的 redis 命令与 redis_builder 内部缺省的命令相同，则执行 redis_commands.txt 中指定的 redis 命令权限。\n\n## 三、redis_builder 在交互方式下的命令操作\n在交互模式下，redis_builder 可以执行所有的 redis 客户端命令，其中，redis_builder 内置了一些针对某些重要命令的特殊执行过程，除了这些内置的 redis 客户端命令，其它的命令执行方式均为标准的 redis 协议命令格式（具体格式可参考：redis.io 或 redisdoc.com）。下面首先介绍 redis_builder 内置的一些 redis 命令，随便输入一些字符串回车后，显示内置的命令如下：\n\n![redis命令帮助](/img/redis_help.png)\n\n- keys 命令：该命令根据字符串匹配模式 pattern 扫描 redis 集群中所有子节点（之所以扫描子节点，是为了减轻对主节点的访问压力，如果需要强制扫描主节点，则在启动 redis_builder 时增加参数 -M），获得符合匹配条件的所有键值，为了防止键太多造成刷屏问题，可以通过 limit 参数指定每个节点显示的条目数\n- get 命令：该命令可以获得五种数据类型（STRING, HASH, LIST, SET, ZSET）的值，内部会根据数据类型自动匹配查询，并根据类型的不同按不同的方式显示。示例如下：\n\n![redis获取命令](/img/redis_get.png)\n\n由上图可以看到，对于 STRING 和 HASH 类型，get 命令会自行进行分别处理。此外，为了防止结果集太大造成刷屏，还可以通过指定参数 :limit 来限定显示的条目，如对于 HASH 类型的 hash_test_key_53479，可以这样查找：get :2 hash_test_key_53479，虽然有三个值，则最多只会显示两个，如下：\n![redisHash获取命令](/img/redis_hash_get.png)\n\n- dbsize 命令：这是一个广播式式命令，会向所有主节点（当启动时指定参数 -M）或从所有主节点各挑选一个子节点发送 dbsize，获得整个 redis 集群中总的记录条数：\n\n![redis数据量命令](/img/redis_dbsize.png)\n\n- nodes 命令：该命令会发送给随意一个 redis 节点，获得当前 redis 集群的分布状态，显示如下：\n![redis节点状态命令](/img/redis_nodes.png)\n\n该图以树型方式展示了整个 redis 集群中的主从分布情况，层次结构清晰，一目了然。\n\n- server 命令：该命令用于切换 redis 集群，管理员可以使用该命令随时切换至其它的 redis 的集群，从而方便管理员使用 redis_builder 命令同时管理多个 redis 集群。命令格式：server ip port\n- 非 redis_builder 内置的其它 redis 命令：随了上面列出的一些内置命令外，管理员可以通过在命令行中输入任意合法的 redis 客户端命令，redis_builder 会将该命令发送至单个 redis 节点或广播（通过在 redis_commands.txt 指定广播方式）至所有的节点。比如：\n\n![redis设置命令](/img/redis_set.png)\n\n图中的 set 及 hmset 命令均不是 redis_builder 内置的命令，但 redis_builder 依然可以按标准 redis 协议命令将请求发送至 redis 节点。\n\n## 四、使用 redis_builder 实时显示当前 redis 集群的运行状态：\n此外，redis_builder 还提供了以命令行方式实时显示当前 redis 集群的运行状态，显示如下：\n![redis状态](/img/redis_status.png)\n \n## 五、编译 redis_builder\n因为该工具依赖于 lib_acl/lib_protocol/lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：\n\n```\n$cd lib_acl; make\n$cd lib_protocol; make\n$cd lib_acl_cpp; make\n```\n\n然后再进入 app/redis_tools/redis_builder 编译：$cd app/redis_tools/redis_builder; make\n\n六、参考\n\nredis_builder 工具下载：https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder\nacl 中的 redis 模块例子：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis\n\nacl on github：https://github.com/acl-dev/acl\nacl on gitee：https://gitee.com/acl-dev/acl","source":"_posts/redis_builder2.md","raw":"---\ntitle: 使用 redis_builder 管理 redis 集群\ndate: 2016-04-23 19:59\ncategories: redis使用\n---\n\n在 <一个 C++ redis 集群管理工具> 中主要讲述了如何使用 redis_builder 工具创建 redis 集群的过程，除此之外，该工具还具有更为强大的 redis 客户端管理功能（相对于官方提供的 redis-cli功能要强大的多）。本文主要讲解使用 redis_builder 以交互方式管理 redis 集群的过程。\n\n## 一、启动 redis_builder 的交互过程\n\n只要运行：./redis_builder -s redis_ip:redis_port，便进入 redis_builder 工具的命令行交互过程，其中 redis_ip 和 redis_port 为 redis 集群中的任一个节点的 IP 及端口号。启动成功后，显示界面如下：\n\n![redis_builder界面](/img/redis_builder.png)\n\n在上图中，首先显示了针对一些 redis 客户端命令的：是否采用广播方式，命令执行权限。\n\n“广播方式”的含义是：该命令需要向 redis 集群中的所有节点发送某个 redis 客户端命令，有的命令向所有主从节点广播，有的命令仅向所有主节点广播。对于象 config xxx xxx （如：config get save）类的命令，是需要向所有主从节点广播以获得所有节点的配置信息；对于象 dbsize 命令，则需要向所有主节点广播，以便获得整个集群总的键值数。\n\n“执行权限”的用处是：1、防止误操作，2、禁止使用 redis_builder 执行某些非常危险的命令。其中“执行权限”的三个级别分别为：yes --- 允许执行，warn --- 警告执行，no --- 禁止执行。对于大部分命令，如：get, incr, dbsize 等命令的执行对于整个系统一般是无害的，所以不会有限制，而对于象 del 类的命令则带有一定危险性，管理员可以配置该命令（下面单独介绍如何配置命令的执行权限）的执行为“警告”方式，这样当运行此类命令时，redis_builder 会首先提示警告信息让管理员再次确认是否真的要执行，这样做的好处是可以在一定程度上防止管理员误操作。\n\n## 二、配置 redis 客户端命令的执行权限\n当以命令行交互方式启动 redis_builder 时，该工具首先会强制检查该工具所在目录下是否有 redis_commands.txt 文件（该文件里配置着一些 redis 客户端命令的执行权限及广播方式），如果存在，则加载命令配置信息，如果该文件不存在则尝试加载由 -F 指定的命令配置信息。之所以要强制加载 redis_commands.txt 命令配置文件，主要适应这样一种应用场景：由 root 超级管理员创建了 redis_commands.txt 文件（属主当然为 root），普通用户只有读的权限，这样 root 管理员在 redis_commands.txt 中设置的 redis 命令执行权限普通用户是不能修改的。\n\n如果在 redis_builder 命令的相同目录下存在 redis_commands.txt 文件且内容如下：\n![redis命令权限](/img/redis_commands.png) \n\n则启动 redis_builder 交互方式后，则显示一些 redis 命令的执行权限如下（红圈内的命令为 redis_commands.txt 文件指定的）：\n\ni![redis命令权限](/img/redis_commands2.png)\n\n如果在 redis_commands.txt 指定的 redis 命令与 redis_builder 内部缺省的命令相同，则执行 redis_commands.txt 中指定的 redis 命令权限。\n\n## 三、redis_builder 在交互方式下的命令操作\n在交互模式下，redis_builder 可以执行所有的 redis 客户端命令，其中，redis_builder 内置了一些针对某些重要命令的特殊执行过程，除了这些内置的 redis 客户端命令，其它的命令执行方式均为标准的 redis 协议命令格式（具体格式可参考：redis.io 或 redisdoc.com）。下面首先介绍 redis_builder 内置的一些 redis 命令，随便输入一些字符串回车后，显示内置的命令如下：\n\n![redis命令帮助](/img/redis_help.png)\n\n- keys 命令：该命令根据字符串匹配模式 pattern 扫描 redis 集群中所有子节点（之所以扫描子节点，是为了减轻对主节点的访问压力，如果需要强制扫描主节点，则在启动 redis_builder 时增加参数 -M），获得符合匹配条件的所有键值，为了防止键太多造成刷屏问题，可以通过 limit 参数指定每个节点显示的条目数\n- get 命令：该命令可以获得五种数据类型（STRING, HASH, LIST, SET, ZSET）的值，内部会根据数据类型自动匹配查询，并根据类型的不同按不同的方式显示。示例如下：\n\n![redis获取命令](/img/redis_get.png)\n\n由上图可以看到，对于 STRING 和 HASH 类型，get 命令会自行进行分别处理。此外，为了防止结果集太大造成刷屏，还可以通过指定参数 :limit 来限定显示的条目，如对于 HASH 类型的 hash_test_key_53479，可以这样查找：get :2 hash_test_key_53479，虽然有三个值，则最多只会显示两个，如下：\n![redisHash获取命令](/img/redis_hash_get.png)\n\n- dbsize 命令：这是一个广播式式命令，会向所有主节点（当启动时指定参数 -M）或从所有主节点各挑选一个子节点发送 dbsize，获得整个 redis 集群中总的记录条数：\n\n![redis数据量命令](/img/redis_dbsize.png)\n\n- nodes 命令：该命令会发送给随意一个 redis 节点，获得当前 redis 集群的分布状态，显示如下：\n![redis节点状态命令](/img/redis_nodes.png)\n\n该图以树型方式展示了整个 redis 集群中的主从分布情况，层次结构清晰，一目了然。\n\n- server 命令：该命令用于切换 redis 集群，管理员可以使用该命令随时切换至其它的 redis 的集群，从而方便管理员使用 redis_builder 命令同时管理多个 redis 集群。命令格式：server ip port\n- 非 redis_builder 内置的其它 redis 命令：随了上面列出的一些内置命令外，管理员可以通过在命令行中输入任意合法的 redis 客户端命令，redis_builder 会将该命令发送至单个 redis 节点或广播（通过在 redis_commands.txt 指定广播方式）至所有的节点。比如：\n\n![redis设置命令](/img/redis_set.png)\n\n图中的 set 及 hmset 命令均不是 redis_builder 内置的命令，但 redis_builder 依然可以按标准 redis 协议命令将请求发送至 redis 节点。\n\n## 四、使用 redis_builder 实时显示当前 redis 集群的运行状态：\n此外，redis_builder 还提供了以命令行方式实时显示当前 redis 集群的运行状态，显示如下：\n![redis状态](/img/redis_status.png)\n \n## 五、编译 redis_builder\n因为该工具依赖于 lib_acl/lib_protocol/lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：\n\n```\n$cd lib_acl; make\n$cd lib_protocol; make\n$cd lib_acl_cpp; make\n```\n\n然后再进入 app/redis_tools/redis_builder 编译：$cd app/redis_tools/redis_builder; make\n\n六、参考\n\nredis_builder 工具下载：https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder\nacl 中的 redis 模块例子：https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis\n\nacl on github：https://github.com/acl-dev/acl\nacl on gitee：https://gitee.com/acl-dev/acl","slug":"redis_builder2","published":1,"updated":"2023-01-24T09:21:06.221Z","_id":"clda0hdjk0005yr9khh179b1z","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在 &lt;一个 C++ redis 集群管理工具&gt; 中主要讲述了如何使用 redis_builder 工具创建 redis 集群的过程，除此之外，该工具还具有更为强大的 redis 客户端管理功能（相对于官方提供的 redis-cli功能要强大的多）。本文主要讲解使用 redis_builder 以交互方式管理 redis 集群的过程。</p>\n<h2 id=\"一、启动-redis-builder-的交互过程\"><a href=\"#一、启动-redis-builder-的交互过程\" class=\"headerlink\" title=\"一、启动 redis_builder 的交互过程\"></a>一、启动 redis_builder 的交互过程</h2><p>只要运行：.&#x2F;redis_builder -s redis_ip:redis_port，便进入 redis_builder 工具的命令行交互过程，其中 redis_ip 和 redis_port 为 redis 集群中的任一个节点的 IP 及端口号。启动成功后，显示界面如下：</p>\n<p><img src=\"/img/redis_builder.png\" alt=\"redis_builder界面\"></p>\n<p>在上图中，首先显示了针对一些 redis 客户端命令的：是否采用广播方式，命令执行权限。</p>\n<p>“广播方式”的含义是：该命令需要向 redis 集群中的所有节点发送某个 redis 客户端命令，有的命令向所有主从节点广播，有的命令仅向所有主节点广播。对于象 config xxx xxx （如：config get save）类的命令，是需要向所有主从节点广播以获得所有节点的配置信息；对于象 dbsize 命令，则需要向所有主节点广播，以便获得整个集群总的键值数。</p>\n<p>“执行权限”的用处是：1、防止误操作，2、禁止使用 redis_builder 执行某些非常危险的命令。其中“执行权限”的三个级别分别为：yes — 允许执行，warn — 警告执行，no — 禁止执行。对于大部分命令，如：get, incr, dbsize 等命令的执行对于整个系统一般是无害的，所以不会有限制，而对于象 del 类的命令则带有一定危险性，管理员可以配置该命令（下面单独介绍如何配置命令的执行权限）的执行为“警告”方式，这样当运行此类命令时，redis_builder 会首先提示警告信息让管理员再次确认是否真的要执行，这样做的好处是可以在一定程度上防止管理员误操作。</p>\n<h2 id=\"二、配置-redis-客户端命令的执行权限\"><a href=\"#二、配置-redis-客户端命令的执行权限\" class=\"headerlink\" title=\"二、配置 redis 客户端命令的执行权限\"></a>二、配置 redis 客户端命令的执行权限</h2><p>当以命令行交互方式启动 redis_builder 时，该工具首先会强制检查该工具所在目录下是否有 redis_commands.txt 文件（该文件里配置着一些 redis 客户端命令的执行权限及广播方式），如果存在，则加载命令配置信息，如果该文件不存在则尝试加载由 -F 指定的命令配置信息。之所以要强制加载 redis_commands.txt 命令配置文件，主要适应这样一种应用场景：由 root 超级管理员创建了 redis_commands.txt 文件（属主当然为 root），普通用户只有读的权限，这样 root 管理员在 redis_commands.txt 中设置的 redis 命令执行权限普通用户是不能修改的。</p>\n<p>如果在 redis_builder 命令的相同目录下存在 redis_commands.txt 文件且内容如下：<br><img src=\"/img/redis_commands.png\" alt=\"redis命令权限\"> </p>\n<p>则启动 redis_builder 交互方式后，则显示一些 redis 命令的执行权限如下（红圈内的命令为 redis_commands.txt 文件指定的）：</p>\n<p>i<img src=\"/img/redis_commands2.png\" alt=\"redis命令权限\"></p>\n<p>如果在 redis_commands.txt 指定的 redis 命令与 redis_builder 内部缺省的命令相同，则执行 redis_commands.txt 中指定的 redis 命令权限。</p>\n<h2 id=\"三、redis-builder-在交互方式下的命令操作\"><a href=\"#三、redis-builder-在交互方式下的命令操作\" class=\"headerlink\" title=\"三、redis_builder 在交互方式下的命令操作\"></a>三、redis_builder 在交互方式下的命令操作</h2><p>在交互模式下，redis_builder 可以执行所有的 redis 客户端命令，其中，redis_builder 内置了一些针对某些重要命令的特殊执行过程，除了这些内置的 redis 客户端命令，其它的命令执行方式均为标准的 redis 协议命令格式（具体格式可参考：redis.io 或 redisdoc.com）。下面首先介绍 redis_builder 内置的一些 redis 命令，随便输入一些字符串回车后，显示内置的命令如下：</p>\n<p><img src=\"/img/redis_help.png\" alt=\"redis命令帮助\"></p>\n<ul>\n<li>keys 命令：该命令根据字符串匹配模式 pattern 扫描 redis 集群中所有子节点（之所以扫描子节点，是为了减轻对主节点的访问压力，如果需要强制扫描主节点，则在启动 redis_builder 时增加参数 -M），获得符合匹配条件的所有键值，为了防止键太多造成刷屏问题，可以通过 limit 参数指定每个节点显示的条目数</li>\n<li>get 命令：该命令可以获得五种数据类型（STRING, HASH, LIST, SET, ZSET）的值，内部会根据数据类型自动匹配查询，并根据类型的不同按不同的方式显示。示例如下：</li>\n</ul>\n<p><img src=\"/img/redis_get.png\" alt=\"redis获取命令\"></p>\n<p>由上图可以看到，对于 STRING 和 HASH 类型，get 命令会自行进行分别处理。此外，为了防止结果集太大造成刷屏，还可以通过指定参数 :limit 来限定显示的条目，如对于 HASH 类型的 hash_test_key_53479，可以这样查找：get :2 hash_test_key_53479，虽然有三个值，则最多只会显示两个，如下：<br><img src=\"/img/redis_hash_get.png\" alt=\"redisHash获取命令\"></p>\n<ul>\n<li>dbsize 命令：这是一个广播式式命令，会向所有主节点（当启动时指定参数 -M）或从所有主节点各挑选一个子节点发送 dbsize，获得整个 redis 集群中总的记录条数：</li>\n</ul>\n<p><img src=\"/img/redis_dbsize.png\" alt=\"redis数据量命令\"></p>\n<ul>\n<li>nodes 命令：该命令会发送给随意一个 redis 节点，获得当前 redis 集群的分布状态，显示如下：<br><img src=\"/img/redis_nodes.png\" alt=\"redis节点状态命令\"></li>\n</ul>\n<p>该图以树型方式展示了整个 redis 集群中的主从分布情况，层次结构清晰，一目了然。</p>\n<ul>\n<li>server 命令：该命令用于切换 redis 集群，管理员可以使用该命令随时切换至其它的 redis 的集群，从而方便管理员使用 redis_builder 命令同时管理多个 redis 集群。命令格式：server ip port</li>\n<li>非 redis_builder 内置的其它 redis 命令：随了上面列出的一些内置命令外，管理员可以通过在命令行中输入任意合法的 redis 客户端命令，redis_builder 会将该命令发送至单个 redis 节点或广播（通过在 redis_commands.txt 指定广播方式）至所有的节点。比如：</li>\n</ul>\n<p><img src=\"/img/redis_set.png\" alt=\"redis设置命令\"></p>\n<p>图中的 set 及 hmset 命令均不是 redis_builder 内置的命令，但 redis_builder 依然可以按标准 redis 协议命令将请求发送至 redis 节点。</p>\n<h2 id=\"四、使用-redis-builder-实时显示当前-redis-集群的运行状态：\"><a href=\"#四、使用-redis-builder-实时显示当前-redis-集群的运行状态：\" class=\"headerlink\" title=\"四、使用 redis_builder 实时显示当前 redis 集群的运行状态：\"></a>四、使用 redis_builder 实时显示当前 redis 集群的运行状态：</h2><p>此外，redis_builder 还提供了以命令行方式实时显示当前 redis 集群的运行状态，显示如下：<br><img src=\"/img/redis_status.png\" alt=\"redis状态\"></p>\n<h2 id=\"五、编译-redis-builder\"><a href=\"#五、编译-redis-builder\" class=\"headerlink\" title=\"五、编译 redis_builder\"></a>五、编译 redis_builder</h2><p>因为该工具依赖于 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_acl; make</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_protocol; make</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_acl_cpp; make</span><br></code></pre></td></tr></table></figure>\n\n<p>然后再进入 app&#x2F;redis_tools&#x2F;redis_builder 编译：$cd app&#x2F;redis_tools&#x2F;redis_builder; make</p>\n<p>六、参考</p>\n<p>redis_builder 工具下载：<a href=\"https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder\">https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder</a><br>acl 中的 redis 模块例子：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis</a></p>\n<p>acl on github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>acl on gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 &lt;一个 C++ redis 集群管理工具&gt; 中主要讲述了如何使用 redis_builder 工具创建 redis 集群的过程，除此之外，该工具还具有更为强大的 redis 客户端管理功能（相对于官方提供的 redis-cli功能要强大的多）。本文主要讲解使用 redis_builder 以交互方式管理 redis 集群的过程。</p>\n<h2 id=\"一、启动-redis-builder-的交互过程\"><a href=\"#一、启动-redis-builder-的交互过程\" class=\"headerlink\" title=\"一、启动 redis_builder 的交互过程\"></a>一、启动 redis_builder 的交互过程</h2><p>只要运行：.&#x2F;redis_builder -s redis_ip:redis_port，便进入 redis_builder 工具的命令行交互过程，其中 redis_ip 和 redis_port 为 redis 集群中的任一个节点的 IP 及端口号。启动成功后，显示界面如下：</p>\n<p><img src=\"/img/redis_builder.png\" alt=\"redis_builder界面\"></p>\n<p>在上图中，首先显示了针对一些 redis 客户端命令的：是否采用广播方式，命令执行权限。</p>\n<p>“广播方式”的含义是：该命令需要向 redis 集群中的所有节点发送某个 redis 客户端命令，有的命令向所有主从节点广播，有的命令仅向所有主节点广播。对于象 config xxx xxx （如：config get save）类的命令，是需要向所有主从节点广播以获得所有节点的配置信息；对于象 dbsize 命令，则需要向所有主节点广播，以便获得整个集群总的键值数。</p>\n<p>“执行权限”的用处是：1、防止误操作，2、禁止使用 redis_builder 执行某些非常危险的命令。其中“执行权限”的三个级别分别为：yes — 允许执行，warn — 警告执行，no — 禁止执行。对于大部分命令，如：get, incr, dbsize 等命令的执行对于整个系统一般是无害的，所以不会有限制，而对于象 del 类的命令则带有一定危险性，管理员可以配置该命令（下面单独介绍如何配置命令的执行权限）的执行为“警告”方式，这样当运行此类命令时，redis_builder 会首先提示警告信息让管理员再次确认是否真的要执行，这样做的好处是可以在一定程度上防止管理员误操作。</p>\n<h2 id=\"二、配置-redis-客户端命令的执行权限\"><a href=\"#二、配置-redis-客户端命令的执行权限\" class=\"headerlink\" title=\"二、配置 redis 客户端命令的执行权限\"></a>二、配置 redis 客户端命令的执行权限</h2><p>当以命令行交互方式启动 redis_builder 时，该工具首先会强制检查该工具所在目录下是否有 redis_commands.txt 文件（该文件里配置着一些 redis 客户端命令的执行权限及广播方式），如果存在，则加载命令配置信息，如果该文件不存在则尝试加载由 -F 指定的命令配置信息。之所以要强制加载 redis_commands.txt 命令配置文件，主要适应这样一种应用场景：由 root 超级管理员创建了 redis_commands.txt 文件（属主当然为 root），普通用户只有读的权限，这样 root 管理员在 redis_commands.txt 中设置的 redis 命令执行权限普通用户是不能修改的。</p>\n<p>如果在 redis_builder 命令的相同目录下存在 redis_commands.txt 文件且内容如下：<br><img src=\"/img/redis_commands.png\" alt=\"redis命令权限\"> </p>\n<p>则启动 redis_builder 交互方式后，则显示一些 redis 命令的执行权限如下（红圈内的命令为 redis_commands.txt 文件指定的）：</p>\n<p>i<img src=\"/img/redis_commands2.png\" alt=\"redis命令权限\"></p>\n<p>如果在 redis_commands.txt 指定的 redis 命令与 redis_builder 内部缺省的命令相同，则执行 redis_commands.txt 中指定的 redis 命令权限。</p>\n<h2 id=\"三、redis-builder-在交互方式下的命令操作\"><a href=\"#三、redis-builder-在交互方式下的命令操作\" class=\"headerlink\" title=\"三、redis_builder 在交互方式下的命令操作\"></a>三、redis_builder 在交互方式下的命令操作</h2><p>在交互模式下，redis_builder 可以执行所有的 redis 客户端命令，其中，redis_builder 内置了一些针对某些重要命令的特殊执行过程，除了这些内置的 redis 客户端命令，其它的命令执行方式均为标准的 redis 协议命令格式（具体格式可参考：redis.io 或 redisdoc.com）。下面首先介绍 redis_builder 内置的一些 redis 命令，随便输入一些字符串回车后，显示内置的命令如下：</p>\n<p><img src=\"/img/redis_help.png\" alt=\"redis命令帮助\"></p>\n<ul>\n<li>keys 命令：该命令根据字符串匹配模式 pattern 扫描 redis 集群中所有子节点（之所以扫描子节点，是为了减轻对主节点的访问压力，如果需要强制扫描主节点，则在启动 redis_builder 时增加参数 -M），获得符合匹配条件的所有键值，为了防止键太多造成刷屏问题，可以通过 limit 参数指定每个节点显示的条目数</li>\n<li>get 命令：该命令可以获得五种数据类型（STRING, HASH, LIST, SET, ZSET）的值，内部会根据数据类型自动匹配查询，并根据类型的不同按不同的方式显示。示例如下：</li>\n</ul>\n<p><img src=\"/img/redis_get.png\" alt=\"redis获取命令\"></p>\n<p>由上图可以看到，对于 STRING 和 HASH 类型，get 命令会自行进行分别处理。此外，为了防止结果集太大造成刷屏，还可以通过指定参数 :limit 来限定显示的条目，如对于 HASH 类型的 hash_test_key_53479，可以这样查找：get :2 hash_test_key_53479，虽然有三个值，则最多只会显示两个，如下：<br><img src=\"/img/redis_hash_get.png\" alt=\"redisHash获取命令\"></p>\n<ul>\n<li>dbsize 命令：这是一个广播式式命令，会向所有主节点（当启动时指定参数 -M）或从所有主节点各挑选一个子节点发送 dbsize，获得整个 redis 集群中总的记录条数：</li>\n</ul>\n<p><img src=\"/img/redis_dbsize.png\" alt=\"redis数据量命令\"></p>\n<ul>\n<li>nodes 命令：该命令会发送给随意一个 redis 节点，获得当前 redis 集群的分布状态，显示如下：<br><img src=\"/img/redis_nodes.png\" alt=\"redis节点状态命令\"></li>\n</ul>\n<p>该图以树型方式展示了整个 redis 集群中的主从分布情况，层次结构清晰，一目了然。</p>\n<ul>\n<li>server 命令：该命令用于切换 redis 集群，管理员可以使用该命令随时切换至其它的 redis 的集群，从而方便管理员使用 redis_builder 命令同时管理多个 redis 集群。命令格式：server ip port</li>\n<li>非 redis_builder 内置的其它 redis 命令：随了上面列出的一些内置命令外，管理员可以通过在命令行中输入任意合法的 redis 客户端命令，redis_builder 会将该命令发送至单个 redis 节点或广播（通过在 redis_commands.txt 指定广播方式）至所有的节点。比如：</li>\n</ul>\n<p><img src=\"/img/redis_set.png\" alt=\"redis设置命令\"></p>\n<p>图中的 set 及 hmset 命令均不是 redis_builder 内置的命令，但 redis_builder 依然可以按标准 redis 协议命令将请求发送至 redis 节点。</p>\n<h2 id=\"四、使用-redis-builder-实时显示当前-redis-集群的运行状态：\"><a href=\"#四、使用-redis-builder-实时显示当前-redis-集群的运行状态：\" class=\"headerlink\" title=\"四、使用 redis_builder 实时显示当前 redis 集群的运行状态：\"></a>四、使用 redis_builder 实时显示当前 redis 集群的运行状态：</h2><p>此外，redis_builder 还提供了以命令行方式实时显示当前 redis 集群的运行状态，显示如下：<br><img src=\"/img/redis_status.png\" alt=\"redis状态\"></p>\n<h2 id=\"五、编译-redis-builder\"><a href=\"#五、编译-redis-builder\" class=\"headerlink\" title=\"五、编译 redis_builder\"></a>五、编译 redis_builder</h2><p>因为该工具依赖于 lib_acl&#x2F;lib_protocol&#x2F;lib_acl_cpp 三个 acl 基础库，所以需要首先编译这三个库：</p>\n<figure class=\"highlight gams\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs gams\"><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_acl; make</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_protocol; make</span><br><span class=\"hljs-meta\"><span class=\"hljs-keyword\">$cd</span> lib_acl_cpp; make</span><br></code></pre></td></tr></table></figure>\n\n<p>然后再进入 app&#x2F;redis_tools&#x2F;redis_builder 编译：$cd app&#x2F;redis_tools&#x2F;redis_builder; make</p>\n<p>六、参考</p>\n<p>redis_builder 工具下载：<a href=\"https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder\">https://github.com/acl-dev/acl/tree/master/app/redis_tools/redis_builder</a><br>acl 中的 redis 模块例子：<a href=\"https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis\">https://github.com/acl-dev/acl/tree/master/lib_acl_cpp/samples/redis</a></p>\n<p>acl on github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>acl on gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"使用 acl 内存池模块管理动态对象","date":"2015-11-14T16:27:00.000Z","_content":"\nC/C++ 最容易出问题的地方是内存管理，容易造成内存泄露和内存越界，这一直是 C/C++ 程序员比较头疼的事情，但 C/C++ 最大的优势也是内存管理，可以让程序员直接管理内存，从而使程序运行更为高效。acl 库中的内存池管理器 dbuf_guard 在管理内存的效率上比系统级内存管理方式（malloc/free, new/delete）更为高效，同时也使内存管理更为健壮性，这可以使 C/C++ 程序员避免出现一些常见的内存问题。本节主要介绍了 acl 库中 dbuf_guard 类的设计特点及使用方法。\n\ndbuf_guard 类内部封装了内存池对象类 dbuf_pool，提供了与 dbuf_pool 一样的内存分配方法，dbuf_guard 类与 dbuf_pool 类的最大区别是 dbuf_guard 类对象既可以在堆上动态分配，也可以在栈上分配，而 dbuf_pool 类对象必须在堆上动态分配，另外，dbuf_guard 类还统一管理在 dbuf_pool 内存池上所创建的所有 dbuf_obj 子类对象，在 dbuf_guard 类对象析构时，所有由其管理的 dbuf_obj 子类对象被统一析构。下面先从一个简单的例子来说明 dbuf_guard 的使用方法，例子如下：\n\n```c++\nvoid test(void)\n{\n\t// 定义一个内存池管理对象\n\tacl::dbuf_guard dbuf;\n\n#define\tSTR\t\"hello world\"\n\n\t// 在 dbuf 对象上动态创建一个字符串内存\n\tchar* str = dbuf.dbuf_strdup(STR);\n\tprintf(\"str: %s\\r\\n\", str);\n\n\t// 在 dbuf 对象上动态创建内存\n\n\t// sizeof(STR) 取得 STR 所包含的字符串长度 + 1\n\tstr = (char*) dbuf.dbuf_alloc(sizeof(STR));\n\tmemcpy(str, STR, sizeof(STR));\n\tprintf(\"str: %s\\r\\n\", str);\n\n\t// 在本函数返回前，dbuf 对象自动被销毁，同时释放其所管理的\n\t// 内存池以及在内存池上分配的内存\n}\n```\n\n上面的例子展示了使用 dbuf_guard 类对象直接分配内存块的过程，可以看出，所有在 dbuf_guard 对象的内存池上动态分配的内存都会在 dbuf_guard 对象销毁时被自动释放。这只是一个简单的使用 dbuf_guard 进行内存管理的例子，那么对于 C++ 对象的内存如何进行管理呢？请看下面的的例子：\n\n```c++\nclass myobj : public acl::dbuf_obj\n{\npublic:\n\tmyobj()\n\t{\n\t\t// 调用系统 API 分配动态内存\n\t\tstr_ = strdup(\"hello world\");\n\t}\n\n\tvoid run()\n\t{\n\t\tprintf(\"str: %s\\r\\n\", str_);\n\t}\n\nprivate:\n\tchar* str_;\n\n\t~myobj()\n\t{\n\t\t// 释放构造函数中分配的内存，否则会造成内存泄露\n\t\tfree(str_);\n\t}\n};\n\nvoid test(void)\n{\n\tacl::dbuf_guard dbuf;\n\n\t// 调用 dbuf_guard::create<T>() 模板函数创建 myobj 对象\n\tmyobj* obj = dbuf.create<myobj>();\n\n\t// 调用 myobj::run 方法\n\tobj->run();\n\n\t// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁\n}\n```\n\n该例子展示了 C++ 对象在 dbuf_guard 动态创建的过程，其中有两个要点：\n\n- 由 dbuf_guard 对象统一管理的 C++ 对象必须是 dbuf_obj 的子类，这样在 dbuf_guard 类对象的析构时才可以通过调用 dbuf_obj 的析构函数来达到将 dbuf_obj 子类析构的目的（其中 dbuf_obj 的析构函数为虚函数）；\n- 创建 dbuf_obj 的子类对象时，调用 dbuf_guard 对象的模板函数 create，同时指定子类名称 myobj 来创建 myobj 对象，create 内部会自动将该对象指针加入内部数组对象集合中，从而达到统一管理的目的。\n\n上面例子的构造函数不带参数，在 dbuf_guard::create 模板函数中允许添加 0  至 10 个参数（其实内部有 11 个 create 模板函数），如果一个构造函数需要多于 10 个参数，则说明该构造函数设计的太复杂了。下面的例子展示了构造函数带参数的类对象创建过程：\n\n```c++\n// 继承于 acl::dbuf_obj 类\nclass myobj : public acl::dbuf_obj\n{\npublic:\n\tmyobj(int i, int j)\n\t{\n\t\tprintf(\"myobj, i=%d, j=%d\\r\\n\", i, j);\n\t\t// 在内存池上分配动态内存\n\t\tstr_ = dbuf.dbuf_strdup(\"hello world\");\n\t}\n\n\tvoid run()\n\t{\n\t\tprintf(\"str: %s\\r\\n\", str_);\n\t}\n\nprivate:\n\tchar* str_;\n\n\t~myobj()\n\t{\n\t\t// 因为 str_ 的内存也是创建在内存池上，所以此处禁止再调用 free 来释放该内存\n\t\t// free(str_);\n\t}\n};\n\nvoid test(void)\n{\n\tacl::dbuf_guard dbuf;\n\n\t// 调用 dbuf_guard::create<T>(P1, P2) 模板函数创建构造函数带两个参数的 myobj 对象\n\tmyobj* obj = dbuf.create<myobj>(10, 100);\n\n\t// 调用 myobj::run 方法\n\tobj->run();\n\n\t// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁\n}\n```\n\n在 dbuf_guard 类中除了上面提供的方法外，还提供了以下多个方法方便使用：\n\n```c++\n\t/**\n\t * 调用 dbuf_pool::dbuf_reset\n\t * @param reserve {size_t}\n\t * @return {bool}\n\t */\n\tbool dbuf_reset(size_t reserve = 0)\n\t{\n\t\treturn dbuf_->dbuf_reset(reserve);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_alloc\n\t * @param len {size_t}\n\t * @return {void*}\n\t */\n\tvoid* dbuf_alloc(size_t len)\n\t{\n\t\treturn dbuf_->dbuf_alloc(len);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_calloc\n\t * @param len {size_t}\n\t * @return {void*}\n\t */\n\tvoid* dbuf_calloc(size_t len)\n\t{\n\t\treturn dbuf_->dbuf_calloc(len);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_strdup\n\t * @param s {const char*}\n\t * @return {char*}\n\t */\n\tchar* dbuf_strdup(const char* s)\n\t{\n\t\treturn dbuf_->dbuf_strdup(s);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_strndup\n\t * @param s {const char*}\n\t * @param len {size_t}\n\t * @return {char*}\n\t */\n\tchar* dbuf_strndup(const char* s, size_t len)\n\t{\n\t\treturn dbuf_->dbuf_strndup(s, len);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_memdup\n\t * @param addr {const void*}\n\t * @param len {size_t}\n\t * @return {void*}\n\t */\n\tvoid* dbuf_memdup(const void* addr, size_t len)\n\t{\n\t\treturn dbuf_->dbuf_memdup(addr, len);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_free\n\t * @param addr {const void*}\n\t * @return {bool}\n\t */\n\tbool dbuf_free(const void* addr)\n\t{\n\t\treturn dbuf_->dbuf_free(addr);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_keep\n\t * @param addr {const void*}\n\t * @return {bool}\n\t */\n\tbool dbuf_keep(const void* addr)\n\t{\n\t\treturn dbuf_->dbuf_keep(addr);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_unkeep\n\t * @param addr {const void*}\n\t * @return {bool}\n\t */\n\tbool dbuf_unkeep(const void* addr)\n\t{\n\t\treturn dbuf_->dbuf_unkeep(addr);\n\t}\n\n\t/**\n\t * 获得 dbuf_pool 对象\n\t * @return {acl::dbuf_pool&}\n\t */\n\tacl::dbuf_pool& get_dbuf() const\n\t{\n\t\treturn *dbuf_;\n\t}\n\n\t/**\n\t * 可以手动调用本函数，将在 dbuf_pool 上分配的 dbuf_obj 子类对象交给\n\t * dbuf_guard 对象统一进行销毁管理；严禁将同一个 dbuf_obj 子类对象同\n\t * 时将给多个 dbuf_guard 对象进行管理，否则将会产生对象的重复释放\n\t * @param obj {dbuf_obj*}\n\t * @return {int} 返回 obj 被添加后其在 dbuf_obj 对象数组中的下标位置，\n\t *  dbuf_guard 内部对 dbuf_obj 对象的管理具有防重添加机制，所以当多次\n\t *  将同一个 dbuf_obj 对象置入同一个 dbuf_guard 对象时，内部只会放一次\n\t */\n\tint push_back(dbuf_obj* obj);\n\n\t/**\n\t * 获得当前内存池中管理的对象数量\n\t * @return {size_t}\n\t */\n\tsize_t size() const\n\t{\n\t\treturn size_;\n\t}\n\n\t/**\n\t * 获得当前内存池中管理的对象集合，该函数必须与 size() 函数配合使用，\n\t * 以免指针地址越界\n\t * @return {dbuf_obj**} 返回 dbuf_obj 对象集合，永远返回非 NULL 值，\n\t *  该数组的大小由 size() 函数决定\n\t */\n\tdbuf_obj** get_objs() const\n\t{\n\t\treturn objs_;\n\t}\n\n\t/**\n\t * 返回指定下标的对象\n\t * @param pos {size_t} 指定对象的下标位置，不应越界\n\t * @return {dbuf_obj*} 当下标位置越界时返回 NULL\n\t */\n\tdbuf_obj* operator[](size_t pos) const;\n\n\t/**\n\t * 返回指定下标的对象\n\t * @param pos {size_t} 指定对象的下标位置，不应越界\n\t * @return {dbuf_obj*} 当下标位置越界时返回 NULL\n\t */\n\tdbuf_obj* get(size_t pos) const;\n\n\t/**\n\t * 设置内建 objs_ 数组对象每次在扩充空间时的增量，内部缺省值为 100\n\t * @param incr {size_t}\n\t */\n\tvoid set_increment(size_t incr);\n\n       同时，dbuf_obj 类中也提供了额外的操作方法：\n\n\t/**\n\t * 获得该对象在 dbuf_guard 中的数组中的下标位置\n\t * @return {int} 返回该对象在 dbuf_guard 中的数组中的下标位置，当该\n\t *  对象没有被 dbuf_guard 保存时，则返回 -1，此时有可能会造成内存泄露\n\t */\n\tint pos() const\n\t{\n\t\treturn pos_;\n\t}\n\n\t/**\n\t * 返回构造函数中 dbuf_guard 对象\n\t * @return {dbuf_guard*}\n\t */\n\tdbuf_guard* get_guard() const\n\t{\n\t\treturn guard_;\n\t}\n```\n\n最后，以一个稍微复杂的例子做为结尾(该例子源码在 acl 库中的位置：lib_acl_cpp\\samples\\dbuf\\dbuf2)，该例子展示了使用 dbuf_guard 类的几种方法：\n\n```c++\n#include \"stdafx.h\"\n#include <sys/time.h>\n\n/**\n * dbuf_obj 子类，在 dbuf_pool 上动态分配，由 dbuf_guard 统一进行管理\n */\nclass myobj : public acl::dbuf_obj\n{\npublic:\n\tmyobj(acl::dbuf_guard* guard = NULL) : dbuf_obj(guard)\n\t{\n\t\tptr_ = strdup(\"hello\");\n\t}\n\n\tvoid run()\n\t{\n\t\tprintf(\"----> run->hello world <-----\\r\\n\");\n\t}\n\nprivate:\n\tchar* ptr_;\n\n\t// 将析构声明为私人，以强制要求该对象被动态分配，该析构函数将由\n\t// dbuf_guard 统一调用，以释放本类对象中产生的动态内存(ptr_)\n\t~myobj()\n\t{\n\t\tfree(ptr_);\n\t}\n};\n\nstatic void test_dbuf(acl::dbuf_guard& dbuf)\n{\n\tfor (int i = 0; i < 102400; i++)\n\t{\n\t\t// 动态分配内存\n\t\tchar* ptr = (char*) dbuf.dbuf_alloc(10);\n\t\t(void) ptr;\n\t}\n\n\tfor (int i = 0; i < 102400; i++)\n\t{\n\t\t// 动态分配字符串\n\t\tchar* str = dbuf.dbuf_strdup(\"hello world\");\n\t\tif (i < 5)\n\t\t\tprintf(\">>str->%s\\r\\n\", str);\n\t}\n\n\t// 动态分配内存\n\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(2048);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(10240);\n\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\t// 动态分配 dbuf_obj 子类对象，并通过将 dbuf_guard 对象传入\n\t\t// dbuf_obj 的构造函数，从而将之由 dbuf_guard 统一管理，\n\n\t\tmyobj* obj = dbuf.create<myobj>(&dbuf);\n\n\t\t// 验证 dbuf_obj 对象在 dbuf_guard 中的在在一致性\n\t\tassert(obj == dbuf[obj->pos()]);\n\n\t\t// 调用 dbuf_obj 子类对象 myobj 的函数 run\n\t\tif (i < 10)\n\t\t\tobj->run();\n\t}\n\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tmyobj* obj = dbuf.create<myobj>();\n\n\t\tassert(dbuf[obj->pos()] == obj);\n\n\t\tif (i < 10)\n\t\t\tobj->run();\n\t}\n\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tmyobj* obj = dbuf.create<myobj>(&dbuf);\n\n\t\t// 虽然多次将 dbuf_obj 对象置入 dbuf_guard 中，因为 dbuf_obj\n\t\t// 内部的引用计数，所以可以防止被重复添加\n\t\t(void) dbuf.push_back(obj);\n\t\t(void) dbuf.push_back(obj);\n\t\t(void) dbuf.push_back(obj);\n\n\t\tassert(obj == dbuf[obj->pos()]);\n\n\t\tif (i < 10)\n\t\t\tobj->run();\n\t}\n}\n\nstatic void wait_pause()\n{\n\tprintf(\"Enter any key to continue ...\");\n\tfflush(stdout);\n\tgetchar();\n}\n\nstatic void test1()\n{\n\t// dbuf_gaurd 对象创建在栈上，函数返回前该对象自动销毁\n\tacl::dbuf_guard dbuf;\n\n\ttest_dbuf(dbuf);\n}\n\nstatic void test2()\n{\n\t// 动态创建 dbuf_guard 对象，需要手动销毁该对象\n\tacl::dbuf_guard* dbuf = new acl::dbuf_guard;\n\n\ttest_dbuf(*dbuf);\n\n\t// 手工销毁该对象\n\tdelete dbuf;\n}\n\nstatic void test3()\n{\n\t// 将内存池对象 dbuf_pool 做为 dbuf_guard 构造函数参数传入，当\n\t// dbuf_guard 对象销毁时，dbuf_pool 对象一同被销毁\n\tacl::dbuf_guard dbuf(new acl::dbuf_pool);\n\n\ttest_dbuf(dbuf);\n}\n\nstatic void test4()\n{\n\t// 动态创建 dbuf_guard 对象，同时指定内存池中内存块的分配倍数为 10，\n\t// 即指定内部每个内存块大小为 4096 * 10 = 40 KB，同时\n\t// 指定内部动态数组的初始容量大小\n\tacl::dbuf_guard dbuf(10, 100);\n\n\ttest_dbuf(dbuf);\n}\n\nstatic void test5()\n{\n\tacl::dbuf_pool* dp = new acl::dbuf_pool;\n\n\t// 在内存池对象上动态创建 dbuf_guard 对象，这样可以将内存分配的次数\n\t// 进一步减少一次\n\tacl::dbuf_guard* dbuf = new (dp->dbuf_alloc(sizeof(acl::dbuf_guard)))\n\t\tacl::dbuf_guard(dp);\n\n\ttest_dbuf(*dbuf);\n\n\t// 因为 dbuf_gaurd 对象也是在 dbuf_pool 内存池对象上动态创建的，所以\n\t// 只能通过直接调用 dbuf_guard 的析构函数来释放所有的内存对象；\n\t// 既不能直接 dbuf_pool->desotry()，也不能直接 delete dbuf_guard 来\n\t// 销毁 dbuf_guard 对象\n\tdbuf->~dbuf_guard();\n}\n\nclass myobj2 : public acl::dbuf_obj\n{\npublic:\n\tmyobj2() {}\n\n\tvoid run()\n\t{\n\t\tprintf(\"hello world\\r\\n\");\n\t}\n\nprivate:\n\t~myobj2() {}\n};\n\nclass myobj3 : public acl::dbuf_obj\n{\npublic:\n\tmyobj3(int i) : i_(i) {}\n\n\tvoid run()\n\t{\n\t\tprintf(\"hello world: %d\\r\\n\", i_);\n\t}\n\nprivate:\n\t~myobj3() {}\n\nprivate:\n\tint i_;\n};\n\nclass myobj_dummy\n{\npublic:\n\tmyobj_dummy() {}\n\n\tvoid run()\n\t{\n\t\tprintf(\"can't be compiled\\r\\n\");\n\t}\n\nprivate:\n\t~myobj_dummy() {}\n};\n\nstatic void test6()\n{\n\tacl::dbuf_guard dbuf;\n\n\tmyobj* o = dbuf.create<myobj>();\n\to->run();\n\n\tmyobj* o1 = dbuf.create<myobj>(&dbuf);\n\to1->run();\n\n\tmyobj2* o2 = dbuf.create<myobj2>();\n\to2->run();\n\n\tmyobj3* o3 = dbuf.create<myobj3>(10);\n\to3->run();\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tmyobj3* o4 = dbuf.create<myobj3>(i);\n\t\to4->run();\n\t}\n\n\t// below codes can't be compiled, because myobj_dummy isn't\n\t// acl::dbuf_obj's subclass\n\t// myobj_dummy* dummy = dbuf.create<myobj_dummy>();\n\t// dummy->run();\n}\n\nint main(void)\n{\n\tacl::log::stdout_open(true);\n\n\ttest1();\n\twait_pause();\n\n\ttest2();\n\twait_pause();\n\n\ttest3();\n\twait_pause();\n\n\ttest4();\n\twait_pause();\n\n\ttest5();\n\twait_pause();\n\n\ttest6();\n\treturn 0;\n}\n```\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","source":"_posts/memory_pool.md","raw":"---\ntitle: 使用 acl 内存池模块管理动态对象\ndate: 2015-11-15 00:27\ncategories: 内存管理\n---\n\nC/C++ 最容易出问题的地方是内存管理，容易造成内存泄露和内存越界，这一直是 C/C++ 程序员比较头疼的事情，但 C/C++ 最大的优势也是内存管理，可以让程序员直接管理内存，从而使程序运行更为高效。acl 库中的内存池管理器 dbuf_guard 在管理内存的效率上比系统级内存管理方式（malloc/free, new/delete）更为高效，同时也使内存管理更为健壮性，这可以使 C/C++ 程序员避免出现一些常见的内存问题。本节主要介绍了 acl 库中 dbuf_guard 类的设计特点及使用方法。\n\ndbuf_guard 类内部封装了内存池对象类 dbuf_pool，提供了与 dbuf_pool 一样的内存分配方法，dbuf_guard 类与 dbuf_pool 类的最大区别是 dbuf_guard 类对象既可以在堆上动态分配，也可以在栈上分配，而 dbuf_pool 类对象必须在堆上动态分配，另外，dbuf_guard 类还统一管理在 dbuf_pool 内存池上所创建的所有 dbuf_obj 子类对象，在 dbuf_guard 类对象析构时，所有由其管理的 dbuf_obj 子类对象被统一析构。下面先从一个简单的例子来说明 dbuf_guard 的使用方法，例子如下：\n\n```c++\nvoid test(void)\n{\n\t// 定义一个内存池管理对象\n\tacl::dbuf_guard dbuf;\n\n#define\tSTR\t\"hello world\"\n\n\t// 在 dbuf 对象上动态创建一个字符串内存\n\tchar* str = dbuf.dbuf_strdup(STR);\n\tprintf(\"str: %s\\r\\n\", str);\n\n\t// 在 dbuf 对象上动态创建内存\n\n\t// sizeof(STR) 取得 STR 所包含的字符串长度 + 1\n\tstr = (char*) dbuf.dbuf_alloc(sizeof(STR));\n\tmemcpy(str, STR, sizeof(STR));\n\tprintf(\"str: %s\\r\\n\", str);\n\n\t// 在本函数返回前，dbuf 对象自动被销毁，同时释放其所管理的\n\t// 内存池以及在内存池上分配的内存\n}\n```\n\n上面的例子展示了使用 dbuf_guard 类对象直接分配内存块的过程，可以看出，所有在 dbuf_guard 对象的内存池上动态分配的内存都会在 dbuf_guard 对象销毁时被自动释放。这只是一个简单的使用 dbuf_guard 进行内存管理的例子，那么对于 C++ 对象的内存如何进行管理呢？请看下面的的例子：\n\n```c++\nclass myobj : public acl::dbuf_obj\n{\npublic:\n\tmyobj()\n\t{\n\t\t// 调用系统 API 分配动态内存\n\t\tstr_ = strdup(\"hello world\");\n\t}\n\n\tvoid run()\n\t{\n\t\tprintf(\"str: %s\\r\\n\", str_);\n\t}\n\nprivate:\n\tchar* str_;\n\n\t~myobj()\n\t{\n\t\t// 释放构造函数中分配的内存，否则会造成内存泄露\n\t\tfree(str_);\n\t}\n};\n\nvoid test(void)\n{\n\tacl::dbuf_guard dbuf;\n\n\t// 调用 dbuf_guard::create<T>() 模板函数创建 myobj 对象\n\tmyobj* obj = dbuf.create<myobj>();\n\n\t// 调用 myobj::run 方法\n\tobj->run();\n\n\t// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁\n}\n```\n\n该例子展示了 C++ 对象在 dbuf_guard 动态创建的过程，其中有两个要点：\n\n- 由 dbuf_guard 对象统一管理的 C++ 对象必须是 dbuf_obj 的子类，这样在 dbuf_guard 类对象的析构时才可以通过调用 dbuf_obj 的析构函数来达到将 dbuf_obj 子类析构的目的（其中 dbuf_obj 的析构函数为虚函数）；\n- 创建 dbuf_obj 的子类对象时，调用 dbuf_guard 对象的模板函数 create，同时指定子类名称 myobj 来创建 myobj 对象，create 内部会自动将该对象指针加入内部数组对象集合中，从而达到统一管理的目的。\n\n上面例子的构造函数不带参数，在 dbuf_guard::create 模板函数中允许添加 0  至 10 个参数（其实内部有 11 个 create 模板函数），如果一个构造函数需要多于 10 个参数，则说明该构造函数设计的太复杂了。下面的例子展示了构造函数带参数的类对象创建过程：\n\n```c++\n// 继承于 acl::dbuf_obj 类\nclass myobj : public acl::dbuf_obj\n{\npublic:\n\tmyobj(int i, int j)\n\t{\n\t\tprintf(\"myobj, i=%d, j=%d\\r\\n\", i, j);\n\t\t// 在内存池上分配动态内存\n\t\tstr_ = dbuf.dbuf_strdup(\"hello world\");\n\t}\n\n\tvoid run()\n\t{\n\t\tprintf(\"str: %s\\r\\n\", str_);\n\t}\n\nprivate:\n\tchar* str_;\n\n\t~myobj()\n\t{\n\t\t// 因为 str_ 的内存也是创建在内存池上，所以此处禁止再调用 free 来释放该内存\n\t\t// free(str_);\n\t}\n};\n\nvoid test(void)\n{\n\tacl::dbuf_guard dbuf;\n\n\t// 调用 dbuf_guard::create<T>(P1, P2) 模板函数创建构造函数带两个参数的 myobj 对象\n\tmyobj* obj = dbuf.create<myobj>(10, 100);\n\n\t// 调用 myobj::run 方法\n\tobj->run();\n\n\t// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁\n}\n```\n\n在 dbuf_guard 类中除了上面提供的方法外，还提供了以下多个方法方便使用：\n\n```c++\n\t/**\n\t * 调用 dbuf_pool::dbuf_reset\n\t * @param reserve {size_t}\n\t * @return {bool}\n\t */\n\tbool dbuf_reset(size_t reserve = 0)\n\t{\n\t\treturn dbuf_->dbuf_reset(reserve);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_alloc\n\t * @param len {size_t}\n\t * @return {void*}\n\t */\n\tvoid* dbuf_alloc(size_t len)\n\t{\n\t\treturn dbuf_->dbuf_alloc(len);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_calloc\n\t * @param len {size_t}\n\t * @return {void*}\n\t */\n\tvoid* dbuf_calloc(size_t len)\n\t{\n\t\treturn dbuf_->dbuf_calloc(len);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_strdup\n\t * @param s {const char*}\n\t * @return {char*}\n\t */\n\tchar* dbuf_strdup(const char* s)\n\t{\n\t\treturn dbuf_->dbuf_strdup(s);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_strndup\n\t * @param s {const char*}\n\t * @param len {size_t}\n\t * @return {char*}\n\t */\n\tchar* dbuf_strndup(const char* s, size_t len)\n\t{\n\t\treturn dbuf_->dbuf_strndup(s, len);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_memdup\n\t * @param addr {const void*}\n\t * @param len {size_t}\n\t * @return {void*}\n\t */\n\tvoid* dbuf_memdup(const void* addr, size_t len)\n\t{\n\t\treturn dbuf_->dbuf_memdup(addr, len);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_free\n\t * @param addr {const void*}\n\t * @return {bool}\n\t */\n\tbool dbuf_free(const void* addr)\n\t{\n\t\treturn dbuf_->dbuf_free(addr);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_keep\n\t * @param addr {const void*}\n\t * @return {bool}\n\t */\n\tbool dbuf_keep(const void* addr)\n\t{\n\t\treturn dbuf_->dbuf_keep(addr);\n\t}\n\n\t/**\n\t * 调用 dbuf_pool::dbuf_unkeep\n\t * @param addr {const void*}\n\t * @return {bool}\n\t */\n\tbool dbuf_unkeep(const void* addr)\n\t{\n\t\treturn dbuf_->dbuf_unkeep(addr);\n\t}\n\n\t/**\n\t * 获得 dbuf_pool 对象\n\t * @return {acl::dbuf_pool&}\n\t */\n\tacl::dbuf_pool& get_dbuf() const\n\t{\n\t\treturn *dbuf_;\n\t}\n\n\t/**\n\t * 可以手动调用本函数，将在 dbuf_pool 上分配的 dbuf_obj 子类对象交给\n\t * dbuf_guard 对象统一进行销毁管理；严禁将同一个 dbuf_obj 子类对象同\n\t * 时将给多个 dbuf_guard 对象进行管理，否则将会产生对象的重复释放\n\t * @param obj {dbuf_obj*}\n\t * @return {int} 返回 obj 被添加后其在 dbuf_obj 对象数组中的下标位置，\n\t *  dbuf_guard 内部对 dbuf_obj 对象的管理具有防重添加机制，所以当多次\n\t *  将同一个 dbuf_obj 对象置入同一个 dbuf_guard 对象时，内部只会放一次\n\t */\n\tint push_back(dbuf_obj* obj);\n\n\t/**\n\t * 获得当前内存池中管理的对象数量\n\t * @return {size_t}\n\t */\n\tsize_t size() const\n\t{\n\t\treturn size_;\n\t}\n\n\t/**\n\t * 获得当前内存池中管理的对象集合，该函数必须与 size() 函数配合使用，\n\t * 以免指针地址越界\n\t * @return {dbuf_obj**} 返回 dbuf_obj 对象集合，永远返回非 NULL 值，\n\t *  该数组的大小由 size() 函数决定\n\t */\n\tdbuf_obj** get_objs() const\n\t{\n\t\treturn objs_;\n\t}\n\n\t/**\n\t * 返回指定下标的对象\n\t * @param pos {size_t} 指定对象的下标位置，不应越界\n\t * @return {dbuf_obj*} 当下标位置越界时返回 NULL\n\t */\n\tdbuf_obj* operator[](size_t pos) const;\n\n\t/**\n\t * 返回指定下标的对象\n\t * @param pos {size_t} 指定对象的下标位置，不应越界\n\t * @return {dbuf_obj*} 当下标位置越界时返回 NULL\n\t */\n\tdbuf_obj* get(size_t pos) const;\n\n\t/**\n\t * 设置内建 objs_ 数组对象每次在扩充空间时的增量，内部缺省值为 100\n\t * @param incr {size_t}\n\t */\n\tvoid set_increment(size_t incr);\n\n       同时，dbuf_obj 类中也提供了额外的操作方法：\n\n\t/**\n\t * 获得该对象在 dbuf_guard 中的数组中的下标位置\n\t * @return {int} 返回该对象在 dbuf_guard 中的数组中的下标位置，当该\n\t *  对象没有被 dbuf_guard 保存时，则返回 -1，此时有可能会造成内存泄露\n\t */\n\tint pos() const\n\t{\n\t\treturn pos_;\n\t}\n\n\t/**\n\t * 返回构造函数中 dbuf_guard 对象\n\t * @return {dbuf_guard*}\n\t */\n\tdbuf_guard* get_guard() const\n\t{\n\t\treturn guard_;\n\t}\n```\n\n最后，以一个稍微复杂的例子做为结尾(该例子源码在 acl 库中的位置：lib_acl_cpp\\samples\\dbuf\\dbuf2)，该例子展示了使用 dbuf_guard 类的几种方法：\n\n```c++\n#include \"stdafx.h\"\n#include <sys/time.h>\n\n/**\n * dbuf_obj 子类，在 dbuf_pool 上动态分配，由 dbuf_guard 统一进行管理\n */\nclass myobj : public acl::dbuf_obj\n{\npublic:\n\tmyobj(acl::dbuf_guard* guard = NULL) : dbuf_obj(guard)\n\t{\n\t\tptr_ = strdup(\"hello\");\n\t}\n\n\tvoid run()\n\t{\n\t\tprintf(\"----> run->hello world <-----\\r\\n\");\n\t}\n\nprivate:\n\tchar* ptr_;\n\n\t// 将析构声明为私人，以强制要求该对象被动态分配，该析构函数将由\n\t// dbuf_guard 统一调用，以释放本类对象中产生的动态内存(ptr_)\n\t~myobj()\n\t{\n\t\tfree(ptr_);\n\t}\n};\n\nstatic void test_dbuf(acl::dbuf_guard& dbuf)\n{\n\tfor (int i = 0; i < 102400; i++)\n\t{\n\t\t// 动态分配内存\n\t\tchar* ptr = (char*) dbuf.dbuf_alloc(10);\n\t\t(void) ptr;\n\t}\n\n\tfor (int i = 0; i < 102400; i++)\n\t{\n\t\t// 动态分配字符串\n\t\tchar* str = dbuf.dbuf_strdup(\"hello world\");\n\t\tif (i < 5)\n\t\t\tprintf(\">>str->%s\\r\\n\", str);\n\t}\n\n\t// 动态分配内存\n\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(2048);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(1024);\n\t(void) dbuf.dbuf_alloc(10240);\n\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\t// 动态分配 dbuf_obj 子类对象，并通过将 dbuf_guard 对象传入\n\t\t// dbuf_obj 的构造函数，从而将之由 dbuf_guard 统一管理，\n\n\t\tmyobj* obj = dbuf.create<myobj>(&dbuf);\n\n\t\t// 验证 dbuf_obj 对象在 dbuf_guard 中的在在一致性\n\t\tassert(obj == dbuf[obj->pos()]);\n\n\t\t// 调用 dbuf_obj 子类对象 myobj 的函数 run\n\t\tif (i < 10)\n\t\t\tobj->run();\n\t}\n\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tmyobj* obj = dbuf.create<myobj>();\n\n\t\tassert(dbuf[obj->pos()] == obj);\n\n\t\tif (i < 10)\n\t\t\tobj->run();\n\t}\n\n\tfor (int i = 0; i < 10000; i++)\n\t{\n\t\tmyobj* obj = dbuf.create<myobj>(&dbuf);\n\n\t\t// 虽然多次将 dbuf_obj 对象置入 dbuf_guard 中，因为 dbuf_obj\n\t\t// 内部的引用计数，所以可以防止被重复添加\n\t\t(void) dbuf.push_back(obj);\n\t\t(void) dbuf.push_back(obj);\n\t\t(void) dbuf.push_back(obj);\n\n\t\tassert(obj == dbuf[obj->pos()]);\n\n\t\tif (i < 10)\n\t\t\tobj->run();\n\t}\n}\n\nstatic void wait_pause()\n{\n\tprintf(\"Enter any key to continue ...\");\n\tfflush(stdout);\n\tgetchar();\n}\n\nstatic void test1()\n{\n\t// dbuf_gaurd 对象创建在栈上，函数返回前该对象自动销毁\n\tacl::dbuf_guard dbuf;\n\n\ttest_dbuf(dbuf);\n}\n\nstatic void test2()\n{\n\t// 动态创建 dbuf_guard 对象，需要手动销毁该对象\n\tacl::dbuf_guard* dbuf = new acl::dbuf_guard;\n\n\ttest_dbuf(*dbuf);\n\n\t// 手工销毁该对象\n\tdelete dbuf;\n}\n\nstatic void test3()\n{\n\t// 将内存池对象 dbuf_pool 做为 dbuf_guard 构造函数参数传入，当\n\t// dbuf_guard 对象销毁时，dbuf_pool 对象一同被销毁\n\tacl::dbuf_guard dbuf(new acl::dbuf_pool);\n\n\ttest_dbuf(dbuf);\n}\n\nstatic void test4()\n{\n\t// 动态创建 dbuf_guard 对象，同时指定内存池中内存块的分配倍数为 10，\n\t// 即指定内部每个内存块大小为 4096 * 10 = 40 KB，同时\n\t// 指定内部动态数组的初始容量大小\n\tacl::dbuf_guard dbuf(10, 100);\n\n\ttest_dbuf(dbuf);\n}\n\nstatic void test5()\n{\n\tacl::dbuf_pool* dp = new acl::dbuf_pool;\n\n\t// 在内存池对象上动态创建 dbuf_guard 对象，这样可以将内存分配的次数\n\t// 进一步减少一次\n\tacl::dbuf_guard* dbuf = new (dp->dbuf_alloc(sizeof(acl::dbuf_guard)))\n\t\tacl::dbuf_guard(dp);\n\n\ttest_dbuf(*dbuf);\n\n\t// 因为 dbuf_gaurd 对象也是在 dbuf_pool 内存池对象上动态创建的，所以\n\t// 只能通过直接调用 dbuf_guard 的析构函数来释放所有的内存对象；\n\t// 既不能直接 dbuf_pool->desotry()，也不能直接 delete dbuf_guard 来\n\t// 销毁 dbuf_guard 对象\n\tdbuf->~dbuf_guard();\n}\n\nclass myobj2 : public acl::dbuf_obj\n{\npublic:\n\tmyobj2() {}\n\n\tvoid run()\n\t{\n\t\tprintf(\"hello world\\r\\n\");\n\t}\n\nprivate:\n\t~myobj2() {}\n};\n\nclass myobj3 : public acl::dbuf_obj\n{\npublic:\n\tmyobj3(int i) : i_(i) {}\n\n\tvoid run()\n\t{\n\t\tprintf(\"hello world: %d\\r\\n\", i_);\n\t}\n\nprivate:\n\t~myobj3() {}\n\nprivate:\n\tint i_;\n};\n\nclass myobj_dummy\n{\npublic:\n\tmyobj_dummy() {}\n\n\tvoid run()\n\t{\n\t\tprintf(\"can't be compiled\\r\\n\");\n\t}\n\nprivate:\n\t~myobj_dummy() {}\n};\n\nstatic void test6()\n{\n\tacl::dbuf_guard dbuf;\n\n\tmyobj* o = dbuf.create<myobj>();\n\to->run();\n\n\tmyobj* o1 = dbuf.create<myobj>(&dbuf);\n\to1->run();\n\n\tmyobj2* o2 = dbuf.create<myobj2>();\n\to2->run();\n\n\tmyobj3* o3 = dbuf.create<myobj3>(10);\n\to3->run();\n\n\tfor (int i = 0; i < 10; i++)\n\t{\n\t\tmyobj3* o4 = dbuf.create<myobj3>(i);\n\t\to4->run();\n\t}\n\n\t// below codes can't be compiled, because myobj_dummy isn't\n\t// acl::dbuf_obj's subclass\n\t// myobj_dummy* dummy = dbuf.create<myobj_dummy>();\n\t// dummy->run();\n}\n\nint main(void)\n{\n\tacl::log::stdout_open(true);\n\n\ttest1();\n\twait_pause();\n\n\ttest2();\n\twait_pause();\n\n\ttest3();\n\twait_pause();\n\n\ttest4();\n\twait_pause();\n\n\ttest5();\n\twait_pause();\n\n\ttest6();\n\treturn 0;\n}\n```\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","slug":"memory_pool","published":1,"updated":"2023-01-24T09:32:54.682Z","_id":"clda1dl5l00008o9k8ub32v8u","comments":1,"layout":"post","photos":[],"link":"","content":"<p>C&#x2F;C++ 最容易出问题的地方是内存管理，容易造成内存泄露和内存越界，这一直是 C&#x2F;C++ 程序员比较头疼的事情，但 C&#x2F;C++ 最大的优势也是内存管理，可以让程序员直接管理内存，从而使程序运行更为高效。acl 库中的内存池管理器 dbuf_guard 在管理内存的效率上比系统级内存管理方式（malloc&#x2F;free, new&#x2F;delete）更为高效，同时也使内存管理更为健壮性，这可以使 C&#x2F;C++ 程序员避免出现一些常见的内存问题。本节主要介绍了 acl 库中 dbuf_guard 类的设计特点及使用方法。</p>\n<p>dbuf_guard 类内部封装了内存池对象类 dbuf_pool，提供了与 dbuf_pool 一样的内存分配方法，dbuf_guard 类与 dbuf_pool 类的最大区别是 dbuf_guard 类对象既可以在堆上动态分配，也可以在栈上分配，而 dbuf_pool 类对象必须在堆上动态分配，另外，dbuf_guard 类还统一管理在 dbuf_pool 内存池上所创建的所有 dbuf_obj 子类对象，在 dbuf_guard 类对象析构时，所有由其管理的 dbuf_obj 子类对象被统一析构。下面先从一个简单的例子来说明 dbuf_guard 的使用方法，例子如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义一个内存池管理对象</span><br>\tacl::dbuf_guard dbuf;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>\tSTR\t<span class=\"hljs-string\">&quot;hello world&quot;</span></span><br><br>\t<span class=\"hljs-comment\">// 在 dbuf 对象上动态创建一个字符串内存</span><br>\t<span class=\"hljs-type\">char</span>* str = dbuf.<span class=\"hljs-built_in\">dbuf_strdup</span>(STR);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str: %s\\r\\n&quot;</span>, str);<br><br>\t<span class=\"hljs-comment\">// 在 dbuf 对象上动态创建内存</span><br><br>\t<span class=\"hljs-comment\">// sizeof(STR) 取得 STR 所包含的字符串长度 + 1</span><br>\tstr = (<span class=\"hljs-type\">char</span>*) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-built_in\">sizeof</span>(STR));<br>\t<span class=\"hljs-built_in\">memcpy</span>(str, STR, <span class=\"hljs-built_in\">sizeof</span>(STR));<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str: %s\\r\\n&quot;</span>, str);<br><br>\t<span class=\"hljs-comment\">// 在本函数返回前，dbuf 对象自动被销毁，同时释放其所管理的</span><br>\t<span class=\"hljs-comment\">// 内存池以及在内存池上分配的内存</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的例子展示了使用 dbuf_guard 类对象直接分配内存块的过程，可以看出，所有在 dbuf_guard 对象的内存池上动态分配的内存都会在 dbuf_guard 对象销毁时被自动释放。这只是一个简单的使用 dbuf_guard 进行内存管理的例子，那么对于 C++ 对象的内存如何进行管理呢？请看下面的的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 调用系统 API 分配动态内存</span><br>\t\tstr_ = <span class=\"hljs-built_in\">strdup</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str: %s\\r\\n&quot;</span>, str_);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span>* str_;<br><br>\t~<span class=\"hljs-built_in\">myobj</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 释放构造函数中分配的内存，否则会造成内存泄露</span><br>\t\t<span class=\"hljs-built_in\">free</span>(str_);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::dbuf_guard dbuf;<br><br>\t<span class=\"hljs-comment\">// 调用 dbuf_guard::create&lt;T&gt;() 模板函数创建 myobj 对象</span><br>\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;();<br><br>\t<span class=\"hljs-comment\">// 调用 myobj::run 方法</span><br>\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\t<span class=\"hljs-comment\">// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该例子展示了 C++ 对象在 dbuf_guard 动态创建的过程，其中有两个要点：</p>\n<ul>\n<li>由 dbuf_guard 对象统一管理的 C++ 对象必须是 dbuf_obj 的子类，这样在 dbuf_guard 类对象的析构时才可以通过调用 dbuf_obj 的析构函数来达到将 dbuf_obj 子类析构的目的（其中 dbuf_obj 的析构函数为虚函数）；</li>\n<li>创建 dbuf_obj 的子类对象时，调用 dbuf_guard 对象的模板函数 create，同时指定子类名称 myobj 来创建 myobj 对象，create 内部会自动将该对象指针加入内部数组对象集合中，从而达到统一管理的目的。</li>\n</ul>\n<p>上面例子的构造函数不带参数，在 dbuf_guard::create 模板函数中允许添加 0  至 10 个参数（其实内部有 11 个 create 模板函数），如果一个构造函数需要多于 10 个参数，则说明该构造函数设计的太复杂了。下面的例子展示了构造函数带参数的类对象创建过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 继承于 acl::dbuf_obj 类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj</span>(<span class=\"hljs-type\">int</span> i, <span class=\"hljs-type\">int</span> j)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;myobj, i=%d, j=%d\\r\\n&quot;</span>, i, j);<br>\t\t<span class=\"hljs-comment\">// 在内存池上分配动态内存</span><br>\t\tstr_ = dbuf.<span class=\"hljs-built_in\">dbuf_strdup</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str: %s\\r\\n&quot;</span>, str_);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span>* str_;<br><br>\t~<span class=\"hljs-built_in\">myobj</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 因为 str_ 的内存也是创建在内存池上，所以此处禁止再调用 free 来释放该内存</span><br>\t\t<span class=\"hljs-comment\">// free(str_);</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::dbuf_guard dbuf;<br><br>\t<span class=\"hljs-comment\">// 调用 dbuf_guard::create&lt;T&gt;(P1, P2) 模板函数创建构造函数带两个参数的 myobj 对象</span><br>\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">100</span>);<br><br>\t<span class=\"hljs-comment\">// 调用 myobj::run 方法</span><br>\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\t<span class=\"hljs-comment\">// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 dbuf_guard 类中除了上面提供的方法外，还提供了以下多个方法方便使用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_reset</span><br><span class=\"hljs-comment\"> * @param reserve &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dbuf_reset</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> reserve = <span class=\"hljs-number\">0</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_reset</span>(reserve);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_alloc</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;void*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">dbuf_alloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_alloc</span>(len);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_calloc</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;void*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">dbuf_calloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_calloc</span>(len);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_strdup</span><br><span class=\"hljs-comment\"> * @param s &#123;const char*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;char*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">dbuf_strdup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* s)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_strdup</span>(s);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_strndup</span><br><span class=\"hljs-comment\"> * @param s &#123;const char*&#125;</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;char*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">dbuf_strndup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* s, <span class=\"hljs-type\">size_t</span> len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_strndup</span>(s, len);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_memdup</span><br><span class=\"hljs-comment\"> * @param addr &#123;const void*&#125;</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;void*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">dbuf_memdup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* addr, <span class=\"hljs-type\">size_t</span> len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_memdup</span>(addr, len);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_free</span><br><span class=\"hljs-comment\"> * @param addr &#123;const void*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dbuf_free</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* addr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_free</span>(addr);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_keep</span><br><span class=\"hljs-comment\"> * @param addr &#123;const void*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dbuf_keep</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* addr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_keep</span>(addr);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_unkeep</span><br><span class=\"hljs-comment\"> * @param addr &#123;const void*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dbuf_unkeep</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* addr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_unkeep</span>(addr);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得 dbuf_pool 对象</span><br><span class=\"hljs-comment\"> * @return &#123;acl::dbuf_pool&amp;&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">acl::dbuf_pool&amp; <span class=\"hljs-title\">get_dbuf</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> *dbuf_;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 可以手动调用本函数，将在 dbuf_pool 上分配的 dbuf_obj 子类对象交给</span><br><span class=\"hljs-comment\"> * dbuf_guard 对象统一进行销毁管理；严禁将同一个 dbuf_obj 子类对象同</span><br><span class=\"hljs-comment\"> * 时将给多个 dbuf_guard 对象进行管理，否则将会产生对象的重复释放</span><br><span class=\"hljs-comment\"> * @param obj &#123;dbuf_obj*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 返回 obj 被添加后其在 dbuf_obj 对象数组中的下标位置，</span><br><span class=\"hljs-comment\"> *  dbuf_guard 内部对 dbuf_obj 对象的管理具有防重添加机制，所以当多次</span><br><span class=\"hljs-comment\"> *  将同一个 dbuf_obj 对象置入同一个 dbuf_guard 对象时，内部只会放一次</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(dbuf_obj* obj)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得当前内存池中管理的对象数量</span><br><span class=\"hljs-comment\"> * @return &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> size_;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得当前内存池中管理的对象集合，该函数必须与 size() 函数配合使用，</span><br><span class=\"hljs-comment\"> * 以免指针地址越界</span><br><span class=\"hljs-comment\"> * @return &#123;dbuf_obj**&#125; 返回 dbuf_obj 对象集合，永远返回非 NULL 值，</span><br><span class=\"hljs-comment\"> *  该数组的大小由 size() 函数决定</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">dbuf_obj** <span class=\"hljs-title\">get_objs</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> objs_;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 返回指定下标的对象</span><br><span class=\"hljs-comment\"> * @param pos &#123;size_t&#125; 指定对象的下标位置，不应越界</span><br><span class=\"hljs-comment\"> * @return &#123;dbuf_obj*&#125; 当下标位置越界时返回 NULL</span><br><span class=\"hljs-comment\"> */</span><br>dbuf_obj* <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">size_t</span> pos) <span class=\"hljs-type\">const</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 返回指定下标的对象</span><br><span class=\"hljs-comment\"> * @param pos &#123;size_t&#125; 指定对象的下标位置，不应越界</span><br><span class=\"hljs-comment\"> * @return &#123;dbuf_obj*&#125; 当下标位置越界时返回 NULL</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">dbuf_obj* <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> pos)</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置内建 objs_ 数组对象每次在扩充空间时的增量，内部缺省值为 100</span><br><span class=\"hljs-comment\"> * @param incr &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_increment</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> incr)</span></span>;<br><br>      同时，dbuf_obj 类中也提供了额外的操作方法：<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得该对象在 dbuf_guard 中的数组中的下标位置</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 返回该对象在 dbuf_guard 中的数组中的下标位置，当该</span><br><span class=\"hljs-comment\"> *  对象没有被 dbuf_guard 保存时，则返回 -1，此时有可能会造成内存泄露</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pos</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> pos_;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 返回构造函数中 dbuf_guard 对象</span><br><span class=\"hljs-comment\"> * @return &#123;dbuf_guard*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">dbuf_guard* <span class=\"hljs-title\">get_guard</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> guard_;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最后，以一个稍微复杂的例子做为结尾(该例子源码在 acl 库中的位置：lib_acl_cpp\\samples\\dbuf\\dbuf2)，该例子展示了使用 dbuf_guard 类的几种方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/time.h&gt;</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * dbuf_obj 子类，在 dbuf_pool 上动态分配，由 dbuf_guard 统一进行管理</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj</span>(acl::dbuf_guard* guard = <span class=\"hljs-literal\">NULL</span>) : <span class=\"hljs-built_in\">dbuf_obj</span>(guard)<br>\t&#123;<br>\t\tptr_ = <span class=\"hljs-built_in\">strdup</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;----&gt; run-&gt;hello world &lt;-----\\r\\n&quot;</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span>* ptr_;<br><br>\t<span class=\"hljs-comment\">// 将析构声明为私人，以强制要求该对象被动态分配，该析构函数将由</span><br>\t<span class=\"hljs-comment\">// dbuf_guard 统一调用，以释放本类对象中产生的动态内存(ptr_)</span><br>\t~<span class=\"hljs-built_in\">myobj</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">free</span>(ptr_);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_dbuf</span><span class=\"hljs-params\">(acl::dbuf_guard&amp; dbuf)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">102400</span>; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 动态分配内存</span><br>\t\t<span class=\"hljs-type\">char</span>* ptr = (<span class=\"hljs-type\">char</span>*) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">10</span>);<br>\t\t(<span class=\"hljs-type\">void</span>) ptr;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">102400</span>; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 动态分配字符串</span><br>\t\t<span class=\"hljs-type\">char</span>* str = dbuf.<span class=\"hljs-built_in\">dbuf_strdup</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">5</span>)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;str-&gt;%s\\r\\n&quot;</span>, str);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 动态分配内存</span><br><br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">2048</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">10240</span>);<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10000</span>; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 动态分配 dbuf_obj 子类对象，并通过将 dbuf_guard 对象传入</span><br>\t\t<span class=\"hljs-comment\">// dbuf_obj 的构造函数，从而将之由 dbuf_guard 统一管理，</span><br><br>\t\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;(&amp;dbuf);<br><br>\t\t<span class=\"hljs-comment\">// 验证 dbuf_obj 对象在 dbuf_guard 中的在在一致性</span><br>\t\t<span class=\"hljs-built_in\">assert</span>(obj == dbuf[obj-&gt;<span class=\"hljs-built_in\">pos</span>()]);<br><br>\t\t<span class=\"hljs-comment\">// 调用 dbuf_obj 子类对象 myobj 的函数 run</span><br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10000</span>; i++)<br>\t&#123;<br>\t\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;();<br><br>\t\t<span class=\"hljs-built_in\">assert</span>(dbuf[obj-&gt;<span class=\"hljs-built_in\">pos</span>()] == obj);<br><br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10000</span>; i++)<br>\t&#123;<br>\t\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;(&amp;dbuf);<br><br>\t\t<span class=\"hljs-comment\">// 虽然多次将 dbuf_obj 对象置入 dbuf_guard 中，因为 dbuf_obj</span><br>\t\t<span class=\"hljs-comment\">// 内部的引用计数，所以可以防止被重复添加</span><br>\t\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">push_back</span>(obj);<br>\t\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">push_back</span>(obj);<br>\t\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">push_back</span>(obj);<br><br>\t\t<span class=\"hljs-built_in\">assert</span>(obj == dbuf[obj-&gt;<span class=\"hljs-built_in\">pos</span>()]);<br><br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">wait_pause</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter any key to continue ...&quot;</span>);<br>\t<span class=\"hljs-built_in\">fflush</span>(stdout);<br>\t<span class=\"hljs-built_in\">getchar</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// dbuf_gaurd 对象创建在栈上，函数返回前该对象自动销毁</span><br>\tacl::dbuf_guard dbuf;<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(dbuf);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 动态创建 dbuf_guard 对象，需要手动销毁该对象</span><br>\tacl::dbuf_guard* dbuf = <span class=\"hljs-keyword\">new</span> acl::dbuf_guard;<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(*dbuf);<br><br>\t<span class=\"hljs-comment\">// 手工销毁该对象</span><br>\t<span class=\"hljs-keyword\">delete</span> dbuf;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 将内存池对象 dbuf_pool 做为 dbuf_guard 构造函数参数传入，当</span><br>\t<span class=\"hljs-comment\">// dbuf_guard 对象销毁时，dbuf_pool 对象一同被销毁</span><br>\t<span class=\"hljs-function\">acl::dbuf_guard <span class=\"hljs-title\">dbuf</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> acl::dbuf_pool)</span></span>;<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(dbuf);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test4</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 动态创建 dbuf_guard 对象，同时指定内存池中内存块的分配倍数为 10，</span><br>\t<span class=\"hljs-comment\">// 即指定内部每个内存块大小为 4096 * 10 = 40 KB，同时</span><br>\t<span class=\"hljs-comment\">// 指定内部动态数组的初始容量大小</span><br>\t<span class=\"hljs-function\">acl::dbuf_guard <span class=\"hljs-title\">dbuf</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">100</span>)</span></span>;<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(dbuf);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test5</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::dbuf_pool* dp = <span class=\"hljs-keyword\">new</span> acl::dbuf_pool;<br><br>\t<span class=\"hljs-comment\">// 在内存池对象上动态创建 dbuf_guard 对象，这样可以将内存分配的次数</span><br>\t<span class=\"hljs-comment\">// 进一步减少一次</span><br>\tacl::dbuf_guard* dbuf = <span class=\"hljs-built_in\">new</span> (dp-&gt;<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-built_in\">sizeof</span>(acl::dbuf_guard)))<br>\t\tacl::<span class=\"hljs-built_in\">dbuf_guard</span>(dp);<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(*dbuf);<br><br>\t<span class=\"hljs-comment\">// 因为 dbuf_gaurd 对象也是在 dbuf_pool 内存池对象上动态创建的，所以</span><br>\t<span class=\"hljs-comment\">// 只能通过直接调用 dbuf_guard 的析构函数来释放所有的内存对象；</span><br>\t<span class=\"hljs-comment\">// 既不能直接 dbuf_pool-&gt;desotry()，也不能直接 delete dbuf_guard 来</span><br>\t<span class=\"hljs-comment\">// 销毁 dbuf_guard 对象</span><br>\tdbuf-&gt;~<span class=\"hljs-built_in\">dbuf_guard</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj2</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj2</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world\\r\\n&quot;</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t~<span class=\"hljs-built_in\">myobj2</span>() &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj3</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj3</span>(<span class=\"hljs-type\">int</span> i) : <span class=\"hljs-built_in\">i_</span>(i) &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world: %d\\r\\n&quot;</span>, i_);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t~<span class=\"hljs-built_in\">myobj3</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> i_;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj_dummy</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj_dummy</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;can&#x27;t be compiled\\r\\n&quot;</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t~<span class=\"hljs-built_in\">myobj_dummy</span>() &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test6</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::dbuf_guard dbuf;<br><br>\tmyobj* o = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;();<br>\to-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\tmyobj* o1 = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;(&amp;dbuf);<br>\to1-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\tmyobj2* o2 = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj2&gt;();<br>\to2-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\tmyobj3* o3 = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj3&gt;(<span class=\"hljs-number\">10</span>);<br>\to3-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tmyobj3* o4 = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj3&gt;(i);<br>\t\to4-&gt;<span class=\"hljs-built_in\">run</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// below codes can&#x27;t be compiled, because myobj_dummy isn&#x27;t</span><br>\t<span class=\"hljs-comment\">// acl::dbuf_obj&#x27;s subclass</span><br>\t<span class=\"hljs-comment\">// myobj_dummy* dummy = dbuf.create&lt;myobj_dummy&gt;();</span><br>\t<span class=\"hljs-comment\">// dummy-&gt;run();</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::log::<span class=\"hljs-built_in\">stdout_open</span>(<span class=\"hljs-literal\">true</span>);<br><br>\t<span class=\"hljs-built_in\">test1</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test2</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test3</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test4</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test5</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test6</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>C&#x2F;C++ 最容易出问题的地方是内存管理，容易造成内存泄露和内存越界，这一直是 C&#x2F;C++ 程序员比较头疼的事情，但 C&#x2F;C++ 最大的优势也是内存管理，可以让程序员直接管理内存，从而使程序运行更为高效。acl 库中的内存池管理器 dbuf_guard 在管理内存的效率上比系统级内存管理方式（malloc&#x2F;free, new&#x2F;delete）更为高效，同时也使内存管理更为健壮性，这可以使 C&#x2F;C++ 程序员避免出现一些常见的内存问题。本节主要介绍了 acl 库中 dbuf_guard 类的设计特点及使用方法。</p>\n<p>dbuf_guard 类内部封装了内存池对象类 dbuf_pool，提供了与 dbuf_pool 一样的内存分配方法，dbuf_guard 类与 dbuf_pool 类的最大区别是 dbuf_guard 类对象既可以在堆上动态分配，也可以在栈上分配，而 dbuf_pool 类对象必须在堆上动态分配，另外，dbuf_guard 类还统一管理在 dbuf_pool 内存池上所创建的所有 dbuf_obj 子类对象，在 dbuf_guard 类对象析构时，所有由其管理的 dbuf_obj 子类对象被统一析构。下面先从一个简单的例子来说明 dbuf_guard 的使用方法，例子如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 定义一个内存池管理对象</span><br>\tacl::dbuf_guard dbuf;<br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">define</span>\tSTR\t<span class=\"hljs-string\">&quot;hello world&quot;</span></span><br><br>\t<span class=\"hljs-comment\">// 在 dbuf 对象上动态创建一个字符串内存</span><br>\t<span class=\"hljs-type\">char</span>* str = dbuf.<span class=\"hljs-built_in\">dbuf_strdup</span>(STR);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str: %s\\r\\n&quot;</span>, str);<br><br>\t<span class=\"hljs-comment\">// 在 dbuf 对象上动态创建内存</span><br><br>\t<span class=\"hljs-comment\">// sizeof(STR) 取得 STR 所包含的字符串长度 + 1</span><br>\tstr = (<span class=\"hljs-type\">char</span>*) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-built_in\">sizeof</span>(STR));<br>\t<span class=\"hljs-built_in\">memcpy</span>(str, STR, <span class=\"hljs-built_in\">sizeof</span>(STR));<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str: %s\\r\\n&quot;</span>, str);<br><br>\t<span class=\"hljs-comment\">// 在本函数返回前，dbuf 对象自动被销毁，同时释放其所管理的</span><br>\t<span class=\"hljs-comment\">// 内存池以及在内存池上分配的内存</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>上面的例子展示了使用 dbuf_guard 类对象直接分配内存块的过程，可以看出，所有在 dbuf_guard 对象的内存池上动态分配的内存都会在 dbuf_guard 对象销毁时被自动释放。这只是一个简单的使用 dbuf_guard 进行内存管理的例子，那么对于 C++ 对象的内存如何进行管理呢？请看下面的的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 调用系统 API 分配动态内存</span><br>\t\tstr_ = <span class=\"hljs-built_in\">strdup</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str: %s\\r\\n&quot;</span>, str_);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span>* str_;<br><br>\t~<span class=\"hljs-built_in\">myobj</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 释放构造函数中分配的内存，否则会造成内存泄露</span><br>\t\t<span class=\"hljs-built_in\">free</span>(str_);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::dbuf_guard dbuf;<br><br>\t<span class=\"hljs-comment\">// 调用 dbuf_guard::create&lt;T&gt;() 模板函数创建 myobj 对象</span><br>\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;();<br><br>\t<span class=\"hljs-comment\">// 调用 myobj::run 方法</span><br>\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\t<span class=\"hljs-comment\">// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>该例子展示了 C++ 对象在 dbuf_guard 动态创建的过程，其中有两个要点：</p>\n<ul>\n<li>由 dbuf_guard 对象统一管理的 C++ 对象必须是 dbuf_obj 的子类，这样在 dbuf_guard 类对象的析构时才可以通过调用 dbuf_obj 的析构函数来达到将 dbuf_obj 子类析构的目的（其中 dbuf_obj 的析构函数为虚函数）；</li>\n<li>创建 dbuf_obj 的子类对象时，调用 dbuf_guard 对象的模板函数 create，同时指定子类名称 myobj 来创建 myobj 对象，create 内部会自动将该对象指针加入内部数组对象集合中，从而达到统一管理的目的。</li>\n</ul>\n<p>上面例子的构造函数不带参数，在 dbuf_guard::create 模板函数中允许添加 0  至 10 个参数（其实内部有 11 个 create 模板函数），如果一个构造函数需要多于 10 个参数，则说明该构造函数设计的太复杂了。下面的例子展示了构造函数带参数的类对象创建过程：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 继承于 acl::dbuf_obj 类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj</span>(<span class=\"hljs-type\">int</span> i, <span class=\"hljs-type\">int</span> j)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;myobj, i=%d, j=%d\\r\\n&quot;</span>, i, j);<br>\t\t<span class=\"hljs-comment\">// 在内存池上分配动态内存</span><br>\t\tstr_ = dbuf.<span class=\"hljs-built_in\">dbuf_strdup</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;str: %s\\r\\n&quot;</span>, str_);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span>* str_;<br><br>\t~<span class=\"hljs-built_in\">myobj</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 因为 str_ 的内存也是创建在内存池上，所以此处禁止再调用 free 来释放该内存</span><br>\t\t<span class=\"hljs-comment\">// free(str_);</span><br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::dbuf_guard dbuf;<br><br>\t<span class=\"hljs-comment\">// 调用 dbuf_guard::create&lt;T&gt;(P1, P2) 模板函数创建构造函数带两个参数的 myobj 对象</span><br>\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">100</span>);<br><br>\t<span class=\"hljs-comment\">// 调用 myobj::run 方法</span><br>\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\t<span class=\"hljs-comment\">// 本函数返回前，dbuf 对象被销毁，obj 一起被销毁</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>在 dbuf_guard 类中除了上面提供的方法外，还提供了以下多个方法方便使用：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_reset</span><br><span class=\"hljs-comment\"> * @param reserve &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dbuf_reset</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> reserve = <span class=\"hljs-number\">0</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_reset</span>(reserve);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_alloc</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;void*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">dbuf_alloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_alloc</span>(len);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_calloc</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;void*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">dbuf_calloc</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_calloc</span>(len);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_strdup</span><br><span class=\"hljs-comment\"> * @param s &#123;const char*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;char*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">dbuf_strdup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* s)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_strdup</span>(s);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_strndup</span><br><span class=\"hljs-comment\"> * @param s &#123;const char*&#125;</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;char*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">char</span>* <span class=\"hljs-title\">dbuf_strndup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* s, <span class=\"hljs-type\">size_t</span> len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_strndup</span>(s, len);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_memdup</span><br><span class=\"hljs-comment\"> * @param addr &#123;const void*&#125;</span><br><span class=\"hljs-comment\"> * @param len &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;void*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">dbuf_memdup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* addr, <span class=\"hljs-type\">size_t</span> len)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_memdup</span>(addr, len);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_free</span><br><span class=\"hljs-comment\"> * @param addr &#123;const void*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dbuf_free</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* addr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_free</span>(addr);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_keep</span><br><span class=\"hljs-comment\"> * @param addr &#123;const void*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dbuf_keep</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* addr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_keep</span>(addr);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 调用 dbuf_pool::dbuf_unkeep</span><br><span class=\"hljs-comment\"> * @param addr &#123;const void*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">dbuf_unkeep</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">void</span>* addr)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> dbuf_-&gt;<span class=\"hljs-built_in\">dbuf_unkeep</span>(addr);<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得 dbuf_pool 对象</span><br><span class=\"hljs-comment\"> * @return &#123;acl::dbuf_pool&amp;&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">acl::dbuf_pool&amp; <span class=\"hljs-title\">get_dbuf</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> *dbuf_;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 可以手动调用本函数，将在 dbuf_pool 上分配的 dbuf_obj 子类对象交给</span><br><span class=\"hljs-comment\"> * dbuf_guard 对象统一进行销毁管理；严禁将同一个 dbuf_obj 子类对象同</span><br><span class=\"hljs-comment\"> * 时将给多个 dbuf_guard 对象进行管理，否则将会产生对象的重复释放</span><br><span class=\"hljs-comment\"> * @param obj &#123;dbuf_obj*&#125;</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 返回 obj 被添加后其在 dbuf_obj 对象数组中的下标位置，</span><br><span class=\"hljs-comment\"> *  dbuf_guard 内部对 dbuf_obj 对象的管理具有防重添加机制，所以当多次</span><br><span class=\"hljs-comment\"> *  将同一个 dbuf_obj 对象置入同一个 dbuf_guard 对象时，内部只会放一次</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">push_back</span><span class=\"hljs-params\">(dbuf_obj* obj)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得当前内存池中管理的对象数量</span><br><span class=\"hljs-comment\"> * @return &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">size_t</span> <span class=\"hljs-title\">size</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> size_;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得当前内存池中管理的对象集合，该函数必须与 size() 函数配合使用，</span><br><span class=\"hljs-comment\"> * 以免指针地址越界</span><br><span class=\"hljs-comment\"> * @return &#123;dbuf_obj**&#125; 返回 dbuf_obj 对象集合，永远返回非 NULL 值，</span><br><span class=\"hljs-comment\"> *  该数组的大小由 size() 函数决定</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">dbuf_obj** <span class=\"hljs-title\">get_objs</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> objs_;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 返回指定下标的对象</span><br><span class=\"hljs-comment\"> * @param pos &#123;size_t&#125; 指定对象的下标位置，不应越界</span><br><span class=\"hljs-comment\"> * @return &#123;dbuf_obj*&#125; 当下标位置越界时返回 NULL</span><br><span class=\"hljs-comment\"> */</span><br>dbuf_obj* <span class=\"hljs-keyword\">operator</span>[](<span class=\"hljs-type\">size_t</span> pos) <span class=\"hljs-type\">const</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 返回指定下标的对象</span><br><span class=\"hljs-comment\"> * @param pos &#123;size_t&#125; 指定对象的下标位置，不应越界</span><br><span class=\"hljs-comment\"> * @return &#123;dbuf_obj*&#125; 当下标位置越界时返回 NULL</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">dbuf_obj* <span class=\"hljs-title\">get</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> pos)</span> <span class=\"hljs-type\">const</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 设置内建 objs_ 数组对象每次在扩充空间时的增量，内部缺省值为 100</span><br><span class=\"hljs-comment\"> * @param incr &#123;size_t&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">set_increment</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> incr)</span></span>;<br><br>      同时，dbuf_obj 类中也提供了额外的操作方法：<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 获得该对象在 dbuf_guard 中的数组中的下标位置</span><br><span class=\"hljs-comment\"> * @return &#123;int&#125; 返回该对象在 dbuf_guard 中的数组中的下标位置，当该</span><br><span class=\"hljs-comment\"> *  对象没有被 dbuf_guard 保存时，则返回 -1，此时有可能会造成内存泄露</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">pos</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> pos_;<br>&#125;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 返回构造函数中 dbuf_guard 对象</span><br><span class=\"hljs-comment\"> * @return &#123;dbuf_guard*&#125;</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">dbuf_guard* <span class=\"hljs-title\">get_guard</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">return</span> guard_;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>最后，以一个稍微复杂的例子做为结尾(该例子源码在 acl 库中的位置：lib_acl_cpp\\samples\\dbuf\\dbuf2)，该例子展示了使用 dbuf_guard 类的几种方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br><span class=\"line\">187</span><br><span class=\"line\">188</span><br><span class=\"line\">189</span><br><span class=\"line\">190</span><br><span class=\"line\">191</span><br><span class=\"line\">192</span><br><span class=\"line\">193</span><br><span class=\"line\">194</span><br><span class=\"line\">195</span><br><span class=\"line\">196</span><br><span class=\"line\">197</span><br><span class=\"line\">198</span><br><span class=\"line\">199</span><br><span class=\"line\">200</span><br><span class=\"line\">201</span><br><span class=\"line\">202</span><br><span class=\"line\">203</span><br><span class=\"line\">204</span><br><span class=\"line\">205</span><br><span class=\"line\">206</span><br><span class=\"line\">207</span><br><span class=\"line\">208</span><br><span class=\"line\">209</span><br><span class=\"line\">210</span><br><span class=\"line\">211</span><br><span class=\"line\">212</span><br><span class=\"line\">213</span><br><span class=\"line\">214</span><br><span class=\"line\">215</span><br><span class=\"line\">216</span><br><span class=\"line\">217</span><br><span class=\"line\">218</span><br><span class=\"line\">219</span><br><span class=\"line\">220</span><br><span class=\"line\">221</span><br><span class=\"line\">222</span><br><span class=\"line\">223</span><br><span class=\"line\">224</span><br><span class=\"line\">225</span><br><span class=\"line\">226</span><br><span class=\"line\">227</span><br><span class=\"line\">228</span><br><span class=\"line\">229</span><br><span class=\"line\">230</span><br><span class=\"line\">231</span><br><span class=\"line\">232</span><br><span class=\"line\">233</span><br><span class=\"line\">234</span><br><span class=\"line\">235</span><br><span class=\"line\">236</span><br><span class=\"line\">237</span><br><span class=\"line\">238</span><br><span class=\"line\">239</span><br><span class=\"line\">240</span><br><span class=\"line\">241</span><br><span class=\"line\">242</span><br><span class=\"line\">243</span><br><span class=\"line\">244</span><br><span class=\"line\">245</span><br><span class=\"line\">246</span><br><span class=\"line\">247</span><br><span class=\"line\">248</span><br><span class=\"line\">249</span><br><span class=\"line\">250</span><br><span class=\"line\">251</span><br><span class=\"line\">252</span><br><span class=\"line\">253</span><br><span class=\"line\">254</span><br><span class=\"line\">255</span><br><span class=\"line\">256</span><br><span class=\"line\">257</span><br><span class=\"line\">258</span><br><span class=\"line\">259</span><br><span class=\"line\">260</span><br><span class=\"line\">261</span><br><span class=\"line\">262</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;sys/time.h&gt;</span></span><br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * dbuf_obj 子类，在 dbuf_pool 上动态分配，由 dbuf_guard 统一进行管理</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj</span>(acl::dbuf_guard* guard = <span class=\"hljs-literal\">NULL</span>) : <span class=\"hljs-built_in\">dbuf_obj</span>(guard)<br>\t&#123;<br>\t\tptr_ = <span class=\"hljs-built_in\">strdup</span>(<span class=\"hljs-string\">&quot;hello&quot;</span>);<br>\t&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;----&gt; run-&gt;hello world &lt;-----\\r\\n&quot;</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">char</span>* ptr_;<br><br>\t<span class=\"hljs-comment\">// 将析构声明为私人，以强制要求该对象被动态分配，该析构函数将由</span><br>\t<span class=\"hljs-comment\">// dbuf_guard 统一调用，以释放本类对象中产生的动态内存(ptr_)</span><br>\t~<span class=\"hljs-built_in\">myobj</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">free</span>(ptr_);<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_dbuf</span><span class=\"hljs-params\">(acl::dbuf_guard&amp; dbuf)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">102400</span>; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 动态分配内存</span><br>\t\t<span class=\"hljs-type\">char</span>* ptr = (<span class=\"hljs-type\">char</span>*) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">10</span>);<br>\t\t(<span class=\"hljs-type\">void</span>) ptr;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">102400</span>; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 动态分配字符串</span><br>\t\t<span class=\"hljs-type\">char</span>* str = dbuf.<span class=\"hljs-built_in\">dbuf_strdup</span>(<span class=\"hljs-string\">&quot;hello world&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">5</span>)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;str-&gt;%s\\r\\n&quot;</span>, str);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 动态分配内存</span><br><br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">2048</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">1024</span>);<br>\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-number\">10240</span>);<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10000</span>; i++)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 动态分配 dbuf_obj 子类对象，并通过将 dbuf_guard 对象传入</span><br>\t\t<span class=\"hljs-comment\">// dbuf_obj 的构造函数，从而将之由 dbuf_guard 统一管理，</span><br><br>\t\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;(&amp;dbuf);<br><br>\t\t<span class=\"hljs-comment\">// 验证 dbuf_obj 对象在 dbuf_guard 中的在在一致性</span><br>\t\t<span class=\"hljs-built_in\">assert</span>(obj == dbuf[obj-&gt;<span class=\"hljs-built_in\">pos</span>()]);<br><br>\t\t<span class=\"hljs-comment\">// 调用 dbuf_obj 子类对象 myobj 的函数 run</span><br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10000</span>; i++)<br>\t&#123;<br>\t\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;();<br><br>\t\t<span class=\"hljs-built_in\">assert</span>(dbuf[obj-&gt;<span class=\"hljs-built_in\">pos</span>()] == obj);<br><br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10000</span>; i++)<br>\t&#123;<br>\t\tmyobj* obj = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;(&amp;dbuf);<br><br>\t\t<span class=\"hljs-comment\">// 虽然多次将 dbuf_obj 对象置入 dbuf_guard 中，因为 dbuf_obj</span><br>\t\t<span class=\"hljs-comment\">// 内部的引用计数，所以可以防止被重复添加</span><br>\t\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">push_back</span>(obj);<br>\t\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">push_back</span>(obj);<br>\t\t(<span class=\"hljs-type\">void</span>) dbuf.<span class=\"hljs-built_in\">push_back</span>(obj);<br><br>\t\t<span class=\"hljs-built_in\">assert</span>(obj == dbuf[obj-&gt;<span class=\"hljs-built_in\">pos</span>()]);<br><br>\t\t<span class=\"hljs-keyword\">if</span> (i &lt; <span class=\"hljs-number\">10</span>)<br>\t\t\tobj-&gt;<span class=\"hljs-built_in\">run</span>();<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">wait_pause</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter any key to continue ...&quot;</span>);<br>\t<span class=\"hljs-built_in\">fflush</span>(stdout);<br>\t<span class=\"hljs-built_in\">getchar</span>();<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test1</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// dbuf_gaurd 对象创建在栈上，函数返回前该对象自动销毁</span><br>\tacl::dbuf_guard dbuf;<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(dbuf);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test2</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 动态创建 dbuf_guard 对象，需要手动销毁该对象</span><br>\tacl::dbuf_guard* dbuf = <span class=\"hljs-keyword\">new</span> acl::dbuf_guard;<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(*dbuf);<br><br>\t<span class=\"hljs-comment\">// 手工销毁该对象</span><br>\t<span class=\"hljs-keyword\">delete</span> dbuf;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test3</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 将内存池对象 dbuf_pool 做为 dbuf_guard 构造函数参数传入，当</span><br>\t<span class=\"hljs-comment\">// dbuf_guard 对象销毁时，dbuf_pool 对象一同被销毁</span><br>\t<span class=\"hljs-function\">acl::dbuf_guard <span class=\"hljs-title\">dbuf</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">new</span> acl::dbuf_pool)</span></span>;<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(dbuf);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test4</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 动态创建 dbuf_guard 对象，同时指定内存池中内存块的分配倍数为 10，</span><br>\t<span class=\"hljs-comment\">// 即指定内部每个内存块大小为 4096 * 10 = 40 KB，同时</span><br>\t<span class=\"hljs-comment\">// 指定内部动态数组的初始容量大小</span><br>\t<span class=\"hljs-function\">acl::dbuf_guard <span class=\"hljs-title\">dbuf</span><span class=\"hljs-params\">(<span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">100</span>)</span></span>;<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(dbuf);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test5</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::dbuf_pool* dp = <span class=\"hljs-keyword\">new</span> acl::dbuf_pool;<br><br>\t<span class=\"hljs-comment\">// 在内存池对象上动态创建 dbuf_guard 对象，这样可以将内存分配的次数</span><br>\t<span class=\"hljs-comment\">// 进一步减少一次</span><br>\tacl::dbuf_guard* dbuf = <span class=\"hljs-built_in\">new</span> (dp-&gt;<span class=\"hljs-built_in\">dbuf_alloc</span>(<span class=\"hljs-built_in\">sizeof</span>(acl::dbuf_guard)))<br>\t\tacl::<span class=\"hljs-built_in\">dbuf_guard</span>(dp);<br><br>\t<span class=\"hljs-built_in\">test_dbuf</span>(*dbuf);<br><br>\t<span class=\"hljs-comment\">// 因为 dbuf_gaurd 对象也是在 dbuf_pool 内存池对象上动态创建的，所以</span><br>\t<span class=\"hljs-comment\">// 只能通过直接调用 dbuf_guard 的析构函数来释放所有的内存对象；</span><br>\t<span class=\"hljs-comment\">// 既不能直接 dbuf_pool-&gt;desotry()，也不能直接 delete dbuf_guard 来</span><br>\t<span class=\"hljs-comment\">// 销毁 dbuf_guard 对象</span><br>\tdbuf-&gt;~<span class=\"hljs-built_in\">dbuf_guard</span>();<br>&#125;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj2</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj2</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world\\r\\n&quot;</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t~<span class=\"hljs-built_in\">myobj2</span>() &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj3</span> : <span class=\"hljs-keyword\">public</span> acl::dbuf_obj<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj3</span>(<span class=\"hljs-type\">int</span> i) : <span class=\"hljs-built_in\">i_</span>(i) &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;hello world: %d\\r\\n&quot;</span>, i_);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t~<span class=\"hljs-built_in\">myobj3</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t<span class=\"hljs-type\">int</span> i_;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myobj_dummy</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myobj_dummy</span>() &#123;&#125;<br><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;can&#x27;t be compiled\\r\\n&quot;</span>);<br>\t&#125;<br><br><span class=\"hljs-keyword\">private</span>:<br>\t~<span class=\"hljs-built_in\">myobj_dummy</span>() &#123;&#125;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test6</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::dbuf_guard dbuf;<br><br>\tmyobj* o = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;();<br>\to-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\tmyobj* o1 = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj&gt;(&amp;dbuf);<br>\to1-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\tmyobj2* o2 = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj2&gt;();<br>\to2-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\tmyobj3* o3 = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj3&gt;(<span class=\"hljs-number\">10</span>);<br>\to3-&gt;<span class=\"hljs-built_in\">run</span>();<br><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">int</span> i = <span class=\"hljs-number\">0</span>; i &lt; <span class=\"hljs-number\">10</span>; i++)<br>\t&#123;<br>\t\tmyobj3* o4 = dbuf.<span class=\"hljs-built_in\">create</span>&lt;myobj3&gt;(i);<br>\t\to4-&gt;<span class=\"hljs-built_in\">run</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// below codes can&#x27;t be compiled, because myobj_dummy isn&#x27;t</span><br>\t<span class=\"hljs-comment\">// acl::dbuf_obj&#x27;s subclass</span><br>\t<span class=\"hljs-comment\">// myobj_dummy* dummy = dbuf.create&lt;myobj_dummy&gt;();</span><br>\t<span class=\"hljs-comment\">// dummy-&gt;run();</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::log::<span class=\"hljs-built_in\">stdout_open</span>(<span class=\"hljs-literal\">true</span>);<br><br>\t<span class=\"hljs-built_in\">test1</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test2</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test3</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test4</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test5</span>();<br>\t<span class=\"hljs-built_in\">wait_pause</span>();<br><br>\t<span class=\"hljs-built_in\">test6</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"使用 acl_cpp 库编写多线程程序","date":"2013-10-26T10:18:00.000Z","_content":"\n在 《利用ACL库开发高并发半驻留式线程池程序》中介绍了如何使用 C 版本的 acl 线程库编写多线程程序，本文将会介绍如何使用 C++ 版本的 acl 线程库编写多线程程序，虽然 C++ 版 acl 线程库基于 C 版的线程库，但却提供了更为清晰简洁的接口定义（很多地方参考了 JAVA 的线程接口定义）。下面是一个简单的使用线程的例子：\n\n```c++\n#include \"acl_cpp/lib_acl.hpp\"\n\n//////////////////////////////////////////////////////////////////////////\n\n// 子线程类定义\nclass mythread : public acl::thread\n{\npublic:\n\tmythread() {}\n\t~mythread() {}\nprotected:\n\t// 基类纯虚函数，当在主线程中调用线程实例的 start 函数时\n\t// 该虚函数将会被调用\n\tvirtual void* run()\n\t{\n\t\tconst char* myname = \"run\";\n\t\tprintf(\"%s: thread id: %lu, %lu\\r\\n\",\n\t\t\tmyname, thread_id(), acl::thread::thread_self());\n\t\treturn NULL;\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nstatic void test_thread(void)\n{\n\tconst char* myname = \"test_thread\";\n\tmythread thr;  // 子线程对象实例\n\n\t// 设置线程的属性为非分离方式，以便于下面可以调用 wait\n\t// 等待线程结束\n\tthr.set_detachable(false);\n\n\t// 启动一个子线程\n\tif (thr.start() == false)\n\t{\n\t\tprintf(\"start thread failed\\r\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"%s: thread id is %lu, main thread id: %lu\\r\\n\",\n\t\tmyname, thr.thread_id(), acl::thread::thread_self());\n\n\t// 等待子线程运行结束\n\tif (thr.wait(NULL) == false)\n\t\tprintf(\"wait thread failed\\r\\n\");\n\telse\n\t\tprintf(\"wait thread ok\\r\\n\");\n}\n\nint main(void)\n{\n\t// 初始化 acl 库\n\tacl::acl_cpp_init();\n\ttest_thread();\n#ifdef WIN32\n\tprintf(\"enter any key to exit ...\\r\\n\");\n\tgetchar();\n#endif\n\treturn 0;\n}\n```\n\n从上面的示例来看，使用 acl 的线程库创建使用线程还是非常简单的。打开 lib_acl_cpp/include/acl_cpp/stdlib/thread.hpp 文件，可以看到线程类的声明，其中有两个基类：acl::thread 与 acl::thread_job，在 基类 acl::thread_job 中有一个纯虚函数 run（），acl::thread 也继承自 acl::thread_job，用户的线程类需要继承 acl::thread，并且需要实现基类 acl::thread_job 的纯虚函数： run（）。当应用在主线程中调用线程实例的 start() 函数时，acl 线程库内部便创建一个子线程，子线程被创建后线程对象的 run()　函数便被调用。下面是 acl::thread 类中几个主要的方法定义：\n\n```c++\nclass thread_job\n{\npublic:\n\tthread_job() {}\n\tvirtual ~thread_job() {}\n\n\t/**\n\t * 纯虚函数，子类必须实现此函数，该函数在子线程中执行\n\t * @return {void*} 线程退出前返回的参数\n\t */\n\tvirtual void* run() = 0;\n};\n\nclass thread : public thread_job\n{\npublic:\n\tthread();\n\tvirtual ~thread();\n\t\n\t/**\n\t * 开始启动线程过程，一旦该函数被调用，则会立即启动一个新的\n\t * 子线程，在子线程中执行基类 thread_job::run 过程\n\t * @return {bool} 是否成功创建线程\n\t */\n\tbool start();\n\n\t/**\n\t * 当创建线程时为非 detachable 状态，则可以调用此函数\n\t * 等待线程结束；否则，若创建线程时为 detachable 状态\n\t * 在调用本函数时将会报错\n\t * @param out {void**} 当该参数非空指针时，该参数用来存放\n\t *  线程退出前返回的参数\n\t * @return {bool} 是否成功\n\t */\n\tbool wait(void** out = NULL);\n\n\t/**\n\t * 在调用 start 前调用此函数可以设置所创建线程是否为\n\t * 分离 (detachable) 状态；如果未调用此函数，则所创建\n\t * 的线程默认为分离状态\n\t * @param yes {bool} 是否为分离状态\n\t * @return {thread&}\n\t */\n\tthread& set_detachable(bool yes);\n\n\t/**\n\t * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小\n\t * @param size {size_t} 线程堆栈大小，当该值为 0 或未\n\t *  调用此函数，则所创建的线程堆栈大小为系统的默认值\n\t * @return {thread&}\n\t */\n\tthread& set_stacksize(size_t size);\n\n\t/**\n\t * 在调用 start 后调用此函数可以获得所创建线程的 id 号\n\t * @return {unsigned long}\n\t */\n\tunsigned long thread_id() const;\n\n\t/**\n\t * 当前调用者所在线程的线程 id 号\n\t * @return {unsigned long}\n\t */\n\tstatic unsigned long thread_self();\n        ....\n};\n\n```\n\n从上面的线程示例及 acl::thread 的类定义，也许有人会觉得应该把 acl::thread_job 的纯虚方法：run() 放在 acl::thread 类中，甚至觉得 acl::thread_job 类是多余的，但是因为 acl 库中还支持线程池方式，则 acl::thread_job 就显得很有必要了。在 lib_acl_cpp\\include\\acl_cpp\\stdlib\\thread_pool.hpp 头文件中可以看到 acl 的线程池类 acl::thread_pool 的声明，该类的主要函数接口如下：\n\n```c++\nclass thread_pool\n{\n\t/**\n\t * 启动线程池，在创建线程池对象后，必须首先调用此函数以启动线程池\n\t */\n\tvoid start();\n\n\t/**\n\t * 停止并销毁线程池，并释放线程池资源，调用此函数可以使所有子线程退出，\n\t * 但并不释放本实例，如果该类实例是动态分配的则用户应该自释放类实例，\n\t * 在调用本函数后，如果想重启线程池过程，则必须重新调用 start 过程\n\t */\n\tvoid stop();\n\n\t/**\n\t * 等待线程池中的所有线程池执行完所有任务\n\t */\n\tvoid wait();\n\n\t/**\n\t * 将一个任务交给线程池中的一个线程去执行，线程池中的\n\t * 线程会执行该任务中的 run 函数\n\t * @param job {thread_job*} 线程任务\n\t * @return {bool} 是否成功\n\t */\n\tbool run(thread_job* job);\n\n\t/**\n\t * 将一个任务交给线程池中的一个线程去执行，线程池中的\n\t * 线程会执行该任务中的 run 函数；该函数功能与 run 功能完全相同，只是为了\n\t * 使 JAVA 程序员看起来更为熟悉才提供了此接口\n\t * @param job {thread_job*} 线程任务\n\t * @return {bool} 是否成功\n\t */\n\tbool execute(thread_job* job);\n\n\t/**\n\t * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小\n\t * @param size {size_t} 线程堆栈大小，当该值为 0 或未\n\t *  调用此函数，则所创建的线程堆栈大小为系统的默认值\n\t * @return {thread&}\n\t */\n\tthread_pool& set_stacksize(size_t size);\n\n\t/**\n\t * 设置线程池最大线程个数限制\n\t * @param max {size_t} 最大线程数，如果不调用此函数，则内部缺省值为 100\n\t * @return {thread_pool&}\n\t */\n\tthread_pool& set_limit(size_t max);\n\n\t/**\n\t * 设置线程池中空闲线程的超时退出时间\n\t * @param ttl {int} 空闲超时时间(秒)，如果不调用此函数，则内部缺省为 0\n\t * @return {thread_pool&}\n\t */\n\tthread_pool& set_idle(int ttl);\n        ......\n};\n```\n\n这些接口定义也相对简单，下面给出一个使用线程池的例子：\n\n```c++\n// 线程工作类\nclass myjob : public acl::thread_job\n{\npublic:\n\tmyjob() {}\n\t~myjob() {}\n\nprotected:\n\t// 基类中的纯虚函数\n\tvirtual void* run()\n\t{\n\t\tconst char* myname = \"run\";\n\t\tprintf(\"%s: thread id: %lu\\r\\n\",\n\t\t\tmyname, acl::thread::thread_self());\n\t\treturn NULL;\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\n// 线程池类\nclass mythread_pool : public acl::thread_pool\n{\npublic:\n\tmythread_pool() {}\n\t~mythread_pool()\n\t{\n\t\tprintf(\"thread pool destroy now, tid: %lu\\r\\n\",\n\t\t\tacl::thread::thread_self());\n\t}\n\nprotected:\n\t// 基类虚函数，当子线程被创建时该虚函数将被调用\n\tvirtual bool thread_on_init()\n\t{\n\t\tconst char* myname = \"thread_on_init\";\n\n\t\tprintf(\"%s: curr tid: %lu\\r\\n\", myname,\n\t\t\tacl::thread::thread_self());\n\t\treturn true;\n\t}\n\n\t// 基类虚函数，当子线程退出前该虚函数将被调用\n\tvirtual void thread_on_exit()\n\t{\n\t\tconst char* myname = \"thread_on_exit\";\n\n\t\tprintf(\"%s: curr tid: %lu\\r\\n\", myname,\n\t\t\tacl::thread::thread_self());\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nvoid test()\n{\n\tacl::thread_pool* threads = new mythread_pool();\n\tthreads->start();  // 启动线程池过程\n\n\tacl::thread_job *job1= new myjob, *job2 = new myjob;\n\tthreads->execute(job1);\n\tthreads->execute(job2);\n\n\t// 为了保证 job1, job2动态内存被正确释放，\n\t// 必须调用 threads->stop 等待子线程运行结束后在\n\t// 主线程中将其释放\n\tthreads->stop();\n\tdelete threads;\n\n\t// 在主线程中释放动态分配的对象\n\tdelete job1;\n\tdelete job2;\n}\n```\n\n如上例所示，在使用 acl 的C++版本线程池类库时，必须定义一个线程工作类（继承自 acl::thread_job）并实现基类的纯虚函数：run()；另外，在使用线程池时，如果想要在线程创建时初始化一些线程局部变量以及在线程退出前释放一些线程局部变量，则可以定义 acl::thread_pool 的子类，实现基类中的 thread_on_init 和 thread_on_exit 方法，如果不需要，则可以直接使用 acl::thread_pool 类对象。\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","source":"_posts/threads_cpp.md","raw":"---\ntitle: 使用 acl_cpp 库编写多线程程序\ndate: 2013-10-26 18:18\ncategories: 线程编程\n---\n\n在 《利用ACL库开发高并发半驻留式线程池程序》中介绍了如何使用 C 版本的 acl 线程库编写多线程程序，本文将会介绍如何使用 C++ 版本的 acl 线程库编写多线程程序，虽然 C++ 版 acl 线程库基于 C 版的线程库，但却提供了更为清晰简洁的接口定义（很多地方参考了 JAVA 的线程接口定义）。下面是一个简单的使用线程的例子：\n\n```c++\n#include \"acl_cpp/lib_acl.hpp\"\n\n//////////////////////////////////////////////////////////////////////////\n\n// 子线程类定义\nclass mythread : public acl::thread\n{\npublic:\n\tmythread() {}\n\t~mythread() {}\nprotected:\n\t// 基类纯虚函数，当在主线程中调用线程实例的 start 函数时\n\t// 该虚函数将会被调用\n\tvirtual void* run()\n\t{\n\t\tconst char* myname = \"run\";\n\t\tprintf(\"%s: thread id: %lu, %lu\\r\\n\",\n\t\t\tmyname, thread_id(), acl::thread::thread_self());\n\t\treturn NULL;\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nstatic void test_thread(void)\n{\n\tconst char* myname = \"test_thread\";\n\tmythread thr;  // 子线程对象实例\n\n\t// 设置线程的属性为非分离方式，以便于下面可以调用 wait\n\t// 等待线程结束\n\tthr.set_detachable(false);\n\n\t// 启动一个子线程\n\tif (thr.start() == false)\n\t{\n\t\tprintf(\"start thread failed\\r\\n\");\n\t\treturn;\n\t}\n\n\tprintf(\"%s: thread id is %lu, main thread id: %lu\\r\\n\",\n\t\tmyname, thr.thread_id(), acl::thread::thread_self());\n\n\t// 等待子线程运行结束\n\tif (thr.wait(NULL) == false)\n\t\tprintf(\"wait thread failed\\r\\n\");\n\telse\n\t\tprintf(\"wait thread ok\\r\\n\");\n}\n\nint main(void)\n{\n\t// 初始化 acl 库\n\tacl::acl_cpp_init();\n\ttest_thread();\n#ifdef WIN32\n\tprintf(\"enter any key to exit ...\\r\\n\");\n\tgetchar();\n#endif\n\treturn 0;\n}\n```\n\n从上面的示例来看，使用 acl 的线程库创建使用线程还是非常简单的。打开 lib_acl_cpp/include/acl_cpp/stdlib/thread.hpp 文件，可以看到线程类的声明，其中有两个基类：acl::thread 与 acl::thread_job，在 基类 acl::thread_job 中有一个纯虚函数 run（），acl::thread 也继承自 acl::thread_job，用户的线程类需要继承 acl::thread，并且需要实现基类 acl::thread_job 的纯虚函数： run（）。当应用在主线程中调用线程实例的 start() 函数时，acl 线程库内部便创建一个子线程，子线程被创建后线程对象的 run()　函数便被调用。下面是 acl::thread 类中几个主要的方法定义：\n\n```c++\nclass thread_job\n{\npublic:\n\tthread_job() {}\n\tvirtual ~thread_job() {}\n\n\t/**\n\t * 纯虚函数，子类必须实现此函数，该函数在子线程中执行\n\t * @return {void*} 线程退出前返回的参数\n\t */\n\tvirtual void* run() = 0;\n};\n\nclass thread : public thread_job\n{\npublic:\n\tthread();\n\tvirtual ~thread();\n\t\n\t/**\n\t * 开始启动线程过程，一旦该函数被调用，则会立即启动一个新的\n\t * 子线程，在子线程中执行基类 thread_job::run 过程\n\t * @return {bool} 是否成功创建线程\n\t */\n\tbool start();\n\n\t/**\n\t * 当创建线程时为非 detachable 状态，则可以调用此函数\n\t * 等待线程结束；否则，若创建线程时为 detachable 状态\n\t * 在调用本函数时将会报错\n\t * @param out {void**} 当该参数非空指针时，该参数用来存放\n\t *  线程退出前返回的参数\n\t * @return {bool} 是否成功\n\t */\n\tbool wait(void** out = NULL);\n\n\t/**\n\t * 在调用 start 前调用此函数可以设置所创建线程是否为\n\t * 分离 (detachable) 状态；如果未调用此函数，则所创建\n\t * 的线程默认为分离状态\n\t * @param yes {bool} 是否为分离状态\n\t * @return {thread&}\n\t */\n\tthread& set_detachable(bool yes);\n\n\t/**\n\t * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小\n\t * @param size {size_t} 线程堆栈大小，当该值为 0 或未\n\t *  调用此函数，则所创建的线程堆栈大小为系统的默认值\n\t * @return {thread&}\n\t */\n\tthread& set_stacksize(size_t size);\n\n\t/**\n\t * 在调用 start 后调用此函数可以获得所创建线程的 id 号\n\t * @return {unsigned long}\n\t */\n\tunsigned long thread_id() const;\n\n\t/**\n\t * 当前调用者所在线程的线程 id 号\n\t * @return {unsigned long}\n\t */\n\tstatic unsigned long thread_self();\n        ....\n};\n\n```\n\n从上面的线程示例及 acl::thread 的类定义，也许有人会觉得应该把 acl::thread_job 的纯虚方法：run() 放在 acl::thread 类中，甚至觉得 acl::thread_job 类是多余的，但是因为 acl 库中还支持线程池方式，则 acl::thread_job 就显得很有必要了。在 lib_acl_cpp\\include\\acl_cpp\\stdlib\\thread_pool.hpp 头文件中可以看到 acl 的线程池类 acl::thread_pool 的声明，该类的主要函数接口如下：\n\n```c++\nclass thread_pool\n{\n\t/**\n\t * 启动线程池，在创建线程池对象后，必须首先调用此函数以启动线程池\n\t */\n\tvoid start();\n\n\t/**\n\t * 停止并销毁线程池，并释放线程池资源，调用此函数可以使所有子线程退出，\n\t * 但并不释放本实例，如果该类实例是动态分配的则用户应该自释放类实例，\n\t * 在调用本函数后，如果想重启线程池过程，则必须重新调用 start 过程\n\t */\n\tvoid stop();\n\n\t/**\n\t * 等待线程池中的所有线程池执行完所有任务\n\t */\n\tvoid wait();\n\n\t/**\n\t * 将一个任务交给线程池中的一个线程去执行，线程池中的\n\t * 线程会执行该任务中的 run 函数\n\t * @param job {thread_job*} 线程任务\n\t * @return {bool} 是否成功\n\t */\n\tbool run(thread_job* job);\n\n\t/**\n\t * 将一个任务交给线程池中的一个线程去执行，线程池中的\n\t * 线程会执行该任务中的 run 函数；该函数功能与 run 功能完全相同，只是为了\n\t * 使 JAVA 程序员看起来更为熟悉才提供了此接口\n\t * @param job {thread_job*} 线程任务\n\t * @return {bool} 是否成功\n\t */\n\tbool execute(thread_job* job);\n\n\t/**\n\t * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小\n\t * @param size {size_t} 线程堆栈大小，当该值为 0 或未\n\t *  调用此函数，则所创建的线程堆栈大小为系统的默认值\n\t * @return {thread&}\n\t */\n\tthread_pool& set_stacksize(size_t size);\n\n\t/**\n\t * 设置线程池最大线程个数限制\n\t * @param max {size_t} 最大线程数，如果不调用此函数，则内部缺省值为 100\n\t * @return {thread_pool&}\n\t */\n\tthread_pool& set_limit(size_t max);\n\n\t/**\n\t * 设置线程池中空闲线程的超时退出时间\n\t * @param ttl {int} 空闲超时时间(秒)，如果不调用此函数，则内部缺省为 0\n\t * @return {thread_pool&}\n\t */\n\tthread_pool& set_idle(int ttl);\n        ......\n};\n```\n\n这些接口定义也相对简单，下面给出一个使用线程池的例子：\n\n```c++\n// 线程工作类\nclass myjob : public acl::thread_job\n{\npublic:\n\tmyjob() {}\n\t~myjob() {}\n\nprotected:\n\t// 基类中的纯虚函数\n\tvirtual void* run()\n\t{\n\t\tconst char* myname = \"run\";\n\t\tprintf(\"%s: thread id: %lu\\r\\n\",\n\t\t\tmyname, acl::thread::thread_self());\n\t\treturn NULL;\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\n// 线程池类\nclass mythread_pool : public acl::thread_pool\n{\npublic:\n\tmythread_pool() {}\n\t~mythread_pool()\n\t{\n\t\tprintf(\"thread pool destroy now, tid: %lu\\r\\n\",\n\t\t\tacl::thread::thread_self());\n\t}\n\nprotected:\n\t// 基类虚函数，当子线程被创建时该虚函数将被调用\n\tvirtual bool thread_on_init()\n\t{\n\t\tconst char* myname = \"thread_on_init\";\n\n\t\tprintf(\"%s: curr tid: %lu\\r\\n\", myname,\n\t\t\tacl::thread::thread_self());\n\t\treturn true;\n\t}\n\n\t// 基类虚函数，当子线程退出前该虚函数将被调用\n\tvirtual void thread_on_exit()\n\t{\n\t\tconst char* myname = \"thread_on_exit\";\n\n\t\tprintf(\"%s: curr tid: %lu\\r\\n\", myname,\n\t\t\tacl::thread::thread_self());\n\t}\n};\n\n//////////////////////////////////////////////////////////////////////////\n\nvoid test()\n{\n\tacl::thread_pool* threads = new mythread_pool();\n\tthreads->start();  // 启动线程池过程\n\n\tacl::thread_job *job1= new myjob, *job2 = new myjob;\n\tthreads->execute(job1);\n\tthreads->execute(job2);\n\n\t// 为了保证 job1, job2动态内存被正确释放，\n\t// 必须调用 threads->stop 等待子线程运行结束后在\n\t// 主线程中将其释放\n\tthreads->stop();\n\tdelete threads;\n\n\t// 在主线程中释放动态分配的对象\n\tdelete job1;\n\tdelete job2;\n}\n```\n\n如上例所示，在使用 acl 的C++版本线程池类库时，必须定义一个线程工作类（继承自 acl::thread_job）并实现基类的纯虚函数：run()；另外，在使用线程池时，如果想要在线程创建时初始化一些线程局部变量以及在线程退出前释放一些线程局部变量，则可以定义 acl::thread_pool 的子类，实现基类中的 thread_on_init 和 thread_on_exit 方法，如果不需要，则可以直接使用 acl::thread_pool 类对象。\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","slug":"threads_cpp","published":1,"updated":"2023-01-24T09:39:29.369Z","_id":"clda1nabq00038o9k24u43vqu","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在 《利用ACL库开发高并发半驻留式线程池程序》中介绍了如何使用 C 版本的 acl 线程库编写多线程程序，本文将会介绍如何使用 C++ 版本的 acl 线程库编写多线程程序，虽然 C++ 版 acl 线程库基于 C 版的线程库，但却提供了更为清晰简洁的接口定义（很多地方参考了 JAVA 的线程接口定义）。下面是一个简单的使用线程的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-comment\">// 子线程类定义</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">mythread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">mythread</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">mythread</span>() &#123;&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数，当在主线程中调用线程实例的 start 函数时</span><br>\t<span class=\"hljs-comment\">// 该虚函数将会被调用</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;run&quot;</span>;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread id: %lu, %lu\\r\\n&quot;</span>,<br>\t\t\tmyname, <span class=\"hljs-built_in\">thread_id</span>(), acl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_thread</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;test_thread&quot;</span>;<br>\tmythread thr;  <span class=\"hljs-comment\">// 子线程对象实例</span><br><br>\t<span class=\"hljs-comment\">// 设置线程的属性为非分离方式，以便于下面可以调用 wait</span><br>\t<span class=\"hljs-comment\">// 等待线程结束</span><br>\tthr.<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">false</span>);<br><br>\t<span class=\"hljs-comment\">// 启动一个子线程</span><br>\t<span class=\"hljs-keyword\">if</span> (thr.<span class=\"hljs-built_in\">start</span>() == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;start thread failed\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread id is %lu, main thread id: %lu\\r\\n&quot;</span>,<br>\t\tmyname, thr.<span class=\"hljs-built_in\">thread_id</span>(), acl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br><br>\t<span class=\"hljs-comment\">// 等待子线程运行结束</span><br>\t<span class=\"hljs-keyword\">if</span> (thr.<span class=\"hljs-built_in\">wait</span>(<span class=\"hljs-literal\">NULL</span>) == <span class=\"hljs-literal\">false</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;wait thread failed\\r\\n&quot;</span>);<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;wait thread ok\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 初始化 acl 库</span><br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();<br>\t<span class=\"hljs-built_in\">test_thread</span>();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;enter any key to exit ...\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">getchar</span>();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面的示例来看，使用 acl 的线程库创建使用线程还是非常简单的。打开 lib_acl_cpp&#x2F;include&#x2F;acl_cpp&#x2F;stdlib&#x2F;thread.hpp 文件，可以看到线程类的声明，其中有两个基类：acl::thread 与 acl::thread_job，在 基类 acl::thread_job 中有一个纯虚函数 run（），acl::thread 也继承自 acl::thread_job，用户的线程类需要继承 acl::thread，并且需要实现基类 acl::thread_job 的纯虚函数： run（）。当应用在主线程中调用线程实例的 start() 函数时，acl 线程库内部便创建一个子线程，子线程被创建后线程对象的 run()　函数便被调用。下面是 acl::thread 类中几个主要的方法定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">thread_job</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">thread_job</span>() &#123;&#125;<br>\t<span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">thread_job</span>() &#123;&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 纯虚函数，子类必须实现此函数，该函数在子线程中执行</span><br><span class=\"hljs-comment\">\t * @return &#123;void*&#125; 线程退出前返回的参数</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">thread</span> : <span class=\"hljs-keyword\">public</span> thread_job<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">thread</span>();<br>\t<span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">thread</span>();<br>\t<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 开始启动线程过程，一旦该函数被调用，则会立即启动一个新的</span><br><span class=\"hljs-comment\">\t * 子线程，在子线程中执行基类 thread_job::run 过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 是否成功创建线程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 当创建线程时为非 detachable 状态，则可以调用此函数</span><br><span class=\"hljs-comment\">\t * 等待线程结束；否则，若创建线程时为 detachable 状态</span><br><span class=\"hljs-comment\">\t * 在调用本函数时将会报错</span><br><span class=\"hljs-comment\">\t * @param out &#123;void**&#125; 当该参数非空指针时，该参数用来存放</span><br><span class=\"hljs-comment\">\t *  线程退出前返回的参数</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 是否成功</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>** out = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 在调用 start 前调用此函数可以设置所创建线程是否为</span><br><span class=\"hljs-comment\">\t * 分离 (detachable) 状态；如果未调用此函数，则所创建</span><br><span class=\"hljs-comment\">\t * 的线程默认为分离状态</span><br><span class=\"hljs-comment\">\t * @param yes &#123;bool&#125; 是否为分离状态</span><br><span class=\"hljs-comment\">\t * @return &#123;thread&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread&amp; <span class=\"hljs-title\">set_detachable</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> yes)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小</span><br><span class=\"hljs-comment\">\t * @param size &#123;size_t&#125; 线程堆栈大小，当该值为 0 或未</span><br><span class=\"hljs-comment\">\t *  调用此函数，则所创建的线程堆栈大小为系统的默认值</span><br><span class=\"hljs-comment\">\t * @return &#123;thread&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread&amp; <span class=\"hljs-title\">set_stacksize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 在调用 start 后调用此函数可以获得所创建线程的 id 号</span><br><span class=\"hljs-comment\">\t * @return &#123;unsigned long&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title\">thread_id</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 当前调用者所在线程的线程 id 号</span><br><span class=\"hljs-comment\">\t * @return &#123;unsigned long&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title\">thread_self</span><span class=\"hljs-params\">()</span></span>;<br>        ....<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<p>从上面的线程示例及 acl::thread 的类定义，也许有人会觉得应该把 acl::thread_job 的纯虚方法：run() 放在 acl::thread 类中，甚至觉得 acl::thread_job 类是多余的，但是因为 acl 库中还支持线程池方式，则 acl::thread_job 就显得很有必要了。在 lib_acl_cpp\\include\\acl_cpp\\stdlib\\thread_pool.hpp 头文件中可以看到 acl 的线程池类 acl::thread_pool 的声明，该类的主要函数接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">thread_pool</span><br>&#123;<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 启动线程池，在创建线程池对象后，必须首先调用此函数以启动线程池</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 停止并销毁线程池，并释放线程池资源，调用此函数可以使所有子线程退出，</span><br><span class=\"hljs-comment\">\t * 但并不释放本实例，如果该类实例是动态分配的则用户应该自释放类实例，</span><br><span class=\"hljs-comment\">\t * 在调用本函数后，如果想重启线程池过程，则必须重新调用 start 过程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">stop</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 等待线程池中的所有线程池执行完所有任务</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">wait</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 将一个任务交给线程池中的一个线程去执行，线程池中的</span><br><span class=\"hljs-comment\">\t * 线程会执行该任务中的 run 函数</span><br><span class=\"hljs-comment\">\t * @param job &#123;thread_job*&#125; 线程任务</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 是否成功</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(thread_job* job)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 将一个任务交给线程池中的一个线程去执行，线程池中的</span><br><span class=\"hljs-comment\">\t * 线程会执行该任务中的 run 函数；该函数功能与 run 功能完全相同，只是为了</span><br><span class=\"hljs-comment\">\t * 使 JAVA 程序员看起来更为熟悉才提供了此接口</span><br><span class=\"hljs-comment\">\t * @param job &#123;thread_job*&#125; 线程任务</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 是否成功</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(thread_job* job)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小</span><br><span class=\"hljs-comment\">\t * @param size &#123;size_t&#125; 线程堆栈大小，当该值为 0 或未</span><br><span class=\"hljs-comment\">\t *  调用此函数，则所创建的线程堆栈大小为系统的默认值</span><br><span class=\"hljs-comment\">\t * @return &#123;thread&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread_pool&amp; <span class=\"hljs-title\">set_stacksize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 设置线程池最大线程个数限制</span><br><span class=\"hljs-comment\">\t * @param max &#123;size_t&#125; 最大线程数，如果不调用此函数，则内部缺省值为 100</span><br><span class=\"hljs-comment\">\t * @return &#123;thread_pool&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread_pool&amp; <span class=\"hljs-title\">set_limit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> max)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 设置线程池中空闲线程的超时退出时间</span><br><span class=\"hljs-comment\">\t * @param ttl &#123;int&#125; 空闲超时时间(秒)，如果不调用此函数，则内部缺省为 0</span><br><span class=\"hljs-comment\">\t * @return &#123;thread_pool&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread_pool&amp; <span class=\"hljs-title\">set_idle</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> ttl)</span></span>;<br>        ......<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这些接口定义也相对简单，下面给出一个使用线程池的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 线程工作类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myjob</span> : <span class=\"hljs-keyword\">public</span> acl::thread_job<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myjob</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">myjob</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类中的纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;run&quot;</span>;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread id: %lu\\r\\n&quot;</span>,<br>\t\t\tmyname, acl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-comment\">// 线程池类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">mythread_pool</span> : <span class=\"hljs-keyword\">public</span> acl::thread_pool<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">mythread_pool</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">mythread_pool</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;thread pool destroy now, tid: %lu\\r\\n&quot;</span>,<br>\t\t\tacl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类虚函数，当子线程被创建时该虚函数将被调用</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_init</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;thread_on_init&quot;</span>;<br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: curr tid: %lu\\r\\n&quot;</span>, myname,<br>\t\t\tacl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数，当子线程退出前该虚函数将被调用</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_exit</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;thread_on_exit&quot;</span>;<br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: curr tid: %lu\\r\\n&quot;</span>, myname,<br>\t\t\tacl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::thread_pool* threads = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">mythread_pool</span>();<br>\tthreads-&gt;<span class=\"hljs-built_in\">start</span>();  <span class=\"hljs-comment\">// 启动线程池过程</span><br><br>\tacl::thread_job *job1= <span class=\"hljs-keyword\">new</span> myjob, *job2 = <span class=\"hljs-keyword\">new</span> myjob;<br>\tthreads-&gt;<span class=\"hljs-built_in\">execute</span>(job1);<br>\tthreads-&gt;<span class=\"hljs-built_in\">execute</span>(job2);<br><br>\t<span class=\"hljs-comment\">// 为了保证 job1, job2动态内存被正确释放，</span><br>\t<span class=\"hljs-comment\">// 必须调用 threads-&gt;stop 等待子线程运行结束后在</span><br>\t<span class=\"hljs-comment\">// 主线程中将其释放</span><br>\tthreads-&gt;<span class=\"hljs-built_in\">stop</span>();<br>\t<span class=\"hljs-keyword\">delete</span> threads;<br><br>\t<span class=\"hljs-comment\">// 在主线程中释放动态分配的对象</span><br>\t<span class=\"hljs-keyword\">delete</span> job1;<br>\t<span class=\"hljs-keyword\">delete</span> job2;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如上例所示，在使用 acl 的C++版本线程池类库时，必须定义一个线程工作类（继承自 acl::thread_job）并实现基类的纯虚函数：run()；另外，在使用线程池时，如果想要在线程创建时初始化一些线程局部变量以及在线程退出前释放一些线程局部变量，则可以定义 acl::thread_pool 的子类，实现基类中的 thread_on_init 和 thread_on_exit 方法，如果不需要，则可以直接使用 acl::thread_pool 类对象。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在 《利用ACL库开发高并发半驻留式线程池程序》中介绍了如何使用 C 版本的 acl 线程库编写多线程程序，本文将会介绍如何使用 C++ 版本的 acl 线程库编写多线程程序，虽然 C++ 版 acl 线程库基于 C 版的线程库，但却提供了更为清晰简洁的接口定义（很多地方参考了 JAVA 的线程接口定义）。下面是一个简单的使用线程的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;acl_cpp/lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-comment\">// 子线程类定义</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">mythread</span> : <span class=\"hljs-keyword\">public</span> acl::thread<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">mythread</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">mythread</span>() &#123;&#125;<br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类纯虚函数，当在主线程中调用线程实例的 start 函数时</span><br>\t<span class=\"hljs-comment\">// 该虚函数将会被调用</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;run&quot;</span>;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread id: %lu, %lu\\r\\n&quot;</span>,<br>\t\t\tmyname, <span class=\"hljs-built_in\">thread_id</span>(), acl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test_thread</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;test_thread&quot;</span>;<br>\tmythread thr;  <span class=\"hljs-comment\">// 子线程对象实例</span><br><br>\t<span class=\"hljs-comment\">// 设置线程的属性为非分离方式，以便于下面可以调用 wait</span><br>\t<span class=\"hljs-comment\">// 等待线程结束</span><br>\tthr.<span class=\"hljs-built_in\">set_detachable</span>(<span class=\"hljs-literal\">false</span>);<br><br>\t<span class=\"hljs-comment\">// 启动一个子线程</span><br>\t<span class=\"hljs-keyword\">if</span> (thr.<span class=\"hljs-built_in\">start</span>() == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;start thread failed\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread id is %lu, main thread id: %lu\\r\\n&quot;</span>,<br>\t\tmyname, thr.<span class=\"hljs-built_in\">thread_id</span>(), acl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br><br>\t<span class=\"hljs-comment\">// 等待子线程运行结束</span><br>\t<span class=\"hljs-keyword\">if</span> (thr.<span class=\"hljs-built_in\">wait</span>(<span class=\"hljs-literal\">NULL</span>) == <span class=\"hljs-literal\">false</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;wait thread failed\\r\\n&quot;</span>);<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;wait thread ok\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 初始化 acl 库</span><br>\tacl::<span class=\"hljs-built_in\">acl_cpp_init</span>();<br>\t<span class=\"hljs-built_in\">test_thread</span>();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;enter any key to exit ...\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">getchar</span>();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面的示例来看，使用 acl 的线程库创建使用线程还是非常简单的。打开 lib_acl_cpp&#x2F;include&#x2F;acl_cpp&#x2F;stdlib&#x2F;thread.hpp 文件，可以看到线程类的声明，其中有两个基类：acl::thread 与 acl::thread_job，在 基类 acl::thread_job 中有一个纯虚函数 run（），acl::thread 也继承自 acl::thread_job，用户的线程类需要继承 acl::thread，并且需要实现基类 acl::thread_job 的纯虚函数： run（）。当应用在主线程中调用线程实例的 start() 函数时，acl 线程库内部便创建一个子线程，子线程被创建后线程对象的 run()　函数便被调用。下面是 acl::thread 类中几个主要的方法定义：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">thread_job</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">thread_job</span>() &#123;&#125;<br>\t<span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">thread_job</span>() &#123;&#125;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 纯虚函数，子类必须实现此函数，该函数在子线程中执行</span><br><span class=\"hljs-comment\">\t * @return &#123;void*&#125; 线程退出前返回的参数</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">thread</span> : <span class=\"hljs-keyword\">public</span> thread_job<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">thread</span>();<br>\t<span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">thread</span>();<br>\t<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 开始启动线程过程，一旦该函数被调用，则会立即启动一个新的</span><br><span class=\"hljs-comment\">\t * 子线程，在子线程中执行基类 thread_job::run 过程</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 是否成功创建线程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 当创建线程时为非 detachable 状态，则可以调用此函数</span><br><span class=\"hljs-comment\">\t * 等待线程结束；否则，若创建线程时为 detachable 状态</span><br><span class=\"hljs-comment\">\t * 在调用本函数时将会报错</span><br><span class=\"hljs-comment\">\t * @param out &#123;void**&#125; 当该参数非空指针时，该参数用来存放</span><br><span class=\"hljs-comment\">\t *  线程退出前返回的参数</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 是否成功</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>** out = <span class=\"hljs-literal\">NULL</span>)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 在调用 start 前调用此函数可以设置所创建线程是否为</span><br><span class=\"hljs-comment\">\t * 分离 (detachable) 状态；如果未调用此函数，则所创建</span><br><span class=\"hljs-comment\">\t * 的线程默认为分离状态</span><br><span class=\"hljs-comment\">\t * @param yes &#123;bool&#125; 是否为分离状态</span><br><span class=\"hljs-comment\">\t * @return &#123;thread&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread&amp; <span class=\"hljs-title\">set_detachable</span><span class=\"hljs-params\">(<span class=\"hljs-type\">bool</span> yes)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小</span><br><span class=\"hljs-comment\">\t * @param size &#123;size_t&#125; 线程堆栈大小，当该值为 0 或未</span><br><span class=\"hljs-comment\">\t *  调用此函数，则所创建的线程堆栈大小为系统的默认值</span><br><span class=\"hljs-comment\">\t * @return &#123;thread&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread&amp; <span class=\"hljs-title\">set_stacksize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 在调用 start 后调用此函数可以获得所创建线程的 id 号</span><br><span class=\"hljs-comment\">\t * @return &#123;unsigned long&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title\">thread_id</span><span class=\"hljs-params\">()</span> <span class=\"hljs-type\">const</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 当前调用者所在线程的线程 id 号</span><br><span class=\"hljs-comment\">\t * @return &#123;unsigned long&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-title\">thread_self</span><span class=\"hljs-params\">()</span></span>;<br>        ....<br>&#125;;<br><br></code></pre></td></tr></table></figure>\n\n<p>从上面的线程示例及 acl::thread 的类定义，也许有人会觉得应该把 acl::thread_job 的纯虚方法：run() 放在 acl::thread 类中，甚至觉得 acl::thread_job 类是多余的，但是因为 acl 库中还支持线程池方式，则 acl::thread_job 就显得很有必要了。在 lib_acl_cpp\\include\\acl_cpp\\stdlib\\thread_pool.hpp 头文件中可以看到 acl 的线程池类 acl::thread_pool 的声明，该类的主要函数接口如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">thread_pool</span><br>&#123;<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 启动线程池，在创建线程池对象后，必须首先调用此函数以启动线程池</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">start</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 停止并销毁线程池，并释放线程池资源，调用此函数可以使所有子线程退出，</span><br><span class=\"hljs-comment\">\t * 但并不释放本实例，如果该类实例是动态分配的则用户应该自释放类实例，</span><br><span class=\"hljs-comment\">\t * 在调用本函数后，如果想重启线程池过程，则必须重新调用 start 过程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">stop</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 等待线程池中的所有线程池执行完所有任务</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">wait</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 将一个任务交给线程池中的一个线程去执行，线程池中的</span><br><span class=\"hljs-comment\">\t * 线程会执行该任务中的 run 函数</span><br><span class=\"hljs-comment\">\t * @param job &#123;thread_job*&#125; 线程任务</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 是否成功</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(thread_job* job)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 将一个任务交给线程池中的一个线程去执行，线程池中的</span><br><span class=\"hljs-comment\">\t * 线程会执行该任务中的 run 函数；该函数功能与 run 功能完全相同，只是为了</span><br><span class=\"hljs-comment\">\t * 使 JAVA 程序员看起来更为熟悉才提供了此接口</span><br><span class=\"hljs-comment\">\t * @param job &#123;thread_job*&#125; 线程任务</span><br><span class=\"hljs-comment\">\t * @return &#123;bool&#125; 是否成功</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">execute</span><span class=\"hljs-params\">(thread_job* job)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 在调用 start 前调用此函数可以设置所创建线程的堆栈大小</span><br><span class=\"hljs-comment\">\t * @param size &#123;size_t&#125; 线程堆栈大小，当该值为 0 或未</span><br><span class=\"hljs-comment\">\t *  调用此函数，则所创建的线程堆栈大小为系统的默认值</span><br><span class=\"hljs-comment\">\t * @return &#123;thread&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread_pool&amp; <span class=\"hljs-title\">set_stacksize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> size)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 设置线程池最大线程个数限制</span><br><span class=\"hljs-comment\">\t * @param max &#123;size_t&#125; 最大线程数，如果不调用此函数，则内部缺省值为 100</span><br><span class=\"hljs-comment\">\t * @return &#123;thread_pool&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread_pool&amp; <span class=\"hljs-title\">set_limit</span><span class=\"hljs-params\">(<span class=\"hljs-type\">size_t</span> max)</span></span>;<br><br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 设置线程池中空闲线程的超时退出时间</span><br><span class=\"hljs-comment\">\t * @param ttl &#123;int&#125; 空闲超时时间(秒)，如果不调用此函数，则内部缺省为 0</span><br><span class=\"hljs-comment\">\t * @return &#123;thread_pool&amp;&#125;</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-function\">thread_pool&amp; <span class=\"hljs-title\">set_idle</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> ttl)</span></span>;<br>        ......<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>这些接口定义也相对简单，下面给出一个使用线程池的例子：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 线程工作类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">myjob</span> : <span class=\"hljs-keyword\">public</span> acl::thread_job<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">myjob</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">myjob</span>() &#123;&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类中的纯虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span>* <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;run&quot;</span>;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: thread id: %lu\\r\\n&quot;</span>,<br>\t\t\tmyname, acl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-comment\">// 线程池类</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">mythread_pool</span> : <span class=\"hljs-keyword\">public</span> acl::thread_pool<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">mythread_pool</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">mythread_pool</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;thread pool destroy now, tid: %lu\\r\\n&quot;</span>,<br>\t\t\tacl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t&#125;<br><br><span class=\"hljs-keyword\">protected</span>:<br>\t<span class=\"hljs-comment\">// 基类虚函数，当子线程被创建时该虚函数将被调用</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">thread_on_init</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;thread_on_init&quot;</span>;<br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: curr tid: %lu\\r\\n&quot;</span>, myname,<br>\t\t\tacl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数，当子线程退出前该虚函数将被调用</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">thread_on_exit</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* myname = <span class=\"hljs-string\">&quot;thread_on_exit&quot;</span>;<br><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: curr tid: %lu\\r\\n&quot;</span>, myname,<br>\t\t\tacl::thread::<span class=\"hljs-built_in\">thread_self</span>());<br>\t&#125;<br>&#125;;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::thread_pool* threads = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">mythread_pool</span>();<br>\tthreads-&gt;<span class=\"hljs-built_in\">start</span>();  <span class=\"hljs-comment\">// 启动线程池过程</span><br><br>\tacl::thread_job *job1= <span class=\"hljs-keyword\">new</span> myjob, *job2 = <span class=\"hljs-keyword\">new</span> myjob;<br>\tthreads-&gt;<span class=\"hljs-built_in\">execute</span>(job1);<br>\tthreads-&gt;<span class=\"hljs-built_in\">execute</span>(job2);<br><br>\t<span class=\"hljs-comment\">// 为了保证 job1, job2动态内存被正确释放，</span><br>\t<span class=\"hljs-comment\">// 必须调用 threads-&gt;stop 等待子线程运行结束后在</span><br>\t<span class=\"hljs-comment\">// 主线程中将其释放</span><br>\tthreads-&gt;<span class=\"hljs-built_in\">stop</span>();<br>\t<span class=\"hljs-keyword\">delete</span> threads;<br><br>\t<span class=\"hljs-comment\">// 在主线程中释放动态分配的对象</span><br>\t<span class=\"hljs-keyword\">delete</span> job1;<br>\t<span class=\"hljs-keyword\">delete</span> job2;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>如上例所示，在使用 acl 的C++版本线程池类库时，必须定义一个线程工作类（继承自 acl::thread_job）并实现基类的纯虚函数：run()；另外，在使用线程池时，如果想要在线程创建时初始化一些线程局部变量以及在线程退出前释放一些线程局部变量，则可以定义 acl::thread_pool 的子类，实现基类中的 thread_on_init 和 thread_on_exit 方法，如果不需要，则可以直接使用 acl::thread_pool 类对象。</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"使用 acl 库编写数据库应用程序","date":"2014-09-03T04:11:00.000Z","_content":"\nacl 的 C++ 版本库（lib_acl_cpp.a）的 db 模块主要与数据库编程相关，通过这些模块库，开发者可以快速地写出支持数据库连接池的数据库应用程序，目前该 db 模块支持 mysql、sqlite 数据库。本文将以 mysql 应用为例讲述如何使用这些 API 接口编程数据库应用。\n\n在 lib_acl_cpp/include/acl_cpp/db 目录下，可以看到主要分三个部分：数据库操作句柄类（db_handle，db_mysql，db_sqlite）、数据库连接池类（db_pool，mysql_pool，sqlite_pool）及数据库服务类（db_service，db_service_mysql，db_service_sqlite，这些类主要用在阻塞非阻塞结合的应用中，如：MFC界面过程与数据库过程的结合，非阻塞 IO 过程与数据库过程结合）。\n\n## 一、数据库操作句柄\n\n下图显示了数据库句柄的类继承关系：db_handle 为基础类，db_mysql/db_sqlite 类均继承于 db_handle 类。\n\n![db_handle基类](/img/db.png)\n\n在 db_mysql.hpp/db_sqlite.hpp 两个头文件中可以看出，这两个子类仅是实现了基础类 db_handle 的一些虚函数而已，大量关于数据的操作函数都集中于 db_handle.hpp 头文件中，下图为 db_handle 类的功能协作图（其中的 db_rows/db_row 两个类为数据库查询结果类）：\n![db继承关系](/img/db2.png)\n\n下面给出了一个简单的数据库查询示例：\n\n```c++\n////////////////////////////////////////////////////////////////////////////////\n/**\n * 从数据库中查询表数据\n * @param db {acl::db_handle&} acl 中的数据库连接句柄引用\n */\nstatic void tbl_select(acl::db_handle& db)\n{\n\t// 创建 sql 查询语句\n\tconst char* sql = \"select * from group_tbl where\"\n\t\t\" group_name='test_name' and uvip_tbl='test'\";\n\t// 查询数据库\n\tif (db.sql_select(sql) == false)\n\t{\n\t\tprintf(\"select sql: %s error\\r\\n\", sql);\n\t\treturn;\n\t}\n\tprintf(\"\\r\\n---------------------------------------------------\\r\\n\");\n\t// 列出查询结果方法一：从数据库句柄中获得查询结果集合\n\tconst acl::db_rows* result = db.get_result();\n\tif (result)\n\t{\n\t\t// 遍历查询结果集\n\t\tconst std::vector<acl::db_row*>& rows = result->get_rows();\n\t\tfor (size_t i = 0; i < rows.size(); i++)\n\t\t{\n\t\t\tconst acl::db_row* row = rows[i];\n\t\t\t// 打印一行结果中的所有结果\n\t\t\tfor (size_t j = 0; j < row->length(); j++)\n\t\t\t\tprintf(\"%s, \", (*row)[j]);\n\t\t\tprintf(\"\\r\\n\");\n\t\t}\n\t}\n\t// 列出查询结果方法二：根据数组下标遍历数据库句柄的查询结果集\n\tfor (size_t i = 0; i < db.length(); i++)\n\t{\n\t\tconst acl::db_row* row = db[i];\n\n\t\t// 取出该行记录中某个字段的值\n\t\tconst char* ptr = (*row)[\"group_name\"];\n\t\tif (ptr == NULL)\n\t\t{\n\t\t\tprintf(\"error, no group name\\r\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"group_name=%s: \", ptr);\n\t\tfor (size_t j = 0; j < row->length(); j++)\n\t\t\tprintf(\"%s, \", (*row)[j]);\n\t\tprintf(\"\\r\\n\");\n\t}\n\t// 列出查询结果方法三：直接从数据库句柄中获得结果数组\n\tconst std::vector<acl::db_row*>* rows = db.get_rows();\n\tif (rows)\n\t{\n\t\tstd::vector<acl::db_row*>::const_iterator cit = rows->begin();\n\t\tfor (; cit != rows->end(); cit++)\n\t\t{\n\t\t\tconst acl::db_row* row = *cit;\n\t\t\tfor (size_t j = 0; j < row->length(); j++)\n\t\t\t\tprintf(\"%s, \", (*row)[j]);\n\t\t\tprintf(\"\\r\\n\");\n\t\t}\n\t\t\n\t}\n\t// 必须释放查询结果\n\tdb.free_result();\n}\n////////////////////////////////////////////////////////////////////////////////\n/**\n * 打开 mysql 数据库连接句柄\n * @return {acl::db_handle*} 返回值为 NULL 表示连接数据库失败\n */\nstatic acl::db_handle* open_mysql(void)\n{\n\tconst char* dbaddr = \"127.0.0.1:3306\";\n\tconst char* dbname = \"acl_test_db\";\n\tconst char* dbuser = \"acl_user\", *dbpass = \"111111\";\n\tacl::db_handle* db = new acl::db_mysql(dbaddr, dbname, dbuser, dbpass);\n\n\tif (db->open() == false)\n\t{\n\t\tprintf(\"open mysql db error\\r\\n\");\n\t\tdelete db;\n\t\treturn NULL;\n\t}\n\treturn db;\n}\n/**\n * 打开 sqlite 数据库句柄\n * @return {acl::db_handle*} 返回值为 NULL 表示连接数据库失败\n */\nstatic acl::db_handle* open_sqlite(void)\n{\n\tconst char* dbfile = \"test.db\";\n\tacl::db_handle* db = new acl::db_sqlite(dbfile);\n\n\tif (db->open() == flase)\n\t{\n\t\tprintf(\"open mysql db error\\r\\n\");\n\t\tdelete db;\n\t\treturn NULL;\n\t}\n\treturn db;\n}\n////////////////////////////////////////////////////////////////////////////////\nvoid db_demo(void)\n{\n\tacl::db_handle* db;\n\n\t// 操作 mysql 数据库过程\n\tdb = open_mysql();\n\tif (db)\n\t{\n\t\ttbl_select(*db);\n\t\tdelete db;\n\t}\n\n\t// 操作 sqlite 数据库过程\n\tdb = open_sqlite();\n\tif (db)\n\t{\n\t\ttbl_select(*db);\n\t\tdelete db;\n\t}\n}\n```\n\n从上面的例子可以看出，虽然操作的数据库不同，但数据库查询方式却是完全一样的，因为 acl 类内部屏蔽了数据库操作的差异性。下面还有几点需要注意：\n\n- 对于数据库查询结果集有多种操作方式，开发者可以根据需要进行选择；\n- 其中生成的 sql 查询语句比较简单，所以没有做特殊字符转义，真正生产环境中开发者应注意对 sql 中的一些变化查询字段进行转义（可以使用 acl::db_handle 类中的 escape_string 方法），以防止 sql 注入攻击；\n- 如果查询的数据库结果集非空，则在处理结果完毕毕竟调用 acl::db_handle 类中的 free_result() 方法释放中间动态分配的内存；\n- 在使用 acl 数据库类编写代码时不需要包含 mysql 和 sqlite 的头文件，但在程序连接阶段必须将 mysql/sqlite 的静态库加上。\n\n## 二、数据库连接池\n为了避免建立数据库连接开销对数据造成冲击，一般的数据库连接都建议使用连接池方式（尤其是在JAVA、PHP等应用中）；连接池在保持与数据库的长连接过程中，必须要处理连接中断的重连情况，使上层使用者忽略连接中断的情况。\n\n下图为 acl 的数据库连接池中各类的继承关系及连接池基础类的函数接口：\n\n从 mysql_pool.hpp/sqlite_pool.hpp 头文件中可以看出，二者的主要区别是构造函数略有不同：\ndb_pool 类为数据库连接池基类，其中主要有两个方法：\n\n```c++\n \t/**\n\t * 从数据库中连接池获得一个数据库连接，该函数返回的数据库\n\t * 连接对象用完后必须调用 db_pool->put(db_handle*) 将连接\n\t * 归还至数据库连接池，由该函数获得的连接句柄不能 delete，\n\t * 否则会造成连接池的内部计数器出错\n\t * @return {db_handle*} 返回空，则表示出错\n\t */\n\tdb_handle* peek();\n\n\t/**\n\t * 将数据库连接放回至连接池中，当从数据库连接池中获得连接\n\t * 句柄用完后应该通过该函数放回，不能直接 delete，因为那样\n\t * 会导致连接池的内部记数发生错误\n\t * @param conn {db_handle*} 数据库连接句柄，该连接句柄可以\n\t *  是由 peek 创建的，也可以单独动态创建的\n\t * @param keep {bool} 归还给连接池的数据库连接句柄是否继续\n\t *  保持连接，如果否，则内部会自动删除该连接句柄\n\t */\n\tvoid put(db_handle* conn, bool keep = true);\n```\n\nmysql 数据库连接池的构造函数如下：\n\n```c++\n\t/**\n\t * 采用 mysql 数据库时的构造函数\n\t * @param dbaddr {const char*} mysql 服务器地址，格式：IP:PORT，\n\t *  在 UNIX 平台下可以为 UNIX 域套接口\n\t * @param dbname {const char*} 数据库名\n\t * @param dbuser {const char*} 数据库用户\n\t * @param dbpass {const char*} 数据库用户密码\n\t * @param dblimit {int} 数据库连接池的最大连接数限制\n\t * @param dbflags {unsigned long} mysql 标记位\n\t * @param auto_commit {bool} 是否自动提交\n\t * @param conn_timeout {int} 连接数据库超时时间(秒)\n\t * @param rw_timeout {int} 与数据库通信时的IO时间(秒)\n\t */\n\tmysql_pool(const char* dbaddr, const char* dbname,\n\t\tconst char* dbuser, const char* dbpass,\n\t\tint dblimit = 64, unsigned long dbflags = 0,\n\t\tbool auto_commit = true, int conn_timeout = 60,\n\t\tint rw_timeout = 60);\n```\n\n下面以 mysql 为例写一个简单的使用连接池的函数：\n\n```c++\nvoid dbpool_demo(void)\n{\n\tconst char* dbaddr = \"127.0.0.1:3306\";\n\tconst char* dbname = \"acl_test_db\";\n\tconst char* dbuser = \"acl_user\", *dbpass = \"111111\";\n\tacl::db_pool* dbp = new acl::mysql_pool(dbaddr, dbname, dbuser, dbpass);  // 创建 mysql 连接池\n\tacl::db_handle* dbh = dbp->peek(); // 从连接池中获取一个数据库连接\n\tif (dbh == NULL)\n\t{\n\t\tprintf(\"peek db connection error\\r\\n\");\n\t\tdelete dbp;\n\t\treturn;\n\t}\n\ttbl_select(*dbh);  // 从数据库中查询数据（使用上面的查询例子）\n\tdbh->put(dbh);\t// 归还数据库连接给连接池\n\tdelete dbh; // 删除连接池对象\n}\n```\n\n由上面示例可以看出 acl 中的数据库连接池还是比较简单易用的，不过需要注意以下几点：\n\n- 在创建数据库连接池对象时并不立刻连接后端的数据库，数据库的连接过程一般发生在 acl::db_pool::peek() 过程，但在调用 peek 时如果连接池有可用连接则直接使用之；\n- 在使用数据库连接操作数据库时，如果因为网络意外导致连接断开，内部会根据数据库连接的返回错误号决定是否需要重试该数据库操作；\n- 在用完数据库连接后需要调用 acl::db_pool::put() 过程归还数据库连；\n- 在编译 lib_acl_cpp 库时必须需要指定 Makefile.db 为工程文件(make -f Makefile.db)，这样才能使 lib_acl_cpp.a 库内部的数据库功能生效；同时在编译自己的应用程序时必须指定 libmysqlclient_r.a 的链接位置。\n\n好了，关于如何使用 acl 库编写数据库应用先写到此，欢迎读者批评指正。\n\n其它有关数据库使用例子请参考：\n- acl\\lib_acl_cpp\\samples\\mysql\n- acl\\lib_acl_cpp\\samples\\sqlite","source":"_posts/db.md","raw":"---\ntitle: 使用 acl 库编写数据库应用程序\ndate: 2014/09/03 12:11\ncategories: 数据库编程\n---\n\nacl 的 C++ 版本库（lib_acl_cpp.a）的 db 模块主要与数据库编程相关，通过这些模块库，开发者可以快速地写出支持数据库连接池的数据库应用程序，目前该 db 模块支持 mysql、sqlite 数据库。本文将以 mysql 应用为例讲述如何使用这些 API 接口编程数据库应用。\n\n在 lib_acl_cpp/include/acl_cpp/db 目录下，可以看到主要分三个部分：数据库操作句柄类（db_handle，db_mysql，db_sqlite）、数据库连接池类（db_pool，mysql_pool，sqlite_pool）及数据库服务类（db_service，db_service_mysql，db_service_sqlite，这些类主要用在阻塞非阻塞结合的应用中，如：MFC界面过程与数据库过程的结合，非阻塞 IO 过程与数据库过程结合）。\n\n## 一、数据库操作句柄\n\n下图显示了数据库句柄的类继承关系：db_handle 为基础类，db_mysql/db_sqlite 类均继承于 db_handle 类。\n\n![db_handle基类](/img/db.png)\n\n在 db_mysql.hpp/db_sqlite.hpp 两个头文件中可以看出，这两个子类仅是实现了基础类 db_handle 的一些虚函数而已，大量关于数据的操作函数都集中于 db_handle.hpp 头文件中，下图为 db_handle 类的功能协作图（其中的 db_rows/db_row 两个类为数据库查询结果类）：\n![db继承关系](/img/db2.png)\n\n下面给出了一个简单的数据库查询示例：\n\n```c++\n////////////////////////////////////////////////////////////////////////////////\n/**\n * 从数据库中查询表数据\n * @param db {acl::db_handle&} acl 中的数据库连接句柄引用\n */\nstatic void tbl_select(acl::db_handle& db)\n{\n\t// 创建 sql 查询语句\n\tconst char* sql = \"select * from group_tbl where\"\n\t\t\" group_name='test_name' and uvip_tbl='test'\";\n\t// 查询数据库\n\tif (db.sql_select(sql) == false)\n\t{\n\t\tprintf(\"select sql: %s error\\r\\n\", sql);\n\t\treturn;\n\t}\n\tprintf(\"\\r\\n---------------------------------------------------\\r\\n\");\n\t// 列出查询结果方法一：从数据库句柄中获得查询结果集合\n\tconst acl::db_rows* result = db.get_result();\n\tif (result)\n\t{\n\t\t// 遍历查询结果集\n\t\tconst std::vector<acl::db_row*>& rows = result->get_rows();\n\t\tfor (size_t i = 0; i < rows.size(); i++)\n\t\t{\n\t\t\tconst acl::db_row* row = rows[i];\n\t\t\t// 打印一行结果中的所有结果\n\t\t\tfor (size_t j = 0; j < row->length(); j++)\n\t\t\t\tprintf(\"%s, \", (*row)[j]);\n\t\t\tprintf(\"\\r\\n\");\n\t\t}\n\t}\n\t// 列出查询结果方法二：根据数组下标遍历数据库句柄的查询结果集\n\tfor (size_t i = 0; i < db.length(); i++)\n\t{\n\t\tconst acl::db_row* row = db[i];\n\n\t\t// 取出该行记录中某个字段的值\n\t\tconst char* ptr = (*row)[\"group_name\"];\n\t\tif (ptr == NULL)\n\t\t{\n\t\t\tprintf(\"error, no group name\\r\\n\");\n\t\t\tcontinue;\n\t\t}\n\t\tprintf(\"group_name=%s: \", ptr);\n\t\tfor (size_t j = 0; j < row->length(); j++)\n\t\t\tprintf(\"%s, \", (*row)[j]);\n\t\tprintf(\"\\r\\n\");\n\t}\n\t// 列出查询结果方法三：直接从数据库句柄中获得结果数组\n\tconst std::vector<acl::db_row*>* rows = db.get_rows();\n\tif (rows)\n\t{\n\t\tstd::vector<acl::db_row*>::const_iterator cit = rows->begin();\n\t\tfor (; cit != rows->end(); cit++)\n\t\t{\n\t\t\tconst acl::db_row* row = *cit;\n\t\t\tfor (size_t j = 0; j < row->length(); j++)\n\t\t\t\tprintf(\"%s, \", (*row)[j]);\n\t\t\tprintf(\"\\r\\n\");\n\t\t}\n\t\t\n\t}\n\t// 必须释放查询结果\n\tdb.free_result();\n}\n////////////////////////////////////////////////////////////////////////////////\n/**\n * 打开 mysql 数据库连接句柄\n * @return {acl::db_handle*} 返回值为 NULL 表示连接数据库失败\n */\nstatic acl::db_handle* open_mysql(void)\n{\n\tconst char* dbaddr = \"127.0.0.1:3306\";\n\tconst char* dbname = \"acl_test_db\";\n\tconst char* dbuser = \"acl_user\", *dbpass = \"111111\";\n\tacl::db_handle* db = new acl::db_mysql(dbaddr, dbname, dbuser, dbpass);\n\n\tif (db->open() == false)\n\t{\n\t\tprintf(\"open mysql db error\\r\\n\");\n\t\tdelete db;\n\t\treturn NULL;\n\t}\n\treturn db;\n}\n/**\n * 打开 sqlite 数据库句柄\n * @return {acl::db_handle*} 返回值为 NULL 表示连接数据库失败\n */\nstatic acl::db_handle* open_sqlite(void)\n{\n\tconst char* dbfile = \"test.db\";\n\tacl::db_handle* db = new acl::db_sqlite(dbfile);\n\n\tif (db->open() == flase)\n\t{\n\t\tprintf(\"open mysql db error\\r\\n\");\n\t\tdelete db;\n\t\treturn NULL;\n\t}\n\treturn db;\n}\n////////////////////////////////////////////////////////////////////////////////\nvoid db_demo(void)\n{\n\tacl::db_handle* db;\n\n\t// 操作 mysql 数据库过程\n\tdb = open_mysql();\n\tif (db)\n\t{\n\t\ttbl_select(*db);\n\t\tdelete db;\n\t}\n\n\t// 操作 sqlite 数据库过程\n\tdb = open_sqlite();\n\tif (db)\n\t{\n\t\ttbl_select(*db);\n\t\tdelete db;\n\t}\n}\n```\n\n从上面的例子可以看出，虽然操作的数据库不同，但数据库查询方式却是完全一样的，因为 acl 类内部屏蔽了数据库操作的差异性。下面还有几点需要注意：\n\n- 对于数据库查询结果集有多种操作方式，开发者可以根据需要进行选择；\n- 其中生成的 sql 查询语句比较简单，所以没有做特殊字符转义，真正生产环境中开发者应注意对 sql 中的一些变化查询字段进行转义（可以使用 acl::db_handle 类中的 escape_string 方法），以防止 sql 注入攻击；\n- 如果查询的数据库结果集非空，则在处理结果完毕毕竟调用 acl::db_handle 类中的 free_result() 方法释放中间动态分配的内存；\n- 在使用 acl 数据库类编写代码时不需要包含 mysql 和 sqlite 的头文件，但在程序连接阶段必须将 mysql/sqlite 的静态库加上。\n\n## 二、数据库连接池\n为了避免建立数据库连接开销对数据造成冲击，一般的数据库连接都建议使用连接池方式（尤其是在JAVA、PHP等应用中）；连接池在保持与数据库的长连接过程中，必须要处理连接中断的重连情况，使上层使用者忽略连接中断的情况。\n\n下图为 acl 的数据库连接池中各类的继承关系及连接池基础类的函数接口：\n\n从 mysql_pool.hpp/sqlite_pool.hpp 头文件中可以看出，二者的主要区别是构造函数略有不同：\ndb_pool 类为数据库连接池基类，其中主要有两个方法：\n\n```c++\n \t/**\n\t * 从数据库中连接池获得一个数据库连接，该函数返回的数据库\n\t * 连接对象用完后必须调用 db_pool->put(db_handle*) 将连接\n\t * 归还至数据库连接池，由该函数获得的连接句柄不能 delete，\n\t * 否则会造成连接池的内部计数器出错\n\t * @return {db_handle*} 返回空，则表示出错\n\t */\n\tdb_handle* peek();\n\n\t/**\n\t * 将数据库连接放回至连接池中，当从数据库连接池中获得连接\n\t * 句柄用完后应该通过该函数放回，不能直接 delete，因为那样\n\t * 会导致连接池的内部记数发生错误\n\t * @param conn {db_handle*} 数据库连接句柄，该连接句柄可以\n\t *  是由 peek 创建的，也可以单独动态创建的\n\t * @param keep {bool} 归还给连接池的数据库连接句柄是否继续\n\t *  保持连接，如果否，则内部会自动删除该连接句柄\n\t */\n\tvoid put(db_handle* conn, bool keep = true);\n```\n\nmysql 数据库连接池的构造函数如下：\n\n```c++\n\t/**\n\t * 采用 mysql 数据库时的构造函数\n\t * @param dbaddr {const char*} mysql 服务器地址，格式：IP:PORT，\n\t *  在 UNIX 平台下可以为 UNIX 域套接口\n\t * @param dbname {const char*} 数据库名\n\t * @param dbuser {const char*} 数据库用户\n\t * @param dbpass {const char*} 数据库用户密码\n\t * @param dblimit {int} 数据库连接池的最大连接数限制\n\t * @param dbflags {unsigned long} mysql 标记位\n\t * @param auto_commit {bool} 是否自动提交\n\t * @param conn_timeout {int} 连接数据库超时时间(秒)\n\t * @param rw_timeout {int} 与数据库通信时的IO时间(秒)\n\t */\n\tmysql_pool(const char* dbaddr, const char* dbname,\n\t\tconst char* dbuser, const char* dbpass,\n\t\tint dblimit = 64, unsigned long dbflags = 0,\n\t\tbool auto_commit = true, int conn_timeout = 60,\n\t\tint rw_timeout = 60);\n```\n\n下面以 mysql 为例写一个简单的使用连接池的函数：\n\n```c++\nvoid dbpool_demo(void)\n{\n\tconst char* dbaddr = \"127.0.0.1:3306\";\n\tconst char* dbname = \"acl_test_db\";\n\tconst char* dbuser = \"acl_user\", *dbpass = \"111111\";\n\tacl::db_pool* dbp = new acl::mysql_pool(dbaddr, dbname, dbuser, dbpass);  // 创建 mysql 连接池\n\tacl::db_handle* dbh = dbp->peek(); // 从连接池中获取一个数据库连接\n\tif (dbh == NULL)\n\t{\n\t\tprintf(\"peek db connection error\\r\\n\");\n\t\tdelete dbp;\n\t\treturn;\n\t}\n\ttbl_select(*dbh);  // 从数据库中查询数据（使用上面的查询例子）\n\tdbh->put(dbh);\t// 归还数据库连接给连接池\n\tdelete dbh; // 删除连接池对象\n}\n```\n\n由上面示例可以看出 acl 中的数据库连接池还是比较简单易用的，不过需要注意以下几点：\n\n- 在创建数据库连接池对象时并不立刻连接后端的数据库，数据库的连接过程一般发生在 acl::db_pool::peek() 过程，但在调用 peek 时如果连接池有可用连接则直接使用之；\n- 在使用数据库连接操作数据库时，如果因为网络意外导致连接断开，内部会根据数据库连接的返回错误号决定是否需要重试该数据库操作；\n- 在用完数据库连接后需要调用 acl::db_pool::put() 过程归还数据库连；\n- 在编译 lib_acl_cpp 库时必须需要指定 Makefile.db 为工程文件(make -f Makefile.db)，这样才能使 lib_acl_cpp.a 库内部的数据库功能生效；同时在编译自己的应用程序时必须指定 libmysqlclient_r.a 的链接位置。\n\n好了，关于如何使用 acl 库编写数据库应用先写到此，欢迎读者批评指正。\n\n其它有关数据库使用例子请参考：\n- acl\\lib_acl_cpp\\samples\\mysql\n- acl\\lib_acl_cpp\\samples\\sqlite","slug":"db","published":1,"updated":"2023-01-24T09:49:45.815Z","_id":"clda1w9vq00058o9k8otec069","comments":1,"layout":"post","photos":[],"link":"","content":"<p>acl 的 C++ 版本库（lib_acl_cpp.a）的 db 模块主要与数据库编程相关，通过这些模块库，开发者可以快速地写出支持数据库连接池的数据库应用程序，目前该 db 模块支持 mysql、sqlite 数据库。本文将以 mysql 应用为例讲述如何使用这些 API 接口编程数据库应用。</p>\n<p>在 lib_acl_cpp&#x2F;include&#x2F;acl_cpp&#x2F;db 目录下，可以看到主要分三个部分：数据库操作句柄类（db_handle，db_mysql，db_sqlite）、数据库连接池类（db_pool，mysql_pool，sqlite_pool）及数据库服务类（db_service，db_service_mysql，db_service_sqlite，这些类主要用在阻塞非阻塞结合的应用中，如：MFC界面过程与数据库过程的结合，非阻塞 IO 过程与数据库过程结合）。</p>\n<h2 id=\"一、数据库操作句柄\"><a href=\"#一、数据库操作句柄\" class=\"headerlink\" title=\"一、数据库操作句柄\"></a>一、数据库操作句柄</h2><p>下图显示了数据库句柄的类继承关系：db_handle 为基础类，db_mysql&#x2F;db_sqlite 类均继承于 db_handle 类。</p>\n<p><img src=\"/img/db.png\" alt=\"db_handle基类\"></p>\n<p>在 db_mysql.hpp&#x2F;db_sqlite.hpp 两个头文件中可以看出，这两个子类仅是实现了基础类 db_handle 的一些虚函数而已，大量关于数据的操作函数都集中于 db_handle.hpp 头文件中，下图为 db_handle 类的功能协作图（其中的 db_rows&#x2F;db_row 两个类为数据库查询结果类）：<br><img src=\"/img/db2.png\" alt=\"db继承关系\"></p>\n<p>下面给出了一个简单的数据库查询示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">////////////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 从数据库中查询表数据</span><br><span class=\"hljs-comment\"> * @param db &#123;acl::db_handle&amp;&#125; acl 中的数据库连接句柄引用</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tbl_select</span><span class=\"hljs-params\">(acl::db_handle&amp; db)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 sql 查询语句</span><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* sql = <span class=\"hljs-string\">&quot;select * from group_tbl where&quot;</span><br>\t\t<span class=\"hljs-string\">&quot; group_name=&#x27;test_name&#x27; and uvip_tbl=&#x27;test&#x27;&quot;</span>;<br>\t<span class=\"hljs-comment\">// 查询数据库</span><br>\t<span class=\"hljs-keyword\">if</span> (db.<span class=\"hljs-built_in\">sql_select</span>(sql) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;select sql: %s error\\r\\n&quot;</span>, sql);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n---------------------------------------------------\\r\\n&quot;</span>);<br>\t<span class=\"hljs-comment\">// 列出查询结果方法一：从数据库句柄中获得查询结果集合</span><br>\t<span class=\"hljs-type\">const</span> acl::db_rows* result = db.<span class=\"hljs-built_in\">get_result</span>();<br>\t<span class=\"hljs-keyword\">if</span> (result)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 遍历查询结果集</span><br>\t\t<span class=\"hljs-type\">const</span> std::vector&lt;acl::db_row*&gt;&amp; rows = result-&gt;<span class=\"hljs-built_in\">get_rows</span>();<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows.<span class=\"hljs-built_in\">size</span>(); i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">const</span> acl::db_row* row = rows[i];<br>\t\t\t<span class=\"hljs-comment\">// 打印一行结果中的所有结果</span><br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; row-&gt;<span class=\"hljs-built_in\">length</span>(); j++)<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s, &quot;</span>, (*row)[j]);<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 列出查询结果方法二：根据数组下标遍历数据库句柄的查询结果集</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; db.<span class=\"hljs-built_in\">length</span>(); i++)<br>\t&#123;<br>\t\t<span class=\"hljs-type\">const</span> acl::db_row* row = db[i];<br><br>\t\t<span class=\"hljs-comment\">// 取出该行记录中某个字段的值</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ptr = (*row)[<span class=\"hljs-string\">&quot;group_name&quot;</span>];<br>\t\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;error, no group name\\r\\n&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">continue</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;group_name=%s: &quot;</span>, ptr);<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; row-&gt;<span class=\"hljs-built_in\">length</span>(); j++)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s, &quot;</span>, (*row)[j]);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 列出查询结果方法三：直接从数据库句柄中获得结果数组</span><br>\t<span class=\"hljs-type\">const</span> std::vector&lt;acl::db_row*&gt;* rows = db.<span class=\"hljs-built_in\">get_rows</span>();<br>\t<span class=\"hljs-keyword\">if</span> (rows)<br>\t&#123;<br>\t\tstd::vector&lt;acl::db_row*&gt;::const_iterator cit = rows-&gt;<span class=\"hljs-built_in\">begin</span>();<br>\t\t<span class=\"hljs-keyword\">for</span> (; cit != rows-&gt;<span class=\"hljs-built_in\">end</span>(); cit++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">const</span> acl::db_row* row = *cit;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; row-&gt;<span class=\"hljs-built_in\">length</span>(); j++)<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s, &quot;</span>, (*row)[j]);<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>\t\t&#125;<br>\t\t<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 必须释放查询结果</span><br>\tdb.<span class=\"hljs-built_in\">free_result</span>();<br>&#125;<br><span class=\"hljs-comment\">////////////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打开 mysql 数据库连接句柄</span><br><span class=\"hljs-comment\"> * @return &#123;acl::db_handle*&#125; 返回值为 NULL 表示连接数据库失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> acl::db_handle* <span class=\"hljs-title\">open_mysql</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbaddr = <span class=\"hljs-string\">&quot;127.0.0.1:3306&quot;</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbname = <span class=\"hljs-string\">&quot;acl_test_db&quot;</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbuser = <span class=\"hljs-string\">&quot;acl_user&quot;</span>, *dbpass = <span class=\"hljs-string\">&quot;111111&quot;</span>;<br>\tacl::db_handle* db = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">db_mysql</span>(dbaddr, dbname, dbuser, dbpass);<br><br>\t<span class=\"hljs-keyword\">if</span> (db-&gt;<span class=\"hljs-built_in\">open</span>() == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open mysql db error\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">delete</span> db;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> db;<br>&#125;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打开 sqlite 数据库句柄</span><br><span class=\"hljs-comment\"> * @return &#123;acl::db_handle*&#125; 返回值为 NULL 表示连接数据库失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> acl::db_handle* <span class=\"hljs-title\">open_sqlite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbfile = <span class=\"hljs-string\">&quot;test.db&quot;</span>;<br>\tacl::db_handle* db = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">db_sqlite</span>(dbfile);<br><br>\t<span class=\"hljs-keyword\">if</span> (db-&gt;<span class=\"hljs-built_in\">open</span>() == flase)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open mysql db error\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">delete</span> db;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> db;<br>&#125;<br><span class=\"hljs-comment\">////////////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">db_demo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::db_handle* db;<br><br>\t<span class=\"hljs-comment\">// 操作 mysql 数据库过程</span><br>\tdb = <span class=\"hljs-built_in\">open_mysql</span>();<br>\t<span class=\"hljs-keyword\">if</span> (db)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">tbl_select</span>(*db);<br>\t\t<span class=\"hljs-keyword\">delete</span> db;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 操作 sqlite 数据库过程</span><br>\tdb = <span class=\"hljs-built_in\">open_sqlite</span>();<br>\t<span class=\"hljs-keyword\">if</span> (db)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">tbl_select</span>(*db);<br>\t\t<span class=\"hljs-keyword\">delete</span> db;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面的例子可以看出，虽然操作的数据库不同，但数据库查询方式却是完全一样的，因为 acl 类内部屏蔽了数据库操作的差异性。下面还有几点需要注意：</p>\n<ul>\n<li>对于数据库查询结果集有多种操作方式，开发者可以根据需要进行选择；</li>\n<li>其中生成的 sql 查询语句比较简单，所以没有做特殊字符转义，真正生产环境中开发者应注意对 sql 中的一些变化查询字段进行转义（可以使用 acl::db_handle 类中的 escape_string 方法），以防止 sql 注入攻击；</li>\n<li>如果查询的数据库结果集非空，则在处理结果完毕毕竟调用 acl::db_handle 类中的 free_result() 方法释放中间动态分配的内存；</li>\n<li>在使用 acl 数据库类编写代码时不需要包含 mysql 和 sqlite 的头文件，但在程序连接阶段必须将 mysql&#x2F;sqlite 的静态库加上。</li>\n</ul>\n<h2 id=\"二、数据库连接池\"><a href=\"#二、数据库连接池\" class=\"headerlink\" title=\"二、数据库连接池\"></a>二、数据库连接池</h2><p>为了避免建立数据库连接开销对数据造成冲击，一般的数据库连接都建议使用连接池方式（尤其是在JAVA、PHP等应用中）；连接池在保持与数据库的长连接过程中，必须要处理连接中断的重连情况，使上层使用者忽略连接中断的情况。</p>\n<p>下图为 acl 的数据库连接池中各类的继承关系及连接池基础类的函数接口：</p>\n<p>从 mysql_pool.hpp&#x2F;sqlite_pool.hpp 头文件中可以看出，二者的主要区别是构造函数略有不同：<br>db_pool 类为数据库连接池基类，其中主要有两个方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 从数据库中连接池获得一个数据库连接，该函数返回的数据库</span><br><span class=\"hljs-comment\"> * 连接对象用完后必须调用 db_pool-&gt;put(db_handle*) 将连接</span><br><span class=\"hljs-comment\"> * 归还至数据库连接池，由该函数获得的连接句柄不能 delete，</span><br><span class=\"hljs-comment\"> * 否则会造成连接池的内部计数器出错</span><br><span class=\"hljs-comment\"> * @return &#123;db_handle*&#125; 返回空，则表示出错</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">db_handle* <span class=\"hljs-title\">peek</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 将数据库连接放回至连接池中，当从数据库连接池中获得连接</span><br><span class=\"hljs-comment\"> * 句柄用完后应该通过该函数放回，不能直接 delete，因为那样</span><br><span class=\"hljs-comment\"> * 会导致连接池的内部记数发生错误</span><br><span class=\"hljs-comment\"> * @param conn &#123;db_handle*&#125; 数据库连接句柄，该连接句柄可以</span><br><span class=\"hljs-comment\"> *  是由 peek 创建的，也可以单独动态创建的</span><br><span class=\"hljs-comment\"> * @param keep &#123;bool&#125; 归还给连接池的数据库连接句柄是否继续</span><br><span class=\"hljs-comment\"> *  保持连接，如果否，则内部会自动删除该连接句柄</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(db_handle* conn, <span class=\"hljs-type\">bool</span> keep = <span class=\"hljs-literal\">true</span>)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>mysql 数据库连接池的构造函数如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 采用 mysql 数据库时的构造函数</span><br><span class=\"hljs-comment\"> * @param dbaddr &#123;const char*&#125; mysql 服务器地址，格式：IP:PORT，</span><br><span class=\"hljs-comment\"> *  在 UNIX 平台下可以为 UNIX 域套接口</span><br><span class=\"hljs-comment\"> * @param dbname &#123;const char*&#125; 数据库名</span><br><span class=\"hljs-comment\"> * @param dbuser &#123;const char*&#125; 数据库用户</span><br><span class=\"hljs-comment\"> * @param dbpass &#123;const char*&#125; 数据库用户密码</span><br><span class=\"hljs-comment\"> * @param dblimit &#123;int&#125; 数据库连接池的最大连接数限制</span><br><span class=\"hljs-comment\"> * @param dbflags &#123;unsigned long&#125; mysql 标记位</span><br><span class=\"hljs-comment\"> * @param auto_commit &#123;bool&#125; 是否自动提交</span><br><span class=\"hljs-comment\"> * @param conn_timeout &#123;int&#125; 连接数据库超时时间(秒)</span><br><span class=\"hljs-comment\"> * @param rw_timeout &#123;int&#125; 与数据库通信时的IO时间(秒)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">mysql_pool</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbaddr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbname,<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbuser, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbpass,<br>\t<span class=\"hljs-type\">int</span> dblimit = <span class=\"hljs-number\">64</span>, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> dbflags = <span class=\"hljs-number\">0</span>,<br>\t<span class=\"hljs-type\">bool</span> auto_commit = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">int</span> conn_timeout = <span class=\"hljs-number\">60</span>,<br>\t<span class=\"hljs-type\">int</span> rw_timeout = <span class=\"hljs-number\">60</span>);<br></code></pre></td></tr></table></figure>\n\n<p>下面以 mysql 为例写一个简单的使用连接池的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dbpool_demo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbaddr = <span class=\"hljs-string\">&quot;127.0.0.1:3306&quot;</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbname = <span class=\"hljs-string\">&quot;acl_test_db&quot;</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbuser = <span class=\"hljs-string\">&quot;acl_user&quot;</span>, *dbpass = <span class=\"hljs-string\">&quot;111111&quot;</span>;<br>\tacl::db_pool* dbp = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">mysql_pool</span>(dbaddr, dbname, dbuser, dbpass);  <span class=\"hljs-comment\">// 创建 mysql 连接池</span><br>\tacl::db_handle* dbh = dbp-&gt;<span class=\"hljs-built_in\">peek</span>(); <span class=\"hljs-comment\">// 从连接池中获取一个数据库连接</span><br>\t<span class=\"hljs-keyword\">if</span> (dbh == <span class=\"hljs-literal\">NULL</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;peek db connection error\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">delete</span> dbp;<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">tbl_select</span>(*dbh);  <span class=\"hljs-comment\">// 从数据库中查询数据（使用上面的查询例子）</span><br>\tdbh-&gt;<span class=\"hljs-built_in\">put</span>(dbh);\t<span class=\"hljs-comment\">// 归还数据库连接给连接池</span><br>\t<span class=\"hljs-keyword\">delete</span> dbh; <span class=\"hljs-comment\">// 删除连接池对象</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>由上面示例可以看出 acl 中的数据库连接池还是比较简单易用的，不过需要注意以下几点：</p>\n<ul>\n<li>在创建数据库连接池对象时并不立刻连接后端的数据库，数据库的连接过程一般发生在 acl::db_pool::peek() 过程，但在调用 peek 时如果连接池有可用连接则直接使用之；</li>\n<li>在使用数据库连接操作数据库时，如果因为网络意外导致连接断开，内部会根据数据库连接的返回错误号决定是否需要重试该数据库操作；</li>\n<li>在用完数据库连接后需要调用 acl::db_pool::put() 过程归还数据库连；</li>\n<li>在编译 lib_acl_cpp 库时必须需要指定 Makefile.db 为工程文件(make -f Makefile.db)，这样才能使 lib_acl_cpp.a 库内部的数据库功能生效；同时在编译自己的应用程序时必须指定 libmysqlclient_r.a 的链接位置。</li>\n</ul>\n<p>好了，关于如何使用 acl 库编写数据库应用先写到此，欢迎读者批评指正。</p>\n<p>其它有关数据库使用例子请参考：</p>\n<ul>\n<li>acl\\lib_acl_cpp\\samples\\mysql</li>\n<li>acl\\lib_acl_cpp\\samples\\sqlite</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>acl 的 C++ 版本库（lib_acl_cpp.a）的 db 模块主要与数据库编程相关，通过这些模块库，开发者可以快速地写出支持数据库连接池的数据库应用程序，目前该 db 模块支持 mysql、sqlite 数据库。本文将以 mysql 应用为例讲述如何使用这些 API 接口编程数据库应用。</p>\n<p>在 lib_acl_cpp&#x2F;include&#x2F;acl_cpp&#x2F;db 目录下，可以看到主要分三个部分：数据库操作句柄类（db_handle，db_mysql，db_sqlite）、数据库连接池类（db_pool，mysql_pool，sqlite_pool）及数据库服务类（db_service，db_service_mysql，db_service_sqlite，这些类主要用在阻塞非阻塞结合的应用中，如：MFC界面过程与数据库过程的结合，非阻塞 IO 过程与数据库过程结合）。</p>\n<h2 id=\"一、数据库操作句柄\"><a href=\"#一、数据库操作句柄\" class=\"headerlink\" title=\"一、数据库操作句柄\"></a>一、数据库操作句柄</h2><p>下图显示了数据库句柄的类继承关系：db_handle 为基础类，db_mysql&#x2F;db_sqlite 类均继承于 db_handle 类。</p>\n<p><img src=\"/img/db.png\" alt=\"db_handle基类\"></p>\n<p>在 db_mysql.hpp&#x2F;db_sqlite.hpp 两个头文件中可以看出，这两个子类仅是实现了基础类 db_handle 的一些虚函数而已，大量关于数据的操作函数都集中于 db_handle.hpp 头文件中，下图为 db_handle 类的功能协作图（其中的 db_rows&#x2F;db_row 两个类为数据库查询结果类）：<br><img src=\"/img/db2.png\" alt=\"db继承关系\"></p>\n<p>下面给出了一个简单的数据库查询示例：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">////////////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 从数据库中查询表数据</span><br><span class=\"hljs-comment\"> * @param db &#123;acl::db_handle&amp;&#125; acl 中的数据库连接句柄引用</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">tbl_select</span><span class=\"hljs-params\">(acl::db_handle&amp; db)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">// 创建 sql 查询语句</span><br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* sql = <span class=\"hljs-string\">&quot;select * from group_tbl where&quot;</span><br>\t\t<span class=\"hljs-string\">&quot; group_name=&#x27;test_name&#x27; and uvip_tbl=&#x27;test&#x27;&quot;</span>;<br>\t<span class=\"hljs-comment\">// 查询数据库</span><br>\t<span class=\"hljs-keyword\">if</span> (db.<span class=\"hljs-built_in\">sql_select</span>(sql) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;select sql: %s error\\r\\n&quot;</span>, sql);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n---------------------------------------------------\\r\\n&quot;</span>);<br>\t<span class=\"hljs-comment\">// 列出查询结果方法一：从数据库句柄中获得查询结果集合</span><br>\t<span class=\"hljs-type\">const</span> acl::db_rows* result = db.<span class=\"hljs-built_in\">get_result</span>();<br>\t<span class=\"hljs-keyword\">if</span> (result)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 遍历查询结果集</span><br>\t\t<span class=\"hljs-type\">const</span> std::vector&lt;acl::db_row*&gt;&amp; rows = result-&gt;<span class=\"hljs-built_in\">get_rows</span>();<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; rows.<span class=\"hljs-built_in\">size</span>(); i++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">const</span> acl::db_row* row = rows[i];<br>\t\t\t<span class=\"hljs-comment\">// 打印一行结果中的所有结果</span><br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; row-&gt;<span class=\"hljs-built_in\">length</span>(); j++)<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s, &quot;</span>, (*row)[j]);<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>\t\t&#125;<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 列出查询结果方法二：根据数组下标遍历数据库句柄的查询结果集</span><br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>; i &lt; db.<span class=\"hljs-built_in\">length</span>(); i++)<br>\t&#123;<br>\t\t<span class=\"hljs-type\">const</span> acl::db_row* row = db[i];<br><br>\t\t<span class=\"hljs-comment\">// 取出该行记录中某个字段的值</span><br>\t\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* ptr = (*row)[<span class=\"hljs-string\">&quot;group_name&quot;</span>];<br>\t\t<span class=\"hljs-keyword\">if</span> (ptr == <span class=\"hljs-literal\">NULL</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;error, no group name\\r\\n&quot;</span>);<br>\t\t\t<span class=\"hljs-keyword\">continue</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;group_name=%s: &quot;</span>, ptr);<br>\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; row-&gt;<span class=\"hljs-built_in\">length</span>(); j++)<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s, &quot;</span>, (*row)[j]);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 列出查询结果方法三：直接从数据库句柄中获得结果数组</span><br>\t<span class=\"hljs-type\">const</span> std::vector&lt;acl::db_row*&gt;* rows = db.<span class=\"hljs-built_in\">get_rows</span>();<br>\t<span class=\"hljs-keyword\">if</span> (rows)<br>\t&#123;<br>\t\tstd::vector&lt;acl::db_row*&gt;::const_iterator cit = rows-&gt;<span class=\"hljs-built_in\">begin</span>();<br>\t\t<span class=\"hljs-keyword\">for</span> (; cit != rows-&gt;<span class=\"hljs-built_in\">end</span>(); cit++)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-type\">const</span> acl::db_row* row = *cit;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-type\">size_t</span> j = <span class=\"hljs-number\">0</span>; j &lt; row-&gt;<span class=\"hljs-built_in\">length</span>(); j++)<br>\t\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s, &quot;</span>, (*row)[j]);<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>\t\t&#125;<br>\t\t<br>\t&#125;<br>\t<span class=\"hljs-comment\">// 必须释放查询结果</span><br>\tdb.<span class=\"hljs-built_in\">free_result</span>();<br>&#125;<br><span class=\"hljs-comment\">////////////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打开 mysql 数据库连接句柄</span><br><span class=\"hljs-comment\"> * @return &#123;acl::db_handle*&#125; 返回值为 NULL 表示连接数据库失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> acl::db_handle* <span class=\"hljs-title\">open_mysql</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbaddr = <span class=\"hljs-string\">&quot;127.0.0.1:3306&quot;</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbname = <span class=\"hljs-string\">&quot;acl_test_db&quot;</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbuser = <span class=\"hljs-string\">&quot;acl_user&quot;</span>, *dbpass = <span class=\"hljs-string\">&quot;111111&quot;</span>;<br>\tacl::db_handle* db = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">db_mysql</span>(dbaddr, dbname, dbuser, dbpass);<br><br>\t<span class=\"hljs-keyword\">if</span> (db-&gt;<span class=\"hljs-built_in\">open</span>() == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open mysql db error\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">delete</span> db;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> db;<br>&#125;<br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 打开 sqlite 数据库句柄</span><br><span class=\"hljs-comment\"> * @return &#123;acl::db_handle*&#125; 返回值为 NULL 表示连接数据库失败</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> acl::db_handle* <span class=\"hljs-title\">open_sqlite</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbfile = <span class=\"hljs-string\">&quot;test.db&quot;</span>;<br>\tacl::db_handle* db = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">db_sqlite</span>(dbfile);<br><br>\t<span class=\"hljs-keyword\">if</span> (db-&gt;<span class=\"hljs-built_in\">open</span>() == flase)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open mysql db error\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">delete</span> db;<br>\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">NULL</span>;<br>\t&#125;<br>\t<span class=\"hljs-keyword\">return</span> db;<br>&#125;<br><span class=\"hljs-comment\">////////////////////////////////////////////////////////////////////////////////</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">db_demo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tacl::db_handle* db;<br><br>\t<span class=\"hljs-comment\">// 操作 mysql 数据库过程</span><br>\tdb = <span class=\"hljs-built_in\">open_mysql</span>();<br>\t<span class=\"hljs-keyword\">if</span> (db)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">tbl_select</span>(*db);<br>\t\t<span class=\"hljs-keyword\">delete</span> db;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 操作 sqlite 数据库过程</span><br>\tdb = <span class=\"hljs-built_in\">open_sqlite</span>();<br>\t<span class=\"hljs-keyword\">if</span> (db)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">tbl_select</span>(*db);<br>\t\t<span class=\"hljs-keyword\">delete</span> db;<br>\t&#125;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>从上面的例子可以看出，虽然操作的数据库不同，但数据库查询方式却是完全一样的，因为 acl 类内部屏蔽了数据库操作的差异性。下面还有几点需要注意：</p>\n<ul>\n<li>对于数据库查询结果集有多种操作方式，开发者可以根据需要进行选择；</li>\n<li>其中生成的 sql 查询语句比较简单，所以没有做特殊字符转义，真正生产环境中开发者应注意对 sql 中的一些变化查询字段进行转义（可以使用 acl::db_handle 类中的 escape_string 方法），以防止 sql 注入攻击；</li>\n<li>如果查询的数据库结果集非空，则在处理结果完毕毕竟调用 acl::db_handle 类中的 free_result() 方法释放中间动态分配的内存；</li>\n<li>在使用 acl 数据库类编写代码时不需要包含 mysql 和 sqlite 的头文件，但在程序连接阶段必须将 mysql&#x2F;sqlite 的静态库加上。</li>\n</ul>\n<h2 id=\"二、数据库连接池\"><a href=\"#二、数据库连接池\" class=\"headerlink\" title=\"二、数据库连接池\"></a>二、数据库连接池</h2><p>为了避免建立数据库连接开销对数据造成冲击，一般的数据库连接都建议使用连接池方式（尤其是在JAVA、PHP等应用中）；连接池在保持与数据库的长连接过程中，必须要处理连接中断的重连情况，使上层使用者忽略连接中断的情况。</p>\n<p>下图为 acl 的数据库连接池中各类的继承关系及连接池基础类的函数接口：</p>\n<p>从 mysql_pool.hpp&#x2F;sqlite_pool.hpp 头文件中可以看出，二者的主要区别是构造函数略有不同：<br>db_pool 类为数据库连接池基类，其中主要有两个方法：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\">\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 从数据库中连接池获得一个数据库连接，该函数返回的数据库</span><br><span class=\"hljs-comment\"> * 连接对象用完后必须调用 db_pool-&gt;put(db_handle*) 将连接</span><br><span class=\"hljs-comment\"> * 归还至数据库连接池，由该函数获得的连接句柄不能 delete，</span><br><span class=\"hljs-comment\"> * 否则会造成连接池的内部计数器出错</span><br><span class=\"hljs-comment\"> * @return &#123;db_handle*&#125; 返回空，则表示出错</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\">db_handle* <span class=\"hljs-title\">peek</span><span class=\"hljs-params\">()</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 将数据库连接放回至连接池中，当从数据库连接池中获得连接</span><br><span class=\"hljs-comment\"> * 句柄用完后应该通过该函数放回，不能直接 delete，因为那样</span><br><span class=\"hljs-comment\"> * 会导致连接池的内部记数发生错误</span><br><span class=\"hljs-comment\"> * @param conn &#123;db_handle*&#125; 数据库连接句柄，该连接句柄可以</span><br><span class=\"hljs-comment\"> *  是由 peek 创建的，也可以单独动态创建的</span><br><span class=\"hljs-comment\"> * @param keep &#123;bool&#125; 归还给连接池的数据库连接句柄是否继续</span><br><span class=\"hljs-comment\"> *  保持连接，如果否，则内部会自动删除该连接句柄</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">put</span><span class=\"hljs-params\">(db_handle* conn, <span class=\"hljs-type\">bool</span> keep = <span class=\"hljs-literal\">true</span>)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>mysql 数据库连接池的构造函数如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 采用 mysql 数据库时的构造函数</span><br><span class=\"hljs-comment\"> * @param dbaddr &#123;const char*&#125; mysql 服务器地址，格式：IP:PORT，</span><br><span class=\"hljs-comment\"> *  在 UNIX 平台下可以为 UNIX 域套接口</span><br><span class=\"hljs-comment\"> * @param dbname &#123;const char*&#125; 数据库名</span><br><span class=\"hljs-comment\"> * @param dbuser &#123;const char*&#125; 数据库用户</span><br><span class=\"hljs-comment\"> * @param dbpass &#123;const char*&#125; 数据库用户密码</span><br><span class=\"hljs-comment\"> * @param dblimit &#123;int&#125; 数据库连接池的最大连接数限制</span><br><span class=\"hljs-comment\"> * @param dbflags &#123;unsigned long&#125; mysql 标记位</span><br><span class=\"hljs-comment\"> * @param auto_commit &#123;bool&#125; 是否自动提交</span><br><span class=\"hljs-comment\"> * @param conn_timeout &#123;int&#125; 连接数据库超时时间(秒)</span><br><span class=\"hljs-comment\"> * @param rw_timeout &#123;int&#125; 与数据库通信时的IO时间(秒)</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">mysql_pool</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbaddr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbname,<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbuser, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbpass,<br>\t<span class=\"hljs-type\">int</span> dblimit = <span class=\"hljs-number\">64</span>, <span class=\"hljs-type\">unsigned</span> <span class=\"hljs-type\">long</span> dbflags = <span class=\"hljs-number\">0</span>,<br>\t<span class=\"hljs-type\">bool</span> auto_commit = <span class=\"hljs-literal\">true</span>, <span class=\"hljs-type\">int</span> conn_timeout = <span class=\"hljs-number\">60</span>,<br>\t<span class=\"hljs-type\">int</span> rw_timeout = <span class=\"hljs-number\">60</span>);<br></code></pre></td></tr></table></figure>\n\n<p>下面以 mysql 为例写一个简单的使用连接池的函数：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">dbpool_demo</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbaddr = <span class=\"hljs-string\">&quot;127.0.0.1:3306&quot;</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbname = <span class=\"hljs-string\">&quot;acl_test_db&quot;</span>;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* dbuser = <span class=\"hljs-string\">&quot;acl_user&quot;</span>, *dbpass = <span class=\"hljs-string\">&quot;111111&quot;</span>;<br>\tacl::db_pool* dbp = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">mysql_pool</span>(dbaddr, dbname, dbuser, dbpass);  <span class=\"hljs-comment\">// 创建 mysql 连接池</span><br>\tacl::db_handle* dbh = dbp-&gt;<span class=\"hljs-built_in\">peek</span>(); <span class=\"hljs-comment\">// 从连接池中获取一个数据库连接</span><br>\t<span class=\"hljs-keyword\">if</span> (dbh == <span class=\"hljs-literal\">NULL</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;peek db connection error\\r\\n&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">delete</span> dbp;<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">tbl_select</span>(*dbh);  <span class=\"hljs-comment\">// 从数据库中查询数据（使用上面的查询例子）</span><br>\tdbh-&gt;<span class=\"hljs-built_in\">put</span>(dbh);\t<span class=\"hljs-comment\">// 归还数据库连接给连接池</span><br>\t<span class=\"hljs-keyword\">delete</span> dbh; <span class=\"hljs-comment\">// 删除连接池对象</span><br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>由上面示例可以看出 acl 中的数据库连接池还是比较简单易用的，不过需要注意以下几点：</p>\n<ul>\n<li>在创建数据库连接池对象时并不立刻连接后端的数据库，数据库的连接过程一般发生在 acl::db_pool::peek() 过程，但在调用 peek 时如果连接池有可用连接则直接使用之；</li>\n<li>在使用数据库连接操作数据库时，如果因为网络意外导致连接断开，内部会根据数据库连接的返回错误号决定是否需要重试该数据库操作；</li>\n<li>在用完数据库连接后需要调用 acl::db_pool::put() 过程归还数据库连；</li>\n<li>在编译 lib_acl_cpp 库时必须需要指定 Makefile.db 为工程文件(make -f Makefile.db)，这样才能使 lib_acl_cpp.a 库内部的数据库功能生效；同时在编译自己的应用程序时必须指定 libmysqlclient_r.a 的链接位置。</li>\n</ul>\n<p>好了，关于如何使用 acl 库编写数据库应用先写到此，欢迎读者批评指正。</p>\n<p>其它有关数据库使用例子请参考：</p>\n<ul>\n<li>acl\\lib_acl_cpp\\samples\\mysql</li>\n<li>acl\\lib_acl_cpp\\samples\\sqlite</li>\n</ul>\n"},{"title":"使用 acl 库针对 C++ 对象进行序列化及反序列编程","date":"2016-10-16T12:27:00.000Z","_content":"\n在开发网络应用程序时，各个模块之间的数据通信可谓是家常便饭，为了应对这些数据通信时数据交换的要求，程序员发明了各种数据格式：采用二进制数据结构（早期 C 程序员）、采用 XML、采用SOAP（坑人的设计）、采用 URL 编码、采用JSON格式等。客户端与服务端交互时采用这些数据格式进行数据交换时，必然要经历数据编码及数据解码的繁琐过程。早期的二进制数据结构格式对于 C 程序员而是比较简单的，在解码时直接进行结构硬对齐就OK了，但对于其它语言（如 JAVA，PHP）则就麻烦很多，JAVA 语言不仅需要采用字节流一个一个对齐，而且还得要考虑到 C 结构体的数据打包填充方式；SOAP 方式看似满足了各类编程语言数据交换的目的，但数据臃肿是一个很大的问题，我们为了传输几个字节的数据则需要不得不封装大量的 XML 标记。为了使跨语言开发的程序员从麻烦的数据编解码中解脱出来，后来出来很多序列化/反序列化的工具库，比较著名的象 Facebook 的 thrift，Google 的 protobuf。这些工具库功能非常强大，但有一个问题是，这些工具库所要求的预先定义的 schema 的亲民性不够好，增加了额外的大量学习成本。\n\n最近由 niukey@qq.com 为 acl 库新增了 C++ 对象序列化与反序列化库，大大提高了程序员的编程效率及代码准确率。acl 序列化库实现了 C++ struct 对象与 JSON 对象之间互转功能，使用方式非常简单。\n\n## 一、acl 序列化库的功能特点：\n\n - 可以直接将 C++ struct 对象转换为 Json 对象，同时还可以将 Json 对象反序列化为 C++ struct 对象；\n- 支持 C++ struct 对象中包含构造函数及析构函数；\n- C++ struct 对象中的成员支持常见基本类型（short, int, long, long long, char*）、标准 C++ 类对象；\n- C++ struct 对象中的成员支持指针类型；\n- C++ struct 对象中的成员支持常见 C++ 容器类型：std::vector、std::list、std::map，且支持容器对象的内部嵌套；\n- C++ struct 对象中的成员为基本数据类型（如：short, int, long, long long）和指针类型时，支持直接在 struct 中针对这些成员进行初始化（C++11）；\n- 支持在 C++ struct 中添加注释（// 或 /**/）；\n- 支持 C++ struct 对象的多继承；\n- 支持在 C++ struct 对象中的多级包含，建议使用包含方式代替继承方式；\n- 支持 C++ struct 成员增加注释项：//Gson@optional 表示该成员变量为可选项，//Gson@required 表示该成员为必须项，默认为必须的。\n\n## 二、使用 acl 序列化库的限制：\n\n- struct 中的成员类型不能为 char 类型，主要是因为 Json 对象中不存在 char 类型；\n- struct 中的成员前不得有 const 常量限定词，主要是在反序列化时需要对这些成员进行赋值；\n- struct 中不支持 C++ 关键词：public、private、protected；\n- struct 中的成员变量名不得为：$json、$node、$obj，因为这些关键词被 acl 序列化库生成的代码占用；\n-存在包含关系的 struct 类型定义必须在同一个文件中；\n- 不支持纯 C 语言的数组功能，比如，针对 int a[10]，因无法确切知道数组 a 中真实存储的数量而无法进行序列化和反序列化，因此推荐使用 std::vector<int> 代替它。\n\n## 三、使用 acl 序列化库的过程：\n\n- 首先编译 acl 库：在 acl 目录前运行：make build_one，会生成 acl 的三个基础库（lib_acl/lib/lib_acl.a, lib_protocol/lib/lib_protocol.a, lib_acl_cpp/liblib_acl_cpp.a），同时还会在 acl 根目录下生成这三个库的合集（lib_acl.a 和 lib_acl.so）；\n- 编译 acl 序列化工具：进入 app/gson 目录，运行 make，生成 gson 工具，该工具将被用于根据用户自定义 struct 生成序列化 C++ 代码；\n- 定义自己的 struct 结构体（可以定义多个）并保存在文件中（文件后缀名为 .stub）；\n- 使用 gson 工具根据用户的 .stub 文件生成序列化所需的 C++ 代码：./gson -d path，其中 path 为保含 .stub 文件的目录，将会生成三个文件 gson.cpp、 gson.h 和 由 .stub 转换的 .h 头文件；\n- 将 gson.h 和由 .stub 文件转换的 .h 头文件包含在自己的代码中；\n- 针对用户自定义的每一个 struct，在 gson.h 头文件中均会提供 struct 对象的序列化和反序列化的方法，假设用户自定义了一个结构体类型：struct user，则在由工具 gson 生成的 gson.h 文件中包含如下五个方法：\n  ```\n  acl::string gson(const user &$obj);  \n\n    将用户填充好的 user 对象 $obj 转换为 Json 字符串；\n  acl::json_node& gson(acl::json &$json, const user &$obj);\n\n    将用户填充好的 user 对象 $obj 转化为 acl::json 对象 $json 中的一个 acl::json_node 节点对象并将之返回，这样用户可以将这个返回的 acl::json_node& 对象引用添加于 $json 对象中；\n\n  acl::json_node& gson(acl::json &$json, const user *$obj);\n\n     功能与 2）中的方法相同，只是 $obj 参数为对象指针；\n\n  std::pair<bool,std::string> gson(acl::json_node &$node, user &$obj);\n\n     将一个 acl::json_node Json 节点对象转化为用户自定义的 struct user 对象，如果 $node 为该 Json 对象中的根节点，则该根节点可由 $json.get_root() 获得，$obj 存储转换后的结果；\n\n  std::pair<bool,std::string> gson(acl::json_node &$node, user *$obj);\n\n     功能与 5）中的方法相同，只是 $obj 参数为对象指针。\n     ```\n\n## 四、举例：\n\n假设自定义结构对象如下：\n\n```c++\n// struct.stub\n#pragma once\n#include <string>\n\nstruct user\n{\n        std::string name;\n        std::string domain;\n        int age;\n        bool male;\n};\n\n      应用操作 user 对象的过程如下：\n\n// main.cpp\n#include \"stdafx.h\"\n#include <list>\n#include <vector>\n#include <map>\n#include <stdio.h>\n#include <iostream>\n#include <time.h>\n#include \"struct.h\"  // 由 gson 工具根据 struct.stub 转换而成\n#include \"gson.h\"   // 由 gson 工具根据 struct.stub 生成\n\n// 序列化过程\nstatic void serialize(void)\n{\n\tuser u;\n\n\tu.name = \"zsxxsz\";\n\tu.domain = \"263.net\";\n\tu.age = 11;\n\tu.male = true;\n\n\tacl::json json;\n\n\t// 将 user 对象转换为 json 对象\n\tacl::json_node& node = acl::gson(json, u);\n\n\tprintf(\"serialize:\\r\\n\");\n\tprintf(\"json: %s\\r\\n\", node.to_string().c_str());\n\tprintf(\"\\r\\n\");\n}\n\n// 反序列化过程\nstatic void deserialize(void)\n{\n\tconst char *s = \"{\\\"name\\\": \\\"zsxxsz\\\", \\\"domain\\\": \\\"263.net\\\", \\\"age\\\": 11, \\\"male\\\": true}\";\n\tprintf(\"deserialize:\\r\\n\");\n\n\tacl::json json;\n\tjson.update(s);\n\tuser u;\n\n\t// 将 json 对象转换为 user 对象\n\tstd::pair<bool, std::string> ret = acl::gson(json.get_root(), u);\n\n\t// 如果转换失败，则打印转换失败原因\n\tif (ret.first == false)\n\t\tprintf(\"error: %s\\r\\n\", ret.second.c_str());\n\telse\n\t\tprintf(\"name: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tu.name.c_str(), u.domain.c_str(), u.age,\n\t\t\tu.male ? \"yes\" : \"no\");\n}\n\nint main(void)\n{\n\tserialize();\n\tdeserialize();\n\treturn 0;\n}\n```\n\n## 五、参考：\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl\n \n\n ","source":"_posts/serialize.md","raw":"---\ntitle: 使用 acl 库针对 C++ 对象进行序列化及反序列编程\ndate: 2016-10-16 20:27\ncategories: 对象序列化\n---\n\n在开发网络应用程序时，各个模块之间的数据通信可谓是家常便饭，为了应对这些数据通信时数据交换的要求，程序员发明了各种数据格式：采用二进制数据结构（早期 C 程序员）、采用 XML、采用SOAP（坑人的设计）、采用 URL 编码、采用JSON格式等。客户端与服务端交互时采用这些数据格式进行数据交换时，必然要经历数据编码及数据解码的繁琐过程。早期的二进制数据结构格式对于 C 程序员而是比较简单的，在解码时直接进行结构硬对齐就OK了，但对于其它语言（如 JAVA，PHP）则就麻烦很多，JAVA 语言不仅需要采用字节流一个一个对齐，而且还得要考虑到 C 结构体的数据打包填充方式；SOAP 方式看似满足了各类编程语言数据交换的目的，但数据臃肿是一个很大的问题，我们为了传输几个字节的数据则需要不得不封装大量的 XML 标记。为了使跨语言开发的程序员从麻烦的数据编解码中解脱出来，后来出来很多序列化/反序列化的工具库，比较著名的象 Facebook 的 thrift，Google 的 protobuf。这些工具库功能非常强大，但有一个问题是，这些工具库所要求的预先定义的 schema 的亲民性不够好，增加了额外的大量学习成本。\n\n最近由 niukey@qq.com 为 acl 库新增了 C++ 对象序列化与反序列化库，大大提高了程序员的编程效率及代码准确率。acl 序列化库实现了 C++ struct 对象与 JSON 对象之间互转功能，使用方式非常简单。\n\n## 一、acl 序列化库的功能特点：\n\n - 可以直接将 C++ struct 对象转换为 Json 对象，同时还可以将 Json 对象反序列化为 C++ struct 对象；\n- 支持 C++ struct 对象中包含构造函数及析构函数；\n- C++ struct 对象中的成员支持常见基本类型（short, int, long, long long, char*）、标准 C++ 类对象；\n- C++ struct 对象中的成员支持指针类型；\n- C++ struct 对象中的成员支持常见 C++ 容器类型：std::vector、std::list、std::map，且支持容器对象的内部嵌套；\n- C++ struct 对象中的成员为基本数据类型（如：short, int, long, long long）和指针类型时，支持直接在 struct 中针对这些成员进行初始化（C++11）；\n- 支持在 C++ struct 中添加注释（// 或 /**/）；\n- 支持 C++ struct 对象的多继承；\n- 支持在 C++ struct 对象中的多级包含，建议使用包含方式代替继承方式；\n- 支持 C++ struct 成员增加注释项：//Gson@optional 表示该成员变量为可选项，//Gson@required 表示该成员为必须项，默认为必须的。\n\n## 二、使用 acl 序列化库的限制：\n\n- struct 中的成员类型不能为 char 类型，主要是因为 Json 对象中不存在 char 类型；\n- struct 中的成员前不得有 const 常量限定词，主要是在反序列化时需要对这些成员进行赋值；\n- struct 中不支持 C++ 关键词：public、private、protected；\n- struct 中的成员变量名不得为：$json、$node、$obj，因为这些关键词被 acl 序列化库生成的代码占用；\n-存在包含关系的 struct 类型定义必须在同一个文件中；\n- 不支持纯 C 语言的数组功能，比如，针对 int a[10]，因无法确切知道数组 a 中真实存储的数量而无法进行序列化和反序列化，因此推荐使用 std::vector<int> 代替它。\n\n## 三、使用 acl 序列化库的过程：\n\n- 首先编译 acl 库：在 acl 目录前运行：make build_one，会生成 acl 的三个基础库（lib_acl/lib/lib_acl.a, lib_protocol/lib/lib_protocol.a, lib_acl_cpp/liblib_acl_cpp.a），同时还会在 acl 根目录下生成这三个库的合集（lib_acl.a 和 lib_acl.so）；\n- 编译 acl 序列化工具：进入 app/gson 目录，运行 make，生成 gson 工具，该工具将被用于根据用户自定义 struct 生成序列化 C++ 代码；\n- 定义自己的 struct 结构体（可以定义多个）并保存在文件中（文件后缀名为 .stub）；\n- 使用 gson 工具根据用户的 .stub 文件生成序列化所需的 C++ 代码：./gson -d path，其中 path 为保含 .stub 文件的目录，将会生成三个文件 gson.cpp、 gson.h 和 由 .stub 转换的 .h 头文件；\n- 将 gson.h 和由 .stub 文件转换的 .h 头文件包含在自己的代码中；\n- 针对用户自定义的每一个 struct，在 gson.h 头文件中均会提供 struct 对象的序列化和反序列化的方法，假设用户自定义了一个结构体类型：struct user，则在由工具 gson 生成的 gson.h 文件中包含如下五个方法：\n  ```\n  acl::string gson(const user &$obj);  \n\n    将用户填充好的 user 对象 $obj 转换为 Json 字符串；\n  acl::json_node& gson(acl::json &$json, const user &$obj);\n\n    将用户填充好的 user 对象 $obj 转化为 acl::json 对象 $json 中的一个 acl::json_node 节点对象并将之返回，这样用户可以将这个返回的 acl::json_node& 对象引用添加于 $json 对象中；\n\n  acl::json_node& gson(acl::json &$json, const user *$obj);\n\n     功能与 2）中的方法相同，只是 $obj 参数为对象指针；\n\n  std::pair<bool,std::string> gson(acl::json_node &$node, user &$obj);\n\n     将一个 acl::json_node Json 节点对象转化为用户自定义的 struct user 对象，如果 $node 为该 Json 对象中的根节点，则该根节点可由 $json.get_root() 获得，$obj 存储转换后的结果；\n\n  std::pair<bool,std::string> gson(acl::json_node &$node, user *$obj);\n\n     功能与 5）中的方法相同，只是 $obj 参数为对象指针。\n     ```\n\n## 四、举例：\n\n假设自定义结构对象如下：\n\n```c++\n// struct.stub\n#pragma once\n#include <string>\n\nstruct user\n{\n        std::string name;\n        std::string domain;\n        int age;\n        bool male;\n};\n\n      应用操作 user 对象的过程如下：\n\n// main.cpp\n#include \"stdafx.h\"\n#include <list>\n#include <vector>\n#include <map>\n#include <stdio.h>\n#include <iostream>\n#include <time.h>\n#include \"struct.h\"  // 由 gson 工具根据 struct.stub 转换而成\n#include \"gson.h\"   // 由 gson 工具根据 struct.stub 生成\n\n// 序列化过程\nstatic void serialize(void)\n{\n\tuser u;\n\n\tu.name = \"zsxxsz\";\n\tu.domain = \"263.net\";\n\tu.age = 11;\n\tu.male = true;\n\n\tacl::json json;\n\n\t// 将 user 对象转换为 json 对象\n\tacl::json_node& node = acl::gson(json, u);\n\n\tprintf(\"serialize:\\r\\n\");\n\tprintf(\"json: %s\\r\\n\", node.to_string().c_str());\n\tprintf(\"\\r\\n\");\n}\n\n// 反序列化过程\nstatic void deserialize(void)\n{\n\tconst char *s = \"{\\\"name\\\": \\\"zsxxsz\\\", \\\"domain\\\": \\\"263.net\\\", \\\"age\\\": 11, \\\"male\\\": true}\";\n\tprintf(\"deserialize:\\r\\n\");\n\n\tacl::json json;\n\tjson.update(s);\n\tuser u;\n\n\t// 将 json 对象转换为 user 对象\n\tstd::pair<bool, std::string> ret = acl::gson(json.get_root(), u);\n\n\t// 如果转换失败，则打印转换失败原因\n\tif (ret.first == false)\n\t\tprintf(\"error: %s\\r\\n\", ret.second.c_str());\n\telse\n\t\tprintf(\"name: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tu.name.c_str(), u.domain.c_str(), u.age,\n\t\t\tu.male ? \"yes\" : \"no\");\n}\n\nint main(void)\n{\n\tserialize();\n\tdeserialize();\n\treturn 0;\n}\n```\n\n## 五、参考：\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl\n \n\n ","slug":"serialize","published":1,"updated":"2023-01-24T10:08:10.069Z","_id":"clda2hjdo00088o9k49nrhvkh","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在开发网络应用程序时，各个模块之间的数据通信可谓是家常便饭，为了应对这些数据通信时数据交换的要求，程序员发明了各种数据格式：采用二进制数据结构（早期 C 程序员）、采用 XML、采用SOAP（坑人的设计）、采用 URL 编码、采用JSON格式等。客户端与服务端交互时采用这些数据格式进行数据交换时，必然要经历数据编码及数据解码的繁琐过程。早期的二进制数据结构格式对于 C 程序员而是比较简单的，在解码时直接进行结构硬对齐就OK了，但对于其它语言（如 JAVA，PHP）则就麻烦很多，JAVA 语言不仅需要采用字节流一个一个对齐，而且还得要考虑到 C 结构体的数据打包填充方式；SOAP 方式看似满足了各类编程语言数据交换的目的，但数据臃肿是一个很大的问题，我们为了传输几个字节的数据则需要不得不封装大量的 XML 标记。为了使跨语言开发的程序员从麻烦的数据编解码中解脱出来，后来出来很多序列化&#x2F;反序列化的工具库，比较著名的象 Facebook 的 thrift，Google 的 protobuf。这些工具库功能非常强大，但有一个问题是，这些工具库所要求的预先定义的 schema 的亲民性不够好，增加了额外的大量学习成本。</p>\n<p>最近由 <a href=\"mailto:&#x6e;&#x69;&#117;&#x6b;&#x65;&#x79;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;\">&#x6e;&#x69;&#117;&#x6b;&#x65;&#x79;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;</a> 为 acl 库新增了 C++ 对象序列化与反序列化库，大大提高了程序员的编程效率及代码准确率。acl 序列化库实现了 C++ struct 对象与 JSON 对象之间互转功能，使用方式非常简单。</p>\n<h2 id=\"一、acl-序列化库的功能特点：\"><a href=\"#一、acl-序列化库的功能特点：\" class=\"headerlink\" title=\"一、acl 序列化库的功能特点：\"></a>一、acl 序列化库的功能特点：</h2><ul>\n<li>可以直接将 C++ struct 对象转换为 Json 对象，同时还可以将 Json 对象反序列化为 C++ struct 对象；</li>\n<li>支持 C++ struct 对象中包含构造函数及析构函数；</li>\n<li>C++ struct 对象中的成员支持常见基本类型（short, int, long, long long, char*）、标准 C++ 类对象；</li>\n<li>C++ struct 对象中的成员支持指针类型；</li>\n<li>C++ struct 对象中的成员支持常见 C++ 容器类型：std::vector、std::list、std::map，且支持容器对象的内部嵌套；</li>\n<li>C++ struct 对象中的成员为基本数据类型（如：short, int, long, long long）和指针类型时，支持直接在 struct 中针对这些成员进行初始化（C++11）；</li>\n<li>支持在 C++ struct 中添加注释（&#x2F;&#x2F; 或 &#x2F;**&#x2F;）；</li>\n<li>支持 C++ struct 对象的多继承；</li>\n<li>支持在 C++ struct 对象中的多级包含，建议使用包含方式代替继承方式；</li>\n<li>支持 C++ struct 成员增加注释项：&#x2F;&#x2F;Gson@optional 表示该成员变量为可选项，&#x2F;&#x2F;Gson@required 表示该成员为必须项，默认为必须的。</li>\n</ul>\n<h2 id=\"二、使用-acl-序列化库的限制：\"><a href=\"#二、使用-acl-序列化库的限制：\" class=\"headerlink\" title=\"二、使用 acl 序列化库的限制：\"></a>二、使用 acl 序列化库的限制：</h2><ul>\n<li>struct 中的成员类型不能为 char 类型，主要是因为 Json 对象中不存在 char 类型；</li>\n<li>struct 中的成员前不得有 const 常量限定词，主要是在反序列化时需要对这些成员进行赋值；</li>\n<li>struct 中不支持 C++ 关键词：public、private、protected；</li>\n<li>struct 中的成员变量名不得为：$json、$node、$obj，因为这些关键词被 acl 序列化库生成的代码占用；<br>-存在包含关系的 struct 类型定义必须在同一个文件中；</li>\n<li>不支持纯 C 语言的数组功能，比如，针对 int a[10]，因无法确切知道数组 a 中真实存储的数量而无法进行序列化和反序列化，因此推荐使用 std::vector<int> 代替它。</li>\n</ul>\n<h2 id=\"三、使用-acl-序列化库的过程：\"><a href=\"#三、使用-acl-序列化库的过程：\" class=\"headerlink\" title=\"三、使用 acl 序列化库的过程：\"></a>三、使用 acl 序列化库的过程：</h2><ul>\n<li>首先编译 acl 库：在 acl 目录前运行：make build_one，会生成 acl 的三个基础库（lib_acl&#x2F;lib&#x2F;lib_acl.a, lib_protocol&#x2F;lib&#x2F;lib_protocol.a, lib_acl_cpp&#x2F;liblib_acl_cpp.a），同时还会在 acl 根目录下生成这三个库的合集（lib_acl.a 和 lib_acl.so）；</li>\n<li>编译 acl 序列化工具：进入 app&#x2F;gson 目录，运行 make，生成 gson 工具，该工具将被用于根据用户自定义 struct 生成序列化 C++ 代码；</li>\n<li>定义自己的 struct 结构体（可以定义多个）并保存在文件中（文件后缀名为 .stub）；</li>\n<li>使用 gson 工具根据用户的 .stub 文件生成序列化所需的 C++ 代码：.&#x2F;gson -d path，其中 path 为保含 .stub 文件的目录，将会生成三个文件 gson.cpp、 gson.h 和 由 .stub 转换的 .h 头文件；</li>\n<li>将 gson.h 和由 .stub 文件转换的 .h 头文件包含在自己的代码中；</li>\n<li>针对用户自定义的每一个 struct，在 gson.h 头文件中均会提供 struct 对象的序列化和反序列化的方法，假设用户自定义了一个结构体类型：struct user，则在由工具 gson 生成的 gson.h 文件中包含如下五个方法：<figure class=\"highlight nsis\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nsis\"><span class=\"hljs-title function_\">acl::string</span> gson(const <span class=\"hljs-literal\">user</span> &amp;<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;  </span><br><br>  将用户填充好的 <span class=\"hljs-literal\">user</span> 对象 <span class=\"hljs-variable\">$obj</span> 转换为 Json 字符串；<br><span class=\"hljs-title function_\">acl::json_node</span>&amp; gson(<span class=\"hljs-title function_\">acl::json</span> &amp;<span class=\"hljs-variable\">$json</span>, const <span class=\"hljs-literal\">user</span> &amp;<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;</span><br><br>  将用户填充好的 <span class=\"hljs-literal\">user</span> 对象 <span class=\"hljs-variable\">$obj</span> 转化为 <span class=\"hljs-title function_\">acl::json</span> 对象 <span class=\"hljs-variable\">$json</span> 中的一个 <span class=\"hljs-title function_\">acl::json_node</span> 节点对象并将之返回，这样用户可以将这个返回的 <span class=\"hljs-title function_\">acl::json_node</span>&amp; 对象引用添加于 <span class=\"hljs-variable\">$json</span> 对象中；<br><br><span class=\"hljs-title function_\">acl::json_node</span>&amp; gson(<span class=\"hljs-title function_\">acl::json</span> &amp;<span class=\"hljs-variable\">$json</span>, const <span class=\"hljs-literal\">user</span> *<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;</span><br><br>   功能与 <span class=\"hljs-number\">2</span>）中的方法相同，只是 <span class=\"hljs-variable\">$obj</span> 参数为对象指针；<br><br><span class=\"hljs-title function_\">std::pair</span>&lt;bool,<span class=\"hljs-title function_\">std::string</span>&gt; gson(<span class=\"hljs-title function_\">acl::json_node</span> &amp;<span class=\"hljs-variable\">$node</span>, <span class=\"hljs-literal\">user</span> &amp;<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;</span><br><br>   将一个 <span class=\"hljs-title function_\">acl::json_node</span> Json 节点对象转化为用户自定义的 struct <span class=\"hljs-literal\">user</span> 对象，如果 <span class=\"hljs-variable\">$node</span> 为该 Json 对象中的根节点，则该根节点可由 <span class=\"hljs-variable\">$json.get_root</span>() 获得，<span class=\"hljs-variable\">$obj</span> 存储转换后的结果；<br><br><span class=\"hljs-title function_\">std::pair</span>&lt;bool,<span class=\"hljs-title function_\">std::string</span>&gt; gson(<span class=\"hljs-title function_\">acl::json_node</span> &amp;<span class=\"hljs-variable\">$node</span>, <span class=\"hljs-literal\">user</span> *<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;</span><br><br>   功能与 <span class=\"hljs-number\">5</span>）中的方法相同，只是 <span class=\"hljs-variable\">$obj</span> 参数为对象指针。<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"四、举例：\"><a href=\"#四、举例：\" class=\"headerlink\" title=\"四、举例：\"></a>四、举例：</h2><p>假设自定义结构对象如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// struct.stub</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">user</span><br>&#123;<br>        std::string name;<br>        std::string domain;<br>        <span class=\"hljs-type\">int</span> age;<br>        <span class=\"hljs-type\">bool</span> male;<br>&#125;;<br><br>      应用操作 user 对象的过程如下：<br><br><span class=\"hljs-comment\">// main.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;struct.h&quot;</span>  <span class=\"hljs-comment\">// 由 gson 工具根据 struct.stub 转换而成</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gson.h&quot;</span>   <span class=\"hljs-comment\">// 由 gson 工具根据 struct.stub 生成</span></span><br><br><span class=\"hljs-comment\">// 序列化过程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">serialize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tuser u;<br><br>\tu.name = <span class=\"hljs-string\">&quot;zsxxsz&quot;</span>;<br>\tu.domain = <span class=\"hljs-string\">&quot;263.net&quot;</span>;<br>\tu.age = <span class=\"hljs-number\">11</span>;<br>\tu.male = <span class=\"hljs-literal\">true</span>;<br><br>\tacl::json json;<br><br>\t<span class=\"hljs-comment\">// 将 user 对象转换为 json 对象</span><br>\tacl::json_node&amp; node = acl::<span class=\"hljs-built_in\">gson</span>(json, u);<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;serialize:\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;json: %s\\r\\n&quot;</span>, node.<span class=\"hljs-built_in\">to_string</span>().<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 反序列化过程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deserialize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *s = <span class=\"hljs-string\">&quot;&#123;\\&quot;name\\&quot;: \\&quot;zsxxsz\\&quot;, \\&quot;domain\\&quot;: \\&quot;263.net\\&quot;, \\&quot;age\\&quot;: 11, \\&quot;male\\&quot;: true&#125;&quot;</span>;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;deserialize:\\r\\n&quot;</span>);<br><br>\tacl::json json;<br>\tjson.<span class=\"hljs-built_in\">update</span>(s);<br>\tuser u;<br><br>\t<span class=\"hljs-comment\">// 将 json 对象转换为 user 对象</span><br>\tstd::pair&lt;<span class=\"hljs-type\">bool</span>, std::string&gt; ret = acl::<span class=\"hljs-built_in\">gson</span>(json.<span class=\"hljs-built_in\">get_root</span>(), u);<br><br>\t<span class=\"hljs-comment\">// 如果转换失败，则打印转换失败原因</span><br>\t<span class=\"hljs-keyword\">if</span> (ret.first == <span class=\"hljs-literal\">false</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;error: %s\\r\\n&quot;</span>, ret.second.<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;name: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tu.name.<span class=\"hljs-built_in\">c_str</span>(), u.domain.<span class=\"hljs-built_in\">c_str</span>(), u.age,<br>\t\t\tu.male ? <span class=\"hljs-string\">&quot;yes&quot;</span> : <span class=\"hljs-string\">&quot;no&quot;</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">serialize</span>();<br>\t<span class=\"hljs-built_in\">deserialize</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"五、参考：\"><a href=\"#五、参考：\" class=\"headerlink\" title=\"五、参考：\"></a>五、参考：</h2><p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在开发网络应用程序时，各个模块之间的数据通信可谓是家常便饭，为了应对这些数据通信时数据交换的要求，程序员发明了各种数据格式：采用二进制数据结构（早期 C 程序员）、采用 XML、采用SOAP（坑人的设计）、采用 URL 编码、采用JSON格式等。客户端与服务端交互时采用这些数据格式进行数据交换时，必然要经历数据编码及数据解码的繁琐过程。早期的二进制数据结构格式对于 C 程序员而是比较简单的，在解码时直接进行结构硬对齐就OK了，但对于其它语言（如 JAVA，PHP）则就麻烦很多，JAVA 语言不仅需要采用字节流一个一个对齐，而且还得要考虑到 C 结构体的数据打包填充方式；SOAP 方式看似满足了各类编程语言数据交换的目的，但数据臃肿是一个很大的问题，我们为了传输几个字节的数据则需要不得不封装大量的 XML 标记。为了使跨语言开发的程序员从麻烦的数据编解码中解脱出来，后来出来很多序列化&#x2F;反序列化的工具库，比较著名的象 Facebook 的 thrift，Google 的 protobuf。这些工具库功能非常强大，但有一个问题是，这些工具库所要求的预先定义的 schema 的亲民性不够好，增加了额外的大量学习成本。</p>\n<p>最近由 <a href=\"mailto:&#x6e;&#x69;&#117;&#x6b;&#x65;&#x79;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;\">&#x6e;&#x69;&#117;&#x6b;&#x65;&#x79;&#x40;&#x71;&#113;&#x2e;&#99;&#x6f;&#x6d;</a> 为 acl 库新增了 C++ 对象序列化与反序列化库，大大提高了程序员的编程效率及代码准确率。acl 序列化库实现了 C++ struct 对象与 JSON 对象之间互转功能，使用方式非常简单。</p>\n<h2 id=\"一、acl-序列化库的功能特点：\"><a href=\"#一、acl-序列化库的功能特点：\" class=\"headerlink\" title=\"一、acl 序列化库的功能特点：\"></a>一、acl 序列化库的功能特点：</h2><ul>\n<li>可以直接将 C++ struct 对象转换为 Json 对象，同时还可以将 Json 对象反序列化为 C++ struct 对象；</li>\n<li>支持 C++ struct 对象中包含构造函数及析构函数；</li>\n<li>C++ struct 对象中的成员支持常见基本类型（short, int, long, long long, char*）、标准 C++ 类对象；</li>\n<li>C++ struct 对象中的成员支持指针类型；</li>\n<li>C++ struct 对象中的成员支持常见 C++ 容器类型：std::vector、std::list、std::map，且支持容器对象的内部嵌套；</li>\n<li>C++ struct 对象中的成员为基本数据类型（如：short, int, long, long long）和指针类型时，支持直接在 struct 中针对这些成员进行初始化（C++11）；</li>\n<li>支持在 C++ struct 中添加注释（&#x2F;&#x2F; 或 &#x2F;**&#x2F;）；</li>\n<li>支持 C++ struct 对象的多继承；</li>\n<li>支持在 C++ struct 对象中的多级包含，建议使用包含方式代替继承方式；</li>\n<li>支持 C++ struct 成员增加注释项：&#x2F;&#x2F;Gson@optional 表示该成员变量为可选项，&#x2F;&#x2F;Gson@required 表示该成员为必须项，默认为必须的。</li>\n</ul>\n<h2 id=\"二、使用-acl-序列化库的限制：\"><a href=\"#二、使用-acl-序列化库的限制：\" class=\"headerlink\" title=\"二、使用 acl 序列化库的限制：\"></a>二、使用 acl 序列化库的限制：</h2><ul>\n<li>struct 中的成员类型不能为 char 类型，主要是因为 Json 对象中不存在 char 类型；</li>\n<li>struct 中的成员前不得有 const 常量限定词，主要是在反序列化时需要对这些成员进行赋值；</li>\n<li>struct 中不支持 C++ 关键词：public、private、protected；</li>\n<li>struct 中的成员变量名不得为：$json、$node、$obj，因为这些关键词被 acl 序列化库生成的代码占用；<br>-存在包含关系的 struct 类型定义必须在同一个文件中；</li>\n<li>不支持纯 C 语言的数组功能，比如，针对 int a[10]，因无法确切知道数组 a 中真实存储的数量而无法进行序列化和反序列化，因此推荐使用 std::vector<int> 代替它。</li>\n</ul>\n<h2 id=\"三、使用-acl-序列化库的过程：\"><a href=\"#三、使用-acl-序列化库的过程：\" class=\"headerlink\" title=\"三、使用 acl 序列化库的过程：\"></a>三、使用 acl 序列化库的过程：</h2><ul>\n<li>首先编译 acl 库：在 acl 目录前运行：make build_one，会生成 acl 的三个基础库（lib_acl&#x2F;lib&#x2F;lib_acl.a, lib_protocol&#x2F;lib&#x2F;lib_protocol.a, lib_acl_cpp&#x2F;liblib_acl_cpp.a），同时还会在 acl 根目录下生成这三个库的合集（lib_acl.a 和 lib_acl.so）；</li>\n<li>编译 acl 序列化工具：进入 app&#x2F;gson 目录，运行 make，生成 gson 工具，该工具将被用于根据用户自定义 struct 生成序列化 C++ 代码；</li>\n<li>定义自己的 struct 结构体（可以定义多个）并保存在文件中（文件后缀名为 .stub）；</li>\n<li>使用 gson 工具根据用户的 .stub 文件生成序列化所需的 C++ 代码：.&#x2F;gson -d path，其中 path 为保含 .stub 文件的目录，将会生成三个文件 gson.cpp、 gson.h 和 由 .stub 转换的 .h 头文件；</li>\n<li>将 gson.h 和由 .stub 文件转换的 .h 头文件包含在自己的代码中；</li>\n<li>针对用户自定义的每一个 struct，在 gson.h 头文件中均会提供 struct 对象的序列化和反序列化的方法，假设用户自定义了一个结构体类型：struct user，则在由工具 gson 生成的 gson.h 文件中包含如下五个方法：<figure class=\"highlight nsis\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs nsis\"><span class=\"hljs-title function_\">acl::string</span> gson(const <span class=\"hljs-literal\">user</span> &amp;<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;  </span><br><br>  将用户填充好的 <span class=\"hljs-literal\">user</span> 对象 <span class=\"hljs-variable\">$obj</span> 转换为 Json 字符串；<br><span class=\"hljs-title function_\">acl::json_node</span>&amp; gson(<span class=\"hljs-title function_\">acl::json</span> &amp;<span class=\"hljs-variable\">$json</span>, const <span class=\"hljs-literal\">user</span> &amp;<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;</span><br><br>  将用户填充好的 <span class=\"hljs-literal\">user</span> 对象 <span class=\"hljs-variable\">$obj</span> 转化为 <span class=\"hljs-title function_\">acl::json</span> 对象 <span class=\"hljs-variable\">$json</span> 中的一个 <span class=\"hljs-title function_\">acl::json_node</span> 节点对象并将之返回，这样用户可以将这个返回的 <span class=\"hljs-title function_\">acl::json_node</span>&amp; 对象引用添加于 <span class=\"hljs-variable\">$json</span> 对象中；<br><br><span class=\"hljs-title function_\">acl::json_node</span>&amp; gson(<span class=\"hljs-title function_\">acl::json</span> &amp;<span class=\"hljs-variable\">$json</span>, const <span class=\"hljs-literal\">user</span> *<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;</span><br><br>   功能与 <span class=\"hljs-number\">2</span>）中的方法相同，只是 <span class=\"hljs-variable\">$obj</span> 参数为对象指针；<br><br><span class=\"hljs-title function_\">std::pair</span>&lt;bool,<span class=\"hljs-title function_\">std::string</span>&gt; gson(<span class=\"hljs-title function_\">acl::json_node</span> &amp;<span class=\"hljs-variable\">$node</span>, <span class=\"hljs-literal\">user</span> &amp;<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;</span><br><br>   将一个 <span class=\"hljs-title function_\">acl::json_node</span> Json 节点对象转化为用户自定义的 struct <span class=\"hljs-literal\">user</span> 对象，如果 <span class=\"hljs-variable\">$node</span> 为该 Json 对象中的根节点，则该根节点可由 <span class=\"hljs-variable\">$json.get_root</span>() 获得，<span class=\"hljs-variable\">$obj</span> 存储转换后的结果；<br><br><span class=\"hljs-title function_\">std::pair</span>&lt;bool,<span class=\"hljs-title function_\">std::string</span>&gt; gson(<span class=\"hljs-title function_\">acl::json_node</span> &amp;<span class=\"hljs-variable\">$node</span>, <span class=\"hljs-literal\">user</span> *<span class=\"hljs-variable\">$obj</span>)<span class=\"hljs-comment\">;</span><br><br>   功能与 <span class=\"hljs-number\">5</span>）中的方法相同，只是 <span class=\"hljs-variable\">$obj</span> 参数为对象指针。<br></code></pre></td></tr></table></figure></li>\n</ul>\n<h2 id=\"四、举例：\"><a href=\"#四、举例：\" class=\"headerlink\" title=\"四、举例：\"></a>四、举例：</h2><p>假设自定义结构对象如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// struct.stub</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">user</span><br>&#123;<br>        std::string name;<br>        std::string domain;<br>        <span class=\"hljs-type\">int</span> age;<br>        <span class=\"hljs-type\">bool</span> male;<br>&#125;;<br><br>      应用操作 user 对象的过程如下：<br><br><span class=\"hljs-comment\">// main.cpp</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;struct.h&quot;</span>  <span class=\"hljs-comment\">// 由 gson 工具根据 struct.stub 转换而成</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gson.h&quot;</span>   <span class=\"hljs-comment\">// 由 gson 工具根据 struct.stub 生成</span></span><br><br><span class=\"hljs-comment\">// 序列化过程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">serialize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tuser u;<br><br>\tu.name = <span class=\"hljs-string\">&quot;zsxxsz&quot;</span>;<br>\tu.domain = <span class=\"hljs-string\">&quot;263.net&quot;</span>;<br>\tu.age = <span class=\"hljs-number\">11</span>;<br>\tu.male = <span class=\"hljs-literal\">true</span>;<br><br>\tacl::json json;<br><br>\t<span class=\"hljs-comment\">// 将 user 对象转换为 json 对象</span><br>\tacl::json_node&amp; node = acl::<span class=\"hljs-built_in\">gson</span>(json, u);<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;serialize:\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;json: %s\\r\\n&quot;</span>, node.<span class=\"hljs-built_in\">to_string</span>().<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 反序列化过程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deserialize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *s = <span class=\"hljs-string\">&quot;&#123;\\&quot;name\\&quot;: \\&quot;zsxxsz\\&quot;, \\&quot;domain\\&quot;: \\&quot;263.net\\&quot;, \\&quot;age\\&quot;: 11, \\&quot;male\\&quot;: true&#125;&quot;</span>;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;deserialize:\\r\\n&quot;</span>);<br><br>\tacl::json json;<br>\tjson.<span class=\"hljs-built_in\">update</span>(s);<br>\tuser u;<br><br>\t<span class=\"hljs-comment\">// 将 json 对象转换为 user 对象</span><br>\tstd::pair&lt;<span class=\"hljs-type\">bool</span>, std::string&gt; ret = acl::<span class=\"hljs-built_in\">gson</span>(json.<span class=\"hljs-built_in\">get_root</span>(), u);<br><br>\t<span class=\"hljs-comment\">// 如果转换失败，则打印转换失败原因</span><br>\t<span class=\"hljs-keyword\">if</span> (ret.first == <span class=\"hljs-literal\">false</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;error: %s\\r\\n&quot;</span>, ret.second.<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;name: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tu.name.<span class=\"hljs-built_in\">c_str</span>(), u.domain.<span class=\"hljs-built_in\">c_str</span>(), u.age,<br>\t\t\tu.male ? <span class=\"hljs-string\">&quot;yes&quot;</span> : <span class=\"hljs-string\">&quot;no&quot;</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">serialize</span>();<br>\t<span class=\"hljs-built_in\">deserialize</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"五、参考：\"><a href=\"#五、参考：\" class=\"headerlink\" title=\"五、参考：\"></a>五、参考：</h2><p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"c++对象序列化编程实例 编辑","date":"2016-11-14T14:39:00.000Z","_content":"\n在《使用 acl 库针对 C++ 对象进行序列化及反序列编程》中介绍了 acl 库中针对 C/C++ 的 struct 对象进行序列化和反序列化的功能，并且给出了一个简单的例子。本文将介绍一些较为复杂的例子。\n\n## 一、示例一：支持多继承的例子\n\n先定义 struct.stub 文件：\n\n```c++\n#pragma once\n#include <string>\n\nstruct student\n{\n\tstd::string shcool;\n\tstd::string class_name;\n};\n\nstruct province\n{\n\tstd::string province_name;\n\tstd::string position;\n};\n\nstruct user : student, province\n{\n\tstd::string name;\n\tint  age;\n\tbool male;\n};\n```\n\n上面的定义中，user 继承于 student 和 province。\n\n然后使用 gson 工具（运行：./gson -d ）根据此 struct.stub 生成目标源文件和头文件：gson.cpp, gson.h, struct.h。\n\n下面就可以编写业务逻辑代码：\n\n```c++\n#include \"stdafx.h\"\n#include <list>\n#include <vector>\n#include <map>\n#include <stdio.h>\n#include <iostream>\n#include <time.h>\n#include \"struct.h\"  // 由 gson 工具根据 struct.stub 转换而成\n#include \"gson.h\"    // 由 gson 工具根据 struct.stub 生成\n\n// 序列化过程\nstatic void serialize(void)\n{\n\tuser u;\n\n\tu.name = \"zsx\";\n\tu.age = 11;\n\tu.male = true;\n\n\tu.province_name = \"省\";\n\tu.position = \"位置\";\n\n\tu.shcool = \"大学\";\n\tu.class_name = \"班级\";\n\n\tacl::json json;\n\n\t// 将 user 对象转换为 json 对象\n\tacl::json_node& node = acl::gson(json, u);\n\n\tprintf(\"serialize:\\r\\n\");\n\tprintf(\"json: %s\\r\\n\", node.to_string().c_str());\n\tprintf(\"\\r\\n\");\n}\n\n// 反序列化过程\nstatic void deserialize(void)\n{\n\tconst char *s = \"{\\\"shcool\\\": \\\"大学\\\", \\\"class_name\\\": \\\"班级\\\", \\\"province_name\\\": \\\"省\\\", \\\"position\\\": \\\"位置\\\", \\\"name\\\": \\\"zsx\\\", \\\"age\\\": 11, \\\"male\\\": true}\";\n\tprintf(\"deserialize:\\r\\n\");\n\n\tacl::json json;\n\tjson.update(s);\n\tuser u;\n\n\t// 将 json 对象转换为 user 对象\n\tstd::pair<bool, std::string> ret = acl::gson(json.get_root(), u);\n\n\t// 如果转换失败，则打印转换失败原因\n\tif (ret.first == false)\n\t\tprintf(\"error: %s\\r\\n\", ret.second.c_str());\n\telse\n\t{\n\t\tprintf(\"name: %s, age: %d, male: %s\\r\\n\",\n\t\t\tu.name.c_str(), u.age, u.male ? \"yes\" : \"no\");\n\t\tprintf(\"province_name: %s, position: %s\\r\\n\",\n\t\t\tu.province_name.c_str(), u.position.c_str());\n\t\tprintf(\"shcool: %s, class_name: %s\\r\\n\",\n\t\t\tu.shcool.c_str(), u.class_name.c_str());\n\t}\n}\n\nint main(void)\n{\n\tserialize();\n\tdeserialize();\n\treturn 0;\n}\n```\n\n编译并运行该例子，结果如下：\n\n```\nserialize:\njson: {\"shcool\": \"大学\", \"class_name\": \"班级\", \"province_name\": \"省\", \"position\": \"位置\", \"name\": \"zsx\", \"age\": 11, \"male\": true}\n\ndeserialize:\nname: zsx, age: 11, male: yes\nprovince_name: 省, position: 位置\nshcool: 大学, class_name: 班级\n```\n\n## 二、示例二：支持 C++11 的例子\n\n 定义 struct.stub 文件如下：\n\n```c++\n#pragma once\n\nstruct user\n{\n\t// 带参数的构造函数\n\tuser(const char* user_name, const char* user_domain,\n\t\tint user_age, bool user_male)\n\t: username(user_name)\n\t, domain(user_domain)\n\t, age(user_age)\n\t, male(user_male)\n\t{}\n\n\tuser() {}\n\t~user() {}\n\n\tacl::string username;\n\tacl::string domain;\n\tint age = 100;\n\tbool male = true;\n};\n\nstruct message\n{\n\tint type;\n\tacl::string cmd;\n\tstd::list<user> user_list;\n\tstd::list<user> user_vector;\n\tstd::map<acl::string, user> user_map;\n\n\tstd::list<user*> *user_list_ptr = nullptr;\n\tstd::vector<user*> *user_vector_ptr = nullptr;\n\tstd::map<acl::string, user*> *user_map_ptr = nullptr;\n\n\tint n = 100;\t\t\t\t// c++11 允许初始化成员变量\n\tlong n1 = 1000;\n\tlong long int n2 = 1000;\n\tshort n3 = 100;\n\t//Gson@optional\n\tuser* u = nullptr;\n\n\tmessage() {}\n\n\t~message()\n\t{\n\t\tif (user_list_ptr)\n\t\t{\n\t\t\tfor (auto it : *user_list_ptr)\n\t\t\t\tdelete it;\n\t\t\tdelete user_list_ptr;\n\t\t}\n\t\tif (user_vector_ptr)\n\t\t{\n\t\t\tfor (auto it : *user_vector_ptr)\n\t\t\t\tdelete it;\n\t\t\tdelete user_vector_ptr;\n\t\t}\n\t\tif (user_map_ptr)\n\t\t{\n\t\t\tfor (auto it : *user_map_ptr)\n\t\t\t\tdelete it.second;\n\t\t\tdelete user_map_ptr;\n\t\t}\n\t}\n};\n```\n\n用 gson 工具将上述 stub 文件生成同样的三个文件：gson.cpp, gson.h, struct.h，然后编写业务处理代码如下：\n\n```c++\n#include \"stdafx.h\"\n#include <list>\n#include <vector>\n#include <map>\n#include <stdio.h>\n#include <iostream>\n#include <time.h>\n#include \"struct.h\"\n#include \"gson.h\"\n\nstatic void print_msg(message& msg)\n{\n\tprintf(\"=======================================================\\r\\n\");\n\tprintf(\"type: %d\\r\\n\", msg.type);\n\tprintf(\"cmd: %s\\r\\n\", msg.cmd.c_str());\n\n\tprintf(\"-------------------- user list ------------------------\\r\\n\");\n\tsize_t i = 0;\n\tfor (auto cit : msg.user_list)\n\t{\n\t\tprintf(\">>username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit.username.c_str(), cit.domain.c_str(),\n\t\t\tcit.age, cit.male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"-------------------- user vector ----------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : msg.user_vector)\n\t{\n\t\tprintf(\">>username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit.username.c_str(), cit.domain.c_str(),\n\t\t\tcit.age, cit.male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"------------------- user map --------------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : msg.user_map)\n\t{\n\t\tprintf(\">>key: %s, username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit.first.c_str(),\n\t\t\tcit.second.username.c_str(),\n\t\t\tcit.second.domain.c_str(),\n\t\t\tcit.second.age,\n\t\t\tcit.second.male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\tprintf(\"-------------------- user list ptr --------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : *msg.user_list_ptr)\n\t{\n\t\tprintf(\">>username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit->username.c_str(), cit->domain.c_str(),\n\t\t\tcit->age, cit->male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"-------------------- user vector ptr ------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : *msg.user_vector_ptr)\n\t{\n\t\tprintf(\">>username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit->username.c_str(), cit->domain.c_str(),\n\t\t\tcit->age, cit->male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"------------------- user map ptr ----------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : *msg.user_map_ptr)\n\t{\n\t\tprintf(\">>key: %s, username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit.first.c_str(),\n\t\t\tcit.second->username.c_str(),\n\t\t\tcit.second->domain.c_str(),\n\t\t\tcit.second->age,\n\t\t\tcit.second->male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"-------------------------------------------------------\\r\\n\");\n}\n\nstatic void test(void)\n{\n\t//////////////////////////////////////////////////////////////////\n\t// 序列化过程\n\n\tmessage msg;\n\tmsg.user_list_ptr   = new std::list<user*>;\n\tmsg.user_vector_ptr = new std::vector<user*>;\n\tmsg.user_map_ptr    = new std::map<acl::string, user*>;\n\n\tmsg.type = 1;\n\tmsg.cmd  = \"add\";\n\n\tuser u = {\"zsx1\", \"263.net\", 11, true};\n\tmsg.user_list.push_back(u);\n\tmsg.user_list.emplace_back(u);\n\tmsg.user_list.emplace_back(\"zsx1\", \"263.net\", 13, false);\n\n\tu = {\"zsx2\", \"263.net\", 11, true};\n\tmsg.user_vector.push_back(u);\n\tmsg.user_vector.emplace_back(u);\n\tmsg.user_vector.emplace_back(\"zsx2\", \"263.net4\", 14, true);\n\n\tu = {\"zsx31\", \"263.net\", 11, true};\n\tmsg.user_map[u.username] = u;\n\tmsg.user_map[\"zsx32\"] = {\"zsx32\", \"263.net\", 11, true };\n\n\tmsg.user_list_ptr->push_back(new user(\"zsx4\", \"263.net1\", 11, true));\n\tmsg.user_list_ptr->push_back(new user(\"zsx4\", \"263.net2\", 12, true));\n\n\tmsg.user_vector_ptr->push_back(new user(\"zsx5\", \"263.net1\", 11, true));\n\tmsg.user_vector_ptr->push_back(new user(\"zsx5\", \"263.net2\", 12, true));\n\n\t(*msg.user_map_ptr)[\"zsx61\"] = new user(\"zsx61:\", \"263.net1\", 11, true);\n\t(*msg.user_map_ptr)[\"zsx62\"] = new user(\"zsx62\", \"263.net2\", 12, true);\n\n\tacl::json json;\n\n\t// 序列化\n\tacl::json_node& node = acl::gson(json, msg);\n\tprintf(\"serialize: %s\\r\\n\", node.to_string().c_str());\n\n\t/////////////////////////////////////////////////////////////////////\n\t// 反序列化过程\n\n\tmessage msg1;\n\tacl::json json1;\n\tjson1.update(node.to_string());\n\n\tprintf(\"json1 to_string: %s\\r\\n\", json1.to_string().c_str());\n\n\t// 反序列化\n\tstd::pair<bool, std::string> ret = acl::gson(json1.get_root(), msg1);\n\tif (ret.first == false)\n\t\tprintf(\"error: %s\\r\\n\", ret.second.c_str());\n\telse\n\t\tprint_msg(msg);\n}\n\nint main(void)\n{\n\ttest();\n\treturn 0;\n}\n\n       上述例子主要体现了 gson 的两个特点：1、允许有构造函数，2、支持 C++11 中的结构成员初始化。\n```\n\n## 三、参考\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","source":"_posts/serialize2.md","raw":"---\ntitle: c++对象序列化编程实例 编辑\ndate: 2016-11-14 22:39\ncategories: 对象序列化\n---\n\n在《使用 acl 库针对 C++ 对象进行序列化及反序列编程》中介绍了 acl 库中针对 C/C++ 的 struct 对象进行序列化和反序列化的功能，并且给出了一个简单的例子。本文将介绍一些较为复杂的例子。\n\n## 一、示例一：支持多继承的例子\n\n先定义 struct.stub 文件：\n\n```c++\n#pragma once\n#include <string>\n\nstruct student\n{\n\tstd::string shcool;\n\tstd::string class_name;\n};\n\nstruct province\n{\n\tstd::string province_name;\n\tstd::string position;\n};\n\nstruct user : student, province\n{\n\tstd::string name;\n\tint  age;\n\tbool male;\n};\n```\n\n上面的定义中，user 继承于 student 和 province。\n\n然后使用 gson 工具（运行：./gson -d ）根据此 struct.stub 生成目标源文件和头文件：gson.cpp, gson.h, struct.h。\n\n下面就可以编写业务逻辑代码：\n\n```c++\n#include \"stdafx.h\"\n#include <list>\n#include <vector>\n#include <map>\n#include <stdio.h>\n#include <iostream>\n#include <time.h>\n#include \"struct.h\"  // 由 gson 工具根据 struct.stub 转换而成\n#include \"gson.h\"    // 由 gson 工具根据 struct.stub 生成\n\n// 序列化过程\nstatic void serialize(void)\n{\n\tuser u;\n\n\tu.name = \"zsx\";\n\tu.age = 11;\n\tu.male = true;\n\n\tu.province_name = \"省\";\n\tu.position = \"位置\";\n\n\tu.shcool = \"大学\";\n\tu.class_name = \"班级\";\n\n\tacl::json json;\n\n\t// 将 user 对象转换为 json 对象\n\tacl::json_node& node = acl::gson(json, u);\n\n\tprintf(\"serialize:\\r\\n\");\n\tprintf(\"json: %s\\r\\n\", node.to_string().c_str());\n\tprintf(\"\\r\\n\");\n}\n\n// 反序列化过程\nstatic void deserialize(void)\n{\n\tconst char *s = \"{\\\"shcool\\\": \\\"大学\\\", \\\"class_name\\\": \\\"班级\\\", \\\"province_name\\\": \\\"省\\\", \\\"position\\\": \\\"位置\\\", \\\"name\\\": \\\"zsx\\\", \\\"age\\\": 11, \\\"male\\\": true}\";\n\tprintf(\"deserialize:\\r\\n\");\n\n\tacl::json json;\n\tjson.update(s);\n\tuser u;\n\n\t// 将 json 对象转换为 user 对象\n\tstd::pair<bool, std::string> ret = acl::gson(json.get_root(), u);\n\n\t// 如果转换失败，则打印转换失败原因\n\tif (ret.first == false)\n\t\tprintf(\"error: %s\\r\\n\", ret.second.c_str());\n\telse\n\t{\n\t\tprintf(\"name: %s, age: %d, male: %s\\r\\n\",\n\t\t\tu.name.c_str(), u.age, u.male ? \"yes\" : \"no\");\n\t\tprintf(\"province_name: %s, position: %s\\r\\n\",\n\t\t\tu.province_name.c_str(), u.position.c_str());\n\t\tprintf(\"shcool: %s, class_name: %s\\r\\n\",\n\t\t\tu.shcool.c_str(), u.class_name.c_str());\n\t}\n}\n\nint main(void)\n{\n\tserialize();\n\tdeserialize();\n\treturn 0;\n}\n```\n\n编译并运行该例子，结果如下：\n\n```\nserialize:\njson: {\"shcool\": \"大学\", \"class_name\": \"班级\", \"province_name\": \"省\", \"position\": \"位置\", \"name\": \"zsx\", \"age\": 11, \"male\": true}\n\ndeserialize:\nname: zsx, age: 11, male: yes\nprovince_name: 省, position: 位置\nshcool: 大学, class_name: 班级\n```\n\n## 二、示例二：支持 C++11 的例子\n\n 定义 struct.stub 文件如下：\n\n```c++\n#pragma once\n\nstruct user\n{\n\t// 带参数的构造函数\n\tuser(const char* user_name, const char* user_domain,\n\t\tint user_age, bool user_male)\n\t: username(user_name)\n\t, domain(user_domain)\n\t, age(user_age)\n\t, male(user_male)\n\t{}\n\n\tuser() {}\n\t~user() {}\n\n\tacl::string username;\n\tacl::string domain;\n\tint age = 100;\n\tbool male = true;\n};\n\nstruct message\n{\n\tint type;\n\tacl::string cmd;\n\tstd::list<user> user_list;\n\tstd::list<user> user_vector;\n\tstd::map<acl::string, user> user_map;\n\n\tstd::list<user*> *user_list_ptr = nullptr;\n\tstd::vector<user*> *user_vector_ptr = nullptr;\n\tstd::map<acl::string, user*> *user_map_ptr = nullptr;\n\n\tint n = 100;\t\t\t\t// c++11 允许初始化成员变量\n\tlong n1 = 1000;\n\tlong long int n2 = 1000;\n\tshort n3 = 100;\n\t//Gson@optional\n\tuser* u = nullptr;\n\n\tmessage() {}\n\n\t~message()\n\t{\n\t\tif (user_list_ptr)\n\t\t{\n\t\t\tfor (auto it : *user_list_ptr)\n\t\t\t\tdelete it;\n\t\t\tdelete user_list_ptr;\n\t\t}\n\t\tif (user_vector_ptr)\n\t\t{\n\t\t\tfor (auto it : *user_vector_ptr)\n\t\t\t\tdelete it;\n\t\t\tdelete user_vector_ptr;\n\t\t}\n\t\tif (user_map_ptr)\n\t\t{\n\t\t\tfor (auto it : *user_map_ptr)\n\t\t\t\tdelete it.second;\n\t\t\tdelete user_map_ptr;\n\t\t}\n\t}\n};\n```\n\n用 gson 工具将上述 stub 文件生成同样的三个文件：gson.cpp, gson.h, struct.h，然后编写业务处理代码如下：\n\n```c++\n#include \"stdafx.h\"\n#include <list>\n#include <vector>\n#include <map>\n#include <stdio.h>\n#include <iostream>\n#include <time.h>\n#include \"struct.h\"\n#include \"gson.h\"\n\nstatic void print_msg(message& msg)\n{\n\tprintf(\"=======================================================\\r\\n\");\n\tprintf(\"type: %d\\r\\n\", msg.type);\n\tprintf(\"cmd: %s\\r\\n\", msg.cmd.c_str());\n\n\tprintf(\"-------------------- user list ------------------------\\r\\n\");\n\tsize_t i = 0;\n\tfor (auto cit : msg.user_list)\n\t{\n\t\tprintf(\">>username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit.username.c_str(), cit.domain.c_str(),\n\t\t\tcit.age, cit.male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"-------------------- user vector ----------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : msg.user_vector)\n\t{\n\t\tprintf(\">>username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit.username.c_str(), cit.domain.c_str(),\n\t\t\tcit.age, cit.male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"------------------- user map --------------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : msg.user_map)\n\t{\n\t\tprintf(\">>key: %s, username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit.first.c_str(),\n\t\t\tcit.second.username.c_str(),\n\t\t\tcit.second.domain.c_str(),\n\t\t\tcit.second.age,\n\t\t\tcit.second.male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\tprintf(\"-------------------- user list ptr --------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : *msg.user_list_ptr)\n\t{\n\t\tprintf(\">>username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit->username.c_str(), cit->domain.c_str(),\n\t\t\tcit->age, cit->male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"-------------------- user vector ptr ------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : *msg.user_vector_ptr)\n\t{\n\t\tprintf(\">>username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit->username.c_str(), cit->domain.c_str(),\n\t\t\tcit->age, cit->male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"------------------- user map ptr ----------------------\\r\\n\");\n\ti = 0;\n\tfor (auto cit : *msg.user_map_ptr)\n\t{\n\t\tprintf(\">>key: %s, username: %s, domain: %s, age: %d, male: %s\\r\\n\",\n\t\t\tcit.first.c_str(),\n\t\t\tcit.second->username.c_str(),\n\t\t\tcit.second->domain.c_str(),\n\t\t\tcit.second->age,\n\t\t\tcit.second->male ? \"true\" : \"false\");\n\t\tif (++i >= 10)\n\t\t\tbreak;\n\t}\n\n\tprintf(\"-------------------------------------------------------\\r\\n\");\n}\n\nstatic void test(void)\n{\n\t//////////////////////////////////////////////////////////////////\n\t// 序列化过程\n\n\tmessage msg;\n\tmsg.user_list_ptr   = new std::list<user*>;\n\tmsg.user_vector_ptr = new std::vector<user*>;\n\tmsg.user_map_ptr    = new std::map<acl::string, user*>;\n\n\tmsg.type = 1;\n\tmsg.cmd  = \"add\";\n\n\tuser u = {\"zsx1\", \"263.net\", 11, true};\n\tmsg.user_list.push_back(u);\n\tmsg.user_list.emplace_back(u);\n\tmsg.user_list.emplace_back(\"zsx1\", \"263.net\", 13, false);\n\n\tu = {\"zsx2\", \"263.net\", 11, true};\n\tmsg.user_vector.push_back(u);\n\tmsg.user_vector.emplace_back(u);\n\tmsg.user_vector.emplace_back(\"zsx2\", \"263.net4\", 14, true);\n\n\tu = {\"zsx31\", \"263.net\", 11, true};\n\tmsg.user_map[u.username] = u;\n\tmsg.user_map[\"zsx32\"] = {\"zsx32\", \"263.net\", 11, true };\n\n\tmsg.user_list_ptr->push_back(new user(\"zsx4\", \"263.net1\", 11, true));\n\tmsg.user_list_ptr->push_back(new user(\"zsx4\", \"263.net2\", 12, true));\n\n\tmsg.user_vector_ptr->push_back(new user(\"zsx5\", \"263.net1\", 11, true));\n\tmsg.user_vector_ptr->push_back(new user(\"zsx5\", \"263.net2\", 12, true));\n\n\t(*msg.user_map_ptr)[\"zsx61\"] = new user(\"zsx61:\", \"263.net1\", 11, true);\n\t(*msg.user_map_ptr)[\"zsx62\"] = new user(\"zsx62\", \"263.net2\", 12, true);\n\n\tacl::json json;\n\n\t// 序列化\n\tacl::json_node& node = acl::gson(json, msg);\n\tprintf(\"serialize: %s\\r\\n\", node.to_string().c_str());\n\n\t/////////////////////////////////////////////////////////////////////\n\t// 反序列化过程\n\n\tmessage msg1;\n\tacl::json json1;\n\tjson1.update(node.to_string());\n\n\tprintf(\"json1 to_string: %s\\r\\n\", json1.to_string().c_str());\n\n\t// 反序列化\n\tstd::pair<bool, std::string> ret = acl::gson(json1.get_root(), msg1);\n\tif (ret.first == false)\n\t\tprintf(\"error: %s\\r\\n\", ret.second.c_str());\n\telse\n\t\tprint_msg(msg);\n}\n\nint main(void)\n{\n\ttest();\n\treturn 0;\n}\n\n       上述例子主要体现了 gson 的两个特点：1、允许有构造函数，2、支持 C++11 中的结构成员初始化。\n```\n\n## 三、参考\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","slug":"serialize2","published":1,"updated":"2023-01-24T10:11:52.152Z","_id":"clda2sue3000d8o9k5dyr5um4","comments":1,"layout":"post","photos":[],"link":"","content":"<p>在《使用 acl 库针对 C++ 对象进行序列化及反序列编程》中介绍了 acl 库中针对 C&#x2F;C++ 的 struct 对象进行序列化和反序列化的功能，并且给出了一个简单的例子。本文将介绍一些较为复杂的例子。</p>\n<h2 id=\"一、示例一：支持多继承的例子\"><a href=\"#一、示例一：支持多继承的例子\" class=\"headerlink\" title=\"一、示例一：支持多继承的例子\"></a>一、示例一：支持多继承的例子</h2><p>先定义 struct.stub 文件：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">student</span><br>&#123;<br>\tstd::string shcool;<br>\tstd::string class_name;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">province</span><br>&#123;<br>\tstd::string province_name;<br>\tstd::string position;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">user</span> : student, province<br>&#123;<br>\tstd::string name;<br>\t<span class=\"hljs-type\">int</span>  age;<br>\t<span class=\"hljs-type\">bool</span> male;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面的定义中，user 继承于 student 和 province。</p>\n<p>然后使用 gson 工具（运行：.&#x2F;gson -d ）根据此 struct.stub 生成目标源文件和头文件：gson.cpp, gson.h, struct.h。</p>\n<p>下面就可以编写业务逻辑代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;struct.h&quot;</span>  <span class=\"hljs-comment\">// 由 gson 工具根据 struct.stub 转换而成</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gson.h&quot;</span>    <span class=\"hljs-comment\">// 由 gson 工具根据 struct.stub 生成</span></span><br><br><span class=\"hljs-comment\">// 序列化过程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">serialize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tuser u;<br><br>\tu.name = <span class=\"hljs-string\">&quot;zsx&quot;</span>;<br>\tu.age = <span class=\"hljs-number\">11</span>;<br>\tu.male = <span class=\"hljs-literal\">true</span>;<br><br>\tu.province_name = <span class=\"hljs-string\">&quot;省&quot;</span>;<br>\tu.position = <span class=\"hljs-string\">&quot;位置&quot;</span>;<br><br>\tu.shcool = <span class=\"hljs-string\">&quot;大学&quot;</span>;<br>\tu.class_name = <span class=\"hljs-string\">&quot;班级&quot;</span>;<br><br>\tacl::json json;<br><br>\t<span class=\"hljs-comment\">// 将 user 对象转换为 json 对象</span><br>\tacl::json_node&amp; node = acl::<span class=\"hljs-built_in\">gson</span>(json, u);<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;serialize:\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;json: %s\\r\\n&quot;</span>, node.<span class=\"hljs-built_in\">to_string</span>().<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 反序列化过程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deserialize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *s = <span class=\"hljs-string\">&quot;&#123;\\&quot;shcool\\&quot;: \\&quot;大学\\&quot;, \\&quot;class_name\\&quot;: \\&quot;班级\\&quot;, \\&quot;province_name\\&quot;: \\&quot;省\\&quot;, \\&quot;position\\&quot;: \\&quot;位置\\&quot;, \\&quot;name\\&quot;: \\&quot;zsx\\&quot;, \\&quot;age\\&quot;: 11, \\&quot;male\\&quot;: true&#125;&quot;</span>;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;deserialize:\\r\\n&quot;</span>);<br><br>\tacl::json json;<br>\tjson.<span class=\"hljs-built_in\">update</span>(s);<br>\tuser u;<br><br>\t<span class=\"hljs-comment\">// 将 json 对象转换为 user 对象</span><br>\tstd::pair&lt;<span class=\"hljs-type\">bool</span>, std::string&gt; ret = acl::<span class=\"hljs-built_in\">gson</span>(json.<span class=\"hljs-built_in\">get_root</span>(), u);<br><br>\t<span class=\"hljs-comment\">// 如果转换失败，则打印转换失败原因</span><br>\t<span class=\"hljs-keyword\">if</span> (ret.first == <span class=\"hljs-literal\">false</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;error: %s\\r\\n&quot;</span>, ret.second.<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;name: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tu.name.<span class=\"hljs-built_in\">c_str</span>(), u.age, u.male ? <span class=\"hljs-string\">&quot;yes&quot;</span> : <span class=\"hljs-string\">&quot;no&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;province_name: %s, position: %s\\r\\n&quot;</span>,<br>\t\t\tu.province_name.<span class=\"hljs-built_in\">c_str</span>(), u.position.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;shcool: %s, class_name: %s\\r\\n&quot;</span>,<br>\t\t\tu.shcool.<span class=\"hljs-built_in\">c_str</span>(), u.class_name.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">serialize</span>();<br>\t<span class=\"hljs-built_in\">deserialize</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编译并运行该例子，结果如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">serialize:</span><br><span class=\"hljs-attr\">json:</span> &#123;<span class=\"hljs-attr\">&quot;shcool&quot;:</span> <span class=\"hljs-string\">&quot;大学&quot;</span>, <span class=\"hljs-attr\">&quot;class_name&quot;:</span> <span class=\"hljs-string\">&quot;班级&quot;</span>, <span class=\"hljs-attr\">&quot;province_name&quot;:</span> <span class=\"hljs-string\">&quot;省&quot;</span>, <span class=\"hljs-attr\">&quot;position&quot;:</span> <span class=\"hljs-string\">&quot;位置&quot;</span>, <span class=\"hljs-attr\">&quot;name&quot;:</span> <span class=\"hljs-string\">&quot;zsx&quot;</span>, <span class=\"hljs-attr\">&quot;age&quot;:</span> <span class=\"hljs-number\">11</span>, <span class=\"hljs-attr\">&quot;male&quot;:</span> <span class=\"hljs-literal\">true</span>&#125;<br><br><span class=\"hljs-attr\">deserialize:</span><br><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">zsx,</span> <span class=\"hljs-attr\">age:</span> <span class=\"hljs-number\">11</span><span class=\"hljs-string\">,</span> <span class=\"hljs-attr\">male:</span> <span class=\"hljs-literal\">yes</span><br><span class=\"hljs-attr\">province_name:</span> <span class=\"hljs-string\">省,</span> <span class=\"hljs-attr\">position:</span> <span class=\"hljs-string\">位置</span><br><span class=\"hljs-attr\">shcool:</span> <span class=\"hljs-string\">大学,</span> <span class=\"hljs-attr\">class_name:</span> <span class=\"hljs-string\">班级</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、示例二：支持-C-11-的例子\"><a href=\"#二、示例二：支持-C-11-的例子\" class=\"headerlink\" title=\"二、示例二：支持 C++11 的例子\"></a>二、示例二：支持 C++11 的例子</h2><p> 定义 struct.stub 文件如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">user</span><br>&#123;<br>\t<span class=\"hljs-comment\">// 带参数的构造函数</span><br>\t<span class=\"hljs-built_in\">user</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* user_name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* user_domain,<br>\t\t<span class=\"hljs-type\">int</span> user_age, <span class=\"hljs-type\">bool</span> user_male)<br>\t: <span class=\"hljs-built_in\">username</span>(user_name)<br>\t, <span class=\"hljs-built_in\">domain</span>(user_domain)<br>\t, <span class=\"hljs-built_in\">age</span>(user_age)<br>\t, <span class=\"hljs-built_in\">male</span>(user_male)<br>\t&#123;&#125;<br><br>\t<span class=\"hljs-built_in\">user</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">user</span>() &#123;&#125;<br><br>\tacl::string username;<br>\tacl::string domain;<br>\t<span class=\"hljs-type\">int</span> age = <span class=\"hljs-number\">100</span>;<br>\t<span class=\"hljs-type\">bool</span> male = <span class=\"hljs-literal\">true</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">message</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> type;<br>\tacl::string cmd;<br>\tstd::list&lt;user&gt; user_list;<br>\tstd::list&lt;user&gt; user_vector;<br>\tstd::map&lt;acl::string, user&gt; user_map;<br><br>\tstd::list&lt;user*&gt; *user_list_ptr = <span class=\"hljs-literal\">nullptr</span>;<br>\tstd::vector&lt;user*&gt; *user_vector_ptr = <span class=\"hljs-literal\">nullptr</span>;<br>\tstd::map&lt;acl::string, user*&gt; *user_map_ptr = <span class=\"hljs-literal\">nullptr</span>;<br><br>\t<span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">100</span>;\t\t\t\t<span class=\"hljs-comment\">// c++11 允许初始化成员变量</span><br>\t<span class=\"hljs-type\">long</span> n1 = <span class=\"hljs-number\">1000</span>;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> n2 = <span class=\"hljs-number\">1000</span>;<br>\t<span class=\"hljs-type\">short</span> n3 = <span class=\"hljs-number\">100</span>;<br>\t<span class=\"hljs-comment\">//Gson@optional</span><br>\tuser* u = <span class=\"hljs-literal\">nullptr</span>;<br><br>\t<span class=\"hljs-built_in\">message</span>() &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">message</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (user_list_ptr)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : *user_list_ptr)<br>\t\t\t\t<span class=\"hljs-keyword\">delete</span> it;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> user_list_ptr;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (user_vector_ptr)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : *user_vector_ptr)<br>\t\t\t\t<span class=\"hljs-keyword\">delete</span> it;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> user_vector_ptr;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (user_map_ptr)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : *user_map_ptr)<br>\t\t\t\t<span class=\"hljs-keyword\">delete</span> it.second;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> user_map_ptr;<br>\t\t&#125;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>用 gson 工具将上述 stub 文件生成同样的三个文件：gson.cpp, gson.h, struct.h，然后编写业务处理代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;struct.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gson.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print_msg</span><span class=\"hljs-params\">(message&amp; msg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;=======================================================\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;type: %d\\r\\n&quot;</span>, msg.type);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;cmd: %s\\r\\n&quot;</span>, msg.cmd.<span class=\"hljs-built_in\">c_str</span>());<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- user list ------------------------\\r\\n&quot;</span>);<br>\t<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : msg.user_list)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit.username.<span class=\"hljs-built_in\">c_str</span>(), cit.domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.age, cit.male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- user vector ----------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : msg.user_vector)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit.username.<span class=\"hljs-built_in\">c_str</span>(), cit.domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.age, cit.male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------------------- user map --------------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : msg.user_map)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;key: %s, username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit.first.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second.username.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second.domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second.age,<br>\t\t\tcit.second.male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- user list ptr --------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : *msg.user_list_ptr)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit-&gt;username.<span class=\"hljs-built_in\">c_str</span>(), cit-&gt;domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit-&gt;age, cit-&gt;male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- user vector ptr ------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : *msg.user_vector_ptr)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit-&gt;username.<span class=\"hljs-built_in\">c_str</span>(), cit-&gt;domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit-&gt;age, cit-&gt;male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------------------- user map ptr ----------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : *msg.user_map_ptr)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;key: %s, username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit.first.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second-&gt;username.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second-&gt;domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second-&gt;age,<br>\t\t\tcit.second-&gt;male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------------------------------------------\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////</span><br>\t<span class=\"hljs-comment\">// 序列化过程</span><br><br>\tmessage msg;<br>\tmsg.user_list_ptr   = <span class=\"hljs-keyword\">new</span> std::list&lt;user*&gt;;<br>\tmsg.user_vector_ptr = <span class=\"hljs-keyword\">new</span> std::vector&lt;user*&gt;;<br>\tmsg.user_map_ptr    = <span class=\"hljs-keyword\">new</span> std::map&lt;acl::string, user*&gt;;<br><br>\tmsg.type = <span class=\"hljs-number\">1</span>;<br>\tmsg.cmd  = <span class=\"hljs-string\">&quot;add&quot;</span>;<br><br>\tuser u = &#123;<span class=\"hljs-string\">&quot;zsx1&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>&#125;;<br>\tmsg.user_list.<span class=\"hljs-built_in\">push_back</span>(u);<br>\tmsg.user_list.<span class=\"hljs-built_in\">emplace_back</span>(u);<br>\tmsg.user_list.<span class=\"hljs-built_in\">emplace_back</span>(<span class=\"hljs-string\">&quot;zsx1&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-literal\">false</span>);<br><br>\tu = &#123;<span class=\"hljs-string\">&quot;zsx2&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>&#125;;<br>\tmsg.user_vector.<span class=\"hljs-built_in\">push_back</span>(u);<br>\tmsg.user_vector.<span class=\"hljs-built_in\">emplace_back</span>(u);<br>\tmsg.user_vector.<span class=\"hljs-built_in\">emplace_back</span>(<span class=\"hljs-string\">&quot;zsx2&quot;</span>, <span class=\"hljs-string\">&quot;263.net4&quot;</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-literal\">true</span>);<br><br>\tu = &#123;<span class=\"hljs-string\">&quot;zsx31&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>&#125;;<br>\tmsg.user_map[u.username] = u;<br>\tmsg.user_map[<span class=\"hljs-string\">&quot;zsx32&quot;</span>] = &#123;<span class=\"hljs-string\">&quot;zsx32&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span> &#125;;<br><br>\tmsg.user_list_ptr-&gt;<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx4&quot;</span>, <span class=\"hljs-string\">&quot;263.net1&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>));<br>\tmsg.user_list_ptr-&gt;<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx4&quot;</span>, <span class=\"hljs-string\">&quot;263.net2&quot;</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-literal\">true</span>));<br><br>\tmsg.user_vector_ptr-&gt;<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx5&quot;</span>, <span class=\"hljs-string\">&quot;263.net1&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>));<br>\tmsg.user_vector_ptr-&gt;<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx5&quot;</span>, <span class=\"hljs-string\">&quot;263.net2&quot;</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-literal\">true</span>));<br><br>\t(*msg.user_map_ptr)[<span class=\"hljs-string\">&quot;zsx61&quot;</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx61:&quot;</span>, <span class=\"hljs-string\">&quot;263.net1&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>);<br>\t(*msg.user_map_ptr)[<span class=\"hljs-string\">&quot;zsx62&quot;</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx62&quot;</span>, <span class=\"hljs-string\">&quot;263.net2&quot;</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-literal\">true</span>);<br><br>\tacl::json json;<br><br>\t<span class=\"hljs-comment\">// 序列化</span><br>\tacl::json_node&amp; node = acl::<span class=\"hljs-built_in\">gson</span>(json, msg);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;serialize: %s\\r\\n&quot;</span>, node.<span class=\"hljs-built_in\">to_string</span>().<span class=\"hljs-built_in\">c_str</span>());<br><br>\t<span class=\"hljs-comment\">/////////////////////////////////////////////////////////////////////</span><br>\t<span class=\"hljs-comment\">// 反序列化过程</span><br><br>\tmessage msg1;<br>\tacl::json json1;<br>\tjson1.<span class=\"hljs-built_in\">update</span>(node.<span class=\"hljs-built_in\">to_string</span>());<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;json1 to_string: %s\\r\\n&quot;</span>, json1.<span class=\"hljs-built_in\">to_string</span>().<span class=\"hljs-built_in\">c_str</span>());<br><br>\t<span class=\"hljs-comment\">// 反序列化</span><br>\tstd::pair&lt;<span class=\"hljs-type\">bool</span>, std::string&gt; ret = acl::<span class=\"hljs-built_in\">gson</span>(json1.<span class=\"hljs-built_in\">get_root</span>(), msg1);<br>\t<span class=\"hljs-keyword\">if</span> (ret.first == <span class=\"hljs-literal\">false</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;error: %s\\r\\n&quot;</span>, ret.second.<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">print_msg</span>(msg);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">test</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br>       上述例子主要体现了 gson 的两个特点：<span class=\"hljs-number\">1</span>、允许有构造函数，<span class=\"hljs-number\">2</span>、支持 C++<span class=\"hljs-number\">11</span> 中的结构成员初始化。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、参考\"><a href=\"#三、参考\" class=\"headerlink\" title=\"三、参考\"></a>三、参考</h2><p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在《使用 acl 库针对 C++ 对象进行序列化及反序列编程》中介绍了 acl 库中针对 C&#x2F;C++ 的 struct 对象进行序列化和反序列化的功能，并且给出了一个简单的例子。本文将介绍一些较为复杂的例子。</p>\n<h2 id=\"一、示例一：支持多继承的例子\"><a href=\"#一、示例一：支持多继承的例子\" class=\"headerlink\" title=\"一、示例一：支持多继承的例子\"></a>一、示例一：支持多继承的例子</h2><p>先定义 struct.stub 文件：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;string&gt;</span></span><br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">student</span><br>&#123;<br>\tstd::string shcool;<br>\tstd::string class_name;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">province</span><br>&#123;<br>\tstd::string province_name;<br>\tstd::string position;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">user</span> : student, province<br>&#123;<br>\tstd::string name;<br>\t<span class=\"hljs-type\">int</span>  age;<br>\t<span class=\"hljs-type\">bool</span> male;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>上面的定义中，user 继承于 student 和 province。</p>\n<p>然后使用 gson 工具（运行：.&#x2F;gson -d ）根据此 struct.stub 生成目标源文件和头文件：gson.cpp, gson.h, struct.h。</p>\n<p>下面就可以编写业务逻辑代码：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;struct.h&quot;</span>  <span class=\"hljs-comment\">// 由 gson 工具根据 struct.stub 转换而成</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gson.h&quot;</span>    <span class=\"hljs-comment\">// 由 gson 工具根据 struct.stub 生成</span></span><br><br><span class=\"hljs-comment\">// 序列化过程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">serialize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tuser u;<br><br>\tu.name = <span class=\"hljs-string\">&quot;zsx&quot;</span>;<br>\tu.age = <span class=\"hljs-number\">11</span>;<br>\tu.male = <span class=\"hljs-literal\">true</span>;<br><br>\tu.province_name = <span class=\"hljs-string\">&quot;省&quot;</span>;<br>\tu.position = <span class=\"hljs-string\">&quot;位置&quot;</span>;<br><br>\tu.shcool = <span class=\"hljs-string\">&quot;大学&quot;</span>;<br>\tu.class_name = <span class=\"hljs-string\">&quot;班级&quot;</span>;<br><br>\tacl::json json;<br><br>\t<span class=\"hljs-comment\">// 将 user 对象转换为 json 对象</span><br>\tacl::json_node&amp; node = acl::<span class=\"hljs-built_in\">gson</span>(json, u);<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;serialize:\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;json: %s\\r\\n&quot;</span>, node.<span class=\"hljs-built_in\">to_string</span>().<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-comment\">// 反序列化过程</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">deserialize</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span> *s = <span class=\"hljs-string\">&quot;&#123;\\&quot;shcool\\&quot;: \\&quot;大学\\&quot;, \\&quot;class_name\\&quot;: \\&quot;班级\\&quot;, \\&quot;province_name\\&quot;: \\&quot;省\\&quot;, \\&quot;position\\&quot;: \\&quot;位置\\&quot;, \\&quot;name\\&quot;: \\&quot;zsx\\&quot;, \\&quot;age\\&quot;: 11, \\&quot;male\\&quot;: true&#125;&quot;</span>;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;deserialize:\\r\\n&quot;</span>);<br><br>\tacl::json json;<br>\tjson.<span class=\"hljs-built_in\">update</span>(s);<br>\tuser u;<br><br>\t<span class=\"hljs-comment\">// 将 json 对象转换为 user 对象</span><br>\tstd::pair&lt;<span class=\"hljs-type\">bool</span>, std::string&gt; ret = acl::<span class=\"hljs-built_in\">gson</span>(json.<span class=\"hljs-built_in\">get_root</span>(), u);<br><br>\t<span class=\"hljs-comment\">// 如果转换失败，则打印转换失败原因</span><br>\t<span class=\"hljs-keyword\">if</span> (ret.first == <span class=\"hljs-literal\">false</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;error: %s\\r\\n&quot;</span>, ret.second.<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-keyword\">else</span><br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;name: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tu.name.<span class=\"hljs-built_in\">c_str</span>(), u.age, u.male ? <span class=\"hljs-string\">&quot;yes&quot;</span> : <span class=\"hljs-string\">&quot;no&quot;</span>);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;province_name: %s, position: %s\\r\\n&quot;</span>,<br>\t\t\tu.province_name.<span class=\"hljs-built_in\">c_str</span>(), u.position.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;shcool: %s, class_name: %s\\r\\n&quot;</span>,<br>\t\t\tu.shcool.<span class=\"hljs-built_in\">c_str</span>(), u.class_name.<span class=\"hljs-built_in\">c_str</span>());<br>\t&#125;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">serialize</span>();<br>\t<span class=\"hljs-built_in\">deserialize</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>编译并运行该例子，结果如下：</p>\n<figure class=\"highlight yaml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs yaml\"><span class=\"hljs-attr\">serialize:</span><br><span class=\"hljs-attr\">json:</span> &#123;<span class=\"hljs-attr\">&quot;shcool&quot;:</span> <span class=\"hljs-string\">&quot;大学&quot;</span>, <span class=\"hljs-attr\">&quot;class_name&quot;:</span> <span class=\"hljs-string\">&quot;班级&quot;</span>, <span class=\"hljs-attr\">&quot;province_name&quot;:</span> <span class=\"hljs-string\">&quot;省&quot;</span>, <span class=\"hljs-attr\">&quot;position&quot;:</span> <span class=\"hljs-string\">&quot;位置&quot;</span>, <span class=\"hljs-attr\">&quot;name&quot;:</span> <span class=\"hljs-string\">&quot;zsx&quot;</span>, <span class=\"hljs-attr\">&quot;age&quot;:</span> <span class=\"hljs-number\">11</span>, <span class=\"hljs-attr\">&quot;male&quot;:</span> <span class=\"hljs-literal\">true</span>&#125;<br><br><span class=\"hljs-attr\">deserialize:</span><br><span class=\"hljs-attr\">name:</span> <span class=\"hljs-string\">zsx,</span> <span class=\"hljs-attr\">age:</span> <span class=\"hljs-number\">11</span><span class=\"hljs-string\">,</span> <span class=\"hljs-attr\">male:</span> <span class=\"hljs-literal\">yes</span><br><span class=\"hljs-attr\">province_name:</span> <span class=\"hljs-string\">省,</span> <span class=\"hljs-attr\">position:</span> <span class=\"hljs-string\">位置</span><br><span class=\"hljs-attr\">shcool:</span> <span class=\"hljs-string\">大学,</span> <span class=\"hljs-attr\">class_name:</span> <span class=\"hljs-string\">班级</span><br></code></pre></td></tr></table></figure>\n\n<h2 id=\"二、示例二：支持-C-11-的例子\"><a href=\"#二、示例二：支持-C-11-的例子\" class=\"headerlink\" title=\"二、示例二：支持 C++11 的例子\"></a>二、示例二：支持 C++11 的例子</h2><p> 定义 struct.stub 文件如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">pragma</span> once</span><br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">user</span><br>&#123;<br>\t<span class=\"hljs-comment\">// 带参数的构造函数</span><br>\t<span class=\"hljs-built_in\">user</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* user_name, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* user_domain,<br>\t\t<span class=\"hljs-type\">int</span> user_age, <span class=\"hljs-type\">bool</span> user_male)<br>\t: <span class=\"hljs-built_in\">username</span>(user_name)<br>\t, <span class=\"hljs-built_in\">domain</span>(user_domain)<br>\t, <span class=\"hljs-built_in\">age</span>(user_age)<br>\t, <span class=\"hljs-built_in\">male</span>(user_male)<br>\t&#123;&#125;<br><br>\t<span class=\"hljs-built_in\">user</span>() &#123;&#125;<br>\t~<span class=\"hljs-built_in\">user</span>() &#123;&#125;<br><br>\tacl::string username;<br>\tacl::string domain;<br>\t<span class=\"hljs-type\">int</span> age = <span class=\"hljs-number\">100</span>;<br>\t<span class=\"hljs-type\">bool</span> male = <span class=\"hljs-literal\">true</span>;<br>&#125;;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">message</span><br>&#123;<br>\t<span class=\"hljs-type\">int</span> type;<br>\tacl::string cmd;<br>\tstd::list&lt;user&gt; user_list;<br>\tstd::list&lt;user&gt; user_vector;<br>\tstd::map&lt;acl::string, user&gt; user_map;<br><br>\tstd::list&lt;user*&gt; *user_list_ptr = <span class=\"hljs-literal\">nullptr</span>;<br>\tstd::vector&lt;user*&gt; *user_vector_ptr = <span class=\"hljs-literal\">nullptr</span>;<br>\tstd::map&lt;acl::string, user*&gt; *user_map_ptr = <span class=\"hljs-literal\">nullptr</span>;<br><br>\t<span class=\"hljs-type\">int</span> n = <span class=\"hljs-number\">100</span>;\t\t\t\t<span class=\"hljs-comment\">// c++11 允许初始化成员变量</span><br>\t<span class=\"hljs-type\">long</span> n1 = <span class=\"hljs-number\">1000</span>;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> n2 = <span class=\"hljs-number\">1000</span>;<br>\t<span class=\"hljs-type\">short</span> n3 = <span class=\"hljs-number\">100</span>;<br>\t<span class=\"hljs-comment\">//Gson@optional</span><br>\tuser* u = <span class=\"hljs-literal\">nullptr</span>;<br><br>\t<span class=\"hljs-built_in\">message</span>() &#123;&#125;<br><br>\t~<span class=\"hljs-built_in\">message</span>()<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (user_list_ptr)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : *user_list_ptr)<br>\t\t\t\t<span class=\"hljs-keyword\">delete</span> it;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> user_list_ptr;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (user_vector_ptr)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : *user_vector_ptr)<br>\t\t\t\t<span class=\"hljs-keyword\">delete</span> it;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> user_vector_ptr;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">if</span> (user_map_ptr)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> it : *user_map_ptr)<br>\t\t\t\t<span class=\"hljs-keyword\">delete</span> it.second;<br>\t\t\t<span class=\"hljs-keyword\">delete</span> user_map_ptr;<br>\t\t&#125;<br>\t&#125;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>用 gson 工具将上述 stub 文件生成同样的三个文件：gson.cpp, gson.h, struct.h，然后编写业务处理代码如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;list&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;vector&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;map&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;stdio.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;iostream&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;time.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;struct.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;gson.h&quot;</span></span><br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">print_msg</span><span class=\"hljs-params\">(message&amp; msg)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;=======================================================\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;type: %d\\r\\n&quot;</span>, msg.type);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;cmd: %s\\r\\n&quot;</span>, msg.cmd.<span class=\"hljs-built_in\">c_str</span>());<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- user list ------------------------\\r\\n&quot;</span>);<br>\t<span class=\"hljs-type\">size_t</span> i = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : msg.user_list)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit.username.<span class=\"hljs-built_in\">c_str</span>(), cit.domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.age, cit.male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- user vector ----------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : msg.user_vector)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit.username.<span class=\"hljs-built_in\">c_str</span>(), cit.domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.age, cit.male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------------------- user map --------------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : msg.user_map)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;key: %s, username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit.first.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second.username.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second.domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second.age,<br>\t\t\tcit.second.male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- user list ptr --------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : *msg.user_list_ptr)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit-&gt;username.<span class=\"hljs-built_in\">c_str</span>(), cit-&gt;domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit-&gt;age, cit-&gt;male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------- user vector ptr ------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : *msg.user_vector_ptr)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit-&gt;username.<span class=\"hljs-built_in\">c_str</span>(), cit-&gt;domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit-&gt;age, cit-&gt;male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;------------------- user map ptr ----------------------\\r\\n&quot;</span>);<br>\ti = <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-keyword\">for</span> (<span class=\"hljs-keyword\">auto</span> cit : *msg.user_map_ptr)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;&gt;&gt;key: %s, username: %s, domain: %s, age: %d, male: %s\\r\\n&quot;</span>,<br>\t\t\tcit.first.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second-&gt;username.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second-&gt;domain.<span class=\"hljs-built_in\">c_str</span>(),<br>\t\t\tcit.second-&gt;age,<br>\t\t\tcit.second-&gt;male ? <span class=\"hljs-string\">&quot;true&quot;</span> : <span class=\"hljs-string\">&quot;false&quot;</span>);<br>\t\t<span class=\"hljs-keyword\">if</span> (++i &gt;= <span class=\"hljs-number\">10</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;-------------------------------------------------------\\r\\n&quot;</span>);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">test</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////</span><br>\t<span class=\"hljs-comment\">// 序列化过程</span><br><br>\tmessage msg;<br>\tmsg.user_list_ptr   = <span class=\"hljs-keyword\">new</span> std::list&lt;user*&gt;;<br>\tmsg.user_vector_ptr = <span class=\"hljs-keyword\">new</span> std::vector&lt;user*&gt;;<br>\tmsg.user_map_ptr    = <span class=\"hljs-keyword\">new</span> std::map&lt;acl::string, user*&gt;;<br><br>\tmsg.type = <span class=\"hljs-number\">1</span>;<br>\tmsg.cmd  = <span class=\"hljs-string\">&quot;add&quot;</span>;<br><br>\tuser u = &#123;<span class=\"hljs-string\">&quot;zsx1&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>&#125;;<br>\tmsg.user_list.<span class=\"hljs-built_in\">push_back</span>(u);<br>\tmsg.user_list.<span class=\"hljs-built_in\">emplace_back</span>(u);<br>\tmsg.user_list.<span class=\"hljs-built_in\">emplace_back</span>(<span class=\"hljs-string\">&quot;zsx1&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">13</span>, <span class=\"hljs-literal\">false</span>);<br><br>\tu = &#123;<span class=\"hljs-string\">&quot;zsx2&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>&#125;;<br>\tmsg.user_vector.<span class=\"hljs-built_in\">push_back</span>(u);<br>\tmsg.user_vector.<span class=\"hljs-built_in\">emplace_back</span>(u);<br>\tmsg.user_vector.<span class=\"hljs-built_in\">emplace_back</span>(<span class=\"hljs-string\">&quot;zsx2&quot;</span>, <span class=\"hljs-string\">&quot;263.net4&quot;</span>, <span class=\"hljs-number\">14</span>, <span class=\"hljs-literal\">true</span>);<br><br>\tu = &#123;<span class=\"hljs-string\">&quot;zsx31&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>&#125;;<br>\tmsg.user_map[u.username] = u;<br>\tmsg.user_map[<span class=\"hljs-string\">&quot;zsx32&quot;</span>] = &#123;<span class=\"hljs-string\">&quot;zsx32&quot;</span>, <span class=\"hljs-string\">&quot;263.net&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span> &#125;;<br><br>\tmsg.user_list_ptr-&gt;<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx4&quot;</span>, <span class=\"hljs-string\">&quot;263.net1&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>));<br>\tmsg.user_list_ptr-&gt;<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx4&quot;</span>, <span class=\"hljs-string\">&quot;263.net2&quot;</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-literal\">true</span>));<br><br>\tmsg.user_vector_ptr-&gt;<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx5&quot;</span>, <span class=\"hljs-string\">&quot;263.net1&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>));<br>\tmsg.user_vector_ptr-&gt;<span class=\"hljs-built_in\">push_back</span>(<span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx5&quot;</span>, <span class=\"hljs-string\">&quot;263.net2&quot;</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-literal\">true</span>));<br><br>\t(*msg.user_map_ptr)[<span class=\"hljs-string\">&quot;zsx61&quot;</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx61:&quot;</span>, <span class=\"hljs-string\">&quot;263.net1&quot;</span>, <span class=\"hljs-number\">11</span>, <span class=\"hljs-literal\">true</span>);<br>\t(*msg.user_map_ptr)[<span class=\"hljs-string\">&quot;zsx62&quot;</span>] = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">user</span>(<span class=\"hljs-string\">&quot;zsx62&quot;</span>, <span class=\"hljs-string\">&quot;263.net2&quot;</span>, <span class=\"hljs-number\">12</span>, <span class=\"hljs-literal\">true</span>);<br><br>\tacl::json json;<br><br>\t<span class=\"hljs-comment\">// 序列化</span><br>\tacl::json_node&amp; node = acl::<span class=\"hljs-built_in\">gson</span>(json, msg);<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;serialize: %s\\r\\n&quot;</span>, node.<span class=\"hljs-built_in\">to_string</span>().<span class=\"hljs-built_in\">c_str</span>());<br><br>\t<span class=\"hljs-comment\">/////////////////////////////////////////////////////////////////////</span><br>\t<span class=\"hljs-comment\">// 反序列化过程</span><br><br>\tmessage msg1;<br>\tacl::json json1;<br>\tjson1.<span class=\"hljs-built_in\">update</span>(node.<span class=\"hljs-built_in\">to_string</span>());<br><br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;json1 to_string: %s\\r\\n&quot;</span>, json1.<span class=\"hljs-built_in\">to_string</span>().<span class=\"hljs-built_in\">c_str</span>());<br><br>\t<span class=\"hljs-comment\">// 反序列化</span><br>\tstd::pair&lt;<span class=\"hljs-type\">bool</span>, std::string&gt; ret = acl::<span class=\"hljs-built_in\">gson</span>(json1.<span class=\"hljs-built_in\">get_root</span>(), msg1);<br>\t<span class=\"hljs-keyword\">if</span> (ret.first == <span class=\"hljs-literal\">false</span>)<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;error: %s\\r\\n&quot;</span>, ret.second.<span class=\"hljs-built_in\">c_str</span>());<br>\t<span class=\"hljs-keyword\">else</span><br>\t\t<span class=\"hljs-built_in\">print_msg</span>(msg);<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">test</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br><br>       上述例子主要体现了 gson 的两个特点：<span class=\"hljs-number\">1</span>、允许有构造函数，<span class=\"hljs-number\">2</span>、支持 C++<span class=\"hljs-number\">11</span> 中的结构成员初始化。<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、参考\"><a href=\"#三、参考\" class=\"headerlink\" title=\"三、参考\"></a>三、参考</h2><p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"acl_cpp 的 rpc 相关类整合阻塞及非阻塞过程","date":"2012-07-13T15:03:00.000Z","_content":"\n## 一、概述\n\n非阻塞网络编程无疑成了高并发、高性能编程的代名词，但现实应用编程中并不是每种应用都需要采用非阻塞编程模式，因为这将大大增加编程的复杂性、开发周期以及出错率，所以我们写的绝大部分网络程序程序都是阻塞的，一般是一个进程一个网络连接或一个线程一个网络连接。即然非阻塞模式可以实现高并发网络连接，阻塞模式可以实现复杂的业务逻辑，那是否有办法将二者结合起来呢？答案是肯定的，其中在 acl_cpp 库中，ipc 目录下的模块就是为了满足这种需求而设计的。\n\n## 二、接口设计\n\n在 rpc.hpp 头文件中有两个类：rpc_service 和 rpc_request，其中 rpc_request 是一个纯虚类，用户需要继承此类并实现该类中规定的纯虚接口，从而实现自己的阻塞操作功能；rpc_service 是阻塞与非阻塞结合的粘合类，通过将 rpc_request 子类实例传递给 rpc_service 类实例的 rpc_fork 方法，实现将阻塞请求过程交给子线程处理的目的。\n\n### 1、rpc_service 类\n\n#### 1.1、构造函数：\n```c++\n\t/**\n\t * 构造函数\n\t * @param nthread {int} 如果该值 > 1 则内部自动采用线程池，否则\n\t *  则是一个请求一个线程\n\t * @param win32_gui {bool} 是否是窗口类的消息，如果是，则内部的\n\t *  通讯模式自动设置为基于 WIN32 的消息，否则依然采用通用的套接\n\t *  口通讯方式\n\t */\n\trpc_service(int nthread, bool win32_gui = false)\n```\n\n从参数 win32_gui 可以看出，acl_cpp 的阻塞/非阻塞结合模式不仅可以用在通常的网络编程中，同时还可以用在阻塞过程与 WINDOWS 界面消息相结合的方面，这无非是经常用 MFC 进行界面编程的福音（例如，用户 VC 写了一个界面程序---当然这个界面窗口是基于 WIN32 消息的，但如果想进行一些数据库操作或文件下载操作，对用户而言阻塞式方法是非常容易实现这两类需求的，但 WIN32 的界面过程不能堵在任何一个数据库操作或文件下载过程，原来 VC 程序员通常的做法也是创建单独的线程进行阻塞操作，然后通过给主窗口传递消息将操作结果通知至主线程，幸运的是 acl_cpp 的 rpc 相关类可以使这一过程更为方便快捷；再如，你写的一个网络服务器程序的主线程是非阻塞的，但其中你不得不调用别人提供的库以实现用户身份验证的功能，同时这个用于用户认证的库又恰恰是阻塞的---一般也是如此，固然，你也许可以费很周折实现这一过程，同样，acl_cpp 的 rpc 相关类可以帮你解决这类问题）。\n\n#### 1.2、将阻塞处理过程的对象交由子线程处理：\n```c++\n\t/**\n\t * 主线程中运行：将请求任务放入子线程池的任务请求队列中，当线程池\n\t * 中的一个子线程接收到该任务后便调用 rpc_request::rpc_run 方法调\n\t * 用子类的方法，当任务处理完毕后给主线程发消息，在主线程中再调用\n\t * rpc_request::rpc_callback\n\t * @param req {rpc_request*} rpc_request 子类实例，非空\n\t */\n\tvoid rpc_fork(rpc_request* req);\n```\n\n通过此接口，可以将阻塞请求过程交给子线程处理，子线程处理完后再通知主线程。\n\n### 2、rpc_request 类\n\n在类 rpc_request 中有三个虚接口，用户子类必须实现其中的两个纯虚接口：rpc_run 和 rpc_onover，同时用户可以根据需要实现另一非纯虚接口：rpc_wakeup。是当用户调完 rpc_service::rpc_fork 且子线程接收到此请求任务后 rpc_request::rpc_run 方法会被调用（一定切记：rpc_fork 是在主线程中被调用的，而 rpc_run 是在子线程中被调用的）；当 rpc_request::rpc_run 函数返回后，rpc_reuqest::rpc_onover 会在主线程中被调用以表示子线程已经处理完毕（同样需要严重注意：rpc_request::rpc_onover 方法又回到主线程中被调用），这样，通过这两个过程就实现了将阻塞过程放在子线程中处理，主线程的非阻塞过程（非阻塞网络事件或非阻塞的 WIN32 消息过程）异步地等待子线程完成任务。\n\n```c++\n\t/**\n\t * 在子线程中被调用，子类必须实现此接口，用于处理具体任务\n\t */\n\tvirtual void rpc_run(void) = 0;\n\n\t/**\n\t * 在主线程中被调用，子类必须实现此接口，\n\t * 当子线程处理完请求任务后该接口将被调用，所以该类对象只能\n\t * 是当本接口调用后才能被释放，禁止在调用本接口前释放本类对象\n\t */\n\tvirtual void rpc_onover(void) = 0;\n```\n\n另外，在 rpc_request 类中还有一个非纯虚方法：rpc_wakeup，这是做什么用的呢？可以假设这种应用场景，在子线程中调用 rpc_request::rpc_run 方法内部过程中，用户如果需要通知主线程一些中间状态（比如，文件下载的进度）该怎么办？那就在 rpc_run 方法内先调用 rpc_request::rpc_signal 通知主线程子线程处理的中间状态，则在主线程中用户实现的 rpc_request::rpc_wakeup 虚接口就会被调用。下面是 rpc_signal 和 rpc_wakeup 的接口说明：\n\n```c++\n\t/**\n\t * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息\n\t * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的\n\t * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法\n\t * @param ctx {void*} 传递的参数指针，一般应该是动态地址\n\t *  比较好，这样可以避免同一个参数被重复覆盖的问题\n\t */\n\tvoid rpc_signal(void* ctx);\n\n\t/**\n\t * 虚接口：当子线程调用本对象的 rpc_signal 时，在主线程中会\n\t * 调用本接口，通知在任务未完成前(即调用 rpc_onover 前)收到\n\t * 子线程运行的中间状态信息；内部自动支持套接口或 WIN32 窗口\n\t * 消息；应用场景，例如，对于 HTTP 下载应用，在子线程中可以\n\t * 一边下载，一边向主线程发送(调用 rpc_signal 方法)下载进程，\n\t * 则主线程会调用本类实例的此方法来处理此消息\n\t */\n\tvirtual void rpc_wakeup(void* ctx) { (void) ctx; }\n```\n\n紧接着这个应用场景，假设在子线程调用 rpc_run 的内部通过 rpc_signal 通知主线程的中间状态后，希望主线程能收到此通知消息并且希望得到主线程下一步希望执行的指令才会进一步继续执行。于是便有了 rpc_request::cond_wait 和 rpc_request::cond_signal 两个方法的产生，即子线程通过 cond_wait 阻塞地等待主线程的下一步操作指令，主线程则调用 cond_signal 通知子线程下步指令，下面是这两个方法的说明：\n\n```c++\n\t/**\n\t * 当子线程调用 rpc_signal 给主线程后，调用本方法可以等待\n\t * 主线程发来下一步指令\n\t * @param timeout {int} 等待超时时间(毫秒)，当该值为 0 时\n\t *  则采用非阻塞等待模式，当该值为 < 0 时，则采用完全阻塞\n\t *  等待模式(即一直等到主线程发送 cond_signal 通知)，当该\n\t *  值 > 0 时，则等待的最大超时时间为 timeout 毫秒\n\t * @return {bool} 返回 true 表示收到主线程发来的通知信号，\n\t *  否则，需要调用 cond_wait_timeout 判断是否是超时引起的\n\t */\n\tbool cond_wait(int timeout = -1);\n\n\t/**\n\t * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息\n\t * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的\n\t * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法\n\t * @param ctx {void*} 传递的参数指针，一般应该是动态地址\n\t *  比较好，这样可以避免同一个参数被重复覆盖的问题\n\t */\n\tvoid rpc_signal(void* ctx);\n```\n\n## 三、示例\n\n如果您能大体明白上面有关 rpc_service 和 rpc_request 类的功能说明，相信下面的例子您也一定能看明白：\n\n```c++\n// rpc_download.cpp : 定义控制台应用程序的入口点。\n//\n\n#include \"stdafx.h\"\n#include <assert.h>\n#include \"lib_acl.hpp\"\n\nusing namespace acl;\n\ntypedef enum\n{\n\tCTX_T_CONTENT_LENGTH,\n\tCTX_T_PARTIAL_LENGTH,\n\tCTX_T_END\n} ctx_t;\n\nstruct DOWN_CTX \n{\n\tctx_t type;\n\tint length;\n};\n\nstatic int __download_count = 0;\n\nclass http_download : public rpc_request\n{\npublic:\n\thttp_download(aio_handle& handle, const char* addr, const char* url)\n\t\t: handle_(handle)\n\t\t, addr_(addr)\n\t\t, url_(url)\n\t\t, error_(false)\n\t\t, total_read_(0)\n\t\t, content_length_(0)\n\t{}\n\t~http_download() {}\nprotected:\n\n\t// 子线程处理函数\n\tvoid rpc_run()\n\t{\n\t\thttp_request req(addr_);  // HTTP 请求对象\n\n\t\t// 设置 HTTP 请求头信息\n\t\treq.request_header().set_url(url_.c_str())\n\t\t\t.set_content_type(\"text/html\")\n\t\t\t.set_host(addr_.c_str())\n\t\t\t.set_method(HTTP_METHOD_GET);\n\n\t\t// 测试用，显示 HTTP 请求头信息内容\n\t\tstring header;\n\t\treq.request_header().build_request(header);\n\t\tprintf(\"request: %s\\r\\n\", header.c_str());\n\n\t\t// 发送 HTTP 请求数据\n\t\tif (req.request(NULL, 0) == false)\n\t\t{\n\t\t\tprintf(\"send request error\\r\\n\");\n\t\t\terror_ = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// 获得 HTTP 请求的连接对象\n\t\thttp_client* conn = req.get_client();\n\t\tassert(conn);\n\t\tDOWN_CTX* ctx = new DOWN_CTX;\n\t\tctx->type = CTX_T_CONTENT_LENGTH;\n\n\t\t// 获得 HTTP 响应数据的数据体长度\n\t\tctx->length = (int) conn->body_length();\n\t\tcontent_length_ = ctx->length;\n\n\t\t// 通知主线程\n\t\trpc_signal(ctx);\n\n\t\tchar buf[8192];\n\t\twhile (true)\n\t\t{\n\t\t\t// 读 HTTP 响应数据体\n\t\t\tint ret = req.get_body(buf, sizeof(buf));\n\t\t\tif (ret <= 0)\n\t\t\t{\n\t\t\t\tctx = new DOWN_CTX;\n\t\t\t\tctx->type = CTX_T_END;\n\t\t\t\tctx->length = ret;\n\t\t\t\t// 通知主线程\n\t\t\t\trpc_signal(ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tctx = new DOWN_CTX;\n\t\t\tctx->type = CTX_T_PARTIAL_LENGTH;\n\t\t\tctx->length = ret;\n\t\t\t// 通知主线程\n\t\t\trpc_signal(ctx);\n\t\t}\n\t}\n\n\t// 主线程处理过程，收到子线程任务完成的消息\n\tvoid rpc_onover()\n\t{\n\t\tprintf(\"%s: read over now, total read: %d, content-length: %d\\r\\n\",\n\t\t\taddr_.c_str(), total_read_, content_length_);\n\n\t\t// 当 HTTP 响应都完成时，通知主线程停止事件循环过程\n\t\t__download_count--;\n\t\tif (__download_count == 0)\n\t\t\thandle_.stop();\n\t}\n\n\t// 主线程处理过程，收到子线程的通知消息\n\tvoid rpc_wakeup(void* ctx)\n\t{\n\t\tDOWN_CTX* down_ctx = (DOWN_CTX*) ctx;\n\t\tswitch (down_ctx->type)\n\t\t{\n\t\tcase CTX_T_CONTENT_LENGTH:\n\t\t\tprintf(\"%s: content-length: %d\\r\\n\",\n\t\t\t\taddr_.c_str(), down_ctx->length);\n\t\t\tbreak;\n\t\tcase CTX_T_PARTIAL_LENGTH:\n\t\t\ttotal_read_ += down_ctx->length;\n\t\t\tprintf(\"%s: partial-length: %d, total read: %d\\r\\n\",\n\t\t\t\taddr_.c_str(), down_ctx->length, total_read_);\n\t\t\tbreak;\n\t\tcase CTX_T_END:\n\t\t\tprintf(\"%s: read over\\r\\n\", addr_.c_str());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"%s: ERROR\\r\\n\", addr_.c_str());\n\t\t\tbreak;\n\t\t}\n\t\tdelete down_ctx;\n\t}\nprivate:\n\taio_handle& handle_;\n\tstring addr_;\n\tstring url_;\n\tbool  error_;\n\tint   total_read_;\n\tint   content_length_;\n};\n\nstatic void run(void)\n{\n\taio_handle handle;\n\trpc_service* service = new rpc_service(10);  // 创建 rpc 服务对象\n\n\t// 打开消息服务器\n\tif (service->open(&handle) == false)\n\t{\n\t\tprintf(\"open service error: %s\\r\\n\", last_serror());\n\t\treturn;\n\t}\n\n\t// 下载页面内容\n\n\thttp_download down1(handle, \"www.sina.com.cn:80\", \"http://www.sina.com.cn/\");\n\tservice->rpc_fork(&down1);  // 发起一个阻塞会话过程\n\t__download_count++;\n\n\thttp_download down2(handle, \"www.hexun.com:80\", \"/\");\n\tservice->rpc_fork(&down2);  // 发起第二个阻塞会话过程\n\t__download_count++;\n\n\t// 异步事件循环过程\n\twhile (true)\n\t{\n\t\tif (handle.check() == false)\n\t\t\tbreak;\n\t}\n\n\tdelete service;\n\thandle.check(); // 保证释放所有延迟关闭的异步对象\n}\n\nint main(void)\n{\n#ifdef WIN32\n\tacl_cpp_init();\n#endif\n\n\trun();\n\tprintf(\"Enter any key to continue\\r\\n\");\n\tgetchar();\n\treturn 0;\n}\n```\n\nacl 下载:\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","source":"_posts/aio_rpc.md","raw":"---\ntitle: acl_cpp 的 rpc 相关类整合阻塞及非阻塞过程\ndate: 2012-07-13 23:03\ncategories: 非阻塞编程\n---\n\n## 一、概述\n\n非阻塞网络编程无疑成了高并发、高性能编程的代名词，但现实应用编程中并不是每种应用都需要采用非阻塞编程模式，因为这将大大增加编程的复杂性、开发周期以及出错率，所以我们写的绝大部分网络程序程序都是阻塞的，一般是一个进程一个网络连接或一个线程一个网络连接。即然非阻塞模式可以实现高并发网络连接，阻塞模式可以实现复杂的业务逻辑，那是否有办法将二者结合起来呢？答案是肯定的，其中在 acl_cpp 库中，ipc 目录下的模块就是为了满足这种需求而设计的。\n\n## 二、接口设计\n\n在 rpc.hpp 头文件中有两个类：rpc_service 和 rpc_request，其中 rpc_request 是一个纯虚类，用户需要继承此类并实现该类中规定的纯虚接口，从而实现自己的阻塞操作功能；rpc_service 是阻塞与非阻塞结合的粘合类，通过将 rpc_request 子类实例传递给 rpc_service 类实例的 rpc_fork 方法，实现将阻塞请求过程交给子线程处理的目的。\n\n### 1、rpc_service 类\n\n#### 1.1、构造函数：\n```c++\n\t/**\n\t * 构造函数\n\t * @param nthread {int} 如果该值 > 1 则内部自动采用线程池，否则\n\t *  则是一个请求一个线程\n\t * @param win32_gui {bool} 是否是窗口类的消息，如果是，则内部的\n\t *  通讯模式自动设置为基于 WIN32 的消息，否则依然采用通用的套接\n\t *  口通讯方式\n\t */\n\trpc_service(int nthread, bool win32_gui = false)\n```\n\n从参数 win32_gui 可以看出，acl_cpp 的阻塞/非阻塞结合模式不仅可以用在通常的网络编程中，同时还可以用在阻塞过程与 WINDOWS 界面消息相结合的方面，这无非是经常用 MFC 进行界面编程的福音（例如，用户 VC 写了一个界面程序---当然这个界面窗口是基于 WIN32 消息的，但如果想进行一些数据库操作或文件下载操作，对用户而言阻塞式方法是非常容易实现这两类需求的，但 WIN32 的界面过程不能堵在任何一个数据库操作或文件下载过程，原来 VC 程序员通常的做法也是创建单独的线程进行阻塞操作，然后通过给主窗口传递消息将操作结果通知至主线程，幸运的是 acl_cpp 的 rpc 相关类可以使这一过程更为方便快捷；再如，你写的一个网络服务器程序的主线程是非阻塞的，但其中你不得不调用别人提供的库以实现用户身份验证的功能，同时这个用于用户认证的库又恰恰是阻塞的---一般也是如此，固然，你也许可以费很周折实现这一过程，同样，acl_cpp 的 rpc 相关类可以帮你解决这类问题）。\n\n#### 1.2、将阻塞处理过程的对象交由子线程处理：\n```c++\n\t/**\n\t * 主线程中运行：将请求任务放入子线程池的任务请求队列中，当线程池\n\t * 中的一个子线程接收到该任务后便调用 rpc_request::rpc_run 方法调\n\t * 用子类的方法，当任务处理完毕后给主线程发消息，在主线程中再调用\n\t * rpc_request::rpc_callback\n\t * @param req {rpc_request*} rpc_request 子类实例，非空\n\t */\n\tvoid rpc_fork(rpc_request* req);\n```\n\n通过此接口，可以将阻塞请求过程交给子线程处理，子线程处理完后再通知主线程。\n\n### 2、rpc_request 类\n\n在类 rpc_request 中有三个虚接口，用户子类必须实现其中的两个纯虚接口：rpc_run 和 rpc_onover，同时用户可以根据需要实现另一非纯虚接口：rpc_wakeup。是当用户调完 rpc_service::rpc_fork 且子线程接收到此请求任务后 rpc_request::rpc_run 方法会被调用（一定切记：rpc_fork 是在主线程中被调用的，而 rpc_run 是在子线程中被调用的）；当 rpc_request::rpc_run 函数返回后，rpc_reuqest::rpc_onover 会在主线程中被调用以表示子线程已经处理完毕（同样需要严重注意：rpc_request::rpc_onover 方法又回到主线程中被调用），这样，通过这两个过程就实现了将阻塞过程放在子线程中处理，主线程的非阻塞过程（非阻塞网络事件或非阻塞的 WIN32 消息过程）异步地等待子线程完成任务。\n\n```c++\n\t/**\n\t * 在子线程中被调用，子类必须实现此接口，用于处理具体任务\n\t */\n\tvirtual void rpc_run(void) = 0;\n\n\t/**\n\t * 在主线程中被调用，子类必须实现此接口，\n\t * 当子线程处理完请求任务后该接口将被调用，所以该类对象只能\n\t * 是当本接口调用后才能被释放，禁止在调用本接口前释放本类对象\n\t */\n\tvirtual void rpc_onover(void) = 0;\n```\n\n另外，在 rpc_request 类中还有一个非纯虚方法：rpc_wakeup，这是做什么用的呢？可以假设这种应用场景，在子线程中调用 rpc_request::rpc_run 方法内部过程中，用户如果需要通知主线程一些中间状态（比如，文件下载的进度）该怎么办？那就在 rpc_run 方法内先调用 rpc_request::rpc_signal 通知主线程子线程处理的中间状态，则在主线程中用户实现的 rpc_request::rpc_wakeup 虚接口就会被调用。下面是 rpc_signal 和 rpc_wakeup 的接口说明：\n\n```c++\n\t/**\n\t * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息\n\t * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的\n\t * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法\n\t * @param ctx {void*} 传递的参数指针，一般应该是动态地址\n\t *  比较好，这样可以避免同一个参数被重复覆盖的问题\n\t */\n\tvoid rpc_signal(void* ctx);\n\n\t/**\n\t * 虚接口：当子线程调用本对象的 rpc_signal 时，在主线程中会\n\t * 调用本接口，通知在任务未完成前(即调用 rpc_onover 前)收到\n\t * 子线程运行的中间状态信息；内部自动支持套接口或 WIN32 窗口\n\t * 消息；应用场景，例如，对于 HTTP 下载应用，在子线程中可以\n\t * 一边下载，一边向主线程发送(调用 rpc_signal 方法)下载进程，\n\t * 则主线程会调用本类实例的此方法来处理此消息\n\t */\n\tvirtual void rpc_wakeup(void* ctx) { (void) ctx; }\n```\n\n紧接着这个应用场景，假设在子线程调用 rpc_run 的内部通过 rpc_signal 通知主线程的中间状态后，希望主线程能收到此通知消息并且希望得到主线程下一步希望执行的指令才会进一步继续执行。于是便有了 rpc_request::cond_wait 和 rpc_request::cond_signal 两个方法的产生，即子线程通过 cond_wait 阻塞地等待主线程的下一步操作指令，主线程则调用 cond_signal 通知子线程下步指令，下面是这两个方法的说明：\n\n```c++\n\t/**\n\t * 当子线程调用 rpc_signal 给主线程后，调用本方法可以等待\n\t * 主线程发来下一步指令\n\t * @param timeout {int} 等待超时时间(毫秒)，当该值为 0 时\n\t *  则采用非阻塞等待模式，当该值为 < 0 时，则采用完全阻塞\n\t *  等待模式(即一直等到主线程发送 cond_signal 通知)，当该\n\t *  值 > 0 时，则等待的最大超时时间为 timeout 毫秒\n\t * @return {bool} 返回 true 表示收到主线程发来的通知信号，\n\t *  否则，需要调用 cond_wait_timeout 判断是否是超时引起的\n\t */\n\tbool cond_wait(int timeout = -1);\n\n\t/**\n\t * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息\n\t * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的\n\t * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法\n\t * @param ctx {void*} 传递的参数指针，一般应该是动态地址\n\t *  比较好，这样可以避免同一个参数被重复覆盖的问题\n\t */\n\tvoid rpc_signal(void* ctx);\n```\n\n## 三、示例\n\n如果您能大体明白上面有关 rpc_service 和 rpc_request 类的功能说明，相信下面的例子您也一定能看明白：\n\n```c++\n// rpc_download.cpp : 定义控制台应用程序的入口点。\n//\n\n#include \"stdafx.h\"\n#include <assert.h>\n#include \"lib_acl.hpp\"\n\nusing namespace acl;\n\ntypedef enum\n{\n\tCTX_T_CONTENT_LENGTH,\n\tCTX_T_PARTIAL_LENGTH,\n\tCTX_T_END\n} ctx_t;\n\nstruct DOWN_CTX \n{\n\tctx_t type;\n\tint length;\n};\n\nstatic int __download_count = 0;\n\nclass http_download : public rpc_request\n{\npublic:\n\thttp_download(aio_handle& handle, const char* addr, const char* url)\n\t\t: handle_(handle)\n\t\t, addr_(addr)\n\t\t, url_(url)\n\t\t, error_(false)\n\t\t, total_read_(0)\n\t\t, content_length_(0)\n\t{}\n\t~http_download() {}\nprotected:\n\n\t// 子线程处理函数\n\tvoid rpc_run()\n\t{\n\t\thttp_request req(addr_);  // HTTP 请求对象\n\n\t\t// 设置 HTTP 请求头信息\n\t\treq.request_header().set_url(url_.c_str())\n\t\t\t.set_content_type(\"text/html\")\n\t\t\t.set_host(addr_.c_str())\n\t\t\t.set_method(HTTP_METHOD_GET);\n\n\t\t// 测试用，显示 HTTP 请求头信息内容\n\t\tstring header;\n\t\treq.request_header().build_request(header);\n\t\tprintf(\"request: %s\\r\\n\", header.c_str());\n\n\t\t// 发送 HTTP 请求数据\n\t\tif (req.request(NULL, 0) == false)\n\t\t{\n\t\t\tprintf(\"send request error\\r\\n\");\n\t\t\terror_ = false;\n\t\t\treturn;\n\t\t}\n\n\t\t// 获得 HTTP 请求的连接对象\n\t\thttp_client* conn = req.get_client();\n\t\tassert(conn);\n\t\tDOWN_CTX* ctx = new DOWN_CTX;\n\t\tctx->type = CTX_T_CONTENT_LENGTH;\n\n\t\t// 获得 HTTP 响应数据的数据体长度\n\t\tctx->length = (int) conn->body_length();\n\t\tcontent_length_ = ctx->length;\n\n\t\t// 通知主线程\n\t\trpc_signal(ctx);\n\n\t\tchar buf[8192];\n\t\twhile (true)\n\t\t{\n\t\t\t// 读 HTTP 响应数据体\n\t\t\tint ret = req.get_body(buf, sizeof(buf));\n\t\t\tif (ret <= 0)\n\t\t\t{\n\t\t\t\tctx = new DOWN_CTX;\n\t\t\t\tctx->type = CTX_T_END;\n\t\t\t\tctx->length = ret;\n\t\t\t\t// 通知主线程\n\t\t\t\trpc_signal(ctx);\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tctx = new DOWN_CTX;\n\t\t\tctx->type = CTX_T_PARTIAL_LENGTH;\n\t\t\tctx->length = ret;\n\t\t\t// 通知主线程\n\t\t\trpc_signal(ctx);\n\t\t}\n\t}\n\n\t// 主线程处理过程，收到子线程任务完成的消息\n\tvoid rpc_onover()\n\t{\n\t\tprintf(\"%s: read over now, total read: %d, content-length: %d\\r\\n\",\n\t\t\taddr_.c_str(), total_read_, content_length_);\n\n\t\t// 当 HTTP 响应都完成时，通知主线程停止事件循环过程\n\t\t__download_count--;\n\t\tif (__download_count == 0)\n\t\t\thandle_.stop();\n\t}\n\n\t// 主线程处理过程，收到子线程的通知消息\n\tvoid rpc_wakeup(void* ctx)\n\t{\n\t\tDOWN_CTX* down_ctx = (DOWN_CTX*) ctx;\n\t\tswitch (down_ctx->type)\n\t\t{\n\t\tcase CTX_T_CONTENT_LENGTH:\n\t\t\tprintf(\"%s: content-length: %d\\r\\n\",\n\t\t\t\taddr_.c_str(), down_ctx->length);\n\t\t\tbreak;\n\t\tcase CTX_T_PARTIAL_LENGTH:\n\t\t\ttotal_read_ += down_ctx->length;\n\t\t\tprintf(\"%s: partial-length: %d, total read: %d\\r\\n\",\n\t\t\t\taddr_.c_str(), down_ctx->length, total_read_);\n\t\t\tbreak;\n\t\tcase CTX_T_END:\n\t\t\tprintf(\"%s: read over\\r\\n\", addr_.c_str());\n\t\t\tbreak;\n\t\tdefault:\n\t\t\tprintf(\"%s: ERROR\\r\\n\", addr_.c_str());\n\t\t\tbreak;\n\t\t}\n\t\tdelete down_ctx;\n\t}\nprivate:\n\taio_handle& handle_;\n\tstring addr_;\n\tstring url_;\n\tbool  error_;\n\tint   total_read_;\n\tint   content_length_;\n};\n\nstatic void run(void)\n{\n\taio_handle handle;\n\trpc_service* service = new rpc_service(10);  // 创建 rpc 服务对象\n\n\t// 打开消息服务器\n\tif (service->open(&handle) == false)\n\t{\n\t\tprintf(\"open service error: %s\\r\\n\", last_serror());\n\t\treturn;\n\t}\n\n\t// 下载页面内容\n\n\thttp_download down1(handle, \"www.sina.com.cn:80\", \"http://www.sina.com.cn/\");\n\tservice->rpc_fork(&down1);  // 发起一个阻塞会话过程\n\t__download_count++;\n\n\thttp_download down2(handle, \"www.hexun.com:80\", \"/\");\n\tservice->rpc_fork(&down2);  // 发起第二个阻塞会话过程\n\t__download_count++;\n\n\t// 异步事件循环过程\n\twhile (true)\n\t{\n\t\tif (handle.check() == false)\n\t\t\tbreak;\n\t}\n\n\tdelete service;\n\thandle.check(); // 保证释放所有延迟关闭的异步对象\n}\n\nint main(void)\n{\n#ifdef WIN32\n\tacl_cpp_init();\n#endif\n\n\trun();\n\tprintf(\"Enter any key to continue\\r\\n\");\n\tgetchar();\n\treturn 0;\n}\n```\n\nacl 下载:\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl","slug":"aio_rpc","published":1,"updated":"2023-01-24T10:19:53.783Z","_id":"clda31jzw000f8o9kegech7rr","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>非阻塞网络编程无疑成了高并发、高性能编程的代名词，但现实应用编程中并不是每种应用都需要采用非阻塞编程模式，因为这将大大增加编程的复杂性、开发周期以及出错率，所以我们写的绝大部分网络程序程序都是阻塞的，一般是一个进程一个网络连接或一个线程一个网络连接。即然非阻塞模式可以实现高并发网络连接，阻塞模式可以实现复杂的业务逻辑，那是否有办法将二者结合起来呢？答案是肯定的，其中在 acl_cpp 库中，ipc 目录下的模块就是为了满足这种需求而设计的。</p>\n<h2 id=\"二、接口设计\"><a href=\"#二、接口设计\" class=\"headerlink\" title=\"二、接口设计\"></a>二、接口设计</h2><p>在 rpc.hpp 头文件中有两个类：rpc_service 和 rpc_request，其中 rpc_request 是一个纯虚类，用户需要继承此类并实现该类中规定的纯虚接口，从而实现自己的阻塞操作功能；rpc_service 是阻塞与非阻塞结合的粘合类，通过将 rpc_request 子类实例传递给 rpc_service 类实例的 rpc_fork 方法，实现将阻塞请求过程交给子线程处理的目的。</p>\n<h3 id=\"1、rpc-service-类\"><a href=\"#1、rpc-service-类\" class=\"headerlink\" title=\"1、rpc_service 类\"></a>1、rpc_service 类</h3><h4 id=\"1-1、构造函数：\"><a href=\"#1-1、构造函数：\" class=\"headerlink\" title=\"1.1、构造函数：\"></a>1.1、构造函数：</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构造函数</span><br><span class=\"hljs-comment\"> * @param nthread &#123;int&#125; 如果该值 &gt; 1 则内部自动采用线程池，否则</span><br><span class=\"hljs-comment\"> *  则是一个请求一个线程</span><br><span class=\"hljs-comment\"> * @param win32_gui &#123;bool&#125; 是否是窗口类的消息，如果是，则内部的</span><br><span class=\"hljs-comment\"> *  通讯模式自动设置为基于 WIN32 的消息，否则依然采用通用的套接</span><br><span class=\"hljs-comment\"> *  口通讯方式</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">rpc_service</span>(<span class=\"hljs-type\">int</span> nthread, <span class=\"hljs-type\">bool</span> win32_gui = <span class=\"hljs-literal\">false</span>)<br></code></pre></td></tr></table></figure>\n\n<p>从参数 win32_gui 可以看出，acl_cpp 的阻塞&#x2F;非阻塞结合模式不仅可以用在通常的网络编程中，同时还可以用在阻塞过程与 WINDOWS 界面消息相结合的方面，这无非是经常用 MFC 进行界面编程的福音（例如，用户 VC 写了一个界面程序—当然这个界面窗口是基于 WIN32 消息的，但如果想进行一些数据库操作或文件下载操作，对用户而言阻塞式方法是非常容易实现这两类需求的，但 WIN32 的界面过程不能堵在任何一个数据库操作或文件下载过程，原来 VC 程序员通常的做法也是创建单独的线程进行阻塞操作，然后通过给主窗口传递消息将操作结果通知至主线程，幸运的是 acl_cpp 的 rpc 相关类可以使这一过程更为方便快捷；再如，你写的一个网络服务器程序的主线程是非阻塞的，但其中你不得不调用别人提供的库以实现用户身份验证的功能，同时这个用于用户认证的库又恰恰是阻塞的—一般也是如此，固然，你也许可以费很周折实现这一过程，同样，acl_cpp 的 rpc 相关类可以帮你解决这类问题）。</p>\n<h4 id=\"1-2、将阻塞处理过程的对象交由子线程处理：\"><a href=\"#1-2、将阻塞处理过程的对象交由子线程处理：\" class=\"headerlink\" title=\"1.2、将阻塞处理过程的对象交由子线程处理：\"></a>1.2、将阻塞处理过程的对象交由子线程处理：</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 主线程中运行：将请求任务放入子线程池的任务请求队列中，当线程池</span><br><span class=\"hljs-comment\"> * 中的一个子线程接收到该任务后便调用 rpc_request::rpc_run 方法调</span><br><span class=\"hljs-comment\"> * 用子类的方法，当任务处理完毕后给主线程发消息，在主线程中再调用</span><br><span class=\"hljs-comment\"> * rpc_request::rpc_callback</span><br><span class=\"hljs-comment\"> * @param req &#123;rpc_request*&#125; rpc_request 子类实例，非空</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_fork</span><span class=\"hljs-params\">(rpc_request* req)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>通过此接口，可以将阻塞请求过程交给子线程处理，子线程处理完后再通知主线程。</p>\n<h3 id=\"2、rpc-request-类\"><a href=\"#2、rpc-request-类\" class=\"headerlink\" title=\"2、rpc_request 类\"></a>2、rpc_request 类</h3><p>在类 rpc_request 中有三个虚接口，用户子类必须实现其中的两个纯虚接口：rpc_run 和 rpc_onover，同时用户可以根据需要实现另一非纯虚接口：rpc_wakeup。是当用户调完 rpc_service::rpc_fork 且子线程接收到此请求任务后 rpc_request::rpc_run 方法会被调用（一定切记：rpc_fork 是在主线程中被调用的，而 rpc_run 是在子线程中被调用的）；当 rpc_request::rpc_run 函数返回后，rpc_reuqest::rpc_onover 会在主线程中被调用以表示子线程已经处理完毕（同样需要严重注意：rpc_request::rpc_onover 方法又回到主线程中被调用），这样，通过这两个过程就实现了将阻塞过程放在子线程中处理，主线程的非阻塞过程（非阻塞网络事件或非阻塞的 WIN32 消息过程）异步地等待子线程完成任务。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在子线程中被调用，子类必须实现此接口，用于处理具体任务</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> </span>= <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在主线程中被调用，子类必须实现此接口，</span><br><span class=\"hljs-comment\"> * 当子线程处理完请求任务后该接口将被调用，所以该类对象只能</span><br><span class=\"hljs-comment\"> * 是当本接口调用后才能被释放，禁止在调用本接口前释放本类对象</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_onover</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> </span>= <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n\n<p>另外，在 rpc_request 类中还有一个非纯虚方法：rpc_wakeup，这是做什么用的呢？可以假设这种应用场景，在子线程中调用 rpc_request::rpc_run 方法内部过程中，用户如果需要通知主线程一些中间状态（比如，文件下载的进度）该怎么办？那就在 rpc_run 方法内先调用 rpc_request::rpc_signal 通知主线程子线程处理的中间状态，则在主线程中用户实现的 rpc_request::rpc_wakeup 虚接口就会被调用。下面是 rpc_signal 和 rpc_wakeup 的接口说明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息</span><br><span class=\"hljs-comment\"> * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的</span><br><span class=\"hljs-comment\"> * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法</span><br><span class=\"hljs-comment\"> * @param ctx &#123;void*&#125; 传递的参数指针，一般应该是动态地址</span><br><span class=\"hljs-comment\"> *  比较好，这样可以避免同一个参数被重复覆盖的问题</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_signal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 虚接口：当子线程调用本对象的 rpc_signal 时，在主线程中会</span><br><span class=\"hljs-comment\"> * 调用本接口，通知在任务未完成前(即调用 rpc_onover 前)收到</span><br><span class=\"hljs-comment\"> * 子线程运行的中间状态信息；内部自动支持套接口或 WIN32 窗口</span><br><span class=\"hljs-comment\"> * 消息；应用场景，例如，对于 HTTP 下载应用，在子线程中可以</span><br><span class=\"hljs-comment\"> * 一边下载，一边向主线程发送(调用 rpc_signal 方法)下载进程，</span><br><span class=\"hljs-comment\"> * 则主线程会调用本类实例的此方法来处理此消息</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_wakeup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span> </span>&#123; (<span class=\"hljs-type\">void</span>) ctx; &#125;<br></code></pre></td></tr></table></figure>\n\n<p>紧接着这个应用场景，假设在子线程调用 rpc_run 的内部通过 rpc_signal 通知主线程的中间状态后，希望主线程能收到此通知消息并且希望得到主线程下一步希望执行的指令才会进一步继续执行。于是便有了 rpc_request::cond_wait 和 rpc_request::cond_signal 两个方法的产生，即子线程通过 cond_wait 阻塞地等待主线程的下一步操作指令，主线程则调用 cond_signal 通知子线程下步指令，下面是这两个方法的说明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当子线程调用 rpc_signal 给主线程后，调用本方法可以等待</span><br><span class=\"hljs-comment\"> * 主线程发来下一步指令</span><br><span class=\"hljs-comment\"> * @param timeout &#123;int&#125; 等待超时时间(毫秒)，当该值为 0 时</span><br><span class=\"hljs-comment\"> *  则采用非阻塞等待模式，当该值为 &lt; 0 时，则采用完全阻塞</span><br><span class=\"hljs-comment\"> *  等待模式(即一直等到主线程发送 cond_signal 通知)，当该</span><br><span class=\"hljs-comment\"> *  值 &gt; 0 时，则等待的最大超时时间为 timeout 毫秒</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示收到主线程发来的通知信号，</span><br><span class=\"hljs-comment\"> *  否则，需要调用 cond_wait_timeout 判断是否是超时引起的</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cond_wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> timeout = <span class=\"hljs-number\">-1</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息</span><br><span class=\"hljs-comment\"> * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的</span><br><span class=\"hljs-comment\"> * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法</span><br><span class=\"hljs-comment\"> * @param ctx &#123;void*&#125; 传递的参数指针，一般应该是动态地址</span><br><span class=\"hljs-comment\"> *  比较好，这样可以避免同一个参数被重复覆盖的问题</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_signal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、示例\"><a href=\"#三、示例\" class=\"headerlink\" title=\"三、示例\"></a>三、示例</h2><p>如果您能大体明白上面有关 rpc_service 和 rpc_request 类的功能说明，相信下面的例子您也一定能看明白：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// rpc_download.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span><br>&#123;<br>\tCTX_T_CONTENT_LENGTH,<br>\tCTX_T_PARTIAL_LENGTH,<br>\tCTX_T_END<br>&#125; <span class=\"hljs-type\">ctx_t</span>;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DOWN_CTX</span> <br>&#123;<br>\t<span class=\"hljs-type\">ctx_t</span> type;<br>\t<span class=\"hljs-type\">int</span> length;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __download_count = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_download</span> : <span class=\"hljs-keyword\">public</span> rpc_request<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_download</span>(aio_handle&amp; handle, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* url)<br>\t\t: <span class=\"hljs-built_in\">handle_</span>(handle)<br>\t\t, <span class=\"hljs-built_in\">addr_</span>(addr)<br>\t\t, <span class=\"hljs-built_in\">url_</span>(url)<br>\t\t, <span class=\"hljs-built_in\">error_</span>(<span class=\"hljs-literal\">false</span>)<br>\t\t, <span class=\"hljs-built_in\">total_read_</span>(<span class=\"hljs-number\">0</span>)<br>\t\t, <span class=\"hljs-built_in\">content_length_</span>(<span class=\"hljs-number\">0</span>)<br>\t&#123;&#125;<br>\t~<span class=\"hljs-built_in\">http_download</span>() &#123;&#125;<br><span class=\"hljs-keyword\">protected</span>:<br><br>\t<span class=\"hljs-comment\">// 子线程处理函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-function\">http_request <span class=\"hljs-title\">req</span><span class=\"hljs-params\">(addr_)</span></span>;  <span class=\"hljs-comment\">// HTTP 请求对象</span><br><br>\t\t<span class=\"hljs-comment\">// 设置 HTTP 请求头信息</span><br>\t\treq.<span class=\"hljs-built_in\">request_header</span>().<span class=\"hljs-built_in\">set_url</span>(url_.<span class=\"hljs-built_in\">c_str</span>())<br>\t\t\t.<span class=\"hljs-built_in\">set_content_type</span>(<span class=\"hljs-string\">&quot;text/html&quot;</span>)<br>\t\t\t.<span class=\"hljs-built_in\">set_host</span>(addr_.<span class=\"hljs-built_in\">c_str</span>())<br>\t\t\t.<span class=\"hljs-built_in\">set_method</span>(HTTP_METHOD_GET);<br><br>\t\t<span class=\"hljs-comment\">// 测试用，显示 HTTP 请求头信息内容</span><br>\t\tstring header;<br>\t\treq.<span class=\"hljs-built_in\">request_header</span>().<span class=\"hljs-built_in\">build_request</span>(header);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;request: %s\\r\\n&quot;</span>, header.<span class=\"hljs-built_in\">c_str</span>());<br><br>\t\t<span class=\"hljs-comment\">// 发送 HTTP 请求数据</span><br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">request</span>(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;send request error\\r\\n&quot;</span>);<br>\t\t\terror_ = <span class=\"hljs-literal\">false</span>;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 获得 HTTP 请求的连接对象</span><br>\t\thttp_client* conn = req.<span class=\"hljs-built_in\">get_client</span>();<br>\t\t<span class=\"hljs-built_in\">assert</span>(conn);<br>\t\tDOWN_CTX* ctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\tctx-&gt;type = CTX_T_CONTENT_LENGTH;<br><br>\t\t<span class=\"hljs-comment\">// 获得 HTTP 响应数据的数据体长度</span><br>\t\tctx-&gt;length = (<span class=\"hljs-type\">int</span>) conn-&gt;<span class=\"hljs-built_in\">body_length</span>();<br>\t\tcontent_length_ = ctx-&gt;length;<br><br>\t\t<span class=\"hljs-comment\">// 通知主线程</span><br>\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);<br><br>\t\t<span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 读 HTTP 响应数据体</span><br>\t\t\t<span class=\"hljs-type\">int</span> ret = req.<span class=\"hljs-built_in\">get_body</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf));<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t\t&#123;<br>\t\t\t\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\t\t\tctx-&gt;type = CTX_T_END;<br>\t\t\t\tctx-&gt;length = ret;<br>\t\t\t\t<span class=\"hljs-comment\">// 通知主线程</span><br>\t\t\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\t\tctx-&gt;type = CTX_T_PARTIAL_LENGTH;<br>\t\t\tctx-&gt;length = ret;<br>\t\t\t<span class=\"hljs-comment\">// 通知主线程</span><br>\t\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 主线程处理过程，收到子线程任务完成的消息</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_onover</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: read over now, total read: %d, content-length: %d\\r\\n&quot;</span>,<br>\t\t\taddr_.<span class=\"hljs-built_in\">c_str</span>(), total_read_, content_length_);<br><br>\t\t<span class=\"hljs-comment\">// 当 HTTP 响应都完成时，通知主线程停止事件循环过程</span><br>\t\t__download_count--;<br>\t\t<span class=\"hljs-keyword\">if</span> (__download_count == <span class=\"hljs-number\">0</span>)<br>\t\t\thandle_.<span class=\"hljs-built_in\">stop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 主线程处理过程，收到子线程的通知消息</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_wakeup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tDOWN_CTX* down_ctx = (DOWN_CTX*) ctx;<br>\t\t<span class=\"hljs-keyword\">switch</span> (down_ctx-&gt;type)<br>\t\t&#123;<br>\t\t<span class=\"hljs-keyword\">case</span> CTX_T_CONTENT_LENGTH:<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: content-length: %d\\r\\n&quot;</span>,<br>\t\t\t\taddr_.<span class=\"hljs-built_in\">c_str</span>(), down_ctx-&gt;length);<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> CTX_T_PARTIAL_LENGTH:<br>\t\t\ttotal_read_ += down_ctx-&gt;length;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: partial-length: %d, total read: %d\\r\\n&quot;</span>,<br>\t\t\t\taddr_.<span class=\"hljs-built_in\">c_str</span>(), down_ctx-&gt;length, total_read_);<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> CTX_T_END:<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: read over\\r\\n&quot;</span>, addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: ERROR\\r\\n&quot;</span>, addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">delete</span> down_ctx;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\taio_handle&amp; handle_;<br>\tstring addr_;<br>\tstring url_;<br>\t<span class=\"hljs-type\">bool</span>  error_;<br>\t<span class=\"hljs-type\">int</span>   total_read_;<br>\t<span class=\"hljs-type\">int</span>   content_length_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\taio_handle handle;<br>\trpc_service* service = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">rpc_service</span>(<span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">// 创建 rpc 服务对象</span><br><br>\t<span class=\"hljs-comment\">// 打开消息服务器</span><br>\t<span class=\"hljs-keyword\">if</span> (service-&gt;<span class=\"hljs-built_in\">open</span>(&amp;handle) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open service error: %s\\r\\n&quot;</span>, <span class=\"hljs-built_in\">last_serror</span>());<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 下载页面内容</span><br><br>\t<span class=\"hljs-function\">http_download <span class=\"hljs-title\">down1</span><span class=\"hljs-params\">(handle, <span class=\"hljs-string\">&quot;www.sina.com.cn:80&quot;</span>, <span class=\"hljs-string\">&quot;http://www.sina.com.cn/&quot;</span>)</span></span>;<br>\tservice-&gt;<span class=\"hljs-built_in\">rpc_fork</span>(&amp;down1);  <span class=\"hljs-comment\">// 发起一个阻塞会话过程</span><br>\t__download_count++;<br><br>\t<span class=\"hljs-function\">http_download <span class=\"hljs-title\">down2</span><span class=\"hljs-params\">(handle, <span class=\"hljs-string\">&quot;www.hexun.com:80&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)</span></span>;<br>\tservice-&gt;<span class=\"hljs-built_in\">rpc_fork</span>(&amp;down2);  <span class=\"hljs-comment\">// 发起第二个阻塞会话过程</span><br>\t__download_count++;<br><br>\t<span class=\"hljs-comment\">// 异步事件循环过程</span><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (handle.<span class=\"hljs-built_in\">check</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">delete</span> service;<br>\thandle.<span class=\"hljs-built_in\">check</span>(); <span class=\"hljs-comment\">// 保证释放所有延迟关闭的异步对象</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t<span class=\"hljs-built_in\">acl_cpp_init</span>();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>\t<span class=\"hljs-built_in\">run</span>();<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter any key to continue\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">getchar</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>acl 下载:</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>非阻塞网络编程无疑成了高并发、高性能编程的代名词，但现实应用编程中并不是每种应用都需要采用非阻塞编程模式，因为这将大大增加编程的复杂性、开发周期以及出错率，所以我们写的绝大部分网络程序程序都是阻塞的，一般是一个进程一个网络连接或一个线程一个网络连接。即然非阻塞模式可以实现高并发网络连接，阻塞模式可以实现复杂的业务逻辑，那是否有办法将二者结合起来呢？答案是肯定的，其中在 acl_cpp 库中，ipc 目录下的模块就是为了满足这种需求而设计的。</p>\n<h2 id=\"二、接口设计\"><a href=\"#二、接口设计\" class=\"headerlink\" title=\"二、接口设计\"></a>二、接口设计</h2><p>在 rpc.hpp 头文件中有两个类：rpc_service 和 rpc_request，其中 rpc_request 是一个纯虚类，用户需要继承此类并实现该类中规定的纯虚接口，从而实现自己的阻塞操作功能；rpc_service 是阻塞与非阻塞结合的粘合类，通过将 rpc_request 子类实例传递给 rpc_service 类实例的 rpc_fork 方法，实现将阻塞请求过程交给子线程处理的目的。</p>\n<h3 id=\"1、rpc-service-类\"><a href=\"#1、rpc-service-类\" class=\"headerlink\" title=\"1、rpc_service 类\"></a>1、rpc_service 类</h3><h4 id=\"1-1、构造函数：\"><a href=\"#1-1、构造函数：\" class=\"headerlink\" title=\"1.1、构造函数：\"></a>1.1、构造函数：</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 构造函数</span><br><span class=\"hljs-comment\"> * @param nthread &#123;int&#125; 如果该值 &gt; 1 则内部自动采用线程池，否则</span><br><span class=\"hljs-comment\"> *  则是一个请求一个线程</span><br><span class=\"hljs-comment\"> * @param win32_gui &#123;bool&#125; 是否是窗口类的消息，如果是，则内部的</span><br><span class=\"hljs-comment\"> *  通讯模式自动设置为基于 WIN32 的消息，否则依然采用通用的套接</span><br><span class=\"hljs-comment\"> *  口通讯方式</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-built_in\">rpc_service</span>(<span class=\"hljs-type\">int</span> nthread, <span class=\"hljs-type\">bool</span> win32_gui = <span class=\"hljs-literal\">false</span>)<br></code></pre></td></tr></table></figure>\n\n<p>从参数 win32_gui 可以看出，acl_cpp 的阻塞&#x2F;非阻塞结合模式不仅可以用在通常的网络编程中，同时还可以用在阻塞过程与 WINDOWS 界面消息相结合的方面，这无非是经常用 MFC 进行界面编程的福音（例如，用户 VC 写了一个界面程序—当然这个界面窗口是基于 WIN32 消息的，但如果想进行一些数据库操作或文件下载操作，对用户而言阻塞式方法是非常容易实现这两类需求的，但 WIN32 的界面过程不能堵在任何一个数据库操作或文件下载过程，原来 VC 程序员通常的做法也是创建单独的线程进行阻塞操作，然后通过给主窗口传递消息将操作结果通知至主线程，幸运的是 acl_cpp 的 rpc 相关类可以使这一过程更为方便快捷；再如，你写的一个网络服务器程序的主线程是非阻塞的，但其中你不得不调用别人提供的库以实现用户身份验证的功能，同时这个用于用户认证的库又恰恰是阻塞的—一般也是如此，固然，你也许可以费很周折实现这一过程，同样，acl_cpp 的 rpc 相关类可以帮你解决这类问题）。</p>\n<h4 id=\"1-2、将阻塞处理过程的对象交由子线程处理：\"><a href=\"#1-2、将阻塞处理过程的对象交由子线程处理：\" class=\"headerlink\" title=\"1.2、将阻塞处理过程的对象交由子线程处理：\"></a>1.2、将阻塞处理过程的对象交由子线程处理：</h4><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 主线程中运行：将请求任务放入子线程池的任务请求队列中，当线程池</span><br><span class=\"hljs-comment\"> * 中的一个子线程接收到该任务后便调用 rpc_request::rpc_run 方法调</span><br><span class=\"hljs-comment\"> * 用子类的方法，当任务处理完毕后给主线程发消息，在主线程中再调用</span><br><span class=\"hljs-comment\"> * rpc_request::rpc_callback</span><br><span class=\"hljs-comment\"> * @param req &#123;rpc_request*&#125; rpc_request 子类实例，非空</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_fork</span><span class=\"hljs-params\">(rpc_request* req)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<p>通过此接口，可以将阻塞请求过程交给子线程处理，子线程处理完后再通知主线程。</p>\n<h3 id=\"2、rpc-request-类\"><a href=\"#2、rpc-request-类\" class=\"headerlink\" title=\"2、rpc_request 类\"></a>2、rpc_request 类</h3><p>在类 rpc_request 中有三个虚接口，用户子类必须实现其中的两个纯虚接口：rpc_run 和 rpc_onover，同时用户可以根据需要实现另一非纯虚接口：rpc_wakeup。是当用户调完 rpc_service::rpc_fork 且子线程接收到此请求任务后 rpc_request::rpc_run 方法会被调用（一定切记：rpc_fork 是在主线程中被调用的，而 rpc_run 是在子线程中被调用的）；当 rpc_request::rpc_run 函数返回后，rpc_reuqest::rpc_onover 会在主线程中被调用以表示子线程已经处理完毕（同样需要严重注意：rpc_request::rpc_onover 方法又回到主线程中被调用），这样，通过这两个过程就实现了将阻塞过程放在子线程中处理，主线程的非阻塞过程（非阻塞网络事件或非阻塞的 WIN32 消息过程）异步地等待子线程完成任务。</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在子线程中被调用，子类必须实现此接口，用于处理具体任务</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> </span>= <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在主线程中被调用，子类必须实现此接口，</span><br><span class=\"hljs-comment\"> * 当子线程处理完请求任务后该接口将被调用，所以该类对象只能</span><br><span class=\"hljs-comment\"> * 是当本接口调用后才能被释放，禁止在调用本接口前释放本类对象</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_onover</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span> </span>= <span class=\"hljs-number\">0</span>;<br></code></pre></td></tr></table></figure>\n\n<p>另外，在 rpc_request 类中还有一个非纯虚方法：rpc_wakeup，这是做什么用的呢？可以假设这种应用场景，在子线程中调用 rpc_request::rpc_run 方法内部过程中，用户如果需要通知主线程一些中间状态（比如，文件下载的进度）该怎么办？那就在 rpc_run 方法内先调用 rpc_request::rpc_signal 通知主线程子线程处理的中间状态，则在主线程中用户实现的 rpc_request::rpc_wakeup 虚接口就会被调用。下面是 rpc_signal 和 rpc_wakeup 的接口说明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息</span><br><span class=\"hljs-comment\"> * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的</span><br><span class=\"hljs-comment\"> * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法</span><br><span class=\"hljs-comment\"> * @param ctx &#123;void*&#125; 传递的参数指针，一般应该是动态地址</span><br><span class=\"hljs-comment\"> *  比较好，这样可以避免同一个参数被重复覆盖的问题</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_signal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 虚接口：当子线程调用本对象的 rpc_signal 时，在主线程中会</span><br><span class=\"hljs-comment\"> * 调用本接口，通知在任务未完成前(即调用 rpc_onover 前)收到</span><br><span class=\"hljs-comment\"> * 子线程运行的中间状态信息；内部自动支持套接口或 WIN32 窗口</span><br><span class=\"hljs-comment\"> * 消息；应用场景，例如，对于 HTTP 下载应用，在子线程中可以</span><br><span class=\"hljs-comment\"> * 一边下载，一边向主线程发送(调用 rpc_signal 方法)下载进程，</span><br><span class=\"hljs-comment\"> * 则主线程会调用本类实例的此方法来处理此消息</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_wakeup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span> </span>&#123; (<span class=\"hljs-type\">void</span>) ctx; &#125;<br></code></pre></td></tr></table></figure>\n\n<p>紧接着这个应用场景，假设在子线程调用 rpc_run 的内部通过 rpc_signal 通知主线程的中间状态后，希望主线程能收到此通知消息并且希望得到主线程下一步希望执行的指令才会进一步继续执行。于是便有了 rpc_request::cond_wait 和 rpc_request::cond_signal 两个方法的产生，即子线程通过 cond_wait 阻塞地等待主线程的下一步操作指令，主线程则调用 cond_signal 通知子线程下步指令，下面是这两个方法的说明：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 当子线程调用 rpc_signal 给主线程后，调用本方法可以等待</span><br><span class=\"hljs-comment\"> * 主线程发来下一步指令</span><br><span class=\"hljs-comment\"> * @param timeout &#123;int&#125; 等待超时时间(毫秒)，当该值为 0 时</span><br><span class=\"hljs-comment\"> *  则采用非阻塞等待模式，当该值为 &lt; 0 时，则采用完全阻塞</span><br><span class=\"hljs-comment\"> *  等待模式(即一直等到主线程发送 cond_signal 通知)，当该</span><br><span class=\"hljs-comment\"> *  值 &gt; 0 时，则等待的最大超时时间为 timeout 毫秒</span><br><span class=\"hljs-comment\"> * @return &#123;bool&#125; 返回 true 表示收到主线程发来的通知信号，</span><br><span class=\"hljs-comment\"> *  否则，需要调用 cond_wait_timeout 判断是否是超时引起的</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">bool</span> <span class=\"hljs-title\">cond_wait</span><span class=\"hljs-params\">(<span class=\"hljs-type\">int</span> timeout = <span class=\"hljs-number\">-1</span>)</span></span>;<br><br><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * 在子线程中被调用，内部自动支持套接口或 WIN32 窗口消息</span><br><span class=\"hljs-comment\"> * 子类实例的 rpc_run 方法中可以多次调用此方法向主线程的</span><br><span class=\"hljs-comment\"> * 本类实例发送消息，主线程中调用本对象 rpc_wakeup 方法</span><br><span class=\"hljs-comment\"> * @param ctx &#123;void*&#125; 传递的参数指针，一般应该是动态地址</span><br><span class=\"hljs-comment\"> *  比较好，这样可以避免同一个参数被重复覆盖的问题</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_signal</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span>;<br></code></pre></td></tr></table></figure>\n\n<h2 id=\"三、示例\"><a href=\"#三、示例\" class=\"headerlink\" title=\"三、示例\"></a>三、示例</h2><p>如果您能大体明白上面有关 rpc_service 和 rpc_request 类的功能说明，相信下面的例子您也一定能看明白：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br><span class=\"line\">175</span><br><span class=\"line\">176</span><br><span class=\"line\">177</span><br><span class=\"line\">178</span><br><span class=\"line\">179</span><br><span class=\"line\">180</span><br><span class=\"line\">181</span><br><span class=\"line\">182</span><br><span class=\"line\">183</span><br><span class=\"line\">184</span><br><span class=\"line\">185</span><br><span class=\"line\">186</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// rpc_download.cpp : 定义控制台应用程序的入口点。</span><br><span class=\"hljs-comment\">//</span><br><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;lib_acl.hpp&quot;</span></span><br><br><span class=\"hljs-keyword\">using</span> <span class=\"hljs-keyword\">namespace</span> acl;<br><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span><br>&#123;<br>\tCTX_T_CONTENT_LENGTH,<br>\tCTX_T_PARTIAL_LENGTH,<br>\tCTX_T_END<br>&#125; <span class=\"hljs-type\">ctx_t</span>;<br><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DOWN_CTX</span> <br>&#123;<br>\t<span class=\"hljs-type\">ctx_t</span> type;<br>\t<span class=\"hljs-type\">int</span> length;<br>&#125;;<br><br><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">int</span> __download_count = <span class=\"hljs-number\">0</span>;<br><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_download</span> : <span class=\"hljs-keyword\">public</span> rpc_request<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">http_download</span>(aio_handle&amp; handle, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* url)<br>\t\t: <span class=\"hljs-built_in\">handle_</span>(handle)<br>\t\t, <span class=\"hljs-built_in\">addr_</span>(addr)<br>\t\t, <span class=\"hljs-built_in\">url_</span>(url)<br>\t\t, <span class=\"hljs-built_in\">error_</span>(<span class=\"hljs-literal\">false</span>)<br>\t\t, <span class=\"hljs-built_in\">total_read_</span>(<span class=\"hljs-number\">0</span>)<br>\t\t, <span class=\"hljs-built_in\">content_length_</span>(<span class=\"hljs-number\">0</span>)<br>\t&#123;&#125;<br>\t~<span class=\"hljs-built_in\">http_download</span>() &#123;&#125;<br><span class=\"hljs-keyword\">protected</span>:<br><br>\t<span class=\"hljs-comment\">// 子线程处理函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-function\">http_request <span class=\"hljs-title\">req</span><span class=\"hljs-params\">(addr_)</span></span>;  <span class=\"hljs-comment\">// HTTP 请求对象</span><br><br>\t\t<span class=\"hljs-comment\">// 设置 HTTP 请求头信息</span><br>\t\treq.<span class=\"hljs-built_in\">request_header</span>().<span class=\"hljs-built_in\">set_url</span>(url_.<span class=\"hljs-built_in\">c_str</span>())<br>\t\t\t.<span class=\"hljs-built_in\">set_content_type</span>(<span class=\"hljs-string\">&quot;text/html&quot;</span>)<br>\t\t\t.<span class=\"hljs-built_in\">set_host</span>(addr_.<span class=\"hljs-built_in\">c_str</span>())<br>\t\t\t.<span class=\"hljs-built_in\">set_method</span>(HTTP_METHOD_GET);<br><br>\t\t<span class=\"hljs-comment\">// 测试用，显示 HTTP 请求头信息内容</span><br>\t\tstring header;<br>\t\treq.<span class=\"hljs-built_in\">request_header</span>().<span class=\"hljs-built_in\">build_request</span>(header);<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;request: %s\\r\\n&quot;</span>, header.<span class=\"hljs-built_in\">c_str</span>());<br><br>\t\t<span class=\"hljs-comment\">// 发送 HTTP 请求数据</span><br>\t\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">request</span>(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>) == <span class=\"hljs-literal\">false</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;send request error\\r\\n&quot;</span>);<br>\t\t\terror_ = <span class=\"hljs-literal\">false</span>;<br>\t\t\t<span class=\"hljs-keyword\">return</span>;<br>\t\t&#125;<br><br>\t\t<span class=\"hljs-comment\">// 获得 HTTP 请求的连接对象</span><br>\t\thttp_client* conn = req.<span class=\"hljs-built_in\">get_client</span>();<br>\t\t<span class=\"hljs-built_in\">assert</span>(conn);<br>\t\tDOWN_CTX* ctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\tctx-&gt;type = CTX_T_CONTENT_LENGTH;<br><br>\t\t<span class=\"hljs-comment\">// 获得 HTTP 响应数据的数据体长度</span><br>\t\tctx-&gt;length = (<span class=\"hljs-type\">int</span>) conn-&gt;<span class=\"hljs-built_in\">body_length</span>();<br>\t\tcontent_length_ = ctx-&gt;length;<br><br>\t\t<span class=\"hljs-comment\">// 通知主线程</span><br>\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);<br><br>\t\t<span class=\"hljs-type\">char</span> buf[<span class=\"hljs-number\">8192</span>];<br>\t\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t\t&#123;<br>\t\t\t<span class=\"hljs-comment\">// 读 HTTP 响应数据体</span><br>\t\t\t<span class=\"hljs-type\">int</span> ret = req.<span class=\"hljs-built_in\">get_body</span>(buf, <span class=\"hljs-built_in\">sizeof</span>(buf));<br>\t\t\t<span class=\"hljs-keyword\">if</span> (ret &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t\t&#123;<br>\t\t\t\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\t\t\tctx-&gt;type = CTX_T_END;<br>\t\t\t\tctx-&gt;length = ret;<br>\t\t\t\t<span class=\"hljs-comment\">// 通知主线程</span><br>\t\t\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);<br>\t\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t\t&#125;<br>\t\t\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\t\tctx-&gt;type = CTX_T_PARTIAL_LENGTH;<br>\t\t\tctx-&gt;length = ret;<br>\t\t\t<span class=\"hljs-comment\">// 通知主线程</span><br>\t\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);<br>\t\t&#125;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 主线程处理过程，收到子线程任务完成的消息</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_onover</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: read over now, total read: %d, content-length: %d\\r\\n&quot;</span>,<br>\t\t\taddr_.<span class=\"hljs-built_in\">c_str</span>(), total_read_, content_length_);<br><br>\t\t<span class=\"hljs-comment\">// 当 HTTP 响应都完成时，通知主线程停止事件循环过程</span><br>\t\t__download_count--;<br>\t\t<span class=\"hljs-keyword\">if</span> (__download_count == <span class=\"hljs-number\">0</span>)<br>\t\t\thandle_.<span class=\"hljs-built_in\">stop</span>();<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 主线程处理过程，收到子线程的通知消息</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_wakeup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span><br><span class=\"hljs-function\">\t</span>&#123;<br>\t\tDOWN_CTX* down_ctx = (DOWN_CTX*) ctx;<br>\t\t<span class=\"hljs-keyword\">switch</span> (down_ctx-&gt;type)<br>\t\t&#123;<br>\t\t<span class=\"hljs-keyword\">case</span> CTX_T_CONTENT_LENGTH:<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: content-length: %d\\r\\n&quot;</span>,<br>\t\t\t\taddr_.<span class=\"hljs-built_in\">c_str</span>(), down_ctx-&gt;length);<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> CTX_T_PARTIAL_LENGTH:<br>\t\t\ttotal_read_ += down_ctx-&gt;length;<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: partial-length: %d, total read: %d\\r\\n&quot;</span>,<br>\t\t\t\taddr_.<span class=\"hljs-built_in\">c_str</span>(), down_ctx-&gt;length, total_read_);<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">case</span> CTX_T_END:<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: read over\\r\\n&quot;</span>, addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t<span class=\"hljs-keyword\">default</span>:<br>\t\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s: ERROR\\r\\n&quot;</span>, addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\t<span class=\"hljs-keyword\">delete</span> down_ctx;<br>\t&#125;<br><span class=\"hljs-keyword\">private</span>:<br>\taio_handle&amp; handle_;<br>\tstring addr_;<br>\tstring url_;<br>\t<span class=\"hljs-type\">bool</span>  error_;<br>\t<span class=\"hljs-type\">int</span>   total_read_;<br>\t<span class=\"hljs-type\">int</span>   content_length_;<br>&#125;;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\taio_handle handle;<br>\trpc_service* service = <span class=\"hljs-keyword\">new</span> <span class=\"hljs-built_in\">rpc_service</span>(<span class=\"hljs-number\">10</span>);  <span class=\"hljs-comment\">// 创建 rpc 服务对象</span><br><br>\t<span class=\"hljs-comment\">// 打开消息服务器</span><br>\t<span class=\"hljs-keyword\">if</span> (service-&gt;<span class=\"hljs-built_in\">open</span>(&amp;handle) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;open service error: %s\\r\\n&quot;</span>, <span class=\"hljs-built_in\">last_serror</span>());<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 下载页面内容</span><br><br>\t<span class=\"hljs-function\">http_download <span class=\"hljs-title\">down1</span><span class=\"hljs-params\">(handle, <span class=\"hljs-string\">&quot;www.sina.com.cn:80&quot;</span>, <span class=\"hljs-string\">&quot;http://www.sina.com.cn/&quot;</span>)</span></span>;<br>\tservice-&gt;<span class=\"hljs-built_in\">rpc_fork</span>(&amp;down1);  <span class=\"hljs-comment\">// 发起一个阻塞会话过程</span><br>\t__download_count++;<br><br>\t<span class=\"hljs-function\">http_download <span class=\"hljs-title\">down2</span><span class=\"hljs-params\">(handle, <span class=\"hljs-string\">&quot;www.hexun.com:80&quot;</span>, <span class=\"hljs-string\">&quot;/&quot;</span>)</span></span>;<br>\tservice-&gt;<span class=\"hljs-built_in\">rpc_fork</span>(&amp;down2);  <span class=\"hljs-comment\">// 发起第二个阻塞会话过程</span><br>\t__download_count++;<br><br>\t<span class=\"hljs-comment\">// 异步事件循环过程</span><br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-keyword\">if</span> (handle.<span class=\"hljs-built_in\">check</span>() == <span class=\"hljs-literal\">false</span>)<br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-keyword\">delete</span> service;<br>\thandle.<span class=\"hljs-built_in\">check</span>(); <span class=\"hljs-comment\">// 保证释放所有延迟关闭的异步对象</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-type\">int</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>)</span></span><br><span class=\"hljs-function\"></span>&#123;<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">ifdef</span> WIN32</span><br>\t<span class=\"hljs-built_in\">acl_cpp_init</span>();<br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">endif</span></span><br><br>\t<span class=\"hljs-built_in\">run</span>();<br>\t<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;Enter any key to continue\\r\\n&quot;</span>);<br>\t<span class=\"hljs-built_in\">getchar</span>();<br>\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>\n\n<p>acl 下载:</p>\n<p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"},{"title":"使用 acl 库 rpc 功能类实现 阻塞任务过程与MFC 界面过程分离","date":"2013-02-24T08:42:00.000Z","_content":"\n## 一、概述\n\nMFC 程序员在编写 Windows 界面程序时经常需要处理一些阻塞任务过程，为了避免阻塞窗口的消息过程，一般会将阻塞过程将由一个子线程处理，该子线程在处理过程中通过向界面线程发送 Windows 窗口消息将处理结果传递给窗口线程。在 acl 库中的 rpc 功能类实现了更为方便的处理方式，通过 rpc 功能类，用户可以在主线程中进行非阻塞过程（如：界面消息过程或网络非阻塞通讯过程），而将阻塞任务交由子线程处理（如：网络阻塞通讯或数据库操作等），子线程可以将任务处理的中间状态和最终状态通过 rpc 功能类传递给主线程。\n\nacl 的 rpc 类不仅能实现网络通讯方面的阻塞与非阻塞的粘合，同时还实现了阻塞过程与 MFC 界面过程的粘合，本文将以一个具体的 HTTP 下载过程为例来描述这一过程（示例在 acl 库中的 acl/lib_acl_cpp/samples/gui_rpc 目录下）。关于 acl 库中 rpc 相关类的使用，用户可以参考 《acl_cpp 的 rpc 相关类整合阻塞及非阻塞过程》（在该文中的例子描述了非阻塞主线程与阻塞子线程的交互过程，其示例代码适用于 win32 及 linux 平台）。\n\n## 二、实例\n\n### 1、在界面主线程中初始化时创建 rpc 服务对象：acl::rpc_service\n\n```c++\n\t// 全局静态变量\n\tstatic acl::aio_handle* handle_;\n\tstatic acl::rpc_service* service_;\n\n\t......\n\n\t// 创建非阻塞框架句柄，并采用 WIN32 消息模式：acl::ENGINE_WINMSG\n\thandle_ = new acl::aio_handle(acl::ENGINE_WINMSG);\n\n\t// 创建 rpc 服务对象\n\tint max_threads = 10;  // 服务最大子线程数量\n\tservice_ = new acl::rpc_service(max_threads, true);\n\t// 打开消息服务\n\tif (service_->open(handle_) == false)\n\t\tlogger_fatal(\"open service error: %s\", acl::last_serror());\n```\n\n在上面代码中，有几点需要注意：1）创建的 rpc 服务对象是全局性的；2）在创建非阻塞句柄时必须指定为 win32 界面消息事件类型：acl::ENGINE_WINMSG；3）在创建 rpc_service 时的第二个参数 win32_gui 必须为 true。\n\n### 2、创建 rpc 中 acl::rpc_request 类的子类，以实现阻塞非阻塞粘合过程\n本例中该子类为：http_download，在 http_download 类中必须实现父类 acl::rpc_request 中定义的两个纯虚接口：rpc_run，rpc_onover。\n\n其中，http_download 的头文件如下：\n\n```c++\n/**\n * http 请求过程类，该类对象在子线程中发起远程 HTTP 请求过程，将处理结果\n * 返回给主线程\n */\nclass http_download : public acl::rpc_request\n{\npublic:\n\t/**\n\t * 构造函数\n\t * @param addr {const char*} HTTP 服务器地址，格式：domain:port\n\t * @param url {const char*} http url 地址\n\t * @param callback {rpc_callback*} http 请求结果通过此类对象\n\t *  通知主线程过程\n\t */\n\thttp_download(const char* addr, const char* url,\n\t\trpc_callback* callback);\nprotected:\n\t~http_download() {}\n\n\t// 基类虚函数：子线程处理函数\n\tvirtual void rpc_run();\n\n\t// 基类虚函数：主线程处理过程，收到子线程任务完成的消息\n\tvirtual void rpc_onover();\n\n\t// 基类虚函数：主线程处理过程，收到子线程的通知消息\n\tvirtual void rpc_wakeup(void* ctx);\n\n        ......\n```\n\n在 http_download 类的构造参数中有一个接口类：rpc_callback，这是一个纯虚类，主要是为了方便将 http 的结果数据返回给主线程，该类的声明如下：\n\n```c++\n// 纯虚类，子类须实现该类中的纯虚接口\nclass rpc_callback\n{\npublic:\n\trpc_callback() {}\n\tvirtual ~rpc_callback() {}\n\n\t// 设置 HTTP 请求头数据虚函数\n\tvirtual void SetRequestHdr(const char* hdr) = 0;\n\t// 设置 HTTP 响应头数据虚函数\n\tvirtual void SetResponseHdr(const char* hdr) = 0;\n\t// 下载过程中的回调函数虚函数\n\tvirtual void OnDownloading(long long int content_length,\n\t\tlong long int total_read) = 0;\n\t// 下载完成时的回调函数虚函数\n\tvirtual void OnDownloadOver(long long int total_read,\n\t\tdouble spent) = 0;\n};\n```\n\nhttp_download 类的函数实现如下：\n\n```c++\n#include \"stdafx.h\"\n#include <assert.h>\n#include \"http_download.h\"\n\n// 由子线程动态创建的 DOWN_CTX 对象的数据类型\ntypedef enum\n{\n\tCTX_T_REQ_HDR,\t\t// 为 HTTP 请求头数据\n\tCTX_T_RES_HDR,\t\t// 为 HTTP 响应头数据\n\tCTX_T_CONTENT_LENGTH,\t// 为 HTTP 响应体的长度\n\tCTX_T_PARTIAL_LENGTH,\t// 为 HTTP 下载数据体的长度\n\tCTX_T_END\n} ctx_t;\n\n// 子线程动态创建的数据对象，主线程接收此数据\nstruct DOWN_CTX \n{\n\tctx_t type;\n\tlong long int length;\n};\n\n// 用来精确计算时间截间隔的函数，精确到毫秒级别\nstatic double stamp_sub(const struct timeval *from,\n\tconst struct timeval *sub_by)\n{\n\tstruct timeval res;\n\n\tmemcpy(&res, from, sizeof(struct timeval));\n\n\tres.tv_usec -= sub_by->tv_usec;\n\tif (res.tv_usec < 0)\n\t{\n\t\t--res.tv_sec;\n\t\tres.tv_usec += 1000000;\n\t}\n\n\tres.tv_sec -= sub_by->tv_sec;\n\treturn (res.tv_sec * 1000.0 + res.tv_usec/1000.0);\n}\n\n//////////////////////////////////////////////////////////////////////////\n\n// 子线程处理函数\nvoid http_download::rpc_run()\n{\n\tacl::http_request req(addr_);  // HTTP 请求对象\n\t// 设置 HTTP 请求头信息\n\treq.request_header().set_url(url_.c_str())\n\t\t.set_content_type(\"text/html\")\n\t\t.set_host(addr_.c_str())\n\t\t.set_method(acl::HTTP_METHOD_GET);\n\n\treq.request_header().build_request(req_hdr_);\n\tDOWN_CTX* ctx = new DOWN_CTX;\n\tctx->type = CTX_T_REQ_HDR;\n\trpc_signal(ctx);  // 通知主线程 HTTP 请求头数据\n\n\tstruct timeval begin, end;;\n\tgettimeofday(&begin, NULL);\n\n\t// 发送 HTTP 请求数据\n\tif (req.request(NULL, 0) == false)\n\t{\n\t\tlogger_error(\"send request error\");\n\t\terror_ = false;\n\t\tgettimeofday(&end, NULL);\n\t\ttotal_spent_ = stamp_sub(&end, &begin);\n\t\treturn;\n\t}\n\n\t// 获得 HTTP 请求的连接对象\n\tacl::http_client* conn = req.get_client();\n\tassert(conn);\n\n\t(void) conn->get_respond_head(&res_hdr_);\n\tctx = new DOWN_CTX;\n\tctx->type = CTX_T_RES_HDR;\n\trpc_signal(ctx);   // 通知主线程 HTTP 响应头数据\n\n\tctx = new DOWN_CTX;\n\tctx->type = CTX_T_CONTENT_LENGTH;\n\t\n\tctx->length = conn->body_length();  // 获得 HTTP 响应数据的数据体长度\n\tcontent_length_ = ctx->length;\n\trpc_signal(ctx);  // 通知主线程 HTTP 响应体数据长度\n\n\tacl::string buf(8192);\n\tint   real_size;\n\twhile (true)\n\t{\n\t\t// 读 HTTP 响应数据体\n\t\tint ret = req.read_body(buf, true, &real_size);\n\t\tif (ret <= 0)\n\t\t{\n\t\t\tctx = new DOWN_CTX;\n\t\t\tctx->type = CTX_T_END;\n\t\t\tctx->length = ret;\n\t\t\trpc_signal(ctx);  // 通知主线程下载完毕\n\t\t\tbreak;\n\t\t}\n\t\tctx = new DOWN_CTX;\n\t\tctx->type = CTX_T_PARTIAL_LENGTH;\n\t\tctx->length = real_size;\n\t\t// 通知主线程当前已经下载的大小\n\t\trpc_signal(ctx);\n\t}\n\n\t// 计算下载过程总时长\n\tgettimeofday(&end, NULL);\n\ttotal_spent_ = stamp_sub(&end, &begin);\n\n\t// 至此，子线程运行完毕，主线程的 rpc_onover 过程将被调用\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nhttp_download::http_download(const char* addr, const char* url,\n\trpc_callback* callback)\n\t: addr_(addr)\n\t, url_(url)\n\t, callback_(callback)\n\t, error_(false)\n\t, total_read_(0)\n\t, content_length_(0)\n\t, total_spent_(0)\n{\n\n}\n\n//////////////////////////////////////////////////////////////////////////\n\n// 主线程处理过程，收到子线程任务完成的消息\nvoid http_download::rpc_onover()\n{\n\tlogger(\"http download(%s) over, 共 %I64d 字节，耗时 %.3f 毫秒\",\n\t\turl_.c_str(), total_read_, total_spent_);\n\tcallback_->OnDownloadOver(total_read_, total_spent_);\n\tdelete this;  // 销毁本对象\n}\n\n// 主线程处理过程，收到子线程的通知消息\nvoid http_download::rpc_wakeup(void* ctx)\n{\n\tDOWN_CTX* down_ctx = (DOWN_CTX*) ctx;\n\n\t// 根据子线程中传来的不同的下载阶段进行处理\n\n\tswitch (down_ctx->type)\n\t{\n\tcase CTX_T_REQ_HDR:\n\t\tcallback_->SetRequestHdr(req_hdr_.c_str());\n\t\tbreak;\n\tcase CTX_T_RES_HDR:\n\t\tcallback_->SetResponseHdr(res_hdr_.c_str());\n\t\tbreak;\n\tcase CTX_T_CONTENT_LENGTH:\n\t\tbreak;\n\tcase CTX_T_PARTIAL_LENGTH:\n\t\ttotal_read_ += down_ctx->length;\n\t\tcallback_->OnDownloading(content_length_, total_read_);\n\t\tbreak;\n\tcase CTX_T_END:\n\t\tlogger(\"%s: read over\", addr_.c_str());\n\t\tbreak;\n\tdefault:\n\t\tlogger_error(\"%s: ERROR\", addr_.c_str());\n\t\tbreak;\n\t}\n\n\t// 删除在子线程中动态分配的对象\n\tdelete down_ctx;\n}\n\n//////////////////////////////////////////////////////////////////////////\n```\n  \n\n### 3、在 MFC 界面类中创建 rpc_callback 的子类，接收子线程的 HTTP 处理结果\n本例直接将对话框类继承了 rpc_callback 接口类，其中部分内容如下：\n\n```c++\n// Cgui_rpcDlg 对话框\nclass Cgui_rpcDlg : public CDialog\n\t, public rpc_callback\n{\n// 构造\npublic:\n\tCgui_rpcDlg(CWnd* pParent = NULL);\t// 标准构造函数\n\t~Cgui_rpcDlg();\n\n        ......\n\npublic:\n\t// 基类 rpc_callback 虚函数\n\n\t// 设置 HTTP 请求头数据虚函数\n\tvirtual void SetRequestHdr(const char* hdr);\n\t// 设置 HTTP 响应头数据虚函数\n\tvirtual void SetResponseHdr(const char* hdr);\n\t// 下载过程中的回调函数虚函数\n\tvirtual void OnDownloading(long long int content_length,\n\t\tlong long int total_read);\n\t// 下载完成时的回调函数虚函数\n\tvirtual void OnDownloadOver(long long int total_read,\n\t\tdouble spent);\n        ......\n};\n```\n\n4、用 VC2003 编译该例子，运行可执行程序可以得到如下的界面：\n![运行界面](/img/aio_rpc_mfc.png)\n\n运行这个例子，在 URL 中输入地址（如：http://www.sina.com.cn ），点“开始运行”按钮，在下载 URL 数据的过程中移动界面窗口，可以看到界面窗口的消息过程并未被阻塞（因为 HTTP 阻塞下载过程是在子线程中进行的），同时界面的状态栏还能实时显示当前 URL 下载的进度状态（子线程通过 rpc_request 的消息传递方式将下载状态通知界面主线程）。\n\n## 四、小结\n\n在界面编程中，将阻塞过程与界面过程分离（ 即将阻塞过程交由子线程处理）是一种编程思想，不仅可以用在 PC 机的界面编程中，同时对于手机 APP 开发也有用处，这样做的好处是：一方面可以利用多核，更重要的是使得界面编程更为简单（要比所有模块全部采用非阻塞编程要容易得多）。\n\n## 五、参考\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl\n\n ","source":"_posts/aio_rpc_mfc.md","raw":"---\ntitle: 使用 acl 库 rpc 功能类实现 阻塞任务过程与MFC 界面过程分离\ndate: 2013-02-24 16:42\ncategories: 非阻塞编程\n---\n\n## 一、概述\n\nMFC 程序员在编写 Windows 界面程序时经常需要处理一些阻塞任务过程，为了避免阻塞窗口的消息过程，一般会将阻塞过程将由一个子线程处理，该子线程在处理过程中通过向界面线程发送 Windows 窗口消息将处理结果传递给窗口线程。在 acl 库中的 rpc 功能类实现了更为方便的处理方式，通过 rpc 功能类，用户可以在主线程中进行非阻塞过程（如：界面消息过程或网络非阻塞通讯过程），而将阻塞任务交由子线程处理（如：网络阻塞通讯或数据库操作等），子线程可以将任务处理的中间状态和最终状态通过 rpc 功能类传递给主线程。\n\nacl 的 rpc 类不仅能实现网络通讯方面的阻塞与非阻塞的粘合，同时还实现了阻塞过程与 MFC 界面过程的粘合，本文将以一个具体的 HTTP 下载过程为例来描述这一过程（示例在 acl 库中的 acl/lib_acl_cpp/samples/gui_rpc 目录下）。关于 acl 库中 rpc 相关类的使用，用户可以参考 《acl_cpp 的 rpc 相关类整合阻塞及非阻塞过程》（在该文中的例子描述了非阻塞主线程与阻塞子线程的交互过程，其示例代码适用于 win32 及 linux 平台）。\n\n## 二、实例\n\n### 1、在界面主线程中初始化时创建 rpc 服务对象：acl::rpc_service\n\n```c++\n\t// 全局静态变量\n\tstatic acl::aio_handle* handle_;\n\tstatic acl::rpc_service* service_;\n\n\t......\n\n\t// 创建非阻塞框架句柄，并采用 WIN32 消息模式：acl::ENGINE_WINMSG\n\thandle_ = new acl::aio_handle(acl::ENGINE_WINMSG);\n\n\t// 创建 rpc 服务对象\n\tint max_threads = 10;  // 服务最大子线程数量\n\tservice_ = new acl::rpc_service(max_threads, true);\n\t// 打开消息服务\n\tif (service_->open(handle_) == false)\n\t\tlogger_fatal(\"open service error: %s\", acl::last_serror());\n```\n\n在上面代码中，有几点需要注意：1）创建的 rpc 服务对象是全局性的；2）在创建非阻塞句柄时必须指定为 win32 界面消息事件类型：acl::ENGINE_WINMSG；3）在创建 rpc_service 时的第二个参数 win32_gui 必须为 true。\n\n### 2、创建 rpc 中 acl::rpc_request 类的子类，以实现阻塞非阻塞粘合过程\n本例中该子类为：http_download，在 http_download 类中必须实现父类 acl::rpc_request 中定义的两个纯虚接口：rpc_run，rpc_onover。\n\n其中，http_download 的头文件如下：\n\n```c++\n/**\n * http 请求过程类，该类对象在子线程中发起远程 HTTP 请求过程，将处理结果\n * 返回给主线程\n */\nclass http_download : public acl::rpc_request\n{\npublic:\n\t/**\n\t * 构造函数\n\t * @param addr {const char*} HTTP 服务器地址，格式：domain:port\n\t * @param url {const char*} http url 地址\n\t * @param callback {rpc_callback*} http 请求结果通过此类对象\n\t *  通知主线程过程\n\t */\n\thttp_download(const char* addr, const char* url,\n\t\trpc_callback* callback);\nprotected:\n\t~http_download() {}\n\n\t// 基类虚函数：子线程处理函数\n\tvirtual void rpc_run();\n\n\t// 基类虚函数：主线程处理过程，收到子线程任务完成的消息\n\tvirtual void rpc_onover();\n\n\t// 基类虚函数：主线程处理过程，收到子线程的通知消息\n\tvirtual void rpc_wakeup(void* ctx);\n\n        ......\n```\n\n在 http_download 类的构造参数中有一个接口类：rpc_callback，这是一个纯虚类，主要是为了方便将 http 的结果数据返回给主线程，该类的声明如下：\n\n```c++\n// 纯虚类，子类须实现该类中的纯虚接口\nclass rpc_callback\n{\npublic:\n\trpc_callback() {}\n\tvirtual ~rpc_callback() {}\n\n\t// 设置 HTTP 请求头数据虚函数\n\tvirtual void SetRequestHdr(const char* hdr) = 0;\n\t// 设置 HTTP 响应头数据虚函数\n\tvirtual void SetResponseHdr(const char* hdr) = 0;\n\t// 下载过程中的回调函数虚函数\n\tvirtual void OnDownloading(long long int content_length,\n\t\tlong long int total_read) = 0;\n\t// 下载完成时的回调函数虚函数\n\tvirtual void OnDownloadOver(long long int total_read,\n\t\tdouble spent) = 0;\n};\n```\n\nhttp_download 类的函数实现如下：\n\n```c++\n#include \"stdafx.h\"\n#include <assert.h>\n#include \"http_download.h\"\n\n// 由子线程动态创建的 DOWN_CTX 对象的数据类型\ntypedef enum\n{\n\tCTX_T_REQ_HDR,\t\t// 为 HTTP 请求头数据\n\tCTX_T_RES_HDR,\t\t// 为 HTTP 响应头数据\n\tCTX_T_CONTENT_LENGTH,\t// 为 HTTP 响应体的长度\n\tCTX_T_PARTIAL_LENGTH,\t// 为 HTTP 下载数据体的长度\n\tCTX_T_END\n} ctx_t;\n\n// 子线程动态创建的数据对象，主线程接收此数据\nstruct DOWN_CTX \n{\n\tctx_t type;\n\tlong long int length;\n};\n\n// 用来精确计算时间截间隔的函数，精确到毫秒级别\nstatic double stamp_sub(const struct timeval *from,\n\tconst struct timeval *sub_by)\n{\n\tstruct timeval res;\n\n\tmemcpy(&res, from, sizeof(struct timeval));\n\n\tres.tv_usec -= sub_by->tv_usec;\n\tif (res.tv_usec < 0)\n\t{\n\t\t--res.tv_sec;\n\t\tres.tv_usec += 1000000;\n\t}\n\n\tres.tv_sec -= sub_by->tv_sec;\n\treturn (res.tv_sec * 1000.0 + res.tv_usec/1000.0);\n}\n\n//////////////////////////////////////////////////////////////////////////\n\n// 子线程处理函数\nvoid http_download::rpc_run()\n{\n\tacl::http_request req(addr_);  // HTTP 请求对象\n\t// 设置 HTTP 请求头信息\n\treq.request_header().set_url(url_.c_str())\n\t\t.set_content_type(\"text/html\")\n\t\t.set_host(addr_.c_str())\n\t\t.set_method(acl::HTTP_METHOD_GET);\n\n\treq.request_header().build_request(req_hdr_);\n\tDOWN_CTX* ctx = new DOWN_CTX;\n\tctx->type = CTX_T_REQ_HDR;\n\trpc_signal(ctx);  // 通知主线程 HTTP 请求头数据\n\n\tstruct timeval begin, end;;\n\tgettimeofday(&begin, NULL);\n\n\t// 发送 HTTP 请求数据\n\tif (req.request(NULL, 0) == false)\n\t{\n\t\tlogger_error(\"send request error\");\n\t\terror_ = false;\n\t\tgettimeofday(&end, NULL);\n\t\ttotal_spent_ = stamp_sub(&end, &begin);\n\t\treturn;\n\t}\n\n\t// 获得 HTTP 请求的连接对象\n\tacl::http_client* conn = req.get_client();\n\tassert(conn);\n\n\t(void) conn->get_respond_head(&res_hdr_);\n\tctx = new DOWN_CTX;\n\tctx->type = CTX_T_RES_HDR;\n\trpc_signal(ctx);   // 通知主线程 HTTP 响应头数据\n\n\tctx = new DOWN_CTX;\n\tctx->type = CTX_T_CONTENT_LENGTH;\n\t\n\tctx->length = conn->body_length();  // 获得 HTTP 响应数据的数据体长度\n\tcontent_length_ = ctx->length;\n\trpc_signal(ctx);  // 通知主线程 HTTP 响应体数据长度\n\n\tacl::string buf(8192);\n\tint   real_size;\n\twhile (true)\n\t{\n\t\t// 读 HTTP 响应数据体\n\t\tint ret = req.read_body(buf, true, &real_size);\n\t\tif (ret <= 0)\n\t\t{\n\t\t\tctx = new DOWN_CTX;\n\t\t\tctx->type = CTX_T_END;\n\t\t\tctx->length = ret;\n\t\t\trpc_signal(ctx);  // 通知主线程下载完毕\n\t\t\tbreak;\n\t\t}\n\t\tctx = new DOWN_CTX;\n\t\tctx->type = CTX_T_PARTIAL_LENGTH;\n\t\tctx->length = real_size;\n\t\t// 通知主线程当前已经下载的大小\n\t\trpc_signal(ctx);\n\t}\n\n\t// 计算下载过程总时长\n\tgettimeofday(&end, NULL);\n\ttotal_spent_ = stamp_sub(&end, &begin);\n\n\t// 至此，子线程运行完毕，主线程的 rpc_onover 过程将被调用\n}\n\n//////////////////////////////////////////////////////////////////////////\n\nhttp_download::http_download(const char* addr, const char* url,\n\trpc_callback* callback)\n\t: addr_(addr)\n\t, url_(url)\n\t, callback_(callback)\n\t, error_(false)\n\t, total_read_(0)\n\t, content_length_(0)\n\t, total_spent_(0)\n{\n\n}\n\n//////////////////////////////////////////////////////////////////////////\n\n// 主线程处理过程，收到子线程任务完成的消息\nvoid http_download::rpc_onover()\n{\n\tlogger(\"http download(%s) over, 共 %I64d 字节，耗时 %.3f 毫秒\",\n\t\turl_.c_str(), total_read_, total_spent_);\n\tcallback_->OnDownloadOver(total_read_, total_spent_);\n\tdelete this;  // 销毁本对象\n}\n\n// 主线程处理过程，收到子线程的通知消息\nvoid http_download::rpc_wakeup(void* ctx)\n{\n\tDOWN_CTX* down_ctx = (DOWN_CTX*) ctx;\n\n\t// 根据子线程中传来的不同的下载阶段进行处理\n\n\tswitch (down_ctx->type)\n\t{\n\tcase CTX_T_REQ_HDR:\n\t\tcallback_->SetRequestHdr(req_hdr_.c_str());\n\t\tbreak;\n\tcase CTX_T_RES_HDR:\n\t\tcallback_->SetResponseHdr(res_hdr_.c_str());\n\t\tbreak;\n\tcase CTX_T_CONTENT_LENGTH:\n\t\tbreak;\n\tcase CTX_T_PARTIAL_LENGTH:\n\t\ttotal_read_ += down_ctx->length;\n\t\tcallback_->OnDownloading(content_length_, total_read_);\n\t\tbreak;\n\tcase CTX_T_END:\n\t\tlogger(\"%s: read over\", addr_.c_str());\n\t\tbreak;\n\tdefault:\n\t\tlogger_error(\"%s: ERROR\", addr_.c_str());\n\t\tbreak;\n\t}\n\n\t// 删除在子线程中动态分配的对象\n\tdelete down_ctx;\n}\n\n//////////////////////////////////////////////////////////////////////////\n```\n  \n\n### 3、在 MFC 界面类中创建 rpc_callback 的子类，接收子线程的 HTTP 处理结果\n本例直接将对话框类继承了 rpc_callback 接口类，其中部分内容如下：\n\n```c++\n// Cgui_rpcDlg 对话框\nclass Cgui_rpcDlg : public CDialog\n\t, public rpc_callback\n{\n// 构造\npublic:\n\tCgui_rpcDlg(CWnd* pParent = NULL);\t// 标准构造函数\n\t~Cgui_rpcDlg();\n\n        ......\n\npublic:\n\t// 基类 rpc_callback 虚函数\n\n\t// 设置 HTTP 请求头数据虚函数\n\tvirtual void SetRequestHdr(const char* hdr);\n\t// 设置 HTTP 响应头数据虚函数\n\tvirtual void SetResponseHdr(const char* hdr);\n\t// 下载过程中的回调函数虚函数\n\tvirtual void OnDownloading(long long int content_length,\n\t\tlong long int total_read);\n\t// 下载完成时的回调函数虚函数\n\tvirtual void OnDownloadOver(long long int total_read,\n\t\tdouble spent);\n        ......\n};\n```\n\n4、用 VC2003 编译该例子，运行可执行程序可以得到如下的界面：\n![运行界面](/img/aio_rpc_mfc.png)\n\n运行这个例子，在 URL 中输入地址（如：http://www.sina.com.cn ），点“开始运行”按钮，在下载 URL 数据的过程中移动界面窗口，可以看到界面窗口的消息过程并未被阻塞（因为 HTTP 阻塞下载过程是在子线程中进行的），同时界面的状态栏还能实时显示当前 URL 下载的进度状态（子线程通过 rpc_request 的消息传递方式将下载状态通知界面主线程）。\n\n## 四、小结\n\n在界面编程中，将阻塞过程与界面过程分离（ 即将阻塞过程交由子线程处理）是一种编程思想，不仅可以用在 PC 机的界面编程中，同时对于手机 APP 开发也有用处，这样做的好处是：一方面可以利用多核，更重要的是使得界面编程更为简单（要比所有模块全部采用非阻塞编程要容易得多）。\n\n## 五、参考\n\ngithub：https://github.com/acl-dev/acl\ngitee：https://gitee.com/acl-dev/acl\n\n ","slug":"aio_rpc_mfc","published":1,"updated":"2023-01-24T10:26:53.568Z","_id":"clda37ubj000h8o9ka3shfms3","comments":1,"layout":"post","photos":[],"link":"","content":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>MFC 程序员在编写 Windows 界面程序时经常需要处理一些阻塞任务过程，为了避免阻塞窗口的消息过程，一般会将阻塞过程将由一个子线程处理，该子线程在处理过程中通过向界面线程发送 Windows 窗口消息将处理结果传递给窗口线程。在 acl 库中的 rpc 功能类实现了更为方便的处理方式，通过 rpc 功能类，用户可以在主线程中进行非阻塞过程（如：界面消息过程或网络非阻塞通讯过程），而将阻塞任务交由子线程处理（如：网络阻塞通讯或数据库操作等），子线程可以将任务处理的中间状态和最终状态通过 rpc 功能类传递给主线程。</p>\n<p>acl 的 rpc 类不仅能实现网络通讯方面的阻塞与非阻塞的粘合，同时还实现了阻塞过程与 MFC 界面过程的粘合，本文将以一个具体的 HTTP 下载过程为例来描述这一过程（示例在 acl 库中的 acl&#x2F;lib_acl_cpp&#x2F;samples&#x2F;gui_rpc 目录下）。关于 acl 库中 rpc 相关类的使用，用户可以参考 《acl_cpp 的 rpc 相关类整合阻塞及非阻塞过程》（在该文中的例子描述了非阻塞主线程与阻塞子线程的交互过程，其示例代码适用于 win32 及 linux 平台）。</p>\n<h2 id=\"二、实例\"><a href=\"#二、实例\" class=\"headerlink\" title=\"二、实例\"></a>二、实例</h2><h3 id=\"1、在界面主线程中初始化时创建-rpc-服务对象：acl-rpc-service\"><a href=\"#1、在界面主线程中初始化时创建-rpc-服务对象：acl-rpc-service\" class=\"headerlink\" title=\"1、在界面主线程中初始化时创建 rpc 服务对象：acl::rpc_service\"></a>1、在界面主线程中初始化时创建 rpc 服务对象：acl::rpc_service</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 全局静态变量</span><br><span class=\"hljs-type\">static</span> acl::aio_handle* handle_;<br><span class=\"hljs-type\">static</span> acl::rpc_service* service_;<br><br>......<br><br><span class=\"hljs-comment\">// 创建非阻塞框架句柄，并采用 WIN32 消息模式：acl::ENGINE_WINMSG</span><br>handle_ = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">aio_handle</span>(acl::ENGINE_WINMSG);<br><br><span class=\"hljs-comment\">// 创建 rpc 服务对象</span><br><span class=\"hljs-type\">int</span> max_threads = <span class=\"hljs-number\">10</span>;  <span class=\"hljs-comment\">// 服务最大子线程数量</span><br>service_ = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">rpc_service</span>(max_threads, <span class=\"hljs-literal\">true</span>);<br><span class=\"hljs-comment\">// 打开消息服务</span><br><span class=\"hljs-keyword\">if</span> (service_-&gt;<span class=\"hljs-built_in\">open</span>(handle_) == <span class=\"hljs-literal\">false</span>)<br>\t<span class=\"hljs-built_in\">logger_fatal</span>(<span class=\"hljs-string\">&quot;open service error: %s&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br></code></pre></td></tr></table></figure>\n\n<p>在上面代码中，有几点需要注意：1）创建的 rpc 服务对象是全局性的；2）在创建非阻塞句柄时必须指定为 win32 界面消息事件类型：acl::ENGINE_WINMSG；3）在创建 rpc_service 时的第二个参数 win32_gui 必须为 true。</p>\n<h3 id=\"2、创建-rpc-中-acl-rpc-request-类的子类，以实现阻塞非阻塞粘合过程\"><a href=\"#2、创建-rpc-中-acl-rpc-request-类的子类，以实现阻塞非阻塞粘合过程\" class=\"headerlink\" title=\"2、创建 rpc 中 acl::rpc_request 类的子类，以实现阻塞非阻塞粘合过程\"></a>2、创建 rpc 中 acl::rpc_request 类的子类，以实现阻塞非阻塞粘合过程</h3><p>本例中该子类为：http_download，在 http_download 类中必须实现父类 acl::rpc_request 中定义的两个纯虚接口：rpc_run，rpc_onover。</p>\n<p>其中，http_download 的头文件如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * http 请求过程类，该类对象在子线程中发起远程 HTTP 请求过程，将处理结果</span><br><span class=\"hljs-comment\"> * 返回给主线程</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_download</span> : <span class=\"hljs-keyword\">public</span> acl::rpc_request<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 构造函数</span><br><span class=\"hljs-comment\">\t * @param addr &#123;const char*&#125; HTTP 服务器地址，格式：domain:port</span><br><span class=\"hljs-comment\">\t * @param url &#123;const char*&#125; http url 地址</span><br><span class=\"hljs-comment\">\t * @param callback &#123;rpc_callback*&#125; http 请求结果通过此类对象</span><br><span class=\"hljs-comment\">\t *  通知主线程过程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-built_in\">http_download</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* url,<br>\t\trpc_callback* callback);<br><span class=\"hljs-keyword\">protected</span>:<br>\t~<span class=\"hljs-built_in\">http_download</span>() &#123;&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：子线程处理函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_run</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：主线程处理过程，收到子线程任务完成的消息</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_onover</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：主线程处理过程，收到子线程的通知消息</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_wakeup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span>;<br><br>        ......<br></code></pre></td></tr></table></figure>\n\n<p>在 http_download 类的构造参数中有一个接口类：rpc_callback，这是一个纯虚类，主要是为了方便将 http 的结果数据返回给主线程，该类的声明如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 纯虚类，子类须实现该类中的纯虚接口</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">rpc_callback</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">rpc_callback</span>() &#123;&#125;<br>\t<span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">rpc_callback</span>() &#123;&#125;<br><br>\t<span class=\"hljs-comment\">// 设置 HTTP 请求头数据虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetRequestHdr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* hdr)</span> </span>= <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-comment\">// 设置 HTTP 响应头数据虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetResponseHdr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* hdr)</span> </span>= <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-comment\">// 下载过程中的回调函数虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnDownloading</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> content_length,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> total_read)</span> </span>= <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-comment\">// 下载完成时的回调函数虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnDownloadOver</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> total_read,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">double</span> spent)</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>http_download 类的函数实现如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;http_download.h&quot;</span></span><br><br><span class=\"hljs-comment\">// 由子线程动态创建的 DOWN_CTX 对象的数据类型</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span><br>&#123;<br>\tCTX_T_REQ_HDR,\t\t<span class=\"hljs-comment\">// 为 HTTP 请求头数据</span><br>\tCTX_T_RES_HDR,\t\t<span class=\"hljs-comment\">// 为 HTTP 响应头数据</span><br>\tCTX_T_CONTENT_LENGTH,\t<span class=\"hljs-comment\">// 为 HTTP 响应体的长度</span><br>\tCTX_T_PARTIAL_LENGTH,\t<span class=\"hljs-comment\">// 为 HTTP 下载数据体的长度</span><br>\tCTX_T_END<br>&#125; <span class=\"hljs-type\">ctx_t</span>;<br><br><span class=\"hljs-comment\">// 子线程动态创建的数据对象，主线程接收此数据</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DOWN_CTX</span> <br>&#123;<br>\t<span class=\"hljs-type\">ctx_t</span> type;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> length;<br>&#125;;<br><br><span class=\"hljs-comment\">// 用来精确计算时间截间隔的函数，精确到毫秒级别</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title\">stamp_sub</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> timeval *from,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> timeval *sub_by)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">timeval</span> res;<br><br>\t<span class=\"hljs-built_in\">memcpy</span>(&amp;res, from, <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> timeval));<br><br>\tres.tv_usec -= sub_by-&gt;tv_usec;<br>\t<span class=\"hljs-keyword\">if</span> (res.tv_usec &lt; <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t--res.tv_sec;<br>\t\tres.tv_usec += <span class=\"hljs-number\">1000000</span>;<br>\t&#125;<br><br>\tres.tv_sec -= sub_by-&gt;tv_sec;<br>\t<span class=\"hljs-keyword\">return</span> (res.tv_sec * <span class=\"hljs-number\">1000.0</span> + res.tv_usec/<span class=\"hljs-number\">1000.0</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-comment\">// 子线程处理函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_download::rpc_run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">acl::http_request <span class=\"hljs-title\">req</span><span class=\"hljs-params\">(addr_)</span></span>;  <span class=\"hljs-comment\">// HTTP 请求对象</span><br>\t<span class=\"hljs-comment\">// 设置 HTTP 请求头信息</span><br>\treq.<span class=\"hljs-built_in\">request_header</span>().<span class=\"hljs-built_in\">set_url</span>(url_.<span class=\"hljs-built_in\">c_str</span>())<br>\t\t.<span class=\"hljs-built_in\">set_content_type</span>(<span class=\"hljs-string\">&quot;text/html&quot;</span>)<br>\t\t.<span class=\"hljs-built_in\">set_host</span>(addr_.<span class=\"hljs-built_in\">c_str</span>())<br>\t\t.<span class=\"hljs-built_in\">set_method</span>(acl::HTTP_METHOD_GET);<br><br>\treq.<span class=\"hljs-built_in\">request_header</span>().<span class=\"hljs-built_in\">build_request</span>(req_hdr_);<br>\tDOWN_CTX* ctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\tctx-&gt;type = CTX_T_REQ_HDR;<br>\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);  <span class=\"hljs-comment\">// 通知主线程 HTTP 请求头数据</span><br><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">timeval</span> begin, end;;<br>\t<span class=\"hljs-built_in\">gettimeofday</span>(&amp;begin, <span class=\"hljs-literal\">NULL</span>);<br><br>\t<span class=\"hljs-comment\">// 发送 HTTP 请求数据</span><br>\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">request</span>(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;send request error&quot;</span>);<br>\t\terror_ = <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-built_in\">gettimeofday</span>(&amp;end, <span class=\"hljs-literal\">NULL</span>);<br>\t\ttotal_spent_ = <span class=\"hljs-built_in\">stamp_sub</span>(&amp;end, &amp;begin);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 获得 HTTP 请求的连接对象</span><br>\tacl::http_client* conn = req.<span class=\"hljs-built_in\">get_client</span>();<br>\t<span class=\"hljs-built_in\">assert</span>(conn);<br><br>\t(<span class=\"hljs-type\">void</span>) conn-&gt;<span class=\"hljs-built_in\">get_respond_head</span>(&amp;res_hdr_);<br>\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\tctx-&gt;type = CTX_T_RES_HDR;<br>\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);   <span class=\"hljs-comment\">// 通知主线程 HTTP 响应头数据</span><br><br>\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\tctx-&gt;type = CTX_T_CONTENT_LENGTH;<br>\t<br>\tctx-&gt;length = conn-&gt;<span class=\"hljs-built_in\">body_length</span>();  <span class=\"hljs-comment\">// 获得 HTTP 响应数据的数据体长度</span><br>\tcontent_length_ = ctx-&gt;length;<br>\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);  <span class=\"hljs-comment\">// 通知主线程 HTTP 响应体数据长度</span><br><br>\t<span class=\"hljs-function\">acl::string <span class=\"hljs-title\">buf</span><span class=\"hljs-params\">(<span class=\"hljs-number\">8192</span>)</span></span>;<br>\t<span class=\"hljs-type\">int</span>   real_size;<br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 读 HTTP 响应数据体</span><br>\t\t<span class=\"hljs-type\">int</span> ret = req.<span class=\"hljs-built_in\">read_body</span>(buf, <span class=\"hljs-literal\">true</span>, &amp;real_size);<br>\t\t<span class=\"hljs-keyword\">if</span> (ret &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\t\tctx-&gt;type = CTX_T_END;<br>\t\t\tctx-&gt;length = ret;<br>\t\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);  <span class=\"hljs-comment\">// 通知主线程下载完毕</span><br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\tctx-&gt;type = CTX_T_PARTIAL_LENGTH;<br>\t\tctx-&gt;length = real_size;<br>\t\t<span class=\"hljs-comment\">// 通知主线程当前已经下载的大小</span><br>\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 计算下载过程总时长</span><br>\t<span class=\"hljs-built_in\">gettimeofday</span>(&amp;end, <span class=\"hljs-literal\">NULL</span>);<br>\ttotal_spent_ = <span class=\"hljs-built_in\">stamp_sub</span>(&amp;end, &amp;begin);<br><br>\t<span class=\"hljs-comment\">// 至此，子线程运行完毕，主线程的 rpc_onover 过程将被调用</span><br>&#125;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br>http_download::<span class=\"hljs-built_in\">http_download</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* url,<br>\trpc_callback* callback)<br>\t: <span class=\"hljs-built_in\">addr_</span>(addr)<br>\t, <span class=\"hljs-built_in\">url_</span>(url)<br>\t, <span class=\"hljs-built_in\">callback_</span>(callback)<br>\t, <span class=\"hljs-built_in\">error_</span>(<span class=\"hljs-literal\">false</span>)<br>\t, <span class=\"hljs-built_in\">total_read_</span>(<span class=\"hljs-number\">0</span>)<br>\t, <span class=\"hljs-built_in\">content_length_</span>(<span class=\"hljs-number\">0</span>)<br>\t, <span class=\"hljs-built_in\">total_spent_</span>(<span class=\"hljs-number\">0</span>)<br>&#123;<br><br>&#125;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-comment\">// 主线程处理过程，收到子线程任务完成的消息</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_download::rpc_onover</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">logger</span>(<span class=\"hljs-string\">&quot;http download(%s) over, 共 %I64d 字节，耗时 %.3f 毫秒&quot;</span>,<br>\t\turl_.<span class=\"hljs-built_in\">c_str</span>(), total_read_, total_spent_);<br>\tcallback_-&gt;<span class=\"hljs-built_in\">OnDownloadOver</span>(total_read_, total_spent_);<br>\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;  <span class=\"hljs-comment\">// 销毁本对象</span><br>&#125;<br><br><span class=\"hljs-comment\">// 主线程处理过程，收到子线程的通知消息</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_download::rpc_wakeup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tDOWN_CTX* down_ctx = (DOWN_CTX*) ctx;<br><br>\t<span class=\"hljs-comment\">// 根据子线程中传来的不同的下载阶段进行处理</span><br><br>\t<span class=\"hljs-keyword\">switch</span> (down_ctx-&gt;type)<br>\t&#123;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_REQ_HDR:<br>\t\tcallback_-&gt;<span class=\"hljs-built_in\">SetRequestHdr</span>(req_hdr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_RES_HDR:<br>\t\tcallback_-&gt;<span class=\"hljs-built_in\">SetResponseHdr</span>(res_hdr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_CONTENT_LENGTH:<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_PARTIAL_LENGTH:<br>\t\ttotal_read_ += down_ctx-&gt;length;<br>\t\tcallback_-&gt;<span class=\"hljs-built_in\">OnDownloading</span>(content_length_, total_read_);<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_END:<br>\t\t<span class=\"hljs-built_in\">logger</span>(<span class=\"hljs-string\">&quot;%s: read over&quot;</span>, addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">default</span>:<br>\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;%s: ERROR&quot;</span>, addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 删除在子线程中动态分配的对象</span><br>\t<span class=\"hljs-keyword\">delete</span> down_ctx;<br>&#125;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"3、在-MFC-界面类中创建-rpc-callback-的子类，接收子线程的-HTTP-处理结果\"><a href=\"#3、在-MFC-界面类中创建-rpc-callback-的子类，接收子线程的-HTTP-处理结果\" class=\"headerlink\" title=\"3、在 MFC 界面类中创建 rpc_callback 的子类，接收子线程的 HTTP 处理结果\"></a>3、在 MFC 界面类中创建 rpc_callback 的子类，接收子线程的 HTTP 处理结果</h3><p>本例直接将对话框类继承了 rpc_callback 接口类，其中部分内容如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// Cgui_rpcDlg 对话框</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cgui_rpcDlg</span> : <span class=\"hljs-keyword\">public</span> CDialog<br>\t, <span class=\"hljs-keyword\">public</span> rpc_callback<br>&#123;<br><span class=\"hljs-comment\">// 构造</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Cgui_rpcDlg</span>(CWnd* pParent = <span class=\"hljs-literal\">NULL</span>);\t<span class=\"hljs-comment\">// 标准构造函数</span><br>\t~<span class=\"hljs-built_in\">Cgui_rpcDlg</span>();<br><br>        ......<br><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 基类 rpc_callback 虚函数</span><br><br>\t<span class=\"hljs-comment\">// 设置 HTTP 请求头数据虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetRequestHdr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* hdr)</span></span>;<br>\t<span class=\"hljs-comment\">// 设置 HTTP 响应头数据虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetResponseHdr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* hdr)</span></span>;<br>\t<span class=\"hljs-comment\">// 下载过程中的回调函数虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnDownloading</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> content_length,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> total_read)</span></span>;<br>\t<span class=\"hljs-comment\">// 下载完成时的回调函数虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnDownloadOver</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> total_read,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">double</span> spent)</span></span>;<br>        ......<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>4、用 VC2003 编译该例子，运行可执行程序可以得到如下的界面：<br><img src=\"/img/aio_rpc_mfc.png\" alt=\"运行界面\"></p>\n<p>运行这个例子，在 URL 中输入地址（如：<a href=\"http://www.sina.com.cn/\">http://www.sina.com.cn</a> ），点“开始运行”按钮，在下载 URL 数据的过程中移动界面窗口，可以看到界面窗口的消息过程并未被阻塞（因为 HTTP 阻塞下载过程是在子线程中进行的），同时界面的状态栏还能实时显示当前 URL 下载的进度状态（子线程通过 rpc_request 的消息传递方式将下载状态通知界面主线程）。</p>\n<h2 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h2><p>在界面编程中，将阻塞过程与界面过程分离（ 即将阻塞过程交由子线程处理）是一种编程思想，不仅可以用在 PC 机的界面编程中，同时对于手机 APP 开发也有用处，这样做的好处是：一方面可以利用多核，更重要的是使得界面编程更为简单（要比所有模块全部采用非阻塞编程要容易得多）。</p>\n<h2 id=\"五、参考\"><a href=\"#五、参考\" class=\"headerlink\" title=\"五、参考\"></a>五、参考</h2><p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、概述\"><a href=\"#一、概述\" class=\"headerlink\" title=\"一、概述\"></a>一、概述</h2><p>MFC 程序员在编写 Windows 界面程序时经常需要处理一些阻塞任务过程，为了避免阻塞窗口的消息过程，一般会将阻塞过程将由一个子线程处理，该子线程在处理过程中通过向界面线程发送 Windows 窗口消息将处理结果传递给窗口线程。在 acl 库中的 rpc 功能类实现了更为方便的处理方式，通过 rpc 功能类，用户可以在主线程中进行非阻塞过程（如：界面消息过程或网络非阻塞通讯过程），而将阻塞任务交由子线程处理（如：网络阻塞通讯或数据库操作等），子线程可以将任务处理的中间状态和最终状态通过 rpc 功能类传递给主线程。</p>\n<p>acl 的 rpc 类不仅能实现网络通讯方面的阻塞与非阻塞的粘合，同时还实现了阻塞过程与 MFC 界面过程的粘合，本文将以一个具体的 HTTP 下载过程为例来描述这一过程（示例在 acl 库中的 acl&#x2F;lib_acl_cpp&#x2F;samples&#x2F;gui_rpc 目录下）。关于 acl 库中 rpc 相关类的使用，用户可以参考 《acl_cpp 的 rpc 相关类整合阻塞及非阻塞过程》（在该文中的例子描述了非阻塞主线程与阻塞子线程的交互过程，其示例代码适用于 win32 及 linux 平台）。</p>\n<h2 id=\"二、实例\"><a href=\"#二、实例\" class=\"headerlink\" title=\"二、实例\"></a>二、实例</h2><h3 id=\"1、在界面主线程中初始化时创建-rpc-服务对象：acl-rpc-service\"><a href=\"#1、在界面主线程中初始化时创建-rpc-服务对象：acl-rpc-service\" class=\"headerlink\" title=\"1、在界面主线程中初始化时创建 rpc 服务对象：acl::rpc_service\"></a>1、在界面主线程中初始化时创建 rpc 服务对象：acl::rpc_service</h3><figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 全局静态变量</span><br><span class=\"hljs-type\">static</span> acl::aio_handle* handle_;<br><span class=\"hljs-type\">static</span> acl::rpc_service* service_;<br><br>......<br><br><span class=\"hljs-comment\">// 创建非阻塞框架句柄，并采用 WIN32 消息模式：acl::ENGINE_WINMSG</span><br>handle_ = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">aio_handle</span>(acl::ENGINE_WINMSG);<br><br><span class=\"hljs-comment\">// 创建 rpc 服务对象</span><br><span class=\"hljs-type\">int</span> max_threads = <span class=\"hljs-number\">10</span>;  <span class=\"hljs-comment\">// 服务最大子线程数量</span><br>service_ = <span class=\"hljs-keyword\">new</span> acl::<span class=\"hljs-built_in\">rpc_service</span>(max_threads, <span class=\"hljs-literal\">true</span>);<br><span class=\"hljs-comment\">// 打开消息服务</span><br><span class=\"hljs-keyword\">if</span> (service_-&gt;<span class=\"hljs-built_in\">open</span>(handle_) == <span class=\"hljs-literal\">false</span>)<br>\t<span class=\"hljs-built_in\">logger_fatal</span>(<span class=\"hljs-string\">&quot;open service error: %s&quot;</span>, acl::<span class=\"hljs-built_in\">last_serror</span>());<br></code></pre></td></tr></table></figure>\n\n<p>在上面代码中，有几点需要注意：1）创建的 rpc 服务对象是全局性的；2）在创建非阻塞句柄时必须指定为 win32 界面消息事件类型：acl::ENGINE_WINMSG；3）在创建 rpc_service 时的第二个参数 win32_gui 必须为 true。</p>\n<h3 id=\"2、创建-rpc-中-acl-rpc-request-类的子类，以实现阻塞非阻塞粘合过程\"><a href=\"#2、创建-rpc-中-acl-rpc-request-类的子类，以实现阻塞非阻塞粘合过程\" class=\"headerlink\" title=\"2、创建 rpc 中 acl::rpc_request 类的子类，以实现阻塞非阻塞粘合过程\"></a>2、创建 rpc 中 acl::rpc_request 类的子类，以实现阻塞非阻塞粘合过程</h3><p>本例中该子类为：http_download，在 http_download 类中必须实现父类 acl::rpc_request 中定义的两个纯虚接口：rpc_run，rpc_onover。</p>\n<p>其中，http_download 的头文件如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\"> * http 请求过程类，该类对象在子线程中发起远程 HTTP 请求过程，将处理结果</span><br><span class=\"hljs-comment\"> * 返回给主线程</span><br><span class=\"hljs-comment\"> */</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">http_download</span> : <span class=\"hljs-keyword\">public</span> acl::rpc_request<br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">\t * 构造函数</span><br><span class=\"hljs-comment\">\t * @param addr &#123;const char*&#125; HTTP 服务器地址，格式：domain:port</span><br><span class=\"hljs-comment\">\t * @param url &#123;const char*&#125; http url 地址</span><br><span class=\"hljs-comment\">\t * @param callback &#123;rpc_callback*&#125; http 请求结果通过此类对象</span><br><span class=\"hljs-comment\">\t *  通知主线程过程</span><br><span class=\"hljs-comment\">\t */</span><br>\t<span class=\"hljs-built_in\">http_download</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* url,<br>\t\trpc_callback* callback);<br><span class=\"hljs-keyword\">protected</span>:<br>\t~<span class=\"hljs-built_in\">http_download</span>() &#123;&#125;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：子线程处理函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_run</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：主线程处理过程，收到子线程任务完成的消息</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_onover</span><span class=\"hljs-params\">()</span></span>;<br><br>\t<span class=\"hljs-comment\">// 基类虚函数：主线程处理过程，收到子线程的通知消息</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">rpc_wakeup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span>;<br><br>        ......<br></code></pre></td></tr></table></figure>\n\n<p>在 http_download 类的构造参数中有一个接口类：rpc_callback，这是一个纯虚类，主要是为了方便将 http 的结果数据返回给主线程，该类的声明如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// 纯虚类，子类须实现该类中的纯虚接口</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">rpc_callback</span><br>&#123;<br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">rpc_callback</span>() &#123;&#125;<br>\t<span class=\"hljs-keyword\">virtual</span> ~<span class=\"hljs-built_in\">rpc_callback</span>() &#123;&#125;<br><br>\t<span class=\"hljs-comment\">// 设置 HTTP 请求头数据虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetRequestHdr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* hdr)</span> </span>= <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-comment\">// 设置 HTTP 响应头数据虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetResponseHdr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* hdr)</span> </span>= <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-comment\">// 下载过程中的回调函数虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnDownloading</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> content_length,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> total_read)</span> </span>= <span class=\"hljs-number\">0</span>;<br>\t<span class=\"hljs-comment\">// 下载完成时的回调函数虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnDownloadOver</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> total_read,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">double</span> spent)</span> </span>= <span class=\"hljs-number\">0</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>http_download 类的函数实现如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br><span class=\"line\">137</span><br><span class=\"line\">138</span><br><span class=\"line\">139</span><br><span class=\"line\">140</span><br><span class=\"line\">141</span><br><span class=\"line\">142</span><br><span class=\"line\">143</span><br><span class=\"line\">144</span><br><span class=\"line\">145</span><br><span class=\"line\">146</span><br><span class=\"line\">147</span><br><span class=\"line\">148</span><br><span class=\"line\">149</span><br><span class=\"line\">150</span><br><span class=\"line\">151</span><br><span class=\"line\">152</span><br><span class=\"line\">153</span><br><span class=\"line\">154</span><br><span class=\"line\">155</span><br><span class=\"line\">156</span><br><span class=\"line\">157</span><br><span class=\"line\">158</span><br><span class=\"line\">159</span><br><span class=\"line\">160</span><br><span class=\"line\">161</span><br><span class=\"line\">162</span><br><span class=\"line\">163</span><br><span class=\"line\">164</span><br><span class=\"line\">165</span><br><span class=\"line\">166</span><br><span class=\"line\">167</span><br><span class=\"line\">168</span><br><span class=\"line\">169</span><br><span class=\"line\">170</span><br><span class=\"line\">171</span><br><span class=\"line\">172</span><br><span class=\"line\">173</span><br><span class=\"line\">174</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;stdafx.h&quot;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&lt;assert.h&gt;</span></span><br><span class=\"hljs-meta\">#<span class=\"hljs-keyword\">include</span> <span class=\"hljs-string\">&quot;http_download.h&quot;</span></span><br><br><span class=\"hljs-comment\">// 由子线程动态创建的 DOWN_CTX 对象的数据类型</span><br><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-keyword\">enum</span><br>&#123;<br>\tCTX_T_REQ_HDR,\t\t<span class=\"hljs-comment\">// 为 HTTP 请求头数据</span><br>\tCTX_T_RES_HDR,\t\t<span class=\"hljs-comment\">// 为 HTTP 响应头数据</span><br>\tCTX_T_CONTENT_LENGTH,\t<span class=\"hljs-comment\">// 为 HTTP 响应体的长度</span><br>\tCTX_T_PARTIAL_LENGTH,\t<span class=\"hljs-comment\">// 为 HTTP 下载数据体的长度</span><br>\tCTX_T_END<br>&#125; <span class=\"hljs-type\">ctx_t</span>;<br><br><span class=\"hljs-comment\">// 子线程动态创建的数据对象，主线程接收此数据</span><br><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">DOWN_CTX</span> <br>&#123;<br>\t<span class=\"hljs-type\">ctx_t</span> type;<br>\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> length;<br>&#125;;<br><br><span class=\"hljs-comment\">// 用来精确计算时间截间隔的函数，精确到毫秒级别</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">static</span> <span class=\"hljs-type\">double</span> <span class=\"hljs-title\">stamp_sub</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> timeval *from,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t<span class=\"hljs-type\">const</span> <span class=\"hljs-keyword\">struct</span> timeval *sub_by)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">timeval</span> res;<br><br>\t<span class=\"hljs-built_in\">memcpy</span>(&amp;res, from, <span class=\"hljs-built_in\">sizeof</span>(<span class=\"hljs-keyword\">struct</span> timeval));<br><br>\tres.tv_usec -= sub_by-&gt;tv_usec;<br>\t<span class=\"hljs-keyword\">if</span> (res.tv_usec &lt; <span class=\"hljs-number\">0</span>)<br>\t&#123;<br>\t\t--res.tv_sec;<br>\t\tres.tv_usec += <span class=\"hljs-number\">1000000</span>;<br>\t&#125;<br><br>\tres.tv_sec -= sub_by-&gt;tv_sec;<br>\t<span class=\"hljs-keyword\">return</span> (res.tv_sec * <span class=\"hljs-number\">1000.0</span> + res.tv_usec/<span class=\"hljs-number\">1000.0</span>);<br>&#125;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-comment\">// 子线程处理函数</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_download::rpc_run</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-function\">acl::http_request <span class=\"hljs-title\">req</span><span class=\"hljs-params\">(addr_)</span></span>;  <span class=\"hljs-comment\">// HTTP 请求对象</span><br>\t<span class=\"hljs-comment\">// 设置 HTTP 请求头信息</span><br>\treq.<span class=\"hljs-built_in\">request_header</span>().<span class=\"hljs-built_in\">set_url</span>(url_.<span class=\"hljs-built_in\">c_str</span>())<br>\t\t.<span class=\"hljs-built_in\">set_content_type</span>(<span class=\"hljs-string\">&quot;text/html&quot;</span>)<br>\t\t.<span class=\"hljs-built_in\">set_host</span>(addr_.<span class=\"hljs-built_in\">c_str</span>())<br>\t\t.<span class=\"hljs-built_in\">set_method</span>(acl::HTTP_METHOD_GET);<br><br>\treq.<span class=\"hljs-built_in\">request_header</span>().<span class=\"hljs-built_in\">build_request</span>(req_hdr_);<br>\tDOWN_CTX* ctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\tctx-&gt;type = CTX_T_REQ_HDR;<br>\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);  <span class=\"hljs-comment\">// 通知主线程 HTTP 请求头数据</span><br><br>\t<span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title class_\">timeval</span> begin, end;;<br>\t<span class=\"hljs-built_in\">gettimeofday</span>(&amp;begin, <span class=\"hljs-literal\">NULL</span>);<br><br>\t<span class=\"hljs-comment\">// 发送 HTTP 请求数据</span><br>\t<span class=\"hljs-keyword\">if</span> (req.<span class=\"hljs-built_in\">request</span>(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-number\">0</span>) == <span class=\"hljs-literal\">false</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;send request error&quot;</span>);<br>\t\terror_ = <span class=\"hljs-literal\">false</span>;<br>\t\t<span class=\"hljs-built_in\">gettimeofday</span>(&amp;end, <span class=\"hljs-literal\">NULL</span>);<br>\t\ttotal_spent_ = <span class=\"hljs-built_in\">stamp_sub</span>(&amp;end, &amp;begin);<br>\t\t<span class=\"hljs-keyword\">return</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 获得 HTTP 请求的连接对象</span><br>\tacl::http_client* conn = req.<span class=\"hljs-built_in\">get_client</span>();<br>\t<span class=\"hljs-built_in\">assert</span>(conn);<br><br>\t(<span class=\"hljs-type\">void</span>) conn-&gt;<span class=\"hljs-built_in\">get_respond_head</span>(&amp;res_hdr_);<br>\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\tctx-&gt;type = CTX_T_RES_HDR;<br>\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);   <span class=\"hljs-comment\">// 通知主线程 HTTP 响应头数据</span><br><br>\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\tctx-&gt;type = CTX_T_CONTENT_LENGTH;<br>\t<br>\tctx-&gt;length = conn-&gt;<span class=\"hljs-built_in\">body_length</span>();  <span class=\"hljs-comment\">// 获得 HTTP 响应数据的数据体长度</span><br>\tcontent_length_ = ctx-&gt;length;<br>\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);  <span class=\"hljs-comment\">// 通知主线程 HTTP 响应体数据长度</span><br><br>\t<span class=\"hljs-function\">acl::string <span class=\"hljs-title\">buf</span><span class=\"hljs-params\">(<span class=\"hljs-number\">8192</span>)</span></span>;<br>\t<span class=\"hljs-type\">int</span>   real_size;<br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-literal\">true</span>)<br>\t&#123;<br>\t\t<span class=\"hljs-comment\">// 读 HTTP 响应数据体</span><br>\t\t<span class=\"hljs-type\">int</span> ret = req.<span class=\"hljs-built_in\">read_body</span>(buf, <span class=\"hljs-literal\">true</span>, &amp;real_size);<br>\t\t<span class=\"hljs-keyword\">if</span> (ret &lt;= <span class=\"hljs-number\">0</span>)<br>\t\t&#123;<br>\t\t\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\t\tctx-&gt;type = CTX_T_END;<br>\t\t\tctx-&gt;length = ret;<br>\t\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);  <span class=\"hljs-comment\">// 通知主线程下载完毕</span><br>\t\t\t<span class=\"hljs-keyword\">break</span>;<br>\t\t&#125;<br>\t\tctx = <span class=\"hljs-keyword\">new</span> DOWN_CTX;<br>\t\tctx-&gt;type = CTX_T_PARTIAL_LENGTH;<br>\t\tctx-&gt;length = real_size;<br>\t\t<span class=\"hljs-comment\">// 通知主线程当前已经下载的大小</span><br>\t\t<span class=\"hljs-built_in\">rpc_signal</span>(ctx);<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 计算下载过程总时长</span><br>\t<span class=\"hljs-built_in\">gettimeofday</span>(&amp;end, <span class=\"hljs-literal\">NULL</span>);<br>\ttotal_spent_ = <span class=\"hljs-built_in\">stamp_sub</span>(&amp;end, &amp;begin);<br><br>\t<span class=\"hljs-comment\">// 至此，子线程运行完毕，主线程的 rpc_onover 过程将被调用</span><br>&#125;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br>http_download::<span class=\"hljs-built_in\">http_download</span>(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* addr, <span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* url,<br>\trpc_callback* callback)<br>\t: <span class=\"hljs-built_in\">addr_</span>(addr)<br>\t, <span class=\"hljs-built_in\">url_</span>(url)<br>\t, <span class=\"hljs-built_in\">callback_</span>(callback)<br>\t, <span class=\"hljs-built_in\">error_</span>(<span class=\"hljs-literal\">false</span>)<br>\t, <span class=\"hljs-built_in\">total_read_</span>(<span class=\"hljs-number\">0</span>)<br>\t, <span class=\"hljs-built_in\">content_length_</span>(<span class=\"hljs-number\">0</span>)<br>\t, <span class=\"hljs-built_in\">total_spent_</span>(<span class=\"hljs-number\">0</span>)<br>&#123;<br><br>&#125;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br><br><span class=\"hljs-comment\">// 主线程处理过程，收到子线程任务完成的消息</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_download::rpc_onover</span><span class=\"hljs-params\">()</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\t<span class=\"hljs-built_in\">logger</span>(<span class=\"hljs-string\">&quot;http download(%s) over, 共 %I64d 字节，耗时 %.3f 毫秒&quot;</span>,<br>\t\turl_.<span class=\"hljs-built_in\">c_str</span>(), total_read_, total_spent_);<br>\tcallback_-&gt;<span class=\"hljs-built_in\">OnDownloadOver</span>(total_read_, total_spent_);<br>\t<span class=\"hljs-keyword\">delete</span> <span class=\"hljs-keyword\">this</span>;  <span class=\"hljs-comment\">// 销毁本对象</span><br>&#125;<br><br><span class=\"hljs-comment\">// 主线程处理过程，收到子线程的通知消息</span><br><span class=\"hljs-function\"><span class=\"hljs-type\">void</span> <span class=\"hljs-title\">http_download::rpc_wakeup</span><span class=\"hljs-params\">(<span class=\"hljs-type\">void</span>* ctx)</span></span><br><span class=\"hljs-function\"></span>&#123;<br>\tDOWN_CTX* down_ctx = (DOWN_CTX*) ctx;<br><br>\t<span class=\"hljs-comment\">// 根据子线程中传来的不同的下载阶段进行处理</span><br><br>\t<span class=\"hljs-keyword\">switch</span> (down_ctx-&gt;type)<br>\t&#123;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_REQ_HDR:<br>\t\tcallback_-&gt;<span class=\"hljs-built_in\">SetRequestHdr</span>(req_hdr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_RES_HDR:<br>\t\tcallback_-&gt;<span class=\"hljs-built_in\">SetResponseHdr</span>(res_hdr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_CONTENT_LENGTH:<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_PARTIAL_LENGTH:<br>\t\ttotal_read_ += down_ctx-&gt;length;<br>\t\tcallback_-&gt;<span class=\"hljs-built_in\">OnDownloading</span>(content_length_, total_read_);<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">case</span> CTX_T_END:<br>\t\t<span class=\"hljs-built_in\">logger</span>(<span class=\"hljs-string\">&quot;%s: read over&quot;</span>, addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t<span class=\"hljs-keyword\">default</span>:<br>\t\t<span class=\"hljs-built_in\">logger_error</span>(<span class=\"hljs-string\">&quot;%s: ERROR&quot;</span>, addr_.<span class=\"hljs-built_in\">c_str</span>());<br>\t\t<span class=\"hljs-keyword\">break</span>;<br>\t&#125;<br><br>\t<span class=\"hljs-comment\">// 删除在子线程中动态分配的对象</span><br>\t<span class=\"hljs-keyword\">delete</span> down_ctx;<br>&#125;<br><br><span class=\"hljs-comment\">//////////////////////////////////////////////////////////////////////////</span><br></code></pre></td></tr></table></figure>\n<h3 id=\"3、在-MFC-界面类中创建-rpc-callback-的子类，接收子线程的-HTTP-处理结果\"><a href=\"#3、在-MFC-界面类中创建-rpc-callback-的子类，接收子线程的-HTTP-处理结果\" class=\"headerlink\" title=\"3、在 MFC 界面类中创建 rpc_callback 的子类，接收子线程的 HTTP 处理结果\"></a>3、在 MFC 界面类中创建 rpc_callback 的子类，接收子线程的 HTTP 处理结果</h3><p>本例直接将对话框类继承了 rpc_callback 接口类，其中部分内容如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br></pre></td><td class=\"code\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">// Cgui_rpcDlg 对话框</span><br><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title class_\">Cgui_rpcDlg</span> : <span class=\"hljs-keyword\">public</span> CDialog<br>\t, <span class=\"hljs-keyword\">public</span> rpc_callback<br>&#123;<br><span class=\"hljs-comment\">// 构造</span><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-built_in\">Cgui_rpcDlg</span>(CWnd* pParent = <span class=\"hljs-literal\">NULL</span>);\t<span class=\"hljs-comment\">// 标准构造函数</span><br>\t~<span class=\"hljs-built_in\">Cgui_rpcDlg</span>();<br><br>        ......<br><br><span class=\"hljs-keyword\">public</span>:<br>\t<span class=\"hljs-comment\">// 基类 rpc_callback 虚函数</span><br><br>\t<span class=\"hljs-comment\">// 设置 HTTP 请求头数据虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetRequestHdr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* hdr)</span></span>;<br>\t<span class=\"hljs-comment\">// 设置 HTTP 响应头数据虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">SetResponseHdr</span><span class=\"hljs-params\">(<span class=\"hljs-type\">const</span> <span class=\"hljs-type\">char</span>* hdr)</span></span>;<br>\t<span class=\"hljs-comment\">// 下载过程中的回调函数虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnDownloading</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> content_length,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> total_read)</span></span>;<br>\t<span class=\"hljs-comment\">// 下载完成时的回调函数虚函数</span><br>\t<span class=\"hljs-function\"><span class=\"hljs-keyword\">virtual</span> <span class=\"hljs-type\">void</span> <span class=\"hljs-title\">OnDownloadOver</span><span class=\"hljs-params\">(<span class=\"hljs-type\">long</span> <span class=\"hljs-type\">long</span> <span class=\"hljs-type\">int</span> total_read,</span></span><br><span class=\"hljs-params\"><span class=\"hljs-function\">\t\t<span class=\"hljs-type\">double</span> spent)</span></span>;<br>        ......<br>&#125;;<br></code></pre></td></tr></table></figure>\n\n<p>4、用 VC2003 编译该例子，运行可执行程序可以得到如下的界面：<br><img src=\"/img/aio_rpc_mfc.png\" alt=\"运行界面\"></p>\n<p>运行这个例子，在 URL 中输入地址（如：<a href=\"http://www.sina.com.cn/\">http://www.sina.com.cn</a> ），点“开始运行”按钮，在下载 URL 数据的过程中移动界面窗口，可以看到界面窗口的消息过程并未被阻塞（因为 HTTP 阻塞下载过程是在子线程中进行的），同时界面的状态栏还能实时显示当前 URL 下载的进度状态（子线程通过 rpc_request 的消息传递方式将下载状态通知界面主线程）。</p>\n<h2 id=\"四、小结\"><a href=\"#四、小结\" class=\"headerlink\" title=\"四、小结\"></a>四、小结</h2><p>在界面编程中，将阻塞过程与界面过程分离（ 即将阻塞过程交由子线程处理）是一种编程思想，不仅可以用在 PC 机的界面编程中，同时对于手机 APP 开发也有用处，这样做的好处是：一方面可以利用多核，更重要的是使得界面编程更为简单（要比所有模块全部采用非阻塞编程要容易得多）。</p>\n<h2 id=\"五、参考\"><a href=\"#五、参考\" class=\"headerlink\" title=\"五、参考\"></a>五、参考</h2><p>github：<a href=\"https://github.com/acl-dev/acl\">https://github.com/acl-dev/acl</a><br>gitee：<a href=\"https://gitee.com/acl-dev/acl\">https://gitee.com/acl-dev/acl</a></p>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cld7k62yx0000d09k1she52bt","category_id":"cld8my2zd0000tm9k0ynd21f4","_id":"cld8my2zf0001tm9ke5uq4b39"},{"post_id":"cld8cwq7a0003m7fy4vic72n0","category_id":"cld8my8730002tm9k4d9ag8py","_id":"cld8my8740003tm9k7xxi6hf4"},{"post_id":"cld8rbzr200005i9k9l4v0par","category_id":"cld8my2zd0000tm9k0ynd21f4","_id":"cld8shc5z0001bx9khimsfaxa"},{"post_id":"cld8tqdmt0000bx9k8pa70tko","category_id":"cld8tqdn00001bx9k1m5p7c8u","_id":"cld8tqdn30003bx9kae822y6q"},{"post_id":"cld8u4fck0000c79kex87aoiz","category_id":"cld8tqdn00001bx9k1m5p7c8u","_id":"cld8u4fcp0002c79kb74jblun"},{"post_id":"cld8uubya0000929k3xjqb14b","category_id":"cld8tqdn00001bx9k1m5p7c8u","_id":"cld8uubyh0002929kef3k50t4"},{"post_id":"cld8vgtdm0000rt9kgl6i7qw3","category_id":"cld8vgtdu0001rt9k31wrgab3","_id":"cld8vgtdz0002rt9k8ym498q6"},{"post_id":"cld8wuane0009q79k687c3ocz","category_id":"cld8my2zd0000tm9k0ynd21f4","_id":"cld8wuang000bq79k4vqy4okb"},{"post_id":"cld9lmhgf0000p8fyh62ih70w","category_id":"cld8my2zd0000tm9k0ynd21f4","_id":"cld9lmhgl0002p8fy2m3cetz8"},{"post_id":"cld9n1es000001xfyf246a2cd","category_id":"cld8tqdn00001bx9k1m5p7c8u","_id":"cld9n1es600021xfy04nl32sn"},{"post_id":"cld9naynq000029fydnfx5hdh","category_id":"cld8tqdn00001bx9k1m5p7c8u","_id":"cld9naynr000229fygfiy4qhs"},{"post_id":"cld9nhaj8000329fyaomnc9d9","category_id":"cld8tqdn00001bx9k1m5p7c8u","_id":"cld9nhaja000529fy2bjfbmcr"},{"post_id":"cld9no3at000629fy3luv70vy","category_id":"cld9no3at000729fy8o06e9vr","_id":"cld9no3au000829fy4g6j7nmg"},{"post_id":"cld9s2kme000929fy27ah3g38","category_id":"cld9s2kmf000a29fy1ytfhp1k","_id":"cld9s2kmg000b29fyasij8c03"},{"post_id":"cld9s983y000c29fy5dpxa2a5","category_id":"cld9s9840000d29fy775kfdgo","_id":"cld9s9841000e29fycumx0gpw"},{"post_id":"cld9uizpo00057x9k4xoi3txp","category_id":"cld9ui39200017x9k8v7n4frm","_id":"cld9uizpp00067x9k2fga56ji"},{"post_id":"cld9vmr0d00097x9k102077aw","category_id":"cld9vmr0e000a7x9karih8922","_id":"cld9vmr0f000b7x9k5rrhf197"},{"post_id":"cld9wjkeh000e7x9khziq491w","category_id":"cld9s9840000d29fy775kfdgo","_id":"cld9wjkei000f7x9k3n3e7nyd"},{"post_id":"cld9wk4hj000g7x9kflqx26u8","category_id":"cld9s9840000d29fy775kfdgo","_id":"cld9wk4hl000h7x9k4eysa5ai"},{"post_id":"cld9xuv8f000i7x9kbbf6btt5","category_id":"cld9xuv8g000j7x9kgnca3dko","_id":"cld9xuv8g000k7x9k1zst6cpr"},{"post_id":"cld9y3v0m000l7x9kasrkfao0","category_id":"cld9y3v0n000m7x9ke1pga0uz","_id":"cld9y3v0n000n7x9k5oii7229"},{"post_id":"cld9yjrsq000o7x9k0npw0m9b","category_id":"cld9xuv8g000j7x9kgnca3dko","_id":"cld9yjrss000p7x9k2povc5f6"},{"post_id":"clda039u10000yr9ke63a02x3","category_id":"clda039u70001yr9k9kxn67rz","_id":"clda039ud0002yr9kbvymd0jk"},{"post_id":"clda075ix0003yr9k7m324z1c","category_id":"clda039u70001yr9k9kxn67rz","_id":"clda075iy0004yr9kejrbdmzs"},{"post_id":"clda0hdjk0005yr9khh179b1z","category_id":"clda039u70001yr9k9kxn67rz","_id":"clda0hdjn0006yr9k4eprgcvb"},{"post_id":"clda1dl5l00008o9k8ub32v8u","category_id":"clda1dl5o00018o9k8i7y1fdf","_id":"clda1dl5p00028o9kaj7pgpjp"},{"post_id":"clda1nabq00038o9k24u43vqu","category_id":"cld9xuv8g000j7x9kgnca3dko","_id":"clda1nabr00048o9kg51v5tok"},{"post_id":"clda1w9vq00058o9k8otec069","category_id":"clda1w9vq00068o9kazdy4rdj","_id":"clda1w9vr00078o9kdhreb0i6"},{"post_id":"clda2hjdo00088o9k49nrhvkh","category_id":"clda2quwr000b8o9k5urx1doa","_id":"clda2quws000c8o9k1iux4qwk"},{"post_id":"clda2sue3000d8o9k5dyr5um4","category_id":"clda2quwr000b8o9k5urx1doa","_id":"clda2sue4000e8o9k0skp21es"},{"post_id":"clda31jzw000f8o9kegech7rr","category_id":"cld9vmr0e000a7x9karih8922","_id":"clda31jzx000g8o9k9x7g18yd"},{"post_id":"clda37ubj000h8o9ka3shfms3","category_id":"cld9vmr0e000a7x9karih8922","_id":"clda37ubk000i8o9k63li061e"}],"PostTag":[{"post_id":"cld7k62yx0000d09k1she52bt","tag_id":"cld8ctbyh0000m7fy2ufpfyhw","_id":"cld8ctbyj0001m7fybu9qh741"},{"post_id":"cld8cwq7a0003m7fy4vic72n0","tag_id":"cld8cwq7b0004m7fyd6nz9x28","_id":"cld8cwq7c0005m7fyh79dc23p"},{"post_id":"cld8rbzr200005i9k9l4v0par","tag_id":"cld8ctbyh0000m7fy2ufpfyhw","_id":"cld8shc5y0000bx9k2rs6fqp1"},{"post_id":"cld8tqdmt0000bx9k8pa70tko","tag_id":"cld8uvd6300009c9khh8w3de0","_id":"cld8uvd6500019c9k4mljeyjx"},{"post_id":"cld8uubya0000929k3xjqb14b","tag_id":"cld8uvd6300009c9khh8w3de0","_id":"cld8uvlyg00029c9kddl49rjy"},{"post_id":"cld8u4fck0000c79kex87aoiz","tag_id":"cld8uvd6300009c9khh8w3de0","_id":"cld8uvtas00039c9kat1wf9x7"},{"post_id":"cld8wuane0009q79k687c3ocz","tag_id":"cld8ctbyh0000m7fy2ufpfyhw","_id":"cld8wuang000aq79k0unz8s4o"},{"post_id":"cld9lmhgf0000p8fyh62ih70w","tag_id":"cld8ctbyh0000m7fy2ufpfyhw","_id":"cld9lmhgk0001p8fy18w08ayh"},{"post_id":"cld9n1es000001xfyf246a2cd","tag_id":"cld8uvd6300009c9khh8w3de0","_id":"cld9n1es600011xfy319r9brw"},{"post_id":"cld9naynq000029fydnfx5hdh","tag_id":"cld8uvd6300009c9khh8w3de0","_id":"cld9naynr000129fyd64d2ody"},{"post_id":"cld9nhaj8000329fyaomnc9d9","tag_id":"cld8uvd6300009c9khh8w3de0","_id":"cld9nhaj9000429fy469l82xk"}],"Tag":[{"name":"协程编程","_id":"cld8ctbyh0000m7fy2ufpfyhw"},{"name":"SSL编程","_id":"cld8cwq7b0004m7fyd6nz9x28"},{"name":"http","_id":"cld8uvd6300009c9khh8w3de0"}]}}